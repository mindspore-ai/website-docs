<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.dataset.engine.datasets &mdash; MindSpore 0.1.0-alpha documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script><script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/js/theme.js"></script><script src="../../../../_static/underscore.js"></script><script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dtype.html">mindspore.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.context.html">mindspore.context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.ops.composite.html">mindspore.ops.composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.ops.operations.html">mindspore.ops.operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.parallel.html">mindspore.parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.transforms.c_transforms.html">mindspore.dataset.transforms.c_transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.transforms.vision.c_transforms.html">mindspore.dataset.transforms.vision.c_transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.transforms.py_transforms.html">mindspore.dataset.transforms.py_transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.transforms.vision.py_transforms.html">mindspore.dataset.transforms.vision.py_transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindinsight/mindinsight.lineagemgr.html">mindinsight.lineagemgr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.html">mindarmour</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.utils.html">mindarmour.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.evaluations.html">mindarmour.evaluations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.detectors.html">mindarmour.detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.attacks.html">mindarmour.attacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.defenses.html">mindarmour.defenses</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>mindspore.dataset.engine.datasets</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mindspore.dataset.engine.datasets</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ==============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">datasets.py supports various formats of datasets, including ImageNet, TFData,</span>
<span class="sd">MNIST, Cifar10/100, Manifest, MindRecord, etc. This module could load data in</span>
<span class="sd">high performance and parse data precisely. It also provides the following</span>
<span class="sd">operations for users to preprocess data: shuffle, batch, repeat, map, and zip.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">import_module</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mindspore._c_dataengine</span> <span class="kn">import</span> <span class="n">DataType</span><span class="p">,</span> <span class="n">TFReaderOp</span><span class="p">,</span> <span class="n">ImageFolderOp</span><span class="p">,</span> <span class="n">CifarOp</span><span class="p">,</span> <span class="n">MnistOp</span><span class="p">,</span> <span class="n">ManifestOp</span><span class="p">,</span> \
    <span class="n">MindRecordOp</span><span class="p">,</span> <span class="n">CBatchInfo</span>
<span class="kn">from</span> <span class="nn">mindspore._c_expression</span> <span class="kn">import</span> <span class="n">typing</span>

<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">samplers</span>
<span class="kn">from</span> <span class="nn">.iterators</span> <span class="kn">import</span> <span class="n">DictIterator</span><span class="p">,</span> <span class="n">TupleIterator</span>
<span class="kn">from</span> <span class="nn">.validators</span> <span class="kn">import</span> <span class="n">check</span><span class="p">,</span> <span class="n">check_batch</span><span class="p">,</span> <span class="n">check_shuffle</span><span class="p">,</span> <span class="n">check_map</span><span class="p">,</span> <span class="n">check_repeat</span><span class="p">,</span> <span class="n">check_zip</span><span class="p">,</span> <span class="n">check_rename</span><span class="p">,</span> \
    <span class="n">check_project</span><span class="p">,</span> <span class="n">check_imagefolderdatasetv2</span><span class="p">,</span> <span class="n">check_mnist_cifar_dataset</span><span class="p">,</span> <span class="n">check_manifestdataset</span><span class="p">,</span> \
    <span class="n">check_tfrecorddataset</span><span class="p">,</span> <span class="n">check_vocdataset</span><span class="p">,</span> <span class="n">check_celebadataset</span><span class="p">,</span> <span class="n">check_minddataset</span><span class="p">,</span> <span class="n">check_generatordataset</span><span class="p">,</span> \
    <span class="n">check_zip_dataset</span>
<span class="kn">from</span> <span class="nn">..core.datatypes</span> <span class="kn">import</span> <span class="n">mstype_to_detype</span><span class="p">,</span> <span class="n">mstypelist_to_detypelist</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">context</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;mindspore.context&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">context</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">Shuffle</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
    <span class="n">GLOBAL</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span>
    <span class="n">FILES</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;file&quot;</span>


<div class="viewcode-block" id="zip"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.zip">[docs]</a><span class="nd">@check_zip</span>
<span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="n">datasets</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zips the datasets in the input tuple of datasets.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets (tuple of class Dataset): A tuple of datasets to be zipped together.</span>
<span class="sd">            The number of datasets should be more than 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        DatasetOp, ZipDataset.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the number of datasets is 1.</span>
<span class="sd">        TypeError: If datasets is not a tuple.</span>

<span class="sd">    Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; dataset_dir1 = &quot;path/to/imagefolder_directory1&quot;</span>
<span class="sd">            &gt;&gt;&gt; dataset_dir2 = &quot;path/to/imagefolder_directory2&quot;</span>
<span class="sd">            &gt;&gt;&gt; ds1 = ds.ImageFolderDatasetV2(dataset_dir1, num_parallel_workers=8)</span>
<span class="sd">            &gt;&gt;&gt; ds2 = ds.ImageFolderDatasetV2(dataset_dir2, num_parallel_workers=8)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset which is the combination of ds1 and ds2</span>
<span class="sd">            &gt;&gt;&gt; data = ds.zip((ds1, ds2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Can&#39;t zip empty or just one dataset!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The zip function </span><span class="si">%s</span><span class="s2"> type error!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datasets</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ZipDataset</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number rows of the dataset according to the shards.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_rows (int): The number rows of the dataset should be more than 0.</span>
<span class="sd">            The number rows of the dataset should be more than 0.</span>
<span class="sd">        num_shards (int or None): Number of shards that the dataset should be divided into.</span>
<span class="sd">            The number of shards should be None or more than 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Int, number of rows.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If num_rows is invalid (&lt; 0).</span>
<span class="sd">        ValueError: If num_shards is invalid (&lt;= 0).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_rows</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_rows is invalid (&lt; 0)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_shards</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_shards is invalid (&lt;= 0)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_rows</span> <span class="o">%</span> <span class="n">num_shards</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span> <span class="o">//</span> <span class="n">num_shards</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span> <span class="o">//</span> <span class="n">num_shards</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">num_rows</span>


<span class="k">class</span> <span class="nc">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class to represent a dataset in DataEngine&#39;s data pipeline.</span>

<span class="sd">    This class is the base class of SourceDataset and DatasetOp, and represents</span>
<span class="sd">    a node in the data flow graph.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to process the Dataset in parallel</span>
<span class="sd">            (default=None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="n">num_parallel_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_types</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_shapes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_classes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repeat_count</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns attributes (member variables) related to the current class.</span>

<span class="sd">        Must include all arguments passed to the __init__() of the current class, excluding &#39;input_dataset&#39;.</span>

<span class="sd">        Args:</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_parallel_workers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="nd">@check_batch</span>
    <span class="k">def</span> <span class="nf">batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_batch_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combines batch_size number of consecutive rows into batches.</span>

<span class="sd">        For any child node, a batch is treated as a single row.</span>
<span class="sd">        For any column, all the elements within that column must have the same shape.</span>
<span class="sd">        If a per_batch_map callable is provided, it will be applied to the batches of tensors.</span>

<span class="sd">        Note:</span>
<span class="sd">            The order of using repeat and batch reflects the number of batches. Recommend that</span>
<span class="sd">            repeat operation should be used after batch operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            batch_size (int or function): The number of rows each batch is created with. An</span>
<span class="sd">                int or callable which takes exactly 1 parameter, BatchInfo.</span>
<span class="sd">            drop_remainder (bool, optional): Determines whether or not to drop the last</span>
<span class="sd">                possibly incomplete batch (default=False). If True, and if there are less</span>
<span class="sd">                than batch_size rows available to make the last batch, then those rows will</span>
<span class="sd">                be dropped and not propogated to the child node.</span>
<span class="sd">            num_parallel_workers (int, optional): Number of workers to process the Dataset in parallel (default=None).</span>
<span class="sd">            per_batch_map (callable, optional): Per batch map callable. A callable which takes</span>
<span class="sd">                (list[Tensor], list[Tensor], ..., BatchInfo) as input parameters. Each list[Tensor] represent a batch of</span>
<span class="sd">                Tensors on a given column. The number of lists should match with number of entries in input_columns. The</span>
<span class="sd">                last parameter of the callable should always be a BatchInfo object.</span>
<span class="sd">            input_columns (list of string, optional): List of names of the input columns. The size of the list should</span>
<span class="sd">                match with signature of per_batch_map callable.</span>

<span class="sd">        Returns:</span>
<span class="sd">            BatchDataset, dataset batched.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where every 100 rows is combined into a batch</span>
<span class="sd">            &gt;&gt;&gt; # and drops the last incomplete batch if there is one.</span>
<span class="sd">            &gt;&gt;&gt; data = data.batch(100, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BatchDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">per_batch_map</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">)</span>

    <span class="nd">@check_shuffle</span>
    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly shuffles the rows of this dataset using the following algorithm:</span>

<span class="sd">        1. Make a shuffle buffer that contains the first buffer_size rows.</span>
<span class="sd">        2. Randomly select an element from the shuffle buffer to be the next row</span>
<span class="sd">           propogated to the child node.</span>
<span class="sd">        3. Get the next row (if any) from the parent node and put it in the shuffle buffer.</span>
<span class="sd">        4. Repeat steps 2 and 3 until there are no more rows left in the shuffle buffer.</span>

<span class="sd">        A seed can be provided to be used on the first epoch. In every subsequent</span>
<span class="sd">        epoch, the seed is changed to a new one, randomly generated value.</span>

<span class="sd">        Args:</span>
<span class="sd">            buffer_size (int): The size of the buffer (must be larger than 1) for</span>
<span class="sd">                shuffling. Setting buffer_size equal to the number of rows in the entire</span>
<span class="sd">                dataset will result in a global shuffle.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShuffleDataset, dataset shuffled.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # optionally set the seed for the first epoch</span>
<span class="sd">            &gt;&gt;&gt; ds.config.set_seed(58)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a shuffled dataset using a shuffle buffer of size 4</span>
<span class="sd">            &gt;&gt;&gt; data = data.shuffle(4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShuffleDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>

    <span class="nd">@check_map</span>
    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies each operation in operations to this dataset.</span>

<span class="sd">        The order of operations is determined by the position of each operation in operations.</span>
<span class="sd">        operations[0] will be applied first, then operations[1], then operations[2], etc.</span>

<span class="sd">        Each operation will be passed one or more columns from the dataset as input, and zero or</span>
<span class="sd">        more columns will be outputted. The first operation will be passed the columns specified</span>
<span class="sd">        in input_columns as input. If there is more than one operator in operations, the outputted</span>
<span class="sd">        columns of the previous operation are used as the input columns for the next operation.</span>
<span class="sd">        The columns outputted by the very last operation will be assigned names specified by</span>
<span class="sd">        output_columns.</span>

<span class="sd">        Only the columns specified in columns_order will be propagated to the child node. These</span>
<span class="sd">        columns will be in the same order as specified in columns_order.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_columns (list[str]): List of the names of the columns that will be passed to</span>
<span class="sd">                the first operation as input. The size of this list must match the number of</span>
<span class="sd">                input columns expected by the first operator. (default=None, the first</span>
<span class="sd">                operation will be passed however many columns that is required, starting from</span>
<span class="sd">                the first column).</span>
<span class="sd">            operations (list[TensorOp] or Python list[functions]): List of operations to be</span>
<span class="sd">                applied on the dataset. Operations are applied in the order they appear in this list.</span>
<span class="sd">            output_columns (list[str], optional): List of names assigned to the columns outputted by</span>
<span class="sd">                the last operation. This parameter is mandatory if len(input_columns) !=</span>
<span class="sd">                len(output_columns). The size of this list must match the number of output</span>
<span class="sd">                columns of the last operation. (default=None, output columns will have the same</span>
<span class="sd">                name as the input columns, i.e., the columns will be replaced).</span>
<span class="sd">            columns_order (list[str], optional): list of all the desired columns to propagate to the</span>
<span class="sd">                child node. This list must be a subset of all the columns in the dataset after</span>
<span class="sd">                all operations are applied. The order of the columns in each row propagated to the</span>
<span class="sd">                child node follow the order they appear in this list. The parameter is mandatory</span>
<span class="sd">                if the len(input_columns) != len(output_columns). (default=None, all columns</span>
<span class="sd">                will be propagated to the child node, the order of the columns will remain the</span>
<span class="sd">                same).</span>
<span class="sd">            num_parallel_workers (int, optional): Number of threads used to process the dataset in</span>
<span class="sd">                parallel (default=None, the value from the config will be used).</span>

<span class="sd">        Returns:</span>
<span class="sd">            MapDataset, dataset after mapping operation.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset.transforms.vision.c_transforms as c_transforms</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset which has 2 columns, &quot;image&quot; and &quot;label&quot;.</span>
<span class="sd">            &gt;&gt;&gt; # ds_pyfunc is an instance of Dataset which has 3 columns, &quot;col0&quot;, &quot;col1&quot;, and &quot;col2&quot;. Each column is</span>
<span class="sd">            &gt;&gt;&gt; # a 2d array of integers.</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # This config is a global setting, meaning that all future operations which</span>
<span class="sd">            &gt;&gt;&gt; # uses this config value will use 2 worker threads, unless if specified</span>
<span class="sd">            &gt;&gt;&gt; # otherwise in their constructor. set_num_parallel_workers can be called</span>
<span class="sd">            &gt;&gt;&gt; # again later if a different number of worker threads are needed.</span>
<span class="sd">            &gt;&gt;&gt; ds.config.set_num_parallel_workers(2)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Two operations, which takes 1 column for input and outputs 1 column.</span>
<span class="sd">            &gt;&gt;&gt; decode_op = c_transforms.Decode(rgb_format=True)</span>
<span class="sd">            &gt;&gt;&gt; random_jitter_op = c_transforms.RandomColorAdjust((0.8, 0.8), (1, 1), (1, 1), (0, 0))</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # 1) Simple map example</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; operations = [decode_op]</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;image&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Applies decode_op on column &quot;image&quot;. This column will be replaced by the outputed</span>
<span class="sd">            &gt;&gt;&gt; # column of decode_op. Since columns_order is not provided, both columns &quot;image&quot;</span>
<span class="sd">            &gt;&gt;&gt; # and &quot;label&quot; will be propagated to the child node in their original order.</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Rename column &quot;image&quot; to &quot;decoded_image&quot;</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations, output_columns)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Specify the order of the columns.</span>
<span class="sd">            &gt;&gt;&gt; columns_order [&quot;label&quot;, &quot;image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations, None, columns_order)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Rename column &quot;image&quot; to &quot;decoded_image&quot; and also specify the order of the columns.</span>
<span class="sd">            &gt;&gt;&gt; columns_order [&quot;label&quot;, &quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations, output_columns, columns_order)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Rename column &quot;image&quot; to &quot;decoded_image&quot; and keep only this column.</span>
<span class="sd">            &gt;&gt;&gt; columns_order [&quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations, output_columns, columns_order)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Simple example using pyfunc. Renaming columns and specifying column order</span>
<span class="sd">            &gt;&gt;&gt; # work in the same way as the previous examples.</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;col0&quot;]</span>
<span class="sd">            &gt;&gt;&gt; operations = [(lambda x: x + 1)]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = ds_pyfunc.map(input_columns, operations)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # 2) Map example with more than one operation</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # If this list of operations is used with map, decode_op will be applied</span>
<span class="sd">            &gt;&gt;&gt; # first, then random_jitter_op will be applied.</span>
<span class="sd">            &gt;&gt;&gt; operations = [decode_op, random_jitter_op]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;image&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Creates a dataset where the images are decoded, then randomly color jittered.</span>
<span class="sd">            &gt;&gt;&gt; # decode_op takes column &quot;image&quot; as input and outputs one column. The column</span>
<span class="sd">            &gt;&gt;&gt; # outputted by decode_op is passed as input to random_jitter_op.</span>
<span class="sd">            &gt;&gt;&gt; # random_jitter_op will output one column. Column &quot;image&quot; will be replaced by</span>
<span class="sd">            &gt;&gt;&gt; # the column outputted by random_jitter_op (the very last operation). All other</span>
<span class="sd">            &gt;&gt;&gt; # columns are unchanged. Since columns_order is not specified, the order of the</span>
<span class="sd">            &gt;&gt;&gt; # columns will remain the same.</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = data.map(input_columns, operations)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Creates a dataset that is identical to ds_mapped, except the column &quot;image&quot;</span>
<span class="sd">            &gt;&gt;&gt; # that is outputted by random_jitter_op is renamed to &quot;image_transformed&quot;.</span>
<span class="sd">            &gt;&gt;&gt; # Specifying column order works in the same way as examples in 1).</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;image_transformed&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped_and_renamed = data.map(input_columns, operation, output_columns)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Multiple operations using pyfunc. Renaming columns and specifying column order</span>
<span class="sd">            &gt;&gt;&gt; # work in the same way as examples in 1).</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;col0&quot;]</span>
<span class="sd">            &gt;&gt;&gt; operations = [(lambda x: x + x), (lambda x: x - 1)]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;col0_mapped&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = ds_pyfunc.map(input_columns, operations, output_columns)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # 3) Example where number of input columns is not equal to number of output columns</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # operations[0] is a lambda that takes 2 columns as input and outputs 3 columns.</span>
<span class="sd">            &gt;&gt;&gt; # operations[1] is a lambda that takes 3 columns as input and outputs 1 column.</span>
<span class="sd">            &gt;&gt;&gt; # operations[1] is a lambda that takes 1 column as input and outputs 4 columns.</span>
<span class="sd">            &gt;&gt;&gt; #</span>
<span class="sd">            &gt;&gt;&gt; # Note: the number of output columns of operation[i] must equal the number of</span>
<span class="sd">            &gt;&gt;&gt; # input columns of operation[i+1]. Otherwise, this map call will also result</span>
<span class="sd">            &gt;&gt;&gt; # in an error.</span>
<span class="sd">            &gt;&gt;&gt; operations = [(lambda x y: (x, x + y, x + y + 1)),</span>
<span class="sd">            &gt;&gt;&gt;               (lambda x y z: x * y * z),</span>
<span class="sd">            &gt;&gt;&gt;               (lambda x: (x % 2, x % 3, x % 5, x % 7))]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Note: because the number of input columns is not the same as the number of</span>
<span class="sd">            &gt;&gt;&gt; # output columns, the output_columns and columns_order parameter must be</span>
<span class="sd">            &gt;&gt;&gt; # specified. Otherwise, this map call will also result in an error.</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;col2&quot;, &quot;col0&quot;]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;mod2&quot;, &quot;mod3&quot;, &quot;mod5&quot;, &quot;mod7&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Propagate all columns to the child node in this order:</span>
<span class="sd">            &gt;&gt;&gt; columns_order = [&quot;col0&quot;, &quot;col2&quot;, &quot;mod2&quot;, &quot;mod3&quot;, &quot;mod5&quot;, &quot;mod7&quot;, &quot;col1&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = ds_pyfunc.map(input_columns, operations, output_columns, columns_order)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Propagate some columns to the child node in this order:</span>
<span class="sd">            &gt;&gt;&gt; columns_order = [&quot;mod7&quot;, &quot;mod3&quot;, &quot;col1&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = ds_pyfunc.map(input_columns, operations, output_columns, columns_order)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MapDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">operations</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">,</span> <span class="n">columns_order</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">)</span>

    <span class="nd">@check_repeat</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeats this dataset count times. Repeat indefinitely if the count is None or -1.</span>

<span class="sd">        Note:</span>
<span class="sd">            The order of using repeat and batch reflects the number of batches. Recommend that</span>
<span class="sd">            repeat operation should be used after batch operation.</span>
<span class="sd">            If dataset_sink_mode is False (feed mode), here repeat operation is invalid.</span>

<span class="sd">        Args:</span>
<span class="sd">            count (int): Number of times the dataset should be repeated (default=None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            RepeatDataset, dataset repeated.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where the dataset is repeated for 50 epochs</span>
<span class="sd">            &gt;&gt;&gt; repeated = data.repeat(50)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where each epoch is shuffled individually</span>
<span class="sd">            &gt;&gt;&gt; shuffled_and_repeated = data.shuffle(10)</span>
<span class="sd">            &gt;&gt;&gt; shuffled_and_repeated = shuffled_and_repeated.repeat(50)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where the dataset is first repeated for</span>
<span class="sd">            &gt;&gt;&gt; # 50 epochs before shuffling. the shuffle operator will treat</span>
<span class="sd">            &gt;&gt;&gt; # the entire 50 epochs as one big dataset.</span>
<span class="sd">            &gt;&gt;&gt; repeat_and_shuffle = data.repeat(50)</span>
<span class="sd">            &gt;&gt;&gt; repeat_and_shuffle = repeat_and_shuffle.shuffle(10)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RepeatDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

    <span class="nd">@check_zip_dataset</span>
    <span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Zips the datasets in the input tuple of datasets. Columns in the input datasets must not have the same name.</span>

<span class="sd">        Args:</span>
<span class="sd">            datasets (tuple or class Dataset): A tuple of datasets or a single class Dataset</span>
<span class="sd">                to be zipped together with this dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ZipDataset, dataset zipped.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # ds1 and ds2 are instances of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset which is the combination of ds1 and ds2</span>
<span class="sd">            &gt;&gt;&gt; data = ds1.zip(ds2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">datasets</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The zip function </span><span class="si">%s</span><span class="s2"> type error!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datasets</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ZipDataset</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>

    <span class="nd">@check_rename</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames the columns in input datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_columns (list[str]): list of names of the input columns.</span>
<span class="sd">            output_columns (list[str]): list of names of the output columns.</span>

<span class="sd">        Returns:</span>
<span class="sd">            RenameDataset, dataset renamed.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;input_col1&quot;, &quot;input_col2&quot;, &quot;input_col3&quot;]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;output_col1&quot;, &quot;output_col2&quot;, &quot;output_col3&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where input_col1 is renamed to output_col1, and</span>
<span class="sd">            &gt;&gt;&gt; # input_col2 is renamed to output_col2, and input_col3 is renamed</span>
<span class="sd">            &gt;&gt;&gt; # to output_col3.</span>
<span class="sd">            &gt;&gt;&gt; data = data.rename(input_columns=input_columns, output_columns=output_columns)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">RenameDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">)</span>

    <span class="nd">@check_project</span>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Projects certain columns in input datasets.</span>

<span class="sd">        The specified columns will be selected from the dataset and passed down</span>
<span class="sd">        the pipeline in the order specified. The other columns are discarded.</span>

<span class="sd">        Args:</span>
<span class="sd">            columns(list[str]): list of names of the columns to project.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ProjectDataset, dataset projected.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; columns_to_project = [&quot;column3&quot;, &quot;column1&quot;, &quot;column2&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset that consist of column3, column1, column2</span>
<span class="sd">            &gt;&gt;&gt; # in that order, regardless of the original order of columns.</span>
<span class="sd">            &gt;&gt;&gt; data = data.project(columns=columns_to_project)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">ProjectDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">device_que</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefetch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a transferredDataset that transfer data through tdt.</span>

<span class="sd">        Args:</span>
<span class="sd">            prefetch_size (int, optional): prefetch number of records ahead of the</span>
<span class="sd">                user&#39;s request (default=None).</span>

<span class="sd">        Return:</span>
<span class="sd">            TransferDataset, dataset for transferring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_device</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfers data through CPU, GPU or Ascend devices.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_batch (int, optional): limit the number of batch to be sent to device (default=None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            TransferDataset, dataset for transferring.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If device_type is empty.</span>
<span class="sd">            ValueError: If device_type is not &#39;Ascend&#39;, &#39;GPU&#39; or &#39;CPU&#39;.</span>
<span class="sd">            ValueError: If num_batch is None or 0 or larger than int_max.</span>
<span class="sd">            RuntimeError: If dataset is unknown.</span>
<span class="sd">            RuntimeError: If distribution file path is given but failed to read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num_batch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
            <span class="n">repeat_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_repeat_count</span><span class="p">()</span>
            <span class="n">num_batch</span> <span class="o">=</span> <span class="n">num_batch</span> <span class="o">*</span> <span class="n">repeat_count</span>

        <span class="n">queue_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
            <span class="n">device_type</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;device_target&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">device_type</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span>

        <span class="k">if</span> <span class="n">device_type</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Please set device_type in context&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">device_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Ascend&#39;</span><span class="p">,</span> <span class="s1">&#39;GPU&#39;</span><span class="p">,</span> <span class="s1">&#39;CPU&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only support CPU, Ascend, GPU&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_batch</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">num_batch</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_batch is None or 0.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_distribution</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">):</span>
            <span class="n">dev_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">,</span> <span class="p">(</span><span class="n">StorageDataset</span><span class="p">,</span> <span class="n">GeneratorDataset</span><span class="p">,</span> <span class="n">MindDataset</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">distribution</span><span class="p">,</span> <span class="n">dev_id</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">,</span> <span class="p">(</span><span class="n">Cifar10Dataset</span><span class="p">,</span> <span class="n">Cifar100Dataset</span><span class="p">,</span> <span class="n">ImageFolderDatasetV2</span><span class="p">,</span>
                                           <span class="n">ManifestDataset</span><span class="p">,</span> <span class="n">MnistDataset</span><span class="p">,</span> <span class="n">VOCDataset</span><span class="p">,</span> <span class="n">CelebADataset</span><span class="p">)):</span>
                <span class="n">sampler</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">sampler</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">):</span>
                    <span class="n">dev_id</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">shard_id</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dev_id</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">,</span> <span class="n">TFRecordDataset</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">shard_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dev_id</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">shard_id</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dev_id</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unknown output_dataset: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">)))</span>
            <span class="n">input_dataset</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">get_distribution</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>

        <span class="n">distribution_path</span><span class="p">,</span> <span class="n">device_id</span> <span class="o">=</span> <span class="n">get_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distribution_path</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TransferDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue_name</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">device_type</span><span class="p">,</span> <span class="n">num_batch</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">distribution_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">distribution_f</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">distribution_f</span><span class="p">)</span>
                <span class="n">device_id</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="s2">&quot;deviceId&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Json decode error when load distribution file&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Distribution file failed to read&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TransferDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue_name</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">device_type</span><span class="p">,</span> <span class="n">num_batch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_tuple_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Iterator over the dataset. The data retrieved will be a list of ndarray of data.</span>

<span class="sd">        To specify which columns to list and the order needed, use columns_list. If columns_list</span>
<span class="sd">        is not provided, the order of the columns will not be changed.</span>

<span class="sd">        Args:</span>
<span class="sd">            columns (list[str], optional): List of columns to be used to specify the order of columns</span>
<span class="sd">                (defaults=None, means all columns).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Iterator, list of ndarray.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # creates an iterator. The columns in the data obtained by the</span>
<span class="sd">            &gt;&gt;&gt; # iterator will not be changed.</span>
<span class="sd">            &gt;&gt;&gt; iterator = data.create_tuple_iterator()</span>
<span class="sd">            &gt;&gt;&gt; for item in iterator:</span>
<span class="sd">            &gt;&gt;&gt;     # convert the returned tuple to a list and print</span>
<span class="sd">            &gt;&gt;&gt;     print(list(item))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TupleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_dict_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Iterator over the dataset.</span>

<span class="sd">        The data retrieved will be a dictionary. The order</span>
<span class="sd">        of the columns in the dictionary may not be the same as the original order.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Iterator, dictionary of column_name-ndarray pair.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # creates an iterator. The columns in the data obtained by the</span>
<span class="sd">            &gt;&gt;&gt; # iterator might be changed.</span>
<span class="sd">            &gt;&gt;&gt; iterator = data.create_dict_iterator()</span>
<span class="sd">            &gt;&gt;&gt; for item in iterator:</span>
<span class="sd">            &gt;&gt;&gt;     # print the data in column1</span>
<span class="sd">            &gt;&gt;&gt;     print(item[&quot;column1&quot;])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DictIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an Iterator over the dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_tuple_iterator</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read_dir</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">deterministic_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefetch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append the path of all files in the dir_path to StorageDataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            dir_path (str): Path to the directory that contains the dataset.</span>
<span class="sd">            schema (str): Path to the json schema file.</span>
<span class="sd">            columns_list (list[str], optional): List of columns to be read (default=None).</span>
<span class="sd">                If not provided, read all columns.</span>
<span class="sd">            num_parallel_workers (int, optional): Number of workers to process the Dataset in parallel</span>
<span class="sd">                (default=None).</span>
<span class="sd">            deterministic_output (bool, optional): Whether the result of this dataset can be reproduced</span>
<span class="sd">                or not (default=True). If True, performance might be affected.</span>
<span class="sd">            prefetch_size (int, optional): Prefetch number of records ahead of the</span>
<span class="sd">                user&#39;s request (default=None).</span>
<span class="sd">            shuffle (bool, optional): Shuffle the list of files in the directory (default=False).</span>
<span class="sd">            seed (int, optional): Create a random generator with a fixed seed. If set to None,</span>
<span class="sd">                create a random seed (default=None).</span>
<span class="sd">            distribution (str, optional): The path of distribution config file (default=&quot;&quot;).</span>

<span class="sd">        Returns:</span>
<span class="sd">            StorageDataset.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If dataset folder does not exist.</span>
<span class="sd">            ValueError: If dataset folder permission denied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN_DEPRECATED: The usage of read_dir is deprecated, please use TFRecordDataset with GLOB.&quot;</span><span class="p">)</span>

        <span class="n">list_files</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dir_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dataset folder does not exist!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dataset folder permission denied!&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">dir_path</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">list_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>

        <span class="n">list_files</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
            <span class="n">rand</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">rand</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">list_files</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">StorageDataset</span><span class="p">(</span><span class="n">list_files</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">columns_list</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">,</span>
                              <span class="n">deterministic_output</span><span class="p">,</span> <span class="n">prefetch_size</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_indexs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span>

    <span class="nd">@input_indexs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">input_indexs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_get_pipeline_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">device_iter</span> <span class="o">=</span> <span class="n">TupleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_shapes</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_output_shapes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_types</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_output_types</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_batch_size</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_classes</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">num_classes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repeat_count</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_repeat_count</span><span class="p">()</span>
        <span class="n">device_iter</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">output_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the shapes of output data.</span>

<span class="sd">        Return:</span>
<span class="sd">            List, list of shape of each column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_shapes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_pipeline_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_shapes</span>

    <span class="k">def</span> <span class="nf">output_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the types of output data.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of data type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_pipeline_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_types</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in a dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_classes</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_batch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the size of a batch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, the number of data in a batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_batch_size</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get_repeat_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the replication times in RepeatDataset else 1</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, the count of repeat.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_repeat_count</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the class index.</span>

<span class="sd">        Return:</span>
<span class="sd">            Dict, A str-to-int mapping from label name to index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_class_indexing</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the dataset for next epoch&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">SourceDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class to represent a source dataset  which produces content to the data pipeline.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># No need for __init__ since it is the same as the super&#39;s init</span>


<span class="k">class</span> <span class="nc">DatasetOp</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class to represent a operations on dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># No need for __init__ since it is the same as the super&#39;s init</span>


<span class="k">class</span> <span class="nc">BatchDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Batch operator to the input dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be batched.</span>
<span class="sd">        batch_size (int): The size of the batch.</span>
<span class="sd">        drop_remainder (bool, optional): Whether drop the remainder batch of data (drop_remainder=False).</span>
<span class="sd">            If True, the last incomplete batch will be dropped.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">per_batch_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">BatchDataset</span><span class="o">.</span><span class="n">_is_ancestor_of_repeat</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Repeat is located before batch, data from two epochs can be batched together.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_remainder</span> <span class="o">=</span> <span class="n">drop_remainder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">per_batch_map</span> <span class="o">=</span> <span class="n">per_batch_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span> <span class="o">=</span> <span class="n">input_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;batch_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;drop_remainder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_remainder</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;per_batch_map&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_batch_map</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;input_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_remainder</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">child_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">child_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_batch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the size of a batch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, the number of data in a batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_ancestor_of_repeat</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to find the case where repeat is used before batch.</span>

<span class="sd">        Args:</span>
<span class="sd">             dataset (Dataset): dataset to be checked</span>
<span class="sd">        Return:</span>
<span class="sd">            True or False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">RepeatDataset</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">input_dataset</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">|</span> <span class="n">BatchDataset</span><span class="o">.</span><span class="n">_is_ancestor_of_repeat</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flag</span>


<span class="k">class</span> <span class="nc">BatchInfo</span><span class="p">(</span><span class="n">CBatchInfo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The information object associates with the current batch of tensors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_batch_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the batch number of the current batch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of the current batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">get_epoch_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the epoch number of the current batch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of the current epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>


<span class="k">class</span> <span class="nc">ShuffleDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Shuffle operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be shuffled.</span>
<span class="sd">        buffer_size (int): The size of the buffer.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;buffer_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">class</span> <span class="nc">MapDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Map operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be mapped.</span>
<span class="sd">        input_columns (list[str]): List of names of the input columns</span>
<span class="sd">            (default=None, the operations will be applied on the first columns in the dataset).</span>
<span class="sd">            The size of the list should match the number of inputs of the first operator.</span>
<span class="sd">        operations (TensorOp): A function mapping a nested structure of tensors</span>
<span class="sd">            to another nested structure of tensor (default=None).</span>
<span class="sd">        output_columns (list[str], optional): list of names of the output columns.</span>
<span class="sd">            The size of the list should match the number of outputs of the last operator</span>
<span class="sd">            (default=None, output columns will be the input columns, i.e., the columns will</span>
<span class="sd">            be replaced).</span>
<span class="sd">        columns_order (list[str], optional): list of all the desired columns of the dataset (default=None).</span>
<span class="sd">            The argument is mandatory if len(input_columns) != len(output_columns).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to process the Dataset</span>
<span class="sd">            in parallel (default=None).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If len(input_columns) != len(output_columns) and columns_order is not specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">input_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span> <span class="o">=</span> <span class="n">input_columns</span>
        <span class="k">if</span> <span class="n">operations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operations</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span><span class="n">operations</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operations</span> <span class="o">=</span> <span class="n">operations</span>
        <span class="k">if</span> <span class="n">output_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">output_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span> <span class="o">=</span> <span class="n">output_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_order</span> <span class="o">=</span> <span class="n">columns_order</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span> \
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When (len(input_columns) != len(output_columns)), columns_order must be specified.&quot;</span><span class="p">)</span>

        <span class="n">input_dataset</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;input_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;operations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;output_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">RepeatDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Repeat operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be repeated.</span>
<span class="sd">        count (int): Number of times the dataset should be repeated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">child_size</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_repeat_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the replication times in RepeatDataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, the count of repeat.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>


<span class="k">class</span> <span class="nc">ZipDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Zip operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets (tuple): A tuple of datasets to be zipped together.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If dataset is not an instance of Dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The parameter </span><span class="si">%s</span><span class="s2"> of zip has type error!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span> <span class="o">=</span> <span class="n">datasets</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children_sizes</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">children_sizes</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in a dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">class</span> <span class="nc">RenameDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Rename operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be Renamed.</span>
<span class="sd">        input_column_names (list[str]): list of names of the input columns.</span>
<span class="sd">        output_column_names (list[str]): list of names of the output columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">input_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">output_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_column_names</span> <span class="o">=</span> <span class="n">input_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_column_names</span> <span class="o">=</span> <span class="n">output_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;input_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_column_names</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;output_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_column_names</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">class</span> <span class="nc">ProjectDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Project operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be Project.</span>
<span class="sd">        columns (list[str]): List of names of the columns to project.</span>
<span class="sd">        prefetch_size (int, optional): Prefetch number of records ahead of the</span>
<span class="sd">            user&#39;s request (default=None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">prefetch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span> <span class="o">=</span> <span class="n">prefetch_size</span>

        <span class="n">input_dataset</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;prefetch_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">class</span> <span class="nc">TransferDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying TDT operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be transferred.</span>
<span class="sd">        queue_name (str): Name of device queue.</span>
<span class="sd">        device_id (int): Id of device.</span>
<span class="sd">        device_type (str): Type of device, including &quot;CPU&quot;, &quot;GPU&quot;, and &quot;Ascend&quot;.</span>
<span class="sd">        num_batch (int): limit the number of batch to be sent to device (default=None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">queue_name</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">device_type</span><span class="p">,</span> <span class="n">num_batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue_name</span> <span class="o">=</span> <span class="n">queue_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device_type</span> <span class="o">=</span> <span class="n">device_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device_id</span> <span class="o">=</span> <span class="n">device_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__num_batch</span> <span class="o">=</span> <span class="n">num_batch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;queue_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_name</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;device_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device_type</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;device_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_batch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__num_batch</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">create_dict_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset is not iterable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_tuple_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset is not iterable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset is not iterable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">output_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset does not support output_shapes&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">output_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset does not support output_types&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># need to keep iterator alive so the executionTree is not destroyed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span> <span class="o">=</span> <span class="n">TupleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="StorageDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.StorageDataset">[docs]</a><span class="k">class</span> <span class="nc">StorageDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads and parses datasets stored on disk in various formats, including TFData format.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_files (list[str]): List of files to be read.</span>
<span class="sd">        schema (str): Path to the json schema file.</span>
<span class="sd">        distribution (str, optional): Path of distribution config file (default=&quot;&quot;).</span>
<span class="sd">        columns_list (list[str], optional): List of columns to be read (default=None, read all columns).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of parallel working threads (default=None).</span>
<span class="sd">        deterministic_output (bool, optional): Whether the result of this dataset can be reproduced</span>
<span class="sd">                or not (default=True). If True, performance might be affected.</span>
<span class="sd">        prefetch_size (int, optional): Prefetch number of records ahead of the user&#39;s request (default=None).</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If schema file failed to read.</span>
<span class="sd">        RuntimeError: If distribution file path is given but failed to read.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_files</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">deterministic_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefetch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN_DEPRECATED: The usage of StorageDataset is deprecated, please use TFRecordDataset.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span> <span class="o">=</span> <span class="n">dataset_files</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">load_f</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">load_f</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Json decode error when load schema file&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Schema file failed to load&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">distribution</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">load_d</span><span class="p">:</span>
                    <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">load_d</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Json decode error when load distribution file&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Distribution file failed to load&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">distribution</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span> <span class="o">=</span> <span class="n">columns_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deterministic_output</span> <span class="o">=</span> <span class="n">deterministic_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span> <span class="o">=</span> <span class="n">prefetch_size</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;distribution&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;deterministic_output&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic_output</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;prefetch_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="StorageDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.StorageDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_pipeline_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span></div>

    <span class="c1"># manually set dataset_size as a temporary solution.</span>
    <span class="k">def</span> <span class="nf">set_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN_DEPRECATED: This method is deprecated. Please use get_dataset_size directly.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;set dataset_size with negative value </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

<div class="viewcode-block" id="StorageDataset.num_classes"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.StorageDataset.num_classes">[docs]</a>    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If dataset type is invalid.</span>
<span class="sd">            ValueError: If dataset is not Imagenet dataset or manifest dataset.</span>
<span class="sd">            RuntimeError: If schema file is given but failed to load.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cur_dataset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">cur_dataset</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
            <span class="n">cur_dataset</span> <span class="o">=</span> <span class="n">cur_dataset</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cur_dataset</span><span class="p">,</span> <span class="s2">&quot;schema&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dataset type is invalid&quot;</span><span class="p">)</span>
        <span class="c1"># Only IMAGENET/MANIFEST support numclass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cur_dataset</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">load_f</span><span class="p">:</span>
                <span class="n">load_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">load_f</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Json decode error when load schema file&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Schema file failed to load&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">load_dict</span><span class="p">[</span><span class="s2">&quot;datasetType&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;IMAGENET&quot;</span> <span class="ow">and</span> <span class="n">load_dict</span><span class="p">[</span><span class="s2">&quot;datasetType&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;MANIFEST&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> dataset does not support num_classes!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">load_dict</span><span class="p">[</span><span class="s2">&quot;datasetType&quot;</span><span class="p">]))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_classes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_pipeline_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_classes</span></div></div>


<span class="k">class</span> <span class="nc">RangeDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads and parses datasets stored on disk in a range.</span>

<span class="sd">    Args:</span>
<span class="sd">        start (int): starting index.</span>
<span class="sd">        stop (int): ending index.</span>
<span class="sd">        step (int): step size in a range.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;stop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">def</span> <span class="nf">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">input_sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create sampler based on user input.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_samples (int): Number of samples</span>
<span class="sd">        input_sampler (Iterable / Sampler): Sampler from user</span>
<span class="sd">        shuffle (bool): Shuffle</span>
<span class="sd">        num_shards (int): Number of shard for sharding</span>
<span class="sd">        shard_id (int): Shard ID</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">input_sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If shuffle is not specified, user provided sampler, use user&#39;s sampler</span>
            <span class="k">return</span> <span class="n">input_sampler</span>
        <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If shuffle is not specified, sharding enabled, use distributed random sampler</span>
            <span class="n">shuffle</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">)</span>
        <span class="c1"># If shuffle is not specified, sharding disabled, use random sampler</span>
        <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">(</span><span class="n">replacement</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If shuffle enabled, sharding enabled, use distributed random sampler</span>
            <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">)</span>
        <span class="c1"># If shuffle enabled, sharding disabled, use random sampler</span>
        <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">(</span><span class="n">replacement</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If shuffle disabled, sharding enabled, use distributed sequential sampler</span>
        <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">)</span>
    <span class="c1"># If shuffle disabled, sharding disabled, use sequential sampler</span>
    <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">SequentialSampler</span><span class="p">()</span>



<div class="viewcode-block" id="ImageFolderDatasetV2"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ImageFolderDatasetV2">[docs]</a><span class="k">class</span> <span class="nc">ImageFolderDatasetV2</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads images from a tree of directories.</span>

<span class="sd">    All images within one folder have the same label.</span>
<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;label&#39;].</span>
<span class="sd">    The shape of the image column is [image_size] if decode flag is False, or [H,W,C]</span>
<span class="sd">    otherwise.</span>
<span class="sd">    The type of the image tensor is uint8. The label is just a scalar uint64</span>
<span class="sd">    tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        extensions (list[str], optional): List of file extensions to be</span>
<span class="sd">            included in the dataset (default=None).</span>
<span class="sd">        class_indexing (dict, optional): A str-to-int mapping from folder name to index</span>
<span class="sd">            (default=None, the folder names will be sorted</span>
<span class="sd">            alphabetically and each class will be given a</span>
<span class="sd">            unique index starting from 0).</span>
<span class="sd">        decode (bool, optional): decode the images after reading (default=False).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        RuntimeError: If class_indexing is not a dictionary.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; # path to imagefolder directory. This directory needs to contain sub-directories which contain the images</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/imagefolder_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read all samples (image files) in dataset_dir with 8 threads</span>
<span class="sd">        &gt;&gt;&gt; imagefolder_dataset = ds.ImageFolderDatasetV2(dataset_dir, num_parallel_workers=8)</span>
<span class="sd">        &gt;&gt;&gt; # 2) read all samples (image files) from folder cat and folder dog with label 0 and 1</span>
<span class="sd">        &gt;&gt;&gt; imagefolder_dataset = ds.ImageFolderDatasetV2(dataset_dir,class_indexing={&quot;cat&quot;:0,&quot;dog&quot;:1})</span>
<span class="sd">        &gt;&gt;&gt; # 3) read all samples (image files) in dataset_dir with extensions .JPEG and .png (case sensitive)</span>
<span class="sd">        &gt;&gt;&gt; imagefolder_dataset = ds.ImageFolderDatasetV2(dataset_dir, extensions={&quot;.JPEG&quot;,&quot;.png&quot;})</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_imagefolderdatasetv2</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_indexing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="n">extensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="o">=</span> <span class="n">class_indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;extensions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;class_indexing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="ImageFolderDatasetV2.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ImageFolderDatasetV2.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">ImageFolderOp</span><span class="o">.</span><span class="n">get_num_rows_and_classes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageFolderDatasetV2.num_classes"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ImageFolderDatasetV2.num_classes">[docs]</a>    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">return</span> <span class="n">ImageFolderOp</span><span class="o">.</span><span class="n">get_num_rows_and_classes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="MnistDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.MnistDataset">[docs]</a><span class="k">class</span> <span class="nc">MnistDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset for reading and parsing the Mnist dataset.</span>

<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;label&#39;].</span>
<span class="sd">    The type of the image tensor is uint8. The label is just a scalar uint32 tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=value, set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/mnist_folder&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read 3 samples from mnist_dataset</span>
<span class="sd">        &gt;&gt;&gt; mnist_dataset = ds.MnistDataset(dataset_dir=dataset_dir, num_samples=3)</span>
<span class="sd">        &gt;&gt;&gt; # in mnist_dataset dataset, each dictionary has keys &quot;image&quot; and &quot;label&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mnist_cifar_dataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="MnistDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.MnistDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">MnistOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MindDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.MindDataset">[docs]</a><span class="k">class</span> <span class="nc">MindDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads from shard files and database.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_file (str): one of file names in dataset.</span>
<span class="sd">        columns_list (list[str], optional): List of columns to be read (default=None).</span>
<span class="sd">        num_parallel_workers (int, optional): The number of readers (default=None).</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset</span>
<span class="sd">            (default=None, performs shuffle).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>
<span class="sd">        block_reader (bool, optional): Whether read data by block mode (default=False).</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        ValueError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If block reader is true but partition is specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_minddataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_file</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">block_reader</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span> <span class="o">=</span> <span class="n">dataset_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span> <span class="o">=</span> <span class="n">columns_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_shuffle</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">shuffle</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">block_reader</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;block reader not allowed true when use partitions&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block_reader</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN: global shuffle is not used.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_reader</span> <span class="o">=</span> <span class="n">block_reader</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;global_shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_shuffle</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;partitions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;block_reader&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_reader</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="MindDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.MindDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">MindRecordOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_rows</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num_rows</span></div></div>


<span class="k">def</span> <span class="nf">ds_fn</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
        <span class="c1"># convert output tensors to ndarrays</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">sampler_fn</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sampler</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># convert output tensors to ndarrays</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>


<div class="viewcode-block" id="GeneratorDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.GeneratorDataset">[docs]</a><span class="k">class</span> <span class="nc">GeneratorDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that generate data from calling generator function each epoch.</span>

<span class="sd">    Args:</span>
<span class="sd">        generator_function (callable):</span>
<span class="sd">            A callable object that returns an Generator object that supports the iter() protocol.</span>
<span class="sd">            Generator object is required to return a tuple of numpy array as a row of the dataset on next().</span>
<span class="sd">        column_names (list[str]): List of column names of the dataset.</span>
<span class="sd">        column_types (list[mindspore.dtype], optional): List of column data types of the dataset (default=None).</span>
<span class="sd">            If provided, sanity check will be performed on generator output.</span>
<span class="sd">        prefetch_size (int, optional): Prefetch number of records ahead of the user&#39;s request (default=None).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the dataset (default=None).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; # 1) generator function that generates multi-dimensional data</span>
<span class="sd">        &gt;&gt;&gt; def generator_md():</span>
<span class="sd">        &gt;&gt;&gt;     for i in range(64):</span>
<span class="sd">        &gt;&gt;&gt;         yield (np.array([[i, i + 1], [i + 2, i + 3]]),)</span>
<span class="sd">        &gt;&gt;&gt; # create multi_dimension_generator_dataset with GeneratorMD() and column name &quot;multi_dimensional_data&quot;</span>
<span class="sd">        &gt;&gt;&gt; multi_dimension_generator_dataset = ds.GeneratorDataset(generator_md, [&quot;multi_dimensional_data&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # 2) generator function that generates multi-columns data</span>
<span class="sd">        &gt;&gt;&gt; def generator_mc(maxid = 64):</span>
<span class="sd">        &gt;&gt;&gt;     for i in range(maxid):</span>
<span class="sd">        &gt;&gt;&gt;         yield (np.array([i]), np.array([[i, i + 1], [i + 2, i + 3]]))</span>
<span class="sd">        &gt;&gt;&gt; # create multi_column_generator_dataset with GeneratorMC() and column names &quot;col1&quot; and &quot;col2&quot;</span>
<span class="sd">        &gt;&gt;&gt; multi_column_generator_dataset = ds.GeneratorDataset(generator_mc, [&quot;col1, col2&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_generatordataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator_function</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">column_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefetch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generator_function</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">sampler_fn</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">generator_function</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># test to see if generator_function is iterable</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">generator_function</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># generator_function was not iterable, assume it is a function</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generator_function</span> <span class="o">=</span> <span class="n">generator_function</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># generator_function was iterable, build a function around it</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generator_function</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">ds_fn</span><span class="p">(</span><span class="n">generator_function</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span> <span class="o">=</span> <span class="n">column_names</span>

        <span class="k">if</span> <span class="n">column_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span> <span class="o">=</span> <span class="n">mstypelist_to_detypelist</span><span class="p">(</span><span class="n">column_types</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span> <span class="o">=</span> <span class="n">column_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span> <span class="o">=</span> <span class="n">prefetch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">sampler</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;generator_function&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator_function</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;column_names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;column_types&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;prefetch_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="GeneratorDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.GeneratorDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span></div>

    <span class="c1"># manually set dataset_size as a temporary solution.</span>
    <span class="k">def</span> <span class="nf">set_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;set dataset_size with negative value </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>


<div class="viewcode-block" id="TFRecordDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.TFRecordDataset">[docs]</a><span class="k">class</span> <span class="nc">TFRecordDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads and parses datasets stored on disk in TFData format.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_files (str or list[str]): String or list of files to be read or glob strings to search for a pattern of</span>
<span class="sd">            files. The list will be sorted in a lexicographical order.</span>
<span class="sd">        schema (str or Schema, optional): Path to the json schema file or schema object (default=None).</span>
<span class="sd">            If the schema is not provided, the meta data from the TFData file is considered the schema.</span>
<span class="sd">        columns_list (list[str], optional): List of columns to be read (default=None, read all columns)</span>
<span class="sd">        num_samples (int, optional): number of samples(rows) to read (default=None, reads the full dataset).</span>
<span class="sd">        num_parallel_workers (int, optional): number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, Shuffle level, optional): perform reshuffling of the data every epoch (default=Shuffle.GLOBAL).</span>
<span class="sd">            If shuffle is False, no shuffling will be performed;</span>
<span class="sd">            If shuffle is True, the behavior is the same as setting shuffle to be Shuffle.GLOBAL</span>
<span class="sd">            Otherwise, there are two levels of shuffling:</span>

<span class="sd">            - Shuffle.GLOBAL: Shuffle both the files and samples.</span>

<span class="sd">            - Shuffle.FILES: Shuffle files only.</span>

<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>
<span class="sd">        shard_equal_rows (bool): Get equal rows for all shards(default=False). If shard_equal_rows is false, number</span>
<span class="sd">            of rows of each shard may be not equal.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.common.dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; dataset_files = [&quot;/path/to/1&quot;, &quot;/path/to/2&quot;] # contains 1 or multiple tf data files</span>
<span class="sd">        &gt;&gt;&gt; # 1) get all rows from dataset_files with no explicit schema:</span>
<span class="sd">        &gt;&gt;&gt; # The meta-data in the first row will be used as a schema.</span>
<span class="sd">        &gt;&gt;&gt; tfdataset = ds.TFRecordDataset(dataset_files=dataset_files)</span>
<span class="sd">        &gt;&gt;&gt; # 2) get all rows from dataset_files with user-defined schema:</span>
<span class="sd">        &gt;&gt;&gt; schema = ds.Schema()</span>
<span class="sd">        &gt;&gt;&gt; schema.add_column(&#39;col_1d&#39;, de_type=mstype.int64, shape=[2])</span>
<span class="sd">        &gt;&gt;&gt; tfdataset = ds.TFRecordDataset(dataset_files=dataset_files, schema=schema)</span>
<span class="sd">        &gt;&gt;&gt; # 3) get all rows from dataset_files with schema file &quot;./schema.json&quot;:</span>
<span class="sd">        &gt;&gt;&gt; tfdataset = ds.TFRecordDataset(dataset_files=dataset_files, schema=&quot;./schema.json&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_files</span><span class="p">(</span><span class="n">patterns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to search for files with the given glob patterns.</span>

<span class="sd">        Args:</span>
<span class="sd">            patterns (str or list[str]): string or list of patterns to be searched.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List, files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">flat</span><span class="p">(</span><span class="n">lists</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span><span class="n">patterns</span><span class="p">]</span>

        <span class="n">file_list</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">file_list</span><span class="p">:</span>  <span class="c1"># not empty</span>
            <span class="k">return</span> <span class="n">file_list</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The list of path names matching the patterns is empty.&quot;</span><span class="p">)</span>

    <span class="nd">@check_tfrecorddataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_files</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_equal_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_files</span><span class="p">(</span><span class="n">dataset_files</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="n">schema_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">)):</span>
            <span class="n">schema_obj</span> <span class="o">=</span> <span class="n">Schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>  <span class="c1"># read the schema file and convert to schema object to validate it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span> <span class="o">=</span> <span class="n">columns_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="k">if</span> <span class="n">schema_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">schema_obj</span><span class="o">.</span><span class="n">num_rows</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Shuffle</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shuffle should be of boolean or enum &#39;Shuffle&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">Shuffle</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_equal_rows</span> <span class="o">=</span> <span class="n">shard_equal_rows</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">datasetType</span> <span class="o">=</span> <span class="s1">&#39;TF&#39;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
                <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema_json_string&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema_file_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_equal_rows&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_equal_rows</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="TFRecordDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.TFRecordDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Args:</span>
<span class="sd">            estimate (bool, optional): Fast estimation of the dataset size instead of a full scan.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">TFReaderOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">estimate</span><span class="p">)</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">num_rows</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ManifestDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ManifestDataset">[docs]</a><span class="k">class</span> <span class="nc">ManifestDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads images from a manifest file.</span>

<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;label&#39;].</span>
<span class="sd">    The shape of the image column is [image_size] if decode flag is False, or [H,W,C]</span>
<span class="sd">    otherwise.</span>
<span class="sd">    The type of the image tensor is uint8. The label is just a scalar uint64</span>
<span class="sd">    tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_file (str): File to be read.</span>
<span class="sd">        usage (str, optional): Need train, eval or inference data (default=&quot;train&quot;).</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset.</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        class_indexing (dict, optional): A str-to-int mapping from label name to index</span>
<span class="sd">            (default=None, the folder names will be sorted alphabetically and each</span>
<span class="sd">            class will be given a unique index starting from 0).</span>
<span class="sd">        decode (bool, optional): decode the images after reading (defaults=False).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        RuntimeError: If class_indexing is not a dictionary.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_file = &quot;/path/to/manifest_file.manifest&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read all samples specified in manifest_file dataset with 8 threads for training:</span>
<span class="sd">        &gt;&gt;&gt; manifest_dataset = ds.ManifestDataset(dataset_file, usage=&quot;train&quot;, num_parallel_workers=8)</span>
<span class="sd">        &gt;&gt;&gt; # 2) reads samples (specified in manifest_file.manifest) for shard 0 in a 2-way distributed training setup:</span>
<span class="sd">        &gt;&gt;&gt; manifest_dataset = ds.ManifestDataset(dataset_file, num_shards=2, shard_id=0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_manifestdataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_file</span><span class="p">,</span> <span class="n">usage</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_indexing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span> <span class="o">=</span> <span class="n">dataset_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">class_indexing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">class_indexing</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;class_indexing should be a dictionary.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="o">=</span> <span class="n">class_indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usage</span> <span class="o">=</span> <span class="n">usage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;usage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;class_indexing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="ManifestDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ManifestDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">ManifestOp</span><span class="o">.</span><span class="n">get_num_rows_and_classes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">class_indexing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span></div>

<div class="viewcode-block" id="ManifestDataset.num_classes"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ManifestDataset.num_classes">[docs]</a>    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in a dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>

        <span class="k">return</span> <span class="n">ManifestOp</span><span class="o">.</span><span class="n">get_num_rows_and_classes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">class_indexing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="ManifestDataset.get_class_indexing"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ManifestDataset.get_class_indexing">[docs]</a>    <span class="k">def</span> <span class="nf">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the class index</span>

<span class="sd">        Return:</span>
<span class="sd">            Dict, A str-to-int mapping from label name to index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>

        <span class="k">return</span> <span class="n">ManifestOp</span><span class="o">.</span><span class="n">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">class_indexing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Cifar10Dataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Cifar10Dataset">[docs]</a><span class="k">class</span> <span class="nc">Cifar10Dataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads cifar10 data.</span>

<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;label&#39;].</span>
<span class="sd">    The type of the image tensor is uint8. The label is just a scalar uint32</span>
<span class="sd">    tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset.</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/cifar10_dataset_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) get all samples from CIFAR10 dataset in sequence:</span>
<span class="sd">        &gt;&gt;&gt; dataset = ds.Cifar10Dataset(dataset_dir=dataset_dir,shuffle=False)</span>
<span class="sd">        &gt;&gt;&gt; # 2) randomly select 350 samples from CIFAR10 dataset:</span>
<span class="sd">        &gt;&gt;&gt; dataset = ds.Cifar10Dataset(dataset_dir=dataset_dir,num_samples=350, shuffle=True)</span>
<span class="sd">        &gt;&gt;&gt; # 3) get samples from CIFAR10 dataset for shard 0 in a 2 way distributed training:</span>
<span class="sd">        &gt;&gt;&gt; dataset = ds.Cifar10Dataset(dataset_dir=dataset_dir,num_shards=2,shard_id=0)</span>
<span class="sd">        &gt;&gt;&gt; # in CIFAR10 dataset, each dictionary has keys &quot;image&quot; and &quot;label&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mnist_cifar_dataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="Cifar10Dataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Cifar10Dataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">CifarOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Cifar100Dataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Cifar100Dataset">[docs]</a><span class="k">class</span> <span class="nc">Cifar100Dataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads cifar100 data.</span>

<span class="sd">    The generated dataset has three columns [&#39;image&#39;, &#39;coarse_label&#39;, &#39;fine_label&#39;].</span>
<span class="sd">    The type of the image tensor is uint8. The coarse and fine are just a scalar uint32</span>
<span class="sd">    tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset.</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/cifar100_dataset_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) get all samples from CIFAR100 dataset in sequence:</span>
<span class="sd">        &gt;&gt;&gt; cifar100_dataset = ds.Cifar100Dataset(dataset_dir=dataset_dir,shuffle=False)</span>
<span class="sd">        &gt;&gt;&gt; # 2) randomly select 350 samples from CIFAR100 dataset:</span>
<span class="sd">        &gt;&gt;&gt; cifar100_dataset = ds.Cifar100Dataset(dataset_dir=dataset_dir,num_samples=350, shuffle=True)</span>
<span class="sd">        &gt;&gt;&gt; # in CIFAR100 dataset, each dictionary has 3 keys: &quot;image&quot;, &quot;fine_label&quot; and &quot;coarse_label&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mnist_cifar_dataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="Cifar100Dataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Cifar100Dataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">CifarOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Schema"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema">[docs]</a><span class="k">class</span> <span class="nc">Schema</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to represent a schema of dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        schema_file(str): Path of schema file (default=None).</span>

<span class="sd">    Return:</span>
<span class="sd">        Schema object, schema info about dataset.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If schema file failed to load.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.common.dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; # create schema, specify column name, mindspore.dtype and shape of the column</span>
<span class="sd">        &gt;&gt;&gt; schema = ds.Schema()</span>
<span class="sd">        &gt;&gt;&gt; schema.add_column(&#39;col1&#39;, de_type=mstype.int64, shape=[2])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">schema_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">schema_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">load_f</span><span class="p">:</span>
                    <span class="n">json_obj</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">load_f</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">json_obj</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Schema file failed to load&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Schema.add_column"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema.add_column">[docs]</a>    <span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">de_type</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add new column to the schema.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): name of the column.</span>
<span class="sd">            de_type (str): data type of the column.</span>
<span class="sd">            shape (list[int], optional): shape of the column</span>
<span class="sd">                (default=None, [-1] which is an unknown shape of rank 1).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If column type is unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_column</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">de_type</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">):</span>
            <span class="n">de_type</span> <span class="o">=</span> <span class="n">mstype_to_detype</span><span class="p">(</span><span class="n">de_type</span><span class="p">)</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">de_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">de_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">DataType</span><span class="p">(</span><span class="n">de_type</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown column type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_column</span><span class="p">)</span></div>

<div class="viewcode-block" id="Schema.to_json"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a JSON string of the schema.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Str, JSON string of the schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">json_file</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">json_file</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="p">:</span>
            <span class="n">json_file</span><span class="p">[</span><span class="s2">&quot;datasetType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="n">json_file</span><span class="p">[</span><span class="s2">&quot;numRows&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Schema.parse_columns"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema.parse_columns">[docs]</a>    <span class="k">def</span> <span class="nf">parse_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the columns and add it to self.</span>

<span class="sd">        Args:</span>
<span class="sd">            columns (list[str]): names of columns.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If failed to parse schema file.</span>
<span class="sd">            RuntimeError: If unknown items in schema file.</span>
<span class="sd">            RuntimeError: If column&#39;s name field is missing.</span>
<span class="sd">            RuntimeError: If column&#39;s type field is missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">col_details</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">col_details</span> <span class="o">=</span> <span class="n">col</span>
                <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">col_details</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">col</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error parsing the schema file&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">col_details</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;shape&quot;</span><span class="p">:</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
                    <span class="n">data_type</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">elif</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;t_impl&quot;</span><span class="p">,</span> <span class="s2">&quot;rank&quot;</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unknown field </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Column&#39;s name field is missing.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Column&#39;s type field is missing.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Schema.from_json"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema.from_json">[docs]</a>    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get schema file from json file.</span>

<span class="sd">        Args:</span>
<span class="sd">            json_obj(dictionary): object of json parsed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: if there is unknown item in the object.</span>
<span class="sd">            RuntimeError: if dataset type is missing in the object.</span>
<span class="sd">            RuntimeError: if columns are missing in the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">json_obj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;datasetType&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;numRows&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;columns&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parse_columns</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unknown field </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;DatasetType field is missing.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Columns are missing.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span></div>


<div class="viewcode-block" id="VOCDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.VOCDataset">[docs]</a><span class="k">class</span> <span class="nc">VOCDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset for reading and parsing VOC dataset.</span>

<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;target&#39;].</span>
<span class="sd">    The shape of both column is [image_size] if decode flag is False, or [H, W, C]</span>
<span class="sd">    otherwise.</span>
<span class="sd">    The type of both tensor is uint8.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        decode (bool, optional): Decode the images after reading (default=False).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the dataset</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        distribution (str, optional): Path to the json distribution file to configure</span>
<span class="sd">            dataset sharding (default=None). This argument should be specified</span>
<span class="sd">            only when no &#39;sampler&#39; is used.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If distribution and sampler are specified at the same time.</span>
<span class="sd">        RuntimeError: If distribution is failed to read.</span>
<span class="sd">        RuntimeError: If shuffle and sampler are specified at the same time.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/voc_dataset_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read all VOC dataset samples in dataset_dir with 8 threads in random order:</span>
<span class="sd">        &gt;&gt;&gt; voc_dataset = ds.VOCDataset(dataset_dir, num_parallel_workers=8)</span>
<span class="sd">        &gt;&gt;&gt; # 2) read then decode all VOC dataset samples in dataset_dir in sequence:</span>
<span class="sd">        &gt;&gt;&gt; voc_dataset = ds.VOCDataset(dataset_dir, decode=True, shuffle=False)</span>
<span class="sd">        &gt;&gt;&gt; # in VOC dataset, each dictionary has keys &quot;image&quot; and &quot;target&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_vocdataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">sampler</span>
        <span class="k">if</span> <span class="n">distribution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify distribution and sampler at the same time.&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">load_d</span><span class="p">:</span>
                    <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">load_d</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Json decode error when load distribution file&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Distribution file has failed to load.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify shuffle and sampler at the same time.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;distribution&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="VOCDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.VOCDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span></div></div>


<div class="viewcode-block" id="CelebADataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.CelebADataset">[docs]</a><span class="k">class</span> <span class="nc">CelebADataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset for reading and parsing CelebA dataset.Only support list_attr_celeba.txt currently</span>

<span class="sd">    Note:</span>
<span class="sd">        The generated dataset has two columns [&#39;image&#39;, &#39;attr&#39;].</span>
<span class="sd">        The type of the image tensor is uint8. The attr tensor is uint32 and one hot type.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data (default=value set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None).</span>
<span class="sd">        dataset_type (string): one of &#39;all&#39;, &#39;train&#39;, &#39;valid&#39; or &#39;test&#39;.</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the dataset (default=None).</span>
<span class="sd">        decode (bool, optional): decode the images after reading (default=False).</span>
<span class="sd">        extensions (list[str], optional): List of file extensions to be</span>
<span class="sd">            included in the dataset (default=None).</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset.</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_celebadataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                 <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="n">num_parallel_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="n">extensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span> <span class="o">=</span> <span class="n">dataset_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;extensions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>