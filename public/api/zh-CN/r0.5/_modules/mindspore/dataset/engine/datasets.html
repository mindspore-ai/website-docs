<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.dataset.engine.datasets &mdash; MindSpore r0.5 documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script><script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/js/theme.js"></script><script src="../../../../_static/underscore.js"></script><script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dtype.html">mindspore.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.context.html">mindspore.context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.nn.dynamic_lr.html">mindspore.nn.dynamic_lr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.ops.composite.html">mindspore.ops.composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.ops.operations.html">mindspore.ops.operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.parallel.html">mindspore.parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.text.transforms.html">mindspore.dataset.text.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.text.utils.html">mindspore.dataset.text.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.transforms.c_transforms.html">mindspore.dataset.transforms.c_transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.transforms.vision.c_transforms.html">mindspore.dataset.transforms.vision.c_transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.transforms.py_transforms.html">mindspore.dataset.transforms.py_transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.dataset.transforms.vision.py_transforms.html">mindspore.dataset.transforms.vision.py_transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindspore/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindinsight/mindinsight.lineagemgr.html">mindinsight.lineagemgr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindinsight/mindinsight.profiler.html">mindinsight.profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.html">mindarmour</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.utils.html">mindarmour.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.evaluations.html">mindarmour.evaluations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.detectors.html">mindarmour.detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.attacks.html">mindarmour.attacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.defenses.html">mindarmour.defenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.fuzzing.html">mindarmour.fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/python/mindarmour/mindarmour.diff_privacy.html">mindarmour.diff_privacy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>mindspore.dataset.engine.datasets</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mindspore.dataset.engine.datasets</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ==============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">datasets.py supports various formats of datasets, including ImageNet, TFData,</span>
<span class="sd">MNIST, Cifar10/100, Manifest, MindRecord, etc. This module could load data in</span>
<span class="sd">high performance and parse data precisely. It also provides the following</span>
<span class="sd">operations for users to preprocess data: shuffle, batch, repeat, map, and zip.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">import_module</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">mindspore._c_dataengine</span> <span class="kn">import</span> <span class="n">DataType</span><span class="p">,</span> <span class="n">TFReaderOp</span><span class="p">,</span> <span class="n">ImageFolderOp</span><span class="p">,</span> <span class="n">CifarOp</span><span class="p">,</span> <span class="n">MnistOp</span><span class="p">,</span> <span class="n">ManifestOp</span><span class="p">,</span> \
    <span class="n">MindRecordOp</span><span class="p">,</span> <span class="n">TextFileOp</span><span class="p">,</span> <span class="n">ClueOp</span><span class="p">,</span> <span class="n">VOCOp</span><span class="p">,</span> <span class="n">CocoOp</span><span class="p">,</span> <span class="n">CBatchInfo</span>
<span class="kn">from</span> <span class="nn">mindspore._c_expression</span> <span class="kn">import</span> <span class="n">typing</span>

<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">samplers</span>
<span class="kn">from</span> <span class="nn">.iterators</span> <span class="kn">import</span> <span class="n">DictIterator</span><span class="p">,</span> <span class="n">TupleIterator</span>
<span class="kn">from</span> <span class="nn">.validators</span> <span class="kn">import</span> <span class="n">check_batch</span><span class="p">,</span> <span class="n">check_shuffle</span><span class="p">,</span> <span class="n">check_map</span><span class="p">,</span> <span class="n">check_filter</span><span class="p">,</span> <span class="n">check_repeat</span><span class="p">,</span> <span class="n">check_skip</span><span class="p">,</span> <span class="n">check_zip</span><span class="p">,</span> \
    <span class="n">check_rename</span><span class="p">,</span> <span class="n">check_numpyslicesdataset</span><span class="p">,</span> \
    <span class="n">check_take</span><span class="p">,</span> <span class="n">check_project</span><span class="p">,</span> <span class="n">check_imagefolderdatasetv2</span><span class="p">,</span> <span class="n">check_mnist_cifar_dataset</span><span class="p">,</span> <span class="n">check_manifestdataset</span><span class="p">,</span> \
    <span class="n">check_tfrecorddataset</span><span class="p">,</span> <span class="n">check_vocdataset</span><span class="p">,</span> <span class="n">check_cocodataset</span><span class="p">,</span> <span class="n">check_celebadataset</span><span class="p">,</span> <span class="n">check_minddataset</span><span class="p">,</span> \
    <span class="n">check_generatordataset</span><span class="p">,</span> <span class="n">check_sync_wait</span><span class="p">,</span> <span class="n">check_zip_dataset</span><span class="p">,</span> <span class="n">check_add_column</span><span class="p">,</span> <span class="n">check_textfiledataset</span><span class="p">,</span> <span class="n">check_concat</span><span class="p">,</span> \
    <span class="n">check_split</span><span class="p">,</span> <span class="n">check_bucket_batch_by_length</span><span class="p">,</span> <span class="n">check_cluedataset</span>
<span class="kn">from</span> <span class="nn">..core.datatypes</span> <span class="kn">import</span> <span class="n">mstype_to_detype</span><span class="p">,</span> <span class="n">mstypelist_to_detypelist</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">context</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;mindspore.context&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">context</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">Shuffle</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
    <span class="n">GLOBAL</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span>
    <span class="n">FILES</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;file&quot;</span>


<div class="viewcode-block" id="zip"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.zip">[docs]</a><span class="nd">@check_zip</span>
<span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="n">datasets</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zips the datasets in the input tuple of datasets.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets (tuple of class Dataset): A tuple of datasets to be zipped together.</span>
<span class="sd">            The number of datasets should be more than 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        DatasetOp, ZipDataset.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the number of datasets is 1.</span>
<span class="sd">        TypeError: If datasets is not a tuple.</span>

<span class="sd">    Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; dataset_dir1 = &quot;path/to/imagefolder_directory1&quot;</span>
<span class="sd">            &gt;&gt;&gt; dataset_dir2 = &quot;path/to/imagefolder_directory2&quot;</span>
<span class="sd">            &gt;&gt;&gt; ds1 = ds.ImageFolderDatasetV2(dataset_dir1, num_parallel_workers=8)</span>
<span class="sd">            &gt;&gt;&gt; ds2 = ds.ImageFolderDatasetV2(dataset_dir2, num_parallel_workers=8)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset which is the combination of ds1 and ds2</span>
<span class="sd">            &gt;&gt;&gt; data = ds.zip((ds1, ds2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Can&#39;t zip empty or just one dataset!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ZipDataset</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number rows of the dataset according to the shards.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_rows (int): The number rows of the dataset should be more than 0.</span>
<span class="sd">            The number rows of the dataset should be more than 0.</span>
<span class="sd">        num_shards (int or None): Number of shards that the dataset should be divided into.</span>
<span class="sd">            The number of shards should be None or more than 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Int, number of rows.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If num_rows is invalid (&lt; 0).</span>
<span class="sd">        ValueError: If num_shards is invalid (&lt;= 0).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_rows</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_rows is invalid (&lt; 0)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_shards</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_shards is invalid (&lt;= 0)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_rows</span> <span class="o">%</span> <span class="n">num_shards</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span> <span class="o">//</span> <span class="n">num_shards</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span> <span class="o">//</span> <span class="n">num_shards</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">num_rows</span>


<span class="k">class</span> <span class="nc">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class to represent a dataset in DataEngine&#39;s data pipeline.</span>

<span class="sd">    This class is the base class of SourceDataset and DatasetOp, and represents</span>
<span class="sd">    a node in the data flow graph.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to process the Dataset in parallel</span>
<span class="sd">            (default=None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="n">num_parallel_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_types</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_shapes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_classes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repeat_count</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns attributes (member variables) related to the current class.</span>

<span class="sd">        Must include all arguments passed to the __init__() of the current class, excluding &#39;input_dataset&#39;.</span>

<span class="sd">        Args:</span>

<span class="sd">        Returns:</span>
<span class="sd">            Python dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_parallel_workers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="nd">@check_bucket_batch_by_length</span>
    <span class="k">def</span> <span class="nf">bucket_batch_by_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">bucket_boundaries</span><span class="p">,</span> <span class="n">bucket_batch_sizes</span><span class="p">,</span>
                               <span class="n">element_length_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">pad_to_bucket_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bucket elements according to their lengths, and pad and batch the buckets when</span>
<span class="sd">        they are full.</span>

<span class="sd">        A length function is called on each row in the dataset, the row is then</span>
<span class="sd">        bucketed based on its length and bucket_boundaries. When a bucket reaches its</span>
<span class="sd">        corresponding size specified in bucket_batch_sizes, the entire bucket will be</span>
<span class="sd">        padded according to batch_info, and then batched. Each batch will be full,</span>
<span class="sd">        except for maybe the last batch for each bucket.</span>

<span class="sd">        Args:</span>
<span class="sd">            column_names (list of string): Columns passed to element_length_function.</span>
<span class="sd">            bucket_boundaries (list of int): A list consisting of the upper boundaries</span>
<span class="sd">                of the buckets. Must be strictly increasing. If there are n boundaries,</span>
<span class="sd">                n+1 buckets are created: One bucket for [0, bucket_boundaries[0]), one</span>
<span class="sd">                bucket for [bucket_boundaries[i], bucket_boundaries[i+1]) for each</span>
<span class="sd">                0&lt;i&lt;n, and one bucket for [bucket_boundaries[n-1], inf).</span>
<span class="sd">            bucket_batch_sizes (list of int): A list consisting of the batch sizes for</span>
<span class="sd">                each bucket. Must contain len(bucket_boundaries)+1 elements.</span>
<span class="sd">            element_length_function (Callable, optional): A function that takes in</span>
<span class="sd">                len(column_names) arguments and returns an int. If no value is</span>
<span class="sd">                provided, then len(column_names) must be 1, and the size of the first</span>
<span class="sd">                dimension of that column will be taken as the length (default=None).</span>
<span class="sd">            pad_info (dict, optional): Represents how to batch each column. The key</span>
<span class="sd">                corresponds to the column name, the value must be a tuple of 2 elements.</span>
<span class="sd">                The first element corresponds to the shape to pad to, and the second</span>
<span class="sd">                element corresponds to the value to pad with. If a column is not</span>
<span class="sd">                specified, then that column will be padded to the longest in the current</span>
<span class="sd">                batch, and 0 will be used as the padding value. Any None dimensions will</span>
<span class="sd">                be padded to the longest in the current batch, unless if</span>
<span class="sd">                pad_to_bucket_boundary is True. If no padding is wanted, set pad_info</span>
<span class="sd">                to None (default=None).</span>
<span class="sd">            pad_to_bucket_boundary (bool, optional): If True, will pad each None</span>
<span class="sd">                dimension in pad_info to the bucket_boundary minus 1. If there are any</span>
<span class="sd">                elements that fall into the last bucket, an error will occur</span>
<span class="sd">                (default=False).</span>
<span class="sd">            drop_remainder (bool, optional): If True, will drop the last batch for each</span>
<span class="sd">                bucket if it is not a full batch (default=False).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where every 100 rows is combined into a batch</span>
<span class="sd">            &gt;&gt;&gt; # and drops the last incomplete batch if there is one.</span>
<span class="sd">            &gt;&gt;&gt; column_names = [&quot;col1&quot;, &quot;col2&quot;]</span>
<span class="sd">            &gt;&gt;&gt; buket_boundaries = [5, 10]</span>
<span class="sd">            &gt;&gt;&gt; bucket_batch_sizes = [5, 1, 1]</span>
<span class="sd">            &gt;&gt;&gt; element_length_function = (lambda col1, col2: max(len(col1), len(col2)))</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # will pad col1 to shape [2, bucket_boundaries[i]] where i is the</span>
<span class="sd">            &gt;&gt;&gt; # index of the bucket that is currently being batched.</span>
<span class="sd">            &gt;&gt;&gt; # will pad col2 to a shape where each dimension is the longest in all</span>
<span class="sd">            &gt;&gt;&gt; # the elements currently being batched.</span>
<span class="sd">            &gt;&gt;&gt; pad_info = {&quot;col1&quot;, ([2, None], -1)}</span>
<span class="sd">            &gt;&gt;&gt; pad_to_bucket_boundary = True</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; data = data.bucket_batch_by_length(column_names, bucket_boundaries,</span>
<span class="sd">            &gt;&gt;&gt;                                    bucket_batch_sizes,</span>
<span class="sd">            &gt;&gt;&gt;                                    element_length_function, pad_info,</span>
<span class="sd">            &gt;&gt;&gt;                                    pad_to_bucket_boundary)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BucketBatchByLengthDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">bucket_boundaries</span><span class="p">,</span> <span class="n">bucket_batch_sizes</span><span class="p">,</span>
                                          <span class="n">element_length_function</span><span class="p">,</span> <span class="n">pad_info</span><span class="p">,</span>
                                          <span class="n">pad_to_bucket_boundary</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="p">)</span>

    <span class="nd">@check_batch</span>
    <span class="k">def</span> <span class="nf">batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_batch_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combines batch_size number of consecutive rows into batches.</span>

<span class="sd">        For any child node, a batch is treated as a single row.</span>
<span class="sd">        For any column, all the elements within that column must have the same shape.</span>
<span class="sd">        If a per_batch_map callable is provided, it will be applied to the batches of tensors.</span>

<span class="sd">        Note:</span>
<span class="sd">            The order of using repeat and batch reflects the number of batches. Recommend that</span>
<span class="sd">            repeat operation should be used after batch operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            batch_size (int or function): The number of rows each batch is created with. An</span>
<span class="sd">                int or callable which takes exactly 1 parameter, BatchInfo.</span>
<span class="sd">            drop_remainder (bool, optional): Determines whether or not to drop the last</span>
<span class="sd">                possibly incomplete batch (default=False). If True, and if there are less</span>
<span class="sd">                than batch_size rows available to make the last batch, then those rows will</span>
<span class="sd">                be dropped and not propagated to the child node.</span>
<span class="sd">            num_parallel_workers (int, optional): Number of workers to process the Dataset in parallel (default=None).</span>
<span class="sd">            per_batch_map (callable, optional): Per batch map callable. A callable which takes</span>
<span class="sd">                (list[Tensor], list[Tensor], ..., BatchInfo) as input parameters. Each list[Tensor] represent a batch of</span>
<span class="sd">                Tensors on a given column. The number of lists should match with number of entries in input_columns. The</span>
<span class="sd">                last parameter of the callable should always be a BatchInfo object.</span>
<span class="sd">            input_columns (list of string, optional): List of names of the input columns. The size of the list should</span>
<span class="sd">                match with signature of per_batch_map callable.</span>
<span class="sd">            pad_info (dict, optional): Whether to perform padding on selected columns. pad_info={&quot;col1&quot;:([224,224],0)}</span>
<span class="sd">                would pad column with name &quot;col1&quot; to a tensor of size [224,224] and fill the missing with 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            BatchDataset, dataset batched.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where every 100 rows is combined into a batch</span>
<span class="sd">            &gt;&gt;&gt; # and drops the last incomplete batch if there is one.</span>
<span class="sd">            &gt;&gt;&gt; data = data.batch(100, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BatchDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">per_batch_map</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span>
                            <span class="n">pad_info</span><span class="p">)</span>

    <span class="nd">@check_sync_wait</span>
    <span class="k">def</span> <span class="nf">sync_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition_name</span><span class="p">,</span> <span class="n">num_batch</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add a blocking condition to the input Dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_batch (int): the number of batches without blocking at the start of each epoch.</span>
<span class="sd">            condition_name (str): The condition name that is used to toggle sending next row.</span>
<span class="sd">            callback (function): The callback funciton that will be invoked when sync_update is called.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If condition name already exists.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; data = data.sync_wait(&quot;callback1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; data = data.batch(batch_size)</span>
<span class="sd">            &gt;&gt;&gt; for batch_data in data.create_dict_iterator():</span>
<span class="sd">            &gt;&gt;&gt;     data = data.sync_update(&quot;callback1&quot;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">SyncWaitDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition_name</span><span class="p">,</span> <span class="n">num_batch</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="nd">@check_shuffle</span>
    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly shuffles the rows of this dataset using the following algorithm:</span>

<span class="sd">        1. Make a shuffle buffer that contains the first buffer_size rows.</span>
<span class="sd">        2. Randomly select an element from the shuffle buffer to be the next row</span>
<span class="sd">           propogated to the child node.</span>
<span class="sd">        3. Get the next row (if any) from the parent node and put it in the shuffle buffer.</span>
<span class="sd">        4. Repeat steps 2 and 3 until there are no more rows left in the shuffle buffer.</span>

<span class="sd">        A seed can be provided to be used on the first epoch. In every subsequent</span>
<span class="sd">        epoch, the seed is changed to a new one, randomly generated value.</span>

<span class="sd">        Args:</span>
<span class="sd">            buffer_size (int): The size of the buffer (must be larger than 1) for</span>
<span class="sd">                shuffling. Setting buffer_size equal to the number of rows in the entire</span>
<span class="sd">                dataset will result in a global shuffle.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShuffleDataset, dataset shuffled.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If exist sync operators before shuffle.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # optionally set the seed for the first epoch</span>
<span class="sd">            &gt;&gt;&gt; ds.config.set_seed(58)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a shuffled dataset using a shuffle buffer of size 4</span>
<span class="sd">            &gt;&gt;&gt; data = data.shuffle(4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShuffleDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flat_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maps `func` to each row in dataset and flatten the result.</span>

<span class="sd">        The specified `func` is a function that must take one &#39;Ndarray&#39; as input</span>
<span class="sd">        and return a &#39;Dataset&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            func (function): A function that must take one &#39;Ndarray&#39; as an argument and</span>
<span class="sd">                return a &#39;Dataset&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset, applied by the function.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset.text as text</span>
<span class="sd">            &gt;&gt;&gt; # declare a function which returns a Dataset object</span>
<span class="sd">            &gt;&gt;&gt; def flat_map_func(x):</span>
<span class="sd">            &gt;&gt;&gt;     data_dir = text.to_str(x[0])</span>
<span class="sd">            &gt;&gt;&gt;     d = ds.ImageFolderDatasetV2(data_dir)</span>
<span class="sd">            &gt;&gt;&gt;     return d</span>
<span class="sd">            &gt;&gt;&gt; # data is a Dataset object</span>
<span class="sd">            &gt;&gt;&gt; data = ds.TextFileDataset(DATA_FILE)</span>
<span class="sd">            &gt;&gt;&gt; data = data.flat_map(flat_map_func)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `func` is not a function.</span>
<span class="sd">            TypeError: If `func` doesn&#39;t return a Dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;func must be a function.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">+=</span> <span class="n">func</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;flat_map must return a Dataset object.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span>

    <span class="nd">@check_map</span>
    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">python_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies each operation in operations to this dataset.</span>

<span class="sd">        The order of operations is determined by the position of each operation in operations.</span>
<span class="sd">        operations[0] will be applied first, then operations[1], then operations[2], etc.</span>

<span class="sd">        Each operation will be passed one or more columns from the dataset as input, and zero or</span>
<span class="sd">        more columns will be outputted. The first operation will be passed the columns specified</span>
<span class="sd">        in input_columns as input. If there is more than one operator in operations, the outputted</span>
<span class="sd">        columns of the previous operation are used as the input columns for the next operation.</span>
<span class="sd">        The columns outputted by the very last operation will be assigned names specified by</span>
<span class="sd">        output_columns.</span>

<span class="sd">        Only the columns specified in columns_order will be propagated to the child node. These</span>
<span class="sd">        columns will be in the same order as specified in columns_order.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_columns (list[str]): List of the names of the columns that will be passed to</span>
<span class="sd">                the first operation as input. The size of this list must match the number of</span>
<span class="sd">                input columns expected by the first operator. (default=None, the first</span>
<span class="sd">                operation will be passed however many columns that is required, starting from</span>
<span class="sd">                the first column).</span>
<span class="sd">            operations (list[TensorOp] or Python list[functions]): List of operations to be</span>
<span class="sd">                applied on the dataset. Operations are applied in the order they appear in this list.</span>
<span class="sd">            output_columns (list[str], optional): List of names assigned to the columns outputted by</span>
<span class="sd">                the last operation. This parameter is mandatory if len(input_columns) !=</span>
<span class="sd">                len(output_columns). The size of this list must match the number of output</span>
<span class="sd">                columns of the last operation. (default=None, output columns will have the same</span>
<span class="sd">                name as the input columns, i.e., the columns will be replaced).</span>
<span class="sd">            columns_order (list[str], optional): list of all the desired columns to propagate to the</span>
<span class="sd">                child node. This list must be a subset of all the columns in the dataset after</span>
<span class="sd">                all operations are applied. The order of the columns in each row propagated to the</span>
<span class="sd">                child node follow the order they appear in this list. The parameter is mandatory</span>
<span class="sd">                if the len(input_columns) != len(output_columns). (default=None, all columns</span>
<span class="sd">                will be propagated to the child node, the order of the columns will remain the</span>
<span class="sd">                same).</span>
<span class="sd">            num_parallel_workers (int, optional): Number of threads used to process the dataset in</span>
<span class="sd">                parallel (default=None, the value from the config will be used).</span>
<span class="sd">            python_multiprocessing (bool, optional): Parallelize python operations with multiple worker process. This</span>
<span class="sd">                option could be beneficial if the python operation is computational heavy (default=False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            MapDataset, dataset after mapping operation.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset.transforms.vision.c_transforms as c_transforms</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset which has 2 columns, &quot;image&quot; and &quot;label&quot;.</span>
<span class="sd">            &gt;&gt;&gt; # ds_pyfunc is an instance of Dataset which has 3 columns, &quot;col0&quot;, &quot;col1&quot;, and &quot;col2&quot;. Each column is</span>
<span class="sd">            &gt;&gt;&gt; # a 2d array of integers.</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # This config is a global setting, meaning that all future operations which</span>
<span class="sd">            &gt;&gt;&gt; # uses this config value will use 2 worker threads, unless if specified</span>
<span class="sd">            &gt;&gt;&gt; # otherwise in their constructor. set_num_parallel_workers can be called</span>
<span class="sd">            &gt;&gt;&gt; # again later if a different number of worker threads are needed.</span>
<span class="sd">            &gt;&gt;&gt; ds.config.set_num_parallel_workers(2)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Two operations, which takes 1 column for input and outputs 1 column.</span>
<span class="sd">            &gt;&gt;&gt; decode_op = c_transforms.Decode(rgb_format=True)</span>
<span class="sd">            &gt;&gt;&gt; random_jitter_op = c_transforms.RandomColorAdjust((0.8, 0.8), (1, 1), (1, 1), (0, 0))</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # 1) Simple map example</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; operations = [decode_op]</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;image&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Applies decode_op on column &quot;image&quot;. This column will be replaced by the outputed</span>
<span class="sd">            &gt;&gt;&gt; # column of decode_op. Since columns_order is not provided, both columns &quot;image&quot;</span>
<span class="sd">            &gt;&gt;&gt; # and &quot;label&quot; will be propagated to the child node in their original order.</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Rename column &quot;image&quot; to &quot;decoded_image&quot;</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations, output_columns)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Specify the order of the columns.</span>
<span class="sd">            &gt;&gt;&gt; columns_order [&quot;label&quot;, &quot;image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations, None, columns_order)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Rename column &quot;image&quot; to &quot;decoded_image&quot; and also specify the order of the columns.</span>
<span class="sd">            &gt;&gt;&gt; columns_order [&quot;label&quot;, &quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations, output_columns, columns_order)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Rename column &quot;image&quot; to &quot;decoded_image&quot; and keep only this column.</span>
<span class="sd">            &gt;&gt;&gt; columns_order [&quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;decoded_image&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_decoded = data.map(input_columns, operations, output_columns, columns_order)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Simple example using pyfunc. Renaming columns and specifying column order</span>
<span class="sd">            &gt;&gt;&gt; # work in the same way as the previous examples.</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;col0&quot;]</span>
<span class="sd">            &gt;&gt;&gt; operations = [(lambda x: x + 1)]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = ds_pyfunc.map(input_columns, operations)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # 2) Map example with more than one operation</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # If this list of operations is used with map, decode_op will be applied</span>
<span class="sd">            &gt;&gt;&gt; # first, then random_jitter_op will be applied.</span>
<span class="sd">            &gt;&gt;&gt; operations = [decode_op, random_jitter_op]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;image&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Creates a dataset where the images are decoded, then randomly color jittered.</span>
<span class="sd">            &gt;&gt;&gt; # decode_op takes column &quot;image&quot; as input and outputs one column. The column</span>
<span class="sd">            &gt;&gt;&gt; # outputted by decode_op is passed as input to random_jitter_op.</span>
<span class="sd">            &gt;&gt;&gt; # random_jitter_op will output one column. Column &quot;image&quot; will be replaced by</span>
<span class="sd">            &gt;&gt;&gt; # the column outputted by random_jitter_op (the very last operation). All other</span>
<span class="sd">            &gt;&gt;&gt; # columns are unchanged. Since columns_order is not specified, the order of the</span>
<span class="sd">            &gt;&gt;&gt; # columns will remain the same.</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = data.map(input_columns, operations)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Creates a dataset that is identical to ds_mapped, except the column &quot;image&quot;</span>
<span class="sd">            &gt;&gt;&gt; # that is outputted by random_jitter_op is renamed to &quot;image_transformed&quot;.</span>
<span class="sd">            &gt;&gt;&gt; # Specifying column order works in the same way as examples in 1).</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;image_transformed&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped_and_renamed = data.map(input_columns, operation, output_columns)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Multiple operations using pyfunc. Renaming columns and specifying column order</span>
<span class="sd">            &gt;&gt;&gt; # work in the same way as examples in 1).</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;col0&quot;]</span>
<span class="sd">            &gt;&gt;&gt; operations = [(lambda x: x + x), (lambda x: x - 1)]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;col0_mapped&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = ds_pyfunc.map(input_columns, operations, output_columns)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # 3) Example where number of input columns is not equal to number of output columns</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # operations[0] is a lambda that takes 2 columns as input and outputs 3 columns.</span>
<span class="sd">            &gt;&gt;&gt; # operations[1] is a lambda that takes 3 columns as input and outputs 1 column.</span>
<span class="sd">            &gt;&gt;&gt; # operations[1] is a lambda that takes 1 column as input and outputs 4 columns.</span>
<span class="sd">            &gt;&gt;&gt; #</span>
<span class="sd">            &gt;&gt;&gt; # Note: the number of output columns of operation[i] must equal the number of</span>
<span class="sd">            &gt;&gt;&gt; # input columns of operation[i+1]. Otherwise, this map call will also result</span>
<span class="sd">            &gt;&gt;&gt; # in an error.</span>
<span class="sd">            &gt;&gt;&gt; operations = [(lambda x y: (x, x + y, x + y + 1)),</span>
<span class="sd">            &gt;&gt;&gt;               (lambda x y z: x * y * z),</span>
<span class="sd">            &gt;&gt;&gt;               (lambda x: (x % 2, x % 3, x % 5, x % 7))]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Note: because the number of input columns is not the same as the number of</span>
<span class="sd">            &gt;&gt;&gt; # output columns, the output_columns and columns_order parameter must be</span>
<span class="sd">            &gt;&gt;&gt; # specified. Otherwise, this map call will also result in an error.</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;col2&quot;, &quot;col0&quot;]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;mod2&quot;, &quot;mod3&quot;, &quot;mod5&quot;, &quot;mod7&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Propagate all columns to the child node in this order:</span>
<span class="sd">            &gt;&gt;&gt; columns_order = [&quot;col0&quot;, &quot;col2&quot;, &quot;mod2&quot;, &quot;mod3&quot;, &quot;mod5&quot;, &quot;mod7&quot;, &quot;col1&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = ds_pyfunc.map(input_columns, operations, output_columns, columns_order)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Propagate some columns to the child node in this order:</span>
<span class="sd">            &gt;&gt;&gt; columns_order = [&quot;mod7&quot;, &quot;mod3&quot;, &quot;col1&quot;]</span>
<span class="sd">            &gt;&gt;&gt; ds_mapped = ds_pyfunc.map(input_columns, operations, output_columns, columns_order)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MapDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">operations</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">,</span> <span class="n">columns_order</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">,</span>
                          <span class="n">python_multiprocessing</span><span class="p">)</span>

    <span class="nd">@check_filter</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter dataset by predicate.</span>

<span class="sd">        Note:</span>
<span class="sd">             If input_columns not provided or empty, all columns will be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            predicate(callable): python callable which returns a boolean value, if False then filter the element.</span>
<span class="sd">            input_columns: (list[str], optional): List of names of the input columns, when</span>
<span class="sd">                default=None, the predicate will be applied on all columns in the dataset.</span>
<span class="sd">            num_parallel_workers (int, optional): Number of workers to process the Dataset</span>
<span class="sd">                in parallel (default=None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            FilterDataset, dataset filter.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # generator data(0 ~ 63)</span>
<span class="sd">            &gt;&gt;&gt; # filter the data that greater than or equal to 11</span>
<span class="sd">            &gt;&gt;&gt; dataset_f = dataset.filter(predicate=lambda data: data &lt; 11, input_columns = [&quot;data&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FilterDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">)</span>

    <span class="nd">@check_repeat</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeats this dataset count times. Repeat indefinitely if the count is None or -1.</span>

<span class="sd">        Note:</span>
<span class="sd">            The order of using repeat and batch reflects the number of batches. Recommend that</span>
<span class="sd">            repeat operation should be used after batch operation.</span>
<span class="sd">            If dataset_sink_mode is False, here repeat operation is invalid.</span>
<span class="sd">            If dataset_sink_mode is True, repeat count should be equal to the epoch of training. Otherwise,</span>
<span class="sd">            errors could occur since the amount of data is not the amount training requires.</span>

<span class="sd">        Args:</span>
<span class="sd">            count (int): Number of times the dataset should be repeated (default=None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            RepeatDataset, dataset repeated.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where the dataset is repeated for 50 epochs</span>
<span class="sd">            &gt;&gt;&gt; repeated = data.repeat(50)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where each epoch is shuffled individually</span>
<span class="sd">            &gt;&gt;&gt; shuffled_and_repeated = data.shuffle(10)</span>
<span class="sd">            &gt;&gt;&gt; shuffled_and_repeated = shuffled_and_repeated.repeat(50)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where the dataset is first repeated for</span>
<span class="sd">            &gt;&gt;&gt; # 50 epochs before shuffling. the shuffle operator will treat</span>
<span class="sd">            &gt;&gt;&gt; # the entire 50 epochs as one big dataset.</span>
<span class="sd">            &gt;&gt;&gt; repeat_and_shuffle = data.repeat(50)</span>
<span class="sd">            &gt;&gt;&gt; repeat_and_shuffle = repeat_and_shuffle.shuffle(10)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">RepeatDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

    <span class="nd">@check_skip</span>
    <span class="k">def</span> <span class="nf">skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Skip the first N elements of this dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            count (int): Number of elements the dataset should be skipped.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SkipDataset, dataset skipped.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset which skips first 3 elements from data</span>
<span class="sd">            &gt;&gt;&gt; data = data.skip(3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SkipDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

    <span class="nd">@check_take</span>
    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes at most given numbers of elements from the dataset.</span>

<span class="sd">        Note:</span>
<span class="sd">            1. If count is greater than the number of element in dataset or equal to -1,</span>
<span class="sd">               all the element in dataset will be taken.</span>
<span class="sd">            2. The order of using take and batch effects. If take before batch operation,</span>
<span class="sd">               then taken given number of rows, otherwise take given number of batches.</span>

<span class="sd">        Args:</span>
<span class="sd">            count (int, optional): Number of elements to be taken from the dataset (default=-1).</span>

<span class="sd">        Returns:</span>
<span class="sd">            TakeDataset, dataset taken.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where the dataset including 50 elements.</span>
<span class="sd">            &gt;&gt;&gt; data = data.take(50)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">TakeDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_absolute_split_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method called by split to calculate absolute split sizes and to</span>
<span class="sd">        do some error checking after calculating absolute split sizes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># call get_dataset_size here and check input here because</span>
        <span class="c1"># dont want to call this once in check_split and another time in</span>
        <span class="c1"># here again</span>
        <span class="n">dataset_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">dataset_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dataset_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;dataset size unknown, unable to split.&quot;</span><span class="p">)</span>

        <span class="n">all_int</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_int</span><span class="p">:</span>
            <span class="n">sizes_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sizes_sum</span> <span class="o">!=</span> <span class="n">dataset_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;sum of split sizes </span><span class="si">{}</span><span class="s2"> is not equal to dataset size </span><span class="si">{}</span><span class="s2">.&quot;</span>
                                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sizes_sum</span><span class="p">,</span> <span class="n">dataset_size</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">sizes</span>

        <span class="n">absolute_sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
            <span class="n">absolute_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">item</span> <span class="o">*</span> <span class="n">dataset_size</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">absolute_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;split percentage </span><span class="si">{}</span><span class="s2"> is too small.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">absolute_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">absolute_size</span><span class="p">)</span>

        <span class="n">absolute_sizes_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">absolute_sizes</span><span class="p">)</span>

        <span class="c1"># if we still need more rows, give them to the first split.</span>
        <span class="c1"># if we have too many rows, remove the extras from the first split that has</span>
        <span class="c1"># enough rows.</span>
        <span class="n">size_difference</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dataset_size</span> <span class="o">-</span> <span class="n">absolute_sizes_sum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size_difference</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">absolute_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size_difference</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">absolute_sizes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">absolute_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">size_difference</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">absolute_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size_difference</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">absolute_sizes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dataset_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;sum of calculated split sizes </span><span class="si">{}</span><span class="s2"> is not equal to dataset size </span><span class="si">{}</span><span class="s2">.&quot;</span>
                               <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">absolute_sizes_sum</span><span class="p">,</span> <span class="n">dataset_size</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">absolute_sizes</span>

    <span class="nd">@check_split</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">randomize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the dataset into smaller, non-overlapping datasets.</span>

<span class="sd">        This is a general purpose split function which can be called from any operator in the pipeline.</span>
<span class="sd">        There is another, optimized split function, which will be called automatically if ds.split is</span>
<span class="sd">        called where ds is a MappableDataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            sizes (list of int or list of float): If a list of integers [s1, s2, …, sn] is</span>
<span class="sd">                provided, the dataset will be split into n datasets of size s1, size s2, …, size sn</span>
<span class="sd">                respectively. If the sum of all sizes does not equal the original dataset size, an</span>
<span class="sd">                an error will occur.</span>
<span class="sd">                If a list of floats [f1, f2, …, fn] is provided, all floats must be between 0 and 1</span>
<span class="sd">                and must sum to 1, otherwise an error will occur. The dataset will be split into n</span>
<span class="sd">                Datasets of size round(f1*K), round(f2*K), …, round(fn*K) where K is the size of the</span>
<span class="sd">                original dataset.</span>
<span class="sd">                If after rounding:</span>

<span class="sd">                    - Any size equals 0, an error will occur.</span>

<span class="sd">                    - The sum of split sizes &lt; K, the difference will be added to the first split.</span>

<span class="sd">                    - The sum of split sizes &gt; K, the difference will be removed from the first large</span>
<span class="sd">                      enough split such that it will have atleast 1 row after removing the difference.</span>

<span class="sd">            randomize (bool, optional): determines whether or not to split the data randomly (default=True).</span>
<span class="sd">                If true, the data will be randomly split. Otherwise, each split will be created with</span>
<span class="sd">                consecutive rows from the dataset.</span>

<span class="sd">        Note:</span>
<span class="sd">            1. Dataset cannot be sharded if split is going to be called.</span>
<span class="sd">            2. It is strongly recommended to not shuffle the dataset, but use randomize=True instead.</span>
<span class="sd">               Shuffling the dataset may not be deterministic, which means the data in each split</span>
<span class="sd">               will be different in each epoch.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If get_dataset_size returns None or is not supported for this dataset.</span>
<span class="sd">            RuntimeError: If sizes is list of integers and sum of all elements in sizes does not</span>
<span class="sd">                equal the dataset size.</span>
<span class="sd">            RuntimeError: If sizes is list of float and there is a split with size 0 after calculations.</span>
<span class="sd">            RuntimeError: If the dataset is sharded prior to calling split.</span>
<span class="sd">            ValueError: If sizes is list of float and not all floats are between 0 and 1, or if the</span>
<span class="sd">                floats don’t sum to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">            tuple(Dataset), a tuple of datasets that have been split.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; dataset_dir = &quot;/path/to/text_file.txt&quot;</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # TextFileDataset is not a mappable dataset, so this non optimized split will be called.</span>
<span class="sd">            &gt;&gt;&gt; # many datasets have shuffle on by default, set shuffle to False if split will be called!</span>
<span class="sd">            &gt;&gt;&gt; data = ds.TextFileDataset(dataset_dir, shuffle=False)</span>
<span class="sd">            &gt;&gt;&gt; train, test = data.split([0.9, 0.1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;dataset is shuffled before split.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;dataset should not be sharded before split.&quot;</span><span class="p">)</span>

        <span class="n">absolute_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_absolute_split_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rows_to_skip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">absolute_sizes</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">randomize</span><span class="p">:</span>
                <span class="c1"># want to shuffle the same way every epoch before split</span>
                <span class="c1"># in alter_tree, shuffle buffer is minimum 10000, so use 10000 here</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
                <span class="n">ds</span><span class="o">.</span><span class="n">reshuffle_each_epoch</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">rows_to_skip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="n">rows_to_skip</span><span class="p">)</span>

            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

            <span class="n">rows_to_skip</span> <span class="o">+=</span> <span class="n">size</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span>

    <span class="nd">@check_zip_dataset</span>
    <span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Zips the datasets in the input tuple of datasets. Columns in the input datasets must not have the same name.</span>

<span class="sd">        Args:</span>
<span class="sd">            datasets (tuple or class Dataset): A tuple of datasets or a single class Dataset</span>
<span class="sd">                to be zipped together with this dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ZipDataset, dataset zipped.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # ds1 and ds2 are instances of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset which is the combination of ds1 and ds2</span>
<span class="sd">            &gt;&gt;&gt; data = ds1.zip(ds2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">datasets</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The zip function </span><span class="si">%s</span><span class="s2"> type error!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datasets</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ZipDataset</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>

    <span class="nd">@check_concat</span>
    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concat the datasets in the input list of datasets, supported using &quot;+&quot; to reload concat operation.</span>

<span class="sd">        Note:</span>
<span class="sd">            The column name，column data type and rank of column data should be the same in input datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            datasets (list or class Dataset): A list of datasets or a single class Dataset</span>
<span class="sd">                to be concatenated together with this dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ConcatDataset, dataset concatenated.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # ds1 and ds2 are instances of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset by concating ds1 and ds2 with &quot;+&quot; operation</span>
<span class="sd">            &gt;&gt;&gt; data1 = ds1 + ds2</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset by concating ds1 and ds2 with concat operation</span>
<span class="sd">            &gt;&gt;&gt; data1 = ds1.concat(ds2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">datasets</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">datasets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The concat_dataset function </span><span class="si">%s</span><span class="s2"> type error!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datasets</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ConcatDataset</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>

    <span class="nd">@check_rename</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames the columns in input datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_columns (list[str]): list of names of the input columns.</span>
<span class="sd">            output_columns (list[str]): list of names of the output columns.</span>

<span class="sd">        Returns:</span>
<span class="sd">            RenameDataset, dataset renamed.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object.</span>
<span class="sd">            &gt;&gt;&gt; input_columns = [&quot;input_col1&quot;, &quot;input_col2&quot;, &quot;input_col3&quot;]</span>
<span class="sd">            &gt;&gt;&gt; output_columns = [&quot;output_col1&quot;, &quot;output_col2&quot;, &quot;output_col3&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset where input_col1 is renamed to output_col1, and</span>
<span class="sd">            &gt;&gt;&gt; # input_col2 is renamed to output_col2, and input_col3 is renamed</span>
<span class="sd">            &gt;&gt;&gt; # to output_col3.</span>
<span class="sd">            &gt;&gt;&gt; data = data.rename(input_columns=input_columns, output_columns=output_columns)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">RenameDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">)</span>

    <span class="nd">@check_project</span>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Projects certain columns in input datasets.</span>

<span class="sd">        The specified columns will be selected from the dataset and passed down</span>
<span class="sd">        the pipeline in the order specified. The other columns are discarded.</span>

<span class="sd">        Args:</span>
<span class="sd">            columns(list[str]): list of names of the columns to project.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ProjectDataset, dataset projected.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; columns_to_project = [&quot;column3&quot;, &quot;column1&quot;, &quot;column2&quot;]</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # creates a dataset that consist of column3, column1, column2</span>
<span class="sd">            &gt;&gt;&gt; # in that order, regardless of the original order of columns.</span>
<span class="sd">            &gt;&gt;&gt; data = data.project(columns=columns_to_project)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">ProjectDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">freq_range</span><span class="p">,</span> <span class="n">top_k</span><span class="p">,</span> <span class="n">special_tokens</span><span class="p">,</span> <span class="n">special_first</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BuildVocabDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">freq_range</span><span class="p">,</span> <span class="n">top_k</span><span class="p">,</span> <span class="n">special_tokens</span><span class="p">,</span> <span class="n">special_first</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function in this dataset.</span>

<span class="sd">        The specified apply_func is a function that must take one &#39;Dataset&#39; as an argument</span>
<span class="sd">        and return a preprogressing &#39;Dataset&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            apply_func (function): A function that must take one &#39;Dataset&#39; as an argument and</span>
<span class="sd">                                   return a preprogressing &#39;Dataset&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset, applied by the function.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # declare an apply_func function which returns a Dataset object</span>
<span class="sd">            &gt;&gt;&gt; def apply_func(ds):</span>
<span class="sd">            &gt;&gt;&gt;     ds = ds.batch(2)</span>
<span class="sd">            &gt;&gt;&gt;     return ds</span>
<span class="sd">            &gt;&gt;&gt; # use apply to call apply_func</span>
<span class="sd">            &gt;&gt;&gt; data = data.apply(apply_func)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If apply_func is not a function.</span>
<span class="sd">            TypeError: If apply_func doesn&#39;t return a Dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">apply_func</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;apply_func must be a function.&quot;</span><span class="p">)</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">apply_func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;apply_func must return a dataset.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="nf">device_que</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefetch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a transferredDataset that transfer data through device.</span>

<span class="sd">        Args:</span>
<span class="sd">            prefetch_size (int, optional): prefetch number of records ahead of the</span>
<span class="sd">                user&#39;s request (default=None).</span>

<span class="sd">        Note:</span>
<span class="sd">            If device is Ascend, features of data will be transferred one by one. The limitation</span>
<span class="sd">            of data transmission per time is 256M.</span>

<span class="sd">        Return:</span>
<span class="sd">            TransferDataset, dataset for transferring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_device</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfers data through CPU, GPU or Ascend devices.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_batch (int, optional): limit the number of batch to be sent to device (default=None).</span>

<span class="sd">        Note:</span>
<span class="sd">            If device is Ascend, features of data will be transferred one by one. The limitation</span>
<span class="sd">            of data transmission per time is 256M.</span>

<span class="sd">        Returns:</span>
<span class="sd">            TransferDataset, dataset for transferring.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If device_type is empty.</span>
<span class="sd">            ValueError: If device_type is not &#39;Ascend&#39;, &#39;GPU&#39; or &#39;CPU&#39;.</span>
<span class="sd">            ValueError: If num_batch is None or 0 or larger than int_max.</span>
<span class="sd">            RuntimeError: If dataset is unknown.</span>
<span class="sd">            RuntimeError: If distribution file path is given but failed to read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num_batch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
            <span class="n">repeat_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_repeat_count</span><span class="p">()</span>
            <span class="n">num_batch</span> <span class="o">=</span> <span class="n">num_batch</span> <span class="o">*</span> <span class="n">repeat_count</span>

        <span class="n">queue_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
            <span class="n">device_type</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;device_target&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">device_type</span> <span class="o">=</span> <span class="s2">&quot;CPU&quot;</span>

        <span class="k">if</span> <span class="n">device_type</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Please set device_type in context&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">device_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Ascend&#39;</span><span class="p">,</span> <span class="s1">&#39;GPU&#39;</span><span class="p">,</span> <span class="s1">&#39;CPU&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only support CPU, Ascend, GPU&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_batch</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">num_batch</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_batch is None or 0.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_distribution</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">):</span>
            <span class="n">dev_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">,</span> <span class="p">(</span><span class="n">Cifar10Dataset</span><span class="p">,</span> <span class="n">Cifar100Dataset</span><span class="p">,</span> <span class="n">GeneratorDataset</span><span class="p">,</span> <span class="n">ImageFolderDatasetV2</span><span class="p">,</span>
                                           <span class="n">ManifestDataset</span><span class="p">,</span> <span class="n">MnistDataset</span><span class="p">,</span> <span class="n">VOCDataset</span><span class="p">,</span> <span class="n">CocoDataset</span><span class="p">,</span> <span class="n">CelebADataset</span><span class="p">,</span>
                                           <span class="n">MindDataset</span><span class="p">)):</span>
                <span class="n">sampler</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">sampler</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">):</span>
                    <span class="n">dev_id</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">shard_id</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dev_id</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">,</span> <span class="p">(</span><span class="n">TFRecordDataset</span><span class="p">,</span> <span class="n">TextFileDataset</span><span class="p">,</span> <span class="n">CLUEDataset</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">shard_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dev_id</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">shard_id</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dev_id</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unknown output_dataset: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">)))</span>
            <span class="n">input_dataset</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">get_distribution</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>

        <span class="n">distribution_path</span><span class="p">,</span> <span class="n">device_id</span> <span class="o">=</span> <span class="n">get_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distribution_path</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TransferDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue_name</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">device_type</span><span class="p">,</span> <span class="n">num_batch</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">distribution_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">distribution_f</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">distribution_f</span><span class="p">)</span>
                <span class="n">device_id</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="s2">&quot;deviceId&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Json decode error when load distribution file&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Distribution file failed to read&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TransferDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue_name</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">device_type</span><span class="p">,</span> <span class="n">num_batch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_tuple_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Iterator over the dataset. The data retrieved will be a list of ndarray of data.</span>

<span class="sd">        To specify which columns to list and the order needed, use columns_list. If columns_list</span>
<span class="sd">        is not provided, the order of the columns will not be changed.</span>

<span class="sd">        Args:</span>
<span class="sd">            columns (list[str], optional): List of columns to be used to specify the order of columns</span>
<span class="sd">                (defaults=None, means all columns).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Iterator, list of ndarray.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # creates an iterator. The columns in the data obtained by the</span>
<span class="sd">            &gt;&gt;&gt; # iterator will not be changed.</span>
<span class="sd">            &gt;&gt;&gt; iterator = data.create_tuple_iterator()</span>
<span class="sd">            &gt;&gt;&gt; for item in iterator:</span>
<span class="sd">            &gt;&gt;&gt;     # convert the returned tuple to a list and print</span>
<span class="sd">            &gt;&gt;&gt;     print(list(item))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TupleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_dict_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Iterator over the dataset.</span>

<span class="sd">        The data retrieved will be a dictionary. The order</span>
<span class="sd">        of the columns in the dictionary may not be the same as the original order.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Iterator, dictionary of column_name-ndarray pair.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt; # data is an instance of Dataset object</span>
<span class="sd">            &gt;&gt;&gt; # creates an iterator. The columns in the data obtained by the</span>
<span class="sd">            &gt;&gt;&gt; # iterator might be changed.</span>
<span class="sd">            &gt;&gt;&gt; iterator = data.create_dict_iterator()</span>
<span class="sd">            &gt;&gt;&gt; for item in iterator:</span>
<span class="sd">            &gt;&gt;&gt;     # print the data in column1</span>
<span class="sd">            &gt;&gt;&gt;     print(item[&quot;column1&quot;])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DictIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an Iterator over the dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_tuple_iterator</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_indexs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span>

    <span class="nd">@input_indexs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">input_indexs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_get_pipeline_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets pipeline information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device_iter</span> <span class="o">=</span> <span class="n">TupleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_shapes</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_output_shapes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_types</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_output_types</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_batch_size</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_classes</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">num_classes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repeat_count</span> <span class="o">=</span> <span class="n">device_iter</span><span class="o">.</span><span class="n">get_repeat_count</span><span class="p">()</span>
        <span class="n">device_iter</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">output_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the shapes of output data.</span>

<span class="sd">        Return:</span>
<span class="sd">            List, list of shape of each column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_shapes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_pipeline_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_shapes</span>

    <span class="k">def</span> <span class="nf">output_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the types of output data.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of data type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_pipeline_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_types</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in a dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_classes</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_sync_notifiers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_sync_notifiers</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">disable_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">disable_sync</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">is_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_sync</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">sync_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition_name</span><span class="p">,</span> <span class="n">num_batch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Release a blocking condition and trigger callback with given data.</span>

<span class="sd">        Args:</span>
<span class="sd">            condition_name (str): The condition name that is used to toggle sending next row.</span>
<span class="sd">            num_batch (int or None): The number of batches(rows) that are released.</span>
<span class="sd">                When num_batch is None, it will default to the number specified by the</span>
<span class="sd">                sync_wait operator (default=None).</span>
<span class="sd">            data (dict or None): The data passed to the callback (default=None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_batch</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num_batch</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># throwing exception, disable all sync_wait in pipeline</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disable_sync</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Sync_update batch size can only be positive, got : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_batch</span><span class="p">))</span>
        <span class="n">notifiers_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sync_notifiers</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">condition_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">notifiers_dict</span><span class="p">:</span>
            <span class="c1"># throwing exception, disable all sync_wait in pipeline</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disable_sync</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Condition name not found&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_batch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_batch</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_batch_size</span><span class="p">()</span>
        <span class="n">notifiers_dict</span><span class="p">[</span><span class="n">condition_name</span><span class="p">](</span><span class="n">num_batch</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_batch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the size of a batch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, the number of data in a batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_batch_size</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get_repeat_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the replication times in RepeatDataset else 1.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, the count of repeat.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_repeat_count</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the class index.</span>

<span class="sd">        Return:</span>
<span class="sd">            Dict, A str-to-int mapping from label name to index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_class_indexing</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Dataset </span><span class="si">{}</span><span class="s2"> has not supported api get_class_indexing yet.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the dataset for next epoch.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">input_dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">input_dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">SourceDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class to represent a source dataset which produces content to the data pipeline.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># No need for __init__ since it is the same as the super&#39;s init</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_files</span><span class="p">(</span><span class="n">patterns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to search for files with the given glob patterns.</span>

<span class="sd">        Args:</span>
<span class="sd">            patterns (str or list[str]): string or list of patterns to be searched.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List, files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span><span class="n">patterns</span><span class="p">]</span>

        <span class="n">file_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unmatched_patterns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">match</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">match</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
                <span class="n">file_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unmatched_patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unmatched_patterns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following patterns did not match any files: &quot;</span><span class="p">,</span> <span class="n">unmatched_patterns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file_list</span><span class="p">:</span>  <span class="c1"># not empty</span>
            <span class="k">return</span> <span class="n">file_list</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The list of path names matching the patterns is empty.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;SourceDataset must implement is_shuffled.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;SourceDataset must implement is_sharded.&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MappableDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class to represent a source dataset which supports use of samplers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># check if all subclasses use this name</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">add_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sampler</span><span class="p">):</span>
        <span class="c1"># note: by adding a sampler, we mean that the sampled ids will flow to new_sampler</span>
        <span class="c1"># after first passing through the current samplers attached to this dataset.</span>
        <span class="n">new_sampler</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">new_sampler</span>

    <span class="k">def</span> <span class="nf">use_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sampler</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Will make the current dataset use the new_sampler provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_sampler (Sampler): the sampler to use for the current dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset, that uses new_sampler.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; dataset_dir = &quot;/path/to/imagefolder_directory&quot;</span>
<span class="sd">            &gt;&gt;&gt; # a SequentialSampler is created by default</span>
<span class="sd">            &gt;&gt;&gt; data = ds.ImageFolderDatasetV2(dataset_dir)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # use a DistributedSampler instead of the SequentialSampler</span>
<span class="sd">            &gt;&gt;&gt; new_sampler = ds.DistributedSampler(10, 2)</span>
<span class="sd">            &gt;&gt;&gt; data.use_sampler(new_sampler)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input sampler can not be None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_sampler</span><span class="p">,</span> <span class="p">(</span><span class="n">samplers</span><span class="o">.</span><span class="n">BuiltinSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">Sampler</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input sampler is not an instance of a sampler.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">child_sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_sampler</span><span class="p">(</span><span class="n">new_sampler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;MappableDataset must implement is_shuffled.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;MappableDataset must implement is_sharded.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_sampler_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="s1">&#39;get_num_samples&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_num_samples</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@check_split</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">randomize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the dataset into smaller, non-overlapping datasets.</span>

<span class="sd">        There is the optimized split function, which will be called automatically when the dataset</span>
<span class="sd">        that calls this function is a MappableDataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            sizes (list of int or list of float): If a list of integers [s1, s2, …, sn] is</span>
<span class="sd">                provided, the dataset will be split into n datasets of size s1, size s2, …, size sn</span>
<span class="sd">                respectively. If the sum of all sizes does not equal the original dataset size, an</span>
<span class="sd">                an error will occur.</span>
<span class="sd">                If a list of floats [f1, f2, …, fn] is provided, all floats must be between 0 and 1</span>
<span class="sd">                and must sum to 1, otherwise an error will occur. The dataset will be split into n</span>
<span class="sd">                Datasets of size round(f1*K), round(f2*K), …, round(fn*K) where K is the size of the</span>
<span class="sd">                original dataset.</span>
<span class="sd">                If after rounding:</span>

<span class="sd">                    - Any size equals 0, an error will occur.</span>

<span class="sd">                    - The sum of split sizes &lt; K, the difference will be added to the first split.</span>

<span class="sd">                    - The sum of split sizes &gt; K, the difference will be removed from the first large</span>
<span class="sd">                      enough split such that it will have atleast 1 row after removing the difference.</span>

<span class="sd">            randomize (bool, optional): determines whether or not to split the data randomly (default=True).</span>
<span class="sd">                If true, the data will be randomly split. Otherwise, each split will be created with</span>
<span class="sd">                consecutive rows from the dataset.</span>

<span class="sd">        Note:</span>
<span class="sd">            1. Dataset should not be sharded if split is going to be called. Instead, create a</span>
<span class="sd">               DistributedSampler and specify a split to shard after splitting. If dataset is</span>
<span class="sd">               sharded after a split, it is strongly recommended to set the same seed in each instance</span>
<span class="sd">               of execution, otherwise each shard may not be part of the same split (see Examples).</span>
<span class="sd">            2. It is strongly recommended to not shuffle the dataset, but use randomize=True instead.</span>
<span class="sd">               Shuffling the dataset may not be deterministic, which means the data in each split</span>
<span class="sd">               will be different in each epoch. Furthermore, if sharding occurs after split, each</span>
<span class="sd">               shard may not be part of the same split.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If get_dataset_size returns None or is not supported for this dataset.</span>
<span class="sd">            RuntimeError: If sizes is list of integers and sum of all elements in sizes does not</span>
<span class="sd">                equal the dataset size.</span>
<span class="sd">            RuntimeError: If sizes is list of float and there is a split with size 0 after calculations.</span>
<span class="sd">            RuntimeError: If the dataset is sharded prior to calling split.</span>
<span class="sd">            ValueError: If sizes is list of float and not all floats are between 0 and 1, or if the</span>
<span class="sd">                floats don’t sum to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">            tuple(Dataset), a tuple of datasets that have been split.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; dataset_dir = &quot;/path/to/imagefolder_directory&quot;</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # many datasets have shuffle on by default, set shuffle to False if split will be called!</span>
<span class="sd">            &gt;&gt;&gt; data = ds.ImageFolderDatasetV2(dataset_dir, shuffle=False)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # sets the seed, and tells split to use this seed when randomizing. This</span>
<span class="sd">            &gt;&gt;&gt; # is needed because we are sharding later</span>
<span class="sd">            &gt;&gt;&gt; ds.config.set_seed(58)</span>
<span class="sd">            &gt;&gt;&gt; train, test = data.split([0.9, 0.1])</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # if we want to shard the train dataset, we can use a DistributedSampler</span>
<span class="sd">            &gt;&gt;&gt; train_sampler = ds.DistributedSampler(10, 2)</span>
<span class="sd">            &gt;&gt;&gt; train.use_sampler(train_sampler)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;dataset is shuffled before split.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;dataset should not be sharded before split.&quot;</span><span class="p">)</span>

        <span class="n">absolute_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_absolute_split_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_split_start_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">absolute_sizes</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">randomize</span><span class="p">:</span>
                <span class="c1"># want to shuffle the same way every epoch before split, we are assuming</span>
                <span class="c1"># that the user will call set_seed</span>
                <span class="n">random_sampler</span> <span class="o">=</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">()</span>
                <span class="n">random_sampler</span><span class="o">.</span><span class="n">reshuffle_each_epoch</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">ds</span><span class="o">.</span><span class="n">add_sampler</span><span class="p">(</span><span class="n">random_sampler</span><span class="p">)</span>

            <span class="n">subset_sampler</span> <span class="o">=</span> <span class="n">samplers</span><span class="o">.</span><span class="n">SequentialSampler</span><span class="p">(</span><span class="n">current_split_start_index</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">add_sampler</span><span class="p">(</span><span class="n">subset_sampler</span><span class="p">)</span>

            <span class="c1"># add sequential sampler, so that if user calls use_sampler, we will</span>
            <span class="c1"># get rid of the sequential sampler instead of something we need</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">add_sampler</span><span class="p">(</span><span class="n">samplers</span><span class="o">.</span><span class="n">SequentialSampler</span><span class="p">())</span>

            <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

            <span class="n">current_split_start_index</span> <span class="o">+=</span> <span class="n">size</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DatasetOp</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class to represent a operations on dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># No need for __init__ since it is the same as the super&#39;s init</span>


<span class="k">class</span> <span class="nc">BucketBatchByLengthDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying BucketBatchByLength operator to the input dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">bucket_boundaries</span><span class="p">,</span> <span class="n">bucket_batch_sizes</span><span class="p">,</span>
                 <span class="n">element_length_function</span><span class="p">,</span> <span class="n">pad_info</span><span class="p">,</span> <span class="n">pad_to_bucket_boundary</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span> <span class="o">=</span> <span class="n">column_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bucket_boundaries</span> <span class="o">=</span> <span class="n">bucket_boundaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bucket_batch_sizes</span> <span class="o">=</span> <span class="n">bucket_batch_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element_length_function</span> <span class="o">=</span> <span class="n">element_length_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_info</span> <span class="o">=</span> <span class="n">pad_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_to_bucket_boundary</span> <span class="o">=</span> <span class="n">pad_to_bucket_boundary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_remainder</span> <span class="o">=</span> <span class="n">drop_remainder</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;length_dependent_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bucket_boundaries&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bucket_boundaries</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bucket_batch_sizes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bucket_batch_sizes</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;element_length_function&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_length_function</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;pad_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_info</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;pad_to_bucket_boundary&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_to_bucket_boundary</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;drop_remainder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_remainder</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">BatchDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Batch operator to the input dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be batched.</span>
<span class="sd">        batch_size (int or function): The number of rows each batch is created with. An</span>
<span class="sd">            int or callable which takes exactly 1 parameter, BatchInfo.</span>
<span class="sd">        drop_remainder (bool, optional): Determines whether or not to drop the last</span>
<span class="sd">            possibly incomplete batch (default=False). If True, and if there are less</span>
<span class="sd">            than batch_size rows available to make the last batch, then those rows will</span>
<span class="sd">            be dropped and not propagated to the child node.</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to process the Dataset in parallel (default=None).</span>
<span class="sd">        per_batch_map (callable, optional): Per batch map callable. A callable which takes</span>
<span class="sd">            (list[Tensor], list[Tensor], ..., BatchInfo) as input parameters. Each list[Tensor] represent a batch of</span>
<span class="sd">            Tensors on a given column. The number of lists should match with number of entries in input_columns. The</span>
<span class="sd">            last parameter of the callable should always be a BatchInfo object.</span>
<span class="sd">        input_columns (list of string, optional): List of names of the input columns. The size of the list should</span>
<span class="sd">            match with signature of per_batch_map callable.</span>
<span class="sd">        pad_info (dict, optional): Whether to perform padding on selected columns. pad_info={&quot;col1&quot;:([224,224],0)}</span>
<span class="sd">            would pad column with name &quot;col1&quot; to a tensor of size [224,224] and fill the missing with 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">per_batch_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">BatchDataset</span><span class="o">.</span><span class="n">_is_ancestor_of_repeat</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Repeat is located before batch, data from two epochs can be batched together.&quot;</span><span class="p">)</span>

        <span class="n">BatchDataset</span><span class="o">.</span><span class="n">_update_batch_size_for_syncwait</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_remainder</span> <span class="o">=</span> <span class="n">drop_remainder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">per_batch_map</span> <span class="o">=</span> <span class="n">per_batch_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span> <span class="o">=</span> <span class="n">input_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_info</span> <span class="o">=</span> <span class="n">pad_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;batch_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;drop_remainder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_remainder</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;per_batch_map&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_batch_map</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;input_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;pad_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_info</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_remainder</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">child_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">child_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_batch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the size of a batch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, the number of data in a batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_ancestor_of_repeat</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to find the case where repeat is used before batch.</span>

<span class="sd">        Args:</span>
<span class="sd">             dataset (Dataset): dataset to be checked.</span>
<span class="sd">        Return:</span>
<span class="sd">            True or False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">RepeatDataset</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">input_dataset</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">|</span> <span class="n">BatchDataset</span><span class="o">.</span><span class="n">_is_ancestor_of_repeat</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_batch_size_for_syncwait</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to notify batch size to sync_wait.</span>

<span class="sd">        Args:</span>
<span class="sd">             dataset (Dataset): dataset to be checked.</span>
<span class="sd">             batch_size (int): batch size to notify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">SyncWaitDataset</span><span class="p">):</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">update_sync_batch_size</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">input_dataset</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">BatchDataset</span><span class="o">.</span><span class="n">_update_batch_size_for_syncwait</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BatchInfo</span><span class="p">(</span><span class="n">CBatchInfo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The information object associates with the current batch of tensors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_batch_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the batch number of the current batch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of the current batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">get_epoch_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the epoch number of the current batch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of the current epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>


<span class="k">class</span> <span class="nc">BlockReleasePair</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The blocking condition class used by SyncWaitDataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        init_release_rows (int): Number of lines to allow through the pipeline.</span>
<span class="sd">        callback (function): The callback function that will be called when release is called.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_release_rows</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_release_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">init_release_rows</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;release_rows  need to be greater than 0.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_count</span> <span class="o">=</span> <span class="o">-</span><span class="n">init_release_rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_rows</span> <span class="o">=</span> <span class="n">init_release_rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">memodict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memodict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="n">memodict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># condition variable and callback are the same, but reset the counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_count</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">default_rows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_batched_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="c1"># sanity check</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">batch_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;batch_size need to be greater than 0.&quot;</span><span class="p">)</span>

        <span class="c1"># should only use before the pipeline creates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_count</span> <span class="o">*=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_rows</span> <span class="o">*=</span> <span class="n">batch_size</span>

    <span class="k">def</span> <span class="nf">block_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">:</span>
            <span class="c1"># if disable is true, the always evaluate to true</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">row_count</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">disable</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">release_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pass_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pass_rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pass_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_rows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_count</span> <span class="o">-=</span> <span class="n">pass_rows</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">disable_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">SyncWaitDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of adding a blocking condition to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input dataset to apply flow control.</span>
<span class="sd">        num_batch (int): the number of batches without blocking at the start of each epoch.</span>
<span class="sd">        condition_name (str): The condition name that is used to toggle sending next row.</span>
<span class="sd">        callback (function): The callback function that will be invoked when sync_update is called.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If condition name already exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">condition_name</span><span class="p">,</span> <span class="n">num_batch</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># set to the default value, waiting for the batch to update it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition_name</span> <span class="o">=</span> <span class="n">condition_name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_batch</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num_batch</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_batch need to be greater than 0.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span> <span class="o">=</span> <span class="n">BlockReleasePair</span><span class="p">(</span><span class="n">num_batch</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_sync_notifiers</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Condition name is already in use&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Please remember to add dataset.sync_update(condition=</span><span class="si">%s</span><span class="s2">), otherwise will result in hanging&quot;</span><span class="p">,</span>
                       <span class="n">condition_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_sync_notifiers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_sync_notifiers</span><span class="p">(),</span> <span class="o">**</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_condition_name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">release_func</span><span class="p">}}</span>

    <span class="k">def</span> <span class="nf">is_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;condition_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition_name</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;condition_func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">block_func</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">update_sync_batch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">batch_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_batch need to be greater than 0.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">update_batched_size</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">disable_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Disabling Sync&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pair</span><span class="o">.</span><span class="n">disable_lock</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_ancestor_of_batch</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to find the case where sync_wait is used before batch.</span>

<span class="sd">        Args:</span>
<span class="sd">             dataset (Dataset): dataset to be checked.</span>
<span class="sd">        Return:</span>
<span class="sd">            True or False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">BatchDataset</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">input_dataset</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">|</span> <span class="n">SyncWaitDataset</span><span class="o">.</span><span class="n">_is_ancestor_of_batch</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flag</span>


<span class="k">class</span> <span class="nc">ShuffleDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Shuffle operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be shuffled.</span>
<span class="sd">        buffer_size (int): The size of the buffer.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If exist sync operators before shuffle.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshuffle_each_epoch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sync</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No shuffle after sync operators&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;buffer_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshuffle_each_epoch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;reshuffle_each_epoch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshuffle_each_epoch</span>

        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="c1"># Pyfunc collection for multiprocess pyfunc</span>
<span class="c1"># This global variable will only be used within subprocesses</span>
<span class="n">_GLOBAL_PYFUNC_LIST</span> <span class="o">=</span> <span class="p">[]</span>


<span class="c1"># Pyfunc worker init function</span>
<span class="c1"># Python multiprocessing library forbid sending lambda function through pipe.</span>
<span class="c1"># This init function allow us to add all python function to a global collection and then fork afterwards.</span>
<span class="k">def</span> <span class="nf">_pyfunc_worker_init</span><span class="p">(</span><span class="n">pyfunc_list</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_GLOBAL_PYFUNC_LIST</span>
    <span class="n">_GLOBAL_PYFUNC_LIST</span> <span class="o">=</span> <span class="n">pyfunc_list</span>


<span class="c1"># Pyfunc worker execution function</span>
<span class="c1"># All exceptions will be raised to main processes</span>
<span class="k">def</span> <span class="nf">_pyfunc_worker_exec</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_GLOBAL_PYFUNC_LIST</span><span class="p">[</span><span class="n">index</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Multiprocess MapOp worker receives KeyboardInterrupt&quot;</span><span class="p">)</span>


<span class="c1"># PythonCallable wrapper for multiprocess pyfunc</span>
<span class="k">class</span> <span class="nc">_PythonCallable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal python function wrapper for multiprocessing pyfunc.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">py_callable</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Original python callable from user.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">py_callable</span> <span class="o">=</span> <span class="n">py_callable</span>
        <span class="c1"># Process pool created for current iterator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span>
        <span class="c1"># Python callable index for subprocess _GLOBAL_PYFUNC_LIST</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># This call will send the tensors along with Python callable index to the process pool.</span>
                <span class="c1"># Block, yield GIL. Current thread will reacquire GIL once result is returned.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">_pyfunc_worker_exec</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Multiprocess MapOp worker receives KeyboardInterrupt&quot;</span><span class="p">)</span>
        <span class="c1"># Invoke original python callable in master process in case the pool is gone.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_callable</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MapDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Map operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be mapped.</span>
<span class="sd">        input_columns (list[str]): List of names of the input columns</span>
<span class="sd">            (default=None, the operations will be applied on the first columns in the dataset).</span>
<span class="sd">            The size of the list should match the number of inputs of the first operator.</span>
<span class="sd">        operations (TensorOp): A function mapping a nested structure of tensors</span>
<span class="sd">            to another nested structure of tensor (default=None).</span>
<span class="sd">        output_columns (list[str], optional): list of names of the output columns.</span>
<span class="sd">            The size of the list should match the number of outputs of the last operator</span>
<span class="sd">            (default=None, output columns will be the input columns, i.e., the columns will</span>
<span class="sd">            be replaced).</span>
<span class="sd">        columns_order (list[str], optional): list of all the desired columns of the dataset (default=None).</span>
<span class="sd">            The argument is mandatory if len(input_columns) != len(output_columns).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to process the Dataset</span>
<span class="sd">            in parallel (default=None).</span>
<span class="sd">        python_multiprocessing (bool, optional): Parallelize python operations with multiple worker process. This</span>
<span class="sd">            option could be beneficial if the python operation is computational heavy (default=False).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If len(input_columns) != len(output_columns) and columns_order is not specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">python_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">input_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span> <span class="o">=</span> <span class="n">input_columns</span>
        <span class="k">if</span> <span class="n">operations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operations</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span><span class="n">operations</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operations</span> <span class="o">=</span> <span class="n">operations</span>
        <span class="k">if</span> <span class="n">output_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">output_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span> <span class="o">=</span> <span class="n">output_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_order</span> <span class="o">=</span> <span class="n">columns_order</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span> \
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When (len(input_columns) != len(output_columns)), columns_order must be specified.&quot;</span><span class="p">)</span>

        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">python_multiprocessing</span> <span class="o">=</span> <span class="n">python_multiprocessing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_pool</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;input_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;operations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;output_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_order</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">memodict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memodict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">new_op</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">memodict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_op</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">input_columns</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">output_columns</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">columns_order</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns_order</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">input_indexs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">python_multiprocessing</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">python_multiprocessing</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">operations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span>
        <span class="k">return</span> <span class="n">new_op</span>

    <span class="c1"># Iterator bootstrap will be called on iterator construction.</span>
    <span class="c1"># A deep copy of Dataset object is created prior of iterator_bootstrap.</span>
    <span class="c1"># This method will create per iterator process pool and bind pyfunc execution to the pool.</span>
    <span class="k">def</span> <span class="nf">iterator_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Per iterator bootstrap callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">python_multiprocessing</span><span class="p">:</span>
            <span class="n">iter_specific_operations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">callable_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Pass #1, look for python callables and build list</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                    <span class="n">callable_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">callable_list</span><span class="p">:</span>
                <span class="c1"># Construct pool with the callable list</span>
                <span class="c1"># The callable list and _pyfunc_worker_init are used to pass lambda function in to subprocesses</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span><span class="p">,</span>
                                                         <span class="n">initializer</span><span class="o">=</span><span class="n">_pyfunc_worker_init</span><span class="p">,</span>
                                                         <span class="n">initargs</span><span class="o">=</span><span class="p">(</span><span class="n">callable_list</span><span class="p">,))</span>
                <span class="c1"># Pass #2</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                        <span class="c1"># Wrap python callable into _PythonCallable</span>
                        <span class="n">iter_specific_operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_PythonCallable</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pool</span><span class="p">))</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># CPP ops remain the same</span>
                        <span class="n">iter_specific_operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">operations</span> <span class="o">=</span> <span class="n">iter_specific_operations</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;process_pool&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">FilterDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying filter predicate to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset: Input Dataset to be mapped.</span>
<span class="sd">        predicate: python callable which returns a boolean value, if False then filter the element.</span>
<span class="sd">        input_columns: (list[str]): List of names of the input columns, when</span>
<span class="sd">        default=None, the predicate will be applied all columns in the dataset.</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to process the Dataset</span>
<span class="sd">            in parallel (default=None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">input_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span> <span class="o">=</span> <span class="n">input_columns</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;predicate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicate</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;input_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_columns</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>
<span class="sd">        the size cannot be determined before we run the pipeline.</span>
<span class="sd">        Return:</span>
<span class="sd">            0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">RepeatDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Repeat operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be repeated.</span>
<span class="sd">        count (int): Number of times the dataset should be repeated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">child_size</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_repeat_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the replication times in RepeatDataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, the count of repeat.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>


<span class="k">class</span> <span class="nc">SkipDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Skip operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (tuple): A tuple of datasets to be skipped.</span>
<span class="sd">        count (int): Number of rows the dataset should be skipped.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="n">output_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">child_size</span><span class="p">:</span>
            <span class="n">output_size</span> <span class="o">=</span> <span class="n">child_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="k">return</span> <span class="n">output_size</span>


<span class="k">class</span> <span class="nc">TakeDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Take operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be taken element from.</span>
<span class="sd">        count (int): Number of elements to be taken from the dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">child_size</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>


<span class="k">class</span> <span class="nc">ZipDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Zip operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets (tuple): A tuple of datasets to be zipped together.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If dataset is not an instance of Dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The parameter </span><span class="si">%s</span><span class="s2"> of zip has type error!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span> <span class="o">=</span> <span class="n">datasets</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children_sizes</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">children_sizes</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in a dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">is_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_sync</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">class</span> <span class="nc">ConcatDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying concat dataset operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets (list): A list of datasets to be concatenated together.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If dataset is not an instance of Dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The parameter </span><span class="si">%s</span><span class="s2"> of concat has type error!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span> <span class="o">=</span> <span class="n">datasets</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
        <span class="n">dataset_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">children_sizes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset_size</span>


<span class="k">class</span> <span class="nc">RenameDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Rename operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be Renamed.</span>
<span class="sd">        input_columns (list[str]): list of names of the input columns.</span>
<span class="sd">        output_columns (list[str]): list of names of the output columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">input_columns</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">input_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">output_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_column_names</span> <span class="o">=</span> <span class="n">input_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_column_names</span> <span class="o">=</span> <span class="n">output_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;input_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_column_names</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;output_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_column_names</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">class</span> <span class="nc">ProjectDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying Project operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be Project.</span>
<span class="sd">        columns (list[str]): List of names of the columns to project.</span>
<span class="sd">        prefetch_size (int, optional): Prefetch number of records ahead of the</span>
<span class="sd">            user&#39;s request (default=None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">prefetch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span> <span class="o">=</span> <span class="n">prefetch_size</span>

        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;prefetch_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">class</span> <span class="nc">TransferDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of applying TDT operator to the input Dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_dataset (Dataset): Input Dataset to be transferred.</span>
<span class="sd">        queue_name (str): Name of device queue.</span>
<span class="sd">        device_id (int): Id of device.</span>
<span class="sd">        device_type (str): Type of device, including &quot;CPU&quot;, &quot;GPU&quot;, and &quot;Ascend&quot;.</span>
<span class="sd">        num_batch (int): limit the number of batch to be sent to device (default=None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">queue_name</span><span class="p">,</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">device_type</span><span class="p">,</span> <span class="n">num_batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue_name</span> <span class="o">=</span> <span class="n">queue_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_indexs</span> <span class="o">=</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input_indexs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device_type</span> <span class="o">=</span> <span class="n">device_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device_id</span> <span class="o">=</span> <span class="n">device_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__num_batch</span> <span class="o">=</span> <span class="n">num_batch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;queue_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_name</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;device_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device_type</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;device_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_batch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__num_batch</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">create_dict_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset is not iterable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_tuple_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset is not iterable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset is not iterable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">output_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset does not support output_shapes&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">output_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;TransferDataset does not support output_types&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># need to keep iterator alive so the executionTree is not destroyed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span> <span class="o">=</span> <span class="n">TupleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">RangeDataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads and parses datasets stored on disk in a range.</span>

<span class="sd">    Args:</span>
<span class="sd">        start (int): starting index.</span>
<span class="sd">        stop (int): ending index.</span>
<span class="sd">        step (int): step size in a range.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;stop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">input_sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create sampler based on user input.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_samples (int): Number of samples.</span>
<span class="sd">        input_sampler (Iterable / Sampler): Sampler from user.</span>
<span class="sd">        shuffle (bool): Shuffle.</span>
<span class="sd">        num_shards (int): Number of shard for sharding.</span>
<span class="sd">        shard_id (int): Shard ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">input_sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If the user provided a sampler, then it doesn&#39;t matter what the other args are because</span>
        <span class="c1"># we are being asked specifically to use the given sampler.</span>
        <span class="c1"># That means the following arguments: num_shards, shard_id, shuffle, num_samples should all</span>
        <span class="c1"># be None. Consider this example:</span>
        <span class="c1">#     sampler = ds.DistributedSampler(num_shards=8, shard_id=3, shuffle=shuffle)</span>
        <span class="c1">#     data1 = ds.VOCDataset(voc_dir, decode=True, sampler=sampler, num_shards=4, shard_id=1)</span>
        <span class="c1"># In this case, the user has given different sample-related arguments that contradict each other.</span>
        <span class="c1"># To prevent this, only allow the user to manually specify the sampler if those arguments are all None</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">input_sampler</span><span class="p">,</span> <span class="p">(</span><span class="n">samplers</span><span class="o">.</span><span class="n">SequentialSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">,</span>
                                       <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">SubsetRandomSampler</span><span class="p">,</span>
                                       <span class="n">samplers</span><span class="o">.</span><span class="n">WeightedRandomSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">Sampler</span><span class="p">))</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">shard_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Conflicting arguments during sampler assignments. num_samples: </span><span class="si">{}</span><span class="s1">, num_shards: </span><span class="si">{}</span><span class="s1">,&#39;</span>
                <span class="s1">&#39; shard_id: </span><span class="si">{}</span><span class="s1">, shuffle: </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">input_sampler</span>
    <span class="k">if</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If shuffle is not specified, sharding enabled, use distributed random sampler</span>
            <span class="n">shuffle</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="c1"># If shuffle is not specified, sharding disabled, use random sampler</span>
        <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">(</span><span class="n">replacement</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If shuffle enabled, sharding enabled, use distributed random sampler</span>
            <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="c1"># If shuffle enabled, sharding disabled, use random sampler</span>
        <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">(</span><span class="n">replacement</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If shuffle disabled, sharding enabled, use distributed sequential sampler</span>
        <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="c1"># If shuffle disabled, sharding disabled, use sequential sampler</span>
    <span class="k">return</span> <span class="n">samplers</span><span class="o">.</span><span class="n">SequentialSampler</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>


<div class="viewcode-block" id="ImageFolderDatasetV2"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ImageFolderDatasetV2">[docs]</a><span class="k">class</span> <span class="nc">ImageFolderDatasetV2</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads images from a tree of directories.</span>

<span class="sd">    All images within one folder have the same label.</span>
<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;label&#39;].</span>
<span class="sd">    The shape of the image column is [image_size] if decode flag is False, or [H,W,C]</span>
<span class="sd">    otherwise.</span>
<span class="sd">    The type of the image tensor is uint8. The label is just a scalar uint64</span>
<span class="sd">    tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        extensions (list[str], optional): List of file extensions to be</span>
<span class="sd">            included in the dataset (default=None).</span>
<span class="sd">        class_indexing (dict, optional): A str-to-int mapping from folder name to index</span>
<span class="sd">            (default=None, the folder names will be sorted</span>
<span class="sd">            alphabetically and each class will be given a</span>
<span class="sd">            unique index starting from 0).</span>
<span class="sd">        decode (bool, optional): decode the images after reading (default=False).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        RuntimeError: If class_indexing is not a dictionary.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; # path to imagefolder directory. This directory needs to contain sub-directories which contain the images</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/imagefolder_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read all samples (image files) in dataset_dir with 8 threads</span>
<span class="sd">        &gt;&gt;&gt; imagefolder_dataset = ds.ImageFolderDatasetV2(dataset_dir, num_parallel_workers=8)</span>
<span class="sd">        &gt;&gt;&gt; # 2) read all samples (image files) from folder cat and folder dog with label 0 and 1</span>
<span class="sd">        &gt;&gt;&gt; imagefolder_dataset = ds.ImageFolderDatasetV2(dataset_dir,class_indexing={&quot;cat&quot;:0,&quot;dog&quot;:1})</span>
<span class="sd">        &gt;&gt;&gt; # 3) read all samples (image files) in dataset_dir with extensions .JPEG and .png (case sensitive)</span>
<span class="sd">        &gt;&gt;&gt; imagefolder_dataset = ds.ImageFolderDatasetV2(dataset_dir, extensions={&quot;.JPEG&quot;,&quot;.png&quot;})</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_imagefolderdatasetv2</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_indexing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="n">extensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="o">=</span> <span class="n">class_indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;extensions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;class_indexing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="ImageFolderDatasetV2.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ImageFolderDatasetV2.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">ImageFolderOp</span><span class="o">.</span><span class="n">get_num_rows_and_classes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rows_per_shard</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageFolderDatasetV2.num_classes"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ImageFolderDatasetV2.num_classes">[docs]</a>    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ImageFolderOp</span><span class="o">.</span><span class="n">get_num_rows_and_classes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<div class="viewcode-block" id="MnistDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.MnistDataset">[docs]</a><span class="k">class</span> <span class="nc">MnistDataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset for reading and parsing the Mnist dataset.</span>

<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;label&#39;].</span>
<span class="sd">    The type of the image tensor is uint8. The label is just a scalar uint32 tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=value, set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/mnist_folder&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read 3 samples from mnist_dataset</span>
<span class="sd">        &gt;&gt;&gt; mnist_dataset = ds.MnistDataset(dataset_dir=dataset_dir, num_samples=3)</span>
<span class="sd">        &gt;&gt;&gt; # in mnist_dataset dataset, each dictionary has keys &quot;image&quot; and &quot;label&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mnist_cifar_dataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="MnistDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.MnistDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">MnistOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">)</span>
        <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rows_per_shard</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<div class="viewcode-block" id="MindDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.MindDataset">[docs]</a><span class="k">class</span> <span class="nc">MindDataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads from shard files and database.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_file (str, list[str]): One of file names or file list in dataset.</span>
<span class="sd">        columns_list (list[str], optional): List of columns to be read (default=None).</span>
<span class="sd">        num_parallel_workers (int, optional): The number of readers (default=None).</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset</span>
<span class="sd">            (default=None, performs shuffle).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>
<span class="sd">        block_reader (bool, optional): Whether read data by block mode (default=False).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, sampler is exclusive</span>
<span class="sd">            with shuffle and block_reader). Support list: SubsetRandomSampler,</span>
<span class="sd">            PkSampler, RandomSampler, SequentialSampler, DistributedSampler.</span>
<span class="sd">        padded_sample (dict, optional): Samples will be appended to dataset, which</span>
<span class="sd">            keys are the same as column_list.</span>
<span class="sd">        num_padded (int, optional): Number of padding samples.Dataset size</span>
<span class="sd">            plus num_padded should be divisible by num_shards.</span>
<span class="sd">        num_samples (int, optional): The number of samples to be included in the dataset</span>
<span class="sd">            (default=None, all samples).</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        ValueError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If block reader is true but partition is specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_minddataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_file</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">block_reader</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">padded_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_padded</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset_file</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_dataset</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_dataset</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span> <span class="o">=</span> <span class="n">dataset_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span> <span class="o">=</span> <span class="n">columns_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_option</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

        <span class="k">if</span> <span class="n">block_reader</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;block reader not allowed true when use partitions&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block_reader</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;block reader not allowed true when use shuffle&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block_reader</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN: global shuffle is not used.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="p">(</span><span class="n">samplers</span><span class="o">.</span><span class="n">SubsetRandomSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">PKSampler</span><span class="p">,</span>
                                    <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">,</span>
                                    <span class="n">samplers</span><span class="o">.</span><span class="n">SequentialSampler</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the sampler is not supported yet.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>

        <span class="c1"># sampler exclusive</span>
        <span class="k">if</span> <span class="n">block_reader</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;block reader not allowed true when use sampler&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_padded</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_padded</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">block_reader</span> <span class="o">=</span> <span class="n">block_reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padded_sample</span> <span class="o">=</span> <span class="n">padded_sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_padded</span> <span class="o">=</span> <span class="n">num_padded</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">padded_sample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padded_sample</span><span class="p">:</span>
            <span class="n">padded_sample</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">padded_sample</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">padded_sample</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">padded_sample</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;load_dataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_dataset</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle_option&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_option</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;block_reader&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_reader</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_padded&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_padded</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;padded_sample&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">padded_sample</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="MindDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.MindDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_dataset</span><span class="p">:</span>
                <span class="n">dataset_file</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dataset_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">MindRecordOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="n">dataset_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_padded</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">num_rows</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span></div>

    <span class="c1"># manually set dataset_size as a tempoary solution.</span>
    <span class="k">def</span> <span class="nf">set_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN_DEPRECATED: This method is deprecated. Please use get_dataset_size directly.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;set dataset_size with negative value </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_option</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_option</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">_iter_fn</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generator function wrapper for iterable dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ds_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ds_iter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="c1"># convert output tensors to ndarrays</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="c1"># convert output tensors to ndarrays</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_generator_fn</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generator function wrapper for generator function dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gen_iter</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen_iter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">yield</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gen_iter</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">gen_iter</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_py_sampler_fn</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generator function wrapper for mappable dataset with python sampler.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sampler_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">sampler_iter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="c1"># convert output tensors to ndarrays</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sampler</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># convert output tensors to ndarrays</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_cpp_sampler_fn</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generator function wrapper for mappable dataset with cpp sampler.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># convert output tensors to ndarrays</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_cpp_sampler_fn_mp</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">num_worker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiprocessing generator function wrapper for mappable dataset with cpp sampler.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_sampler_fn_mp</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">num_worker</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_py_sampler_fn_mp</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">num_worker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiprocessing generator function wrapper for mappable dataset with python sampler.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">_fetch_py_sampler_indices</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_sampler_fn_mp</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">num_worker</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_fetch_py_sampler_indices</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Indices fetcher for python sampler.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sampler_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">sampler_iter</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sampler</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_fill_worker_indices</span><span class="p">(</span><span class="n">workers</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Worker index queue filler, fill worker index queue in round robin order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_worker</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">workers</span><span class="p">[</span><span class="n">idx</span> <span class="o">%</span> <span class="n">num_worker</span><span class="p">]</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Full</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">idx</span>


<span class="k">def</span> <span class="nf">_sampler_fn_mp</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">num_worker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiprocessing generator function wrapper master process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">workers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Event for end of epoch</span>
    <span class="n">eoe</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

    <span class="c1"># Create workers</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_worker</span><span class="p">):</span>
        <span class="n">worker</span> <span class="o">=</span> <span class="n">_GeneratorWorker</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">eoe</span><span class="p">)</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">workers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>

    <span class="c1"># Fill initial index queues</span>
    <span class="n">idx_cursor</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">idx_cursor</span> <span class="o">=</span> <span class="n">_fill_worker_indices</span><span class="p">(</span><span class="n">workers</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">idx_cursor</span><span class="p">)</span>

    <span class="c1"># Start all workers</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">:</span>
        <span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># Fetch results</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
        <span class="c1"># Fetch result and put index</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">workers</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">num_worker</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Generator worker process timeout&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">:</span>
                <span class="n">w</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
                <span class="n">w</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Generator worker receives KeyboardInterrupt&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx_cursor</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">idx_cursor</span> <span class="o">=</span> <span class="n">_fill_worker_indices</span><span class="p">(</span><span class="n">workers</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">idx_cursor</span><span class="p">)</span>
        <span class="c1"># Set eoe event once all indices are sent</span>
        <span class="k">if</span> <span class="n">idx_cursor</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eoe</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">eoe</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_generator_worker_loop</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">idx_queue</span><span class="p">,</span> <span class="n">result_queue</span><span class="p">,</span> <span class="n">eoe</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiprocessing generator worker process loop.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Fetch index, block</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Generator worker receives KeyboardInterrupt&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># When the queue is out of scope from master process, a None item can be fetched from the queue.</span>
            <span class="c1"># Upon receiving None, worker process should check if EOE is set.</span>
            <span class="k">assert</span> <span class="n">eoe</span><span class="o">.</span><span class="n">is_set</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span>
            <span class="k">return</span>
        <span class="c1"># Fetch data, any exception from __getitem__ will terminate worker and timeout master process</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># Send data, block</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Generator worker receives KeyboardInterrupt&quot;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">result</span><span class="p">,</span> <span class="n">idx</span>


<span class="k">class</span> <span class="nc">_GeneratorWorker</span><span class="p">(</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Worker process for multiprocess Generator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">eoe</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_queue</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_queue</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">_generator_worker_loop</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_queue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_queue</span><span class="p">,</span> <span class="n">eoe</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put function for worker index queue. Never block. Raise queue.Full on failure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get function for worker result queue. Block with timeout.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>


<div class="viewcode-block" id="GeneratorDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.GeneratorDataset">[docs]</a><span class="k">class</span> <span class="nc">GeneratorDataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that generate data from python by invoking python data source each epoch.</span>

<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        source (Callable/Iterable/Random Accessible):</span>
<span class="sd">            A generator callable object, an iterable python object or a random accessible python object.</span>
<span class="sd">            Callable source is required to return a tuple of numpy array as a row of the dataset on source().next().</span>
<span class="sd">            Iterable source is required to return a tuple of numpy array as a row of the dataset on iter(source).next().</span>
<span class="sd">            Random accessible source is required to return a tuple of numpy array as a row of the dataset on</span>
<span class="sd">            source[idx].</span>
<span class="sd">        column_names (list[str], optional): List of column names of the dataset (default=None). Users are required to</span>
<span class="sd">            provide either column_names or schema.</span>
<span class="sd">        column_types (list[mindspore.dtype], optional): List of column data types of the dataset (default=None).</span>
<span class="sd">            If provided, sanity check will be performed on generator output.</span>
<span class="sd">        schema (Schema/str, optional): Path to the json schema file or schema object (default=None). Users are</span>
<span class="sd">            required to provide either column_names or schema. If both are provided, schema will be used.</span>
<span class="sd">        num_samples (int, optional): The number of samples to be included in the dataset</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of subprocesses used to fetch the dataset in parallel (default=1).</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset. Random accessible input is required.</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler/Iterable, optional): Object used to choose samples from the dataset. Random accessible input is</span>
<span class="sd">            required (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided into (default=None).</span>
<span class="sd">            This argument should be specified only when &#39;num_samples&#39; is &quot;None&quot;. Random accessible input is required.</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This argument should be specified only</span>
<span class="sd">            when num_shards is also specified. Random accessible input is required.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; # 1) Multidimensional generator function as callable input</span>
<span class="sd">        &gt;&gt;&gt; def generator_md():</span>
<span class="sd">        &gt;&gt;&gt;     for i in range(64):</span>
<span class="sd">        &gt;&gt;&gt;         yield (np.array([[i, i + 1], [i + 2, i + 3]]),)</span>
<span class="sd">        &gt;&gt;&gt; # create multi_dimension_generator_dataset with GeneratorMD and column name &quot;multi_dimensional_data&quot;</span>
<span class="sd">        &gt;&gt;&gt; multi_dimension_generator_dataset = ds.GeneratorDataset(generator_md, [&quot;multi_dimensional_data&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # 2) Multi-column generator function as callable input</span>
<span class="sd">        &gt;&gt;&gt; def generator_mc(maxid = 64):</span>
<span class="sd">        &gt;&gt;&gt;     for i in range(maxid):</span>
<span class="sd">        &gt;&gt;&gt;         yield (np.array([i]), np.array([[i, i + 1], [i + 2, i + 3]]))</span>
<span class="sd">        &gt;&gt;&gt; # create multi_column_generator_dataset with GeneratorMC and column names &quot;col1&quot; and &quot;col2&quot;</span>
<span class="sd">        &gt;&gt;&gt; multi_column_generator_dataset = ds.GeneratorDataset(generator_mc, [&quot;col1&quot;, &quot;col2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # 3) Iterable dataset as iterable input</span>
<span class="sd">        &gt;&gt;&gt; class MyIterable():</span>
<span class="sd">        &gt;&gt;&gt;     def __iter__(self):</span>
<span class="sd">        &gt;&gt;&gt;         return # User implementation</span>
<span class="sd">        &gt;&gt;&gt; # create iterable_generator_dataset with MyIterable object</span>
<span class="sd">        &gt;&gt;&gt; iterable_generator_dataset = ds.GeneratorDataset(MyIterable(), [&quot;col1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # 4) Random accessible dataset as Random accessible input</span>
<span class="sd">        &gt;&gt;&gt; class MyRA():</span>
<span class="sd">        &gt;&gt;&gt;     def __getitem__(self, index):</span>
<span class="sd">        &gt;&gt;&gt;         return # User implementation</span>
<span class="sd">        &gt;&gt;&gt; # create ra_generator_dataset with MyRA object</span>
<span class="sd">        &gt;&gt;&gt; ra_generator_dataset = ds.GeneratorDataset(MyRA(), [&quot;col1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # List/Dict/Tuple is also random accessible</span>
<span class="sd">        &gt;&gt;&gt; list_generator = ds.GeneratorDataset([(np.array(0),), (np.array(1)), (np.array(2))], [&quot;col1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # 5) Built-in Sampler</span>
<span class="sd">        &gt;&gt;&gt; my_generator = ds.GeneratorDataset(my_ds, [&quot;img&quot;, &quot;label&quot;], sampler=samplers.RandomSampler())</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_generatordataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">column_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="p">(</span><span class="n">samplers</span><span class="o">.</span><span class="n">SequentialSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">,</span>
                                         <span class="n">samplers</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">SubsetRandomSampler</span><span class="p">,</span>
                                         <span class="n">samplers</span><span class="o">.</span><span class="n">WeightedRandomSampler</span><span class="p">,</span> <span class="n">samplers</span><span class="o">.</span><span class="n">Sampler</span><span class="p">)):</span>
                <span class="n">sampler_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
                <span class="n">sampler_instance</span><span class="o">.</span><span class="n">set_num_rows</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
                <span class="n">sampler_instance</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">num_parallel_workers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_cpp_sampler_fn_mp</span><span class="p">(</span><span class="n">sampler_instance</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_cpp_sampler_fn</span><span class="p">(</span><span class="n">sampler_instance</span><span class="p">,</span> <span class="n">source</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_parallel_workers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_py_sampler_fn_mp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_py_sampler_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">source</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># Use generator function if input callable</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_generator_fn</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use iterator function if input is iterable</span>
                <span class="c1"># Random accessible input is also iterable</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_iter_fn</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">column_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span> <span class="o">=</span> <span class="n">column_names</span>

        <span class="k">if</span> <span class="n">column_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span> <span class="o">=</span> <span class="n">mstypelist_to_detypelist</span><span class="p">(</span><span class="n">column_types</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span> <span class="o">=</span> <span class="n">column_types</span>

        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">schema</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">Schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DataType</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;column_names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;column_types&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="GeneratorDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.GeneratorDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span><span class="p">)</span></div>

    <span class="c1"># manually set dataset_size as a temporary solution.</span>
    <span class="k">def</span> <span class="nf">set_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;set dataset_size with negative value </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">memodict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memodict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">new_op</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">memodict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_op</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">column_types</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_types</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">column_names</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_names</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>

        <span class="n">new_op</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>

        <span class="k">return</span> <span class="n">new_op</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<div class="viewcode-block" id="TFRecordDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.TFRecordDataset">[docs]</a><span class="k">class</span> <span class="nc">TFRecordDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads and parses datasets stored on disk in TFData format.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_files (str or list[str]): String or list of files to be read or glob strings to search for a pattern of</span>
<span class="sd">            files. The list will be sorted in a lexicographical order.</span>
<span class="sd">        schema (str or Schema, optional): Path to the json schema file or schema object (default=None).</span>
<span class="sd">            If the schema is not provided, the meta data from the TFData file is considered the schema.</span>
<span class="sd">        columns_list (list[str], optional): List of columns to be read (default=None, read all columns)</span>
<span class="sd">        num_samples (int, optional): number of samples(rows) to read (default=None).</span>
<span class="sd">            If num_samples is None and numRows(parsed from schema) is not exist, read the full dataset;</span>
<span class="sd">            If num_samples is None and numRows(parsed from schema) is greater than 0, read numRows rows;</span>
<span class="sd">            If both num_samples and numRows(parsed from schema) are greater than 0, read num_samples rows.</span>
<span class="sd">        num_parallel_workers (int, optional): number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, Shuffle level, optional): perform reshuffling of the data every epoch (default=Shuffle.GLOBAL).</span>
<span class="sd">            If shuffle is False, no shuffling will be performed;</span>
<span class="sd">            If shuffle is True, the behavior is the same as setting shuffle to be Shuffle.GLOBAL</span>
<span class="sd">            Otherwise, there are two levels of shuffling:</span>

<span class="sd">            - Shuffle.GLOBAL: Shuffle both the files and samples.</span>

<span class="sd">            - Shuffle.FILES: Shuffle files only.</span>

<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>
<span class="sd">        shard_equal_rows (bool): Get equal rows for all shards(default=False). If shard_equal_rows is false, number</span>
<span class="sd">            of rows of each shard may be not equal.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.common.dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; dataset_files = [&quot;/path/to/1&quot;, &quot;/path/to/2&quot;] # contains 1 or multiple tf data files</span>
<span class="sd">        &gt;&gt;&gt; # 1) get all rows from dataset_files with no explicit schema:</span>
<span class="sd">        &gt;&gt;&gt; # The meta-data in the first row will be used as a schema.</span>
<span class="sd">        &gt;&gt;&gt; tfdataset = ds.TFRecordDataset(dataset_files=dataset_files)</span>
<span class="sd">        &gt;&gt;&gt; # 2) get all rows from dataset_files with user-defined schema:</span>
<span class="sd">        &gt;&gt;&gt; schema = ds.Schema()</span>
<span class="sd">        &gt;&gt;&gt; schema.add_column(&#39;col_1d&#39;, de_type=mindspore.int64, shape=[2])</span>
<span class="sd">        &gt;&gt;&gt; tfdataset = ds.TFRecordDataset(dataset_files=dataset_files, schema=schema)</span>
<span class="sd">        &gt;&gt;&gt; # 3) get all rows from dataset_files with schema file &quot;./schema.json&quot;:</span>
<span class="sd">        &gt;&gt;&gt; tfdataset = ds.TFRecordDataset(dataset_files=dataset_files, schema=&quot;./schema.json&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_tfrecorddataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_files</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_equal_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_files</span><span class="p">(</span><span class="n">dataset_files</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="n">schema_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">)):</span>
            <span class="n">schema_obj</span> <span class="o">=</span> <span class="n">Schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>  <span class="c1"># read the schema file and convert to schema object to validate it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span> <span class="o">=</span> <span class="n">columns_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="k">if</span> <span class="n">schema_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">schema_obj</span><span class="o">.</span><span class="n">num_rows</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Shuffle</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shuffle should be of boolean or enum &#39;Shuffle&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">Shuffle</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_equal_rows</span> <span class="o">=</span> <span class="n">shard_equal_rows</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">datasetType</span> <span class="o">=</span> <span class="s1">&#39;TF&#39;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
                <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema_json_string&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema_file_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle_global&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">==</span> <span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">)</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_equal_rows&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_equal_rows</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="TFRecordDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.TFRecordDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Args:</span>
<span class="sd">            estimate (bool, optional): Fast estimation of the dataset size instead of a full scan.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">TFReaderOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">estimate</span><span class="p">)</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num_rows</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span></div>

    <span class="c1"># manually set dataset_size as a tempoary solution.</span>
    <span class="k">def</span> <span class="nf">set_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN_DEPRECATED: This method is deprecated. Please use get_dataset_size directly.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;set dataset_size with negative value </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="ManifestDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ManifestDataset">[docs]</a><span class="k">class</span> <span class="nc">ManifestDataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads images from a manifest file.</span>

<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;label&#39;].</span>
<span class="sd">    The shape of the image column is [image_size] if decode flag is False, or [H,W,C]</span>
<span class="sd">    otherwise.</span>
<span class="sd">    The type of the image tensor is uint8. The label is just a scalar uint64</span>
<span class="sd">    tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_file (str): File to be read.</span>
<span class="sd">        usage (str, optional): Need train, eval or inference data (default=&quot;train&quot;).</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset.</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        class_indexing (dict, optional): A str-to-int mapping from label name to index</span>
<span class="sd">            (default=None, the folder names will be sorted alphabetically and each</span>
<span class="sd">            class will be given a unique index starting from 0).</span>
<span class="sd">        decode (bool, optional): decode the images after reading (defaults=False).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        RuntimeError: If class_indexing is not a dictionary.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_file = &quot;/path/to/manifest_file.manifest&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read all samples specified in manifest_file dataset with 8 threads for training:</span>
<span class="sd">        &gt;&gt;&gt; manifest_dataset = ds.ManifestDataset(dataset_file, usage=&quot;train&quot;, num_parallel_workers=8)</span>
<span class="sd">        &gt;&gt;&gt; # 2) reads samples (specified in manifest_file.manifest) for shard 0 in a 2-way distributed training setup:</span>
<span class="sd">        &gt;&gt;&gt; manifest_dataset = ds.ManifestDataset(dataset_file, num_shards=2, shard_id=0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_manifestdataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_file</span><span class="p">,</span> <span class="n">usage</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_indexing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span> <span class="o">=</span> <span class="n">dataset_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">class_indexing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">class_indexing</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;class_indexing should be a dictionary.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="o">=</span> <span class="n">class_indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usage</span> <span class="o">=</span> <span class="n">usage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;usage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;class_indexing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="ManifestDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ManifestDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">ManifestOp</span><span class="o">.</span><span class="n">get_num_rows_and_classes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span><span class="p">,</span> <span class="n">class_indexing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rows_per_shard</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span></div>

<div class="viewcode-block" id="ManifestDataset.num_classes"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ManifestDataset.num_classes">[docs]</a>    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of classes in a dataset.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>

        <span class="k">return</span> <span class="n">ManifestOp</span><span class="o">.</span><span class="n">get_num_rows_and_classes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span><span class="p">,</span> <span class="n">class_indexing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="ManifestDataset.get_class_indexing"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.ManifestDataset.get_class_indexing">[docs]</a>    <span class="k">def</span> <span class="nf">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the class index.</span>

<span class="sd">        Return:</span>
<span class="sd">            Dict, A str-to-int mapping from label name to index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>

        <span class="k">return</span> <span class="n">ManifestOp</span><span class="o">.</span><span class="n">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_file</span><span class="p">,</span> <span class="n">class_indexing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cifar10Dataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Cifar10Dataset">[docs]</a><span class="k">class</span> <span class="nc">Cifar10Dataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads cifar10 data.</span>

<span class="sd">    The generated dataset has two columns [&#39;image&#39;, &#39;label&#39;].</span>
<span class="sd">    The type of the image tensor is uint8. The label is just a scalar uint32</span>
<span class="sd">    tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset.</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/cifar10_dataset_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) get all samples from CIFAR10 dataset in sequence:</span>
<span class="sd">        &gt;&gt;&gt; dataset = ds.Cifar10Dataset(dataset_dir=dataset_dir,shuffle=False)</span>
<span class="sd">        &gt;&gt;&gt; # 2) randomly select 350 samples from CIFAR10 dataset:</span>
<span class="sd">        &gt;&gt;&gt; dataset = ds.Cifar10Dataset(dataset_dir=dataset_dir,num_samples=350, shuffle=True)</span>
<span class="sd">        &gt;&gt;&gt; # 3) get samples from CIFAR10 dataset for shard 0 in a 2 way distributed training:</span>
<span class="sd">        &gt;&gt;&gt; dataset = ds.Cifar10Dataset(dataset_dir=dataset_dir,num_shards=2,shard_id=0)</span>
<span class="sd">        &gt;&gt;&gt; # in CIFAR10 dataset, each dictionary has keys &quot;image&quot; and &quot;label&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mnist_cifar_dataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="Cifar10Dataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Cifar10Dataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">CifarOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rows_per_shard</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cifar100Dataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Cifar100Dataset">[docs]</a><span class="k">class</span> <span class="nc">Cifar100Dataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads cifar100 data.</span>

<span class="sd">    The generated dataset has three columns [&#39;image&#39;, &#39;coarse_label&#39;, &#39;fine_label&#39;].</span>
<span class="sd">    The type of the image tensor is uint8. The coarse and fine are just a scalar uint32</span>
<span class="sd">    tensor.</span>
<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset.</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the</span>
<span class="sd">            dataset (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/cifar100_dataset_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) get all samples from CIFAR100 dataset in sequence:</span>
<span class="sd">        &gt;&gt;&gt; cifar100_dataset = ds.Cifar100Dataset(dataset_dir=dataset_dir,shuffle=False)</span>
<span class="sd">        &gt;&gt;&gt; # 2) randomly select 350 samples from CIFAR100 dataset:</span>
<span class="sd">        &gt;&gt;&gt; cifar100_dataset = ds.Cifar100Dataset(dataset_dir=dataset_dir,num_samples=350, shuffle=True)</span>
<span class="sd">        &gt;&gt;&gt; # in CIFAR100 dataset, each dictionary has 3 keys: &quot;image&quot;, &quot;fine_label&quot; and &quot;coarse_label&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mnist_cifar_dataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="Cifar100Dataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Cifar100Dataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">CifarOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rows_per_shard</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<span class="k">class</span> <span class="nc">RandomDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that generates random data.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_samples (int): number of samples to generate.</span>
<span class="sd">        schema (str or Schema, optional): Path to the json schema file or schema object (default=None).</span>
<span class="sd">            If the schema is not provided, the random dataset generates a random schema.</span>
<span class="sd">        columns_list (list[str], optional): List of columns to be read (default=None, read all columns)</span>
<span class="sd">        num_parallel_workers (int, optional): number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="n">schema_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">)):</span>
            <span class="n">schema_obj</span> <span class="o">=</span> <span class="n">Schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>  <span class="c1"># read the schema file and convert to schema object to validate it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span> <span class="o">=</span> <span class="n">columns_list</span>
        <span class="k">if</span> <span class="n">schema_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">schema_obj</span><span class="o">.</span><span class="n">num_rows</span>
        <span class="k">elif</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">Schema</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">datasetType</span> <span class="o">=</span> <span class="s1">&#39;Random&#39;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
                <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema_json_string&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema_file_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_list</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="Schema"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema">[docs]</a><span class="k">class</span> <span class="nc">Schema</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to represent a schema of dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        schema_file(str): Path of schema file (default=None).</span>

<span class="sd">    Return:</span>
<span class="sd">        Schema object, schema info about dataset.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If schema file failed to load.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.common.dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; # create schema, specify column name, mindspore.dtype and shape of the column</span>
<span class="sd">        &gt;&gt;&gt; schema = ds.Schema()</span>
<span class="sd">        &gt;&gt;&gt; schema.add_column(&#39;col1&#39;, de_type=mindspore.int64, shape=[2])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">schema_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">schema_file</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">schema_file</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The file </span><span class="si">%s</span><span class="s2"> does not exist or permission denied!&quot;</span> <span class="o">%</span> <span class="n">schema_file</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">schema_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">load_f</span><span class="p">:</span>
                    <span class="n">json_obj</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">load_f</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Schema file failed to load.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Schema file failed to decode.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Schema file failed to open.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">json_obj</span><span class="p">)</span>

<div class="viewcode-block" id="Schema.add_column"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema.add_column">[docs]</a>    <span class="nd">@check_add_column</span>
    <span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">de_type</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add new column to the schema.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): name of the column.</span>
<span class="sd">            de_type (str): data type of the column.</span>
<span class="sd">            shape (list[int], optional): shape of the column</span>
<span class="sd">                (default=None, [-1] which is an unknown shape of rank 1).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If column type is unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_column</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">de_type</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">):</span>
            <span class="n">de_type</span> <span class="o">=</span> <span class="n">mstype_to_detype</span><span class="p">(</span><span class="n">de_type</span><span class="p">)</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">de_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">DataType</span><span class="p">(</span><span class="n">de_type</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_column</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_column</span><span class="p">)</span></div>

<div class="viewcode-block" id="Schema.to_json"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a JSON string of the schema.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Str, JSON string of the schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">json_file</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">json_file</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span><span class="p">:</span>
            <span class="n">json_file</span><span class="p">[</span><span class="s2">&quot;datasetType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="n">json_file</span><span class="p">[</span><span class="s2">&quot;numRows&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Schema.parse_columns"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema.parse_columns">[docs]</a>    <span class="k">def</span> <span class="nf">parse_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the columns and add it to self.</span>

<span class="sd">        Args:</span>
<span class="sd">            columns (dict or list[dict]): dataset attribution information, decoded from schema file.</span>

<span class="sd">                - list[dict], &#39;name&#39; and &#39;type&#39; must be in keys, &#39;shape&#39; optional.</span>

<span class="sd">                - dict, columns.keys() as name, columns.values() is dict, and &#39;type&#39; inside, &#39;shape&#39; optional.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If failed to parse columns.</span>
<span class="sd">            RuntimeError: If unknown items in columns.</span>
<span class="sd">            RuntimeError: If column&#39;s name field is missing.</span>
<span class="sd">            RuntimeError: If column&#39;s type field is missing.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; schema = Schema()</span>
<span class="sd">            &gt;&gt;&gt; columns1 = [{&#39;name&#39;: &#39;image&#39;, &#39;type&#39;: &#39;int8&#39;, &#39;shape&#39;: [3, 3]},</span>
<span class="sd">            &gt;&gt;&gt;             {&#39;name&#39;: &#39;label&#39;, &#39;type&#39;: &#39;int8&#39;, &#39;shape&#39;: [1]}]</span>
<span class="sd">            &gt;&gt;&gt; schema.parse_columns(columns1)</span>
<span class="sd">            &gt;&gt;&gt; columns2 = {&#39;image&#39;: {&#39;shape&#39;: [3, 3], &#39;type&#39;: &#39;int8&#39;}, &#39;label&#39;: {&#39;shape&#39;: [1], &#39;type&#39;: &#39;int8&#39;}}</span>
<span class="sd">            &gt;&gt;&gt; schema.parse_columns(columns2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Column&#39;s name is missing&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">de_type</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Column&#39; type is missing&quot;</span><span class="p">)</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">column</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;t_impl&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">column</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;rank&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">column</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unknown field </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">de_type</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">key</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">de_type</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Column&#39; type is missing&quot;</span><span class="p">)</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;t_impl&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;rank&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unknown field </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">de_type</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;columns must be dict or list, columns contain name, type, shape(optional).&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Schema.from_json"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.Schema.from_json">[docs]</a>    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get schema file from json file.</span>

<span class="sd">        Args:</span>
<span class="sd">            json_obj(dictionary): object of json parsed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: if there is unknown item in the object.</span>
<span class="sd">            RuntimeError: if dataset type is missing in the object.</span>
<span class="sd">            RuntimeError: if columns are missing in the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="n">json_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected non-empty dict.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">json_obj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;datasetType&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;numRows&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;columns&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parse_columns</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unknown field </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;DatasetType field is missing.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Columns are missing.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;numRows must be greater than 0&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span></div>


<div class="viewcode-block" id="VOCDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.VOCDataset">[docs]</a><span class="k">class</span> <span class="nc">VOCDataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset for reading and parsing VOC dataset.</span>

<span class="sd">    The generated dataset has two columns :</span>
<span class="sd">    task=&#39;Detection&#39; : [&#39;image&#39;, &#39;annotation&#39;].</span>
<span class="sd">    task=&#39;Segmentation&#39; : [&#39;image&#39;, &#39;target&#39;]</span>
<span class="sd">    The shape of both column &#39;image&#39; and &#39;target&#39; is [image_size] if decode flag is False, or [H, W, C]</span>
<span class="sd">    otherwise.</span>
<span class="sd">    The type of both tensor &#39;image&#39; and &#39;target&#39; is uint8.</span>
<span class="sd">    The type of tensor &#39;annotation&#39; is uint32.</span>

<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        task (str): Set the task type of reading voc data, now only support &quot;Segmentation&quot; or &quot;Detection&quot;</span>
<span class="sd">            (default=&quot;Segmentation&quot;)</span>
<span class="sd">        mode(str): Set the data list txt file to be readed (default=&quot;train&quot;)</span>
<span class="sd">        class_indexing (dict, optional): A str-to-int mapping from label name to index</span>
<span class="sd">            (default=None, the folder names will be sorted alphabetically and each</span>
<span class="sd">            class will be given a unique index starting from 0).</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        decode (bool, optional): Decode the images after reading (default=False).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the dataset</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If xml of Annotations is a invalid format</span>
<span class="sd">        RuntimeError: If xml of Annotations loss attribution of &quot;object&quot;</span>
<span class="sd">        RuntimeError: If xml of Annotations loss attribution of &quot;bndbox&quot;</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        ValueError: If task is not equal &#39;Segmentation&#39; or &#39;Detection&#39;.</span>
<span class="sd">        ValueError: If task equal &#39;Segmentation&#39; but class_indexing is not None.</span>
<span class="sd">        ValueError: If txt related to mode is not exist.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/voc_dataset_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read VOC data for segmenatation train</span>
<span class="sd">        &gt;&gt;&gt; voc_dataset = ds.VOCDataset(dataset_dir, task=&quot;Segmentation&quot;, mode=&quot;train&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # 2) read VOC data for detection train</span>
<span class="sd">        &gt;&gt;&gt; voc_dataset = ds.VOCDataset(dataset_dir, task=&quot;Detection&quot;, mode=&quot;train&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # 3) read all VOC dataset samples in dataset_dir with 8 threads in random order:</span>
<span class="sd">        &gt;&gt;&gt; voc_dataset = ds.VOCDataset(dataset_dir, task=&quot;Detection&quot;, mode=&quot;train&quot;, num_parallel_workers=8)</span>
<span class="sd">        &gt;&gt;&gt; # 4) read then decode all VOC dataset samples in dataset_dir in sequence:</span>
<span class="sd">        &gt;&gt;&gt; voc_dataset = ds.VOCDataset(dataset_dir, task=&quot;Detection&quot;, mode=&quot;train&quot;, decode=True, shuffle=False)</span>
<span class="sd">        &gt;&gt;&gt; # in VOC dataset, if task=&#39;Segmentation&#39;, each dictionary has keys &quot;image&quot; and &quot;target&quot;</span>
<span class="sd">        &gt;&gt;&gt; # in VOC dataset, if task=&#39;Detection&#39;, each dictionary has keys &quot;image&quot; and &quot;annotation&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_vocdataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="s2">&quot;Segmentation&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="n">class_indexing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="o">=</span> <span class="n">class_indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;class_indexing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="VOCDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.VOCDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">VOCOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">class_indexing</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
        <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rows_per_shard</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span></div>

<div class="viewcode-block" id="VOCDataset.get_class_indexing"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.VOCDataset.get_class_indexing">[docs]</a>    <span class="k">def</span> <span class="nf">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the class index.</span>

<span class="sd">        Return:</span>
<span class="sd">            Dict, A str-to-int mapping from label name to index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="o">!=</span> <span class="s2">&quot;Detection&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_indexing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indexing</span>

        <span class="k">return</span> <span class="n">VOCOp</span><span class="o">.</span><span class="n">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">class_indexing</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<div class="viewcode-block" id="CocoDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.CocoDataset">[docs]</a><span class="k">class</span> <span class="nc">CocoDataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset for reading and parsing COCO dataset.</span>

<span class="sd">    CocoDataset support four kinds of task:</span>
<span class="sd">        2017 Train/Val/Test Detection, Keypoints, Stuff, Panoptic.</span>

<span class="sd">    The generated dataset has multi-columns :</span>
<span class="sd">        - task=&#39;Detection&#39;, column: [[&#39;image&#39;, dtype=uint8], [&#39;bbox&#39;, dtype=float32], [&#39;category_id&#39;, dtype=uint32],</span>
<span class="sd">          [&#39;iscrowd&#39;, dtype=uint32]].</span>
<span class="sd">        - task=&#39;Stuff&#39;, column: [[&#39;image&#39;, dtype=uint8], [&#39;segmentation&#39;,dtype=float32], [&#39;iscrowd&#39;,dtype=uint32]].</span>
<span class="sd">        - task=&#39;Keypoint&#39;, column: [[&#39;image&#39;, dtype=uint8], [&#39;keypoints&#39;, dtype=float32],</span>
<span class="sd">          [&#39;num_keypoints&#39;, dtype=uint32]].</span>
<span class="sd">        - task=&#39;Panoptic&#39;, column: [[&#39;image&#39;, dtype=uint8], [&#39;bbox&#39;, dtype=float32], [&#39;category_id&#39;, dtype=uint32],</span>
<span class="sd">          [&#39;iscrowd&#39;, dtype=uint32], [&#39;area&#39;, dtype=uint32]].</span>

<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. CocoDataset doesn&#39;t support</span>
<span class="sd">    PKSampler. Table below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        annotation_file (str): Path to the annotation json.</span>
<span class="sd">        task (str): Set the task type of reading coco data, now support &#39;Detection&#39;/&#39;Stuff&#39;/&#39;Panoptic&#39;/&#39;Keypoint&#39;</span>
<span class="sd">            (default=&#39;Detection&#39;)</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None, expected</span>
<span class="sd">            order behavior shown in the table).</span>
<span class="sd">        decode (bool, optional): Decode the images after reading (default=False).</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the dataset</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If sampler and shuffle are specified at the same time.</span>
<span class="sd">        RuntimeError: If sampler and sharding are specified at the same time.</span>
<span class="sd">        RuntimeError: If num_shards is specified but shard_id is None.</span>
<span class="sd">        RuntimeError: If shard_id is specified but num_shards is None.</span>
<span class="sd">        RuntimeError: If parse json file failed.</span>
<span class="sd">        ValueError: If task is not in [&#39;Detection&#39;, &#39;Stuff&#39;, &#39;Panoptic&#39;, &#39;Keypoint&#39;].</span>
<span class="sd">        ValueError: If annotation_file is not exist.</span>
<span class="sd">        ValueError: If dataset_dir is not exist.</span>
<span class="sd">        ValueError: If shard_id is invalid (&lt; 0 or &gt;= num_shards).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_dir = &quot;/path/to/coco_dataset_directory/image_folder&quot;</span>
<span class="sd">        &gt;&gt;&gt; annotation_file = &quot;/path/to/coco_dataset_directory/annotation_folder/annotation.json&quot;</span>
<span class="sd">        &gt;&gt;&gt; # 1) read COCO data for Detection task</span>
<span class="sd">        &gt;&gt;&gt; coco_dataset = ds.CocoDataset(dataset_dir, annotation_file=annotation_file, task=&#39;Detection&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # 2) read COCO data for Stuff task</span>
<span class="sd">        &gt;&gt;&gt; coco_dataset = ds.CocoDataset(dataset_dir, annotation_file=annotation_file, task=&#39;Stuff&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # 3) read COCO data for Panoptic task</span>
<span class="sd">        &gt;&gt;&gt; coco_dataset = ds.CocoDataset(dataset_dir, annotation_file=annotation_file, task=&#39;Panoptic&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # 4) read COCO data for Keypoint task</span>
<span class="sd">        &gt;&gt;&gt; coco_dataset = ds.CocoDataset(dataset_dir, annotation_file=annotation_file, task=&#39;Keypoint&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # in COCO dataset, each dictionary has keys &quot;image&quot; and &quot;annotation&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_cocodataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">annotation_file</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="s2">&quot;Detection&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotation_file</span> <span class="o">=</span> <span class="n">annotation_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;annotation_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotation_file</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="CocoDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.CocoDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">CocoOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotation_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">)</span>
        <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
        <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rows_per_shard</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span></div>

<div class="viewcode-block" id="CocoDataset.get_class_indexing"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.CocoDataset.get_class_indexing">[docs]</a>    <span class="k">def</span> <span class="nf">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the class index.</span>

<span class="sd">        Return:</span>
<span class="sd">            Dict, A str-to-int mapping from label name to index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;Detection&quot;</span><span class="p">,</span> <span class="s2">&quot;Panoptic&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only &#39;Detection&#39; and &#39;Panoptic&#39; support get_class_indexing.&quot;</span><span class="p">)</span>

        <span class="n">class_index</span> <span class="o">=</span> <span class="n">CocoOp</span><span class="o">.</span><span class="n">get_class_indexing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotation_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">class_index</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<div class="viewcode-block" id="CelebADataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.CelebADataset">[docs]</a><span class="k">class</span> <span class="nc">CelebADataset</span><span class="p">(</span><span class="n">MappableDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset for reading and parsing CelebA dataset.Only support list_attr_celeba.txt currently.</span>

<span class="sd">    Note:</span>
<span class="sd">        The generated dataset has two columns [&#39;image&#39;, &#39;attr&#39;].</span>
<span class="sd">        The type of the image tensor is uint8. The attr tensor is uint32 and one hot type.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str): Path to the root directory that contains the dataset.</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to read the data (default=value set in the config).</span>
<span class="sd">        shuffle (bool, optional): Whether to perform shuffle on the dataset (default=None).</span>
<span class="sd">        dataset_type (str): one of &#39;all&#39;, &#39;train&#39;, &#39;valid&#39; or &#39;test&#39;.</span>
<span class="sd">        sampler (Sampler, optional): Object used to choose samples from the dataset (default=None).</span>
<span class="sd">        decode (bool, optional): decode the images after reading (default=False).</span>
<span class="sd">        extensions (list[str], optional): List of file extensions to be</span>
<span class="sd">            included in the dataset (default=None).</span>
<span class="sd">        num_samples (int, optional): The number of images to be included in the dataset.</span>
<span class="sd">            (default=None, all images).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided</span>
<span class="sd">            into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_celebadataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_dir</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataset_type</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                 <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">_select_sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="n">num_parallel_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span> <span class="o">=</span> <span class="n">decode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="n">extensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span> <span class="o">=</span> <span class="n">dataset_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;sampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;decode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;extensions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_type</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="CelebADataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.CelebADataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_dir</span><span class="p">)</span>
            <span class="n">attr_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="s2">&quot;list_attr_celeba.txt&quot;</span><span class="p">)</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">attr_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">num_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Get dataset size failed from attribution file.&quot;</span><span class="p">)</span>
            <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rows_per_shard</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span>
            <span class="n">rows_from_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sampler_dataset_size</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">rows_from_sampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rows_per_shard</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">rows_from_sampler</span><span class="p">,</span> <span class="n">rows_per_shard</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_shuffled</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">is_sharded</span><span class="p">()</span></div>


<div class="viewcode-block" id="CLUEDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.CLUEDataset">[docs]</a><span class="k">class</span> <span class="nc">CLUEDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads and parses CLUE datasets.</span>
<span class="sd">    CLUE, the Chinese Language Understanding Evaluation Benchmark, a collection of datasets, baselines, pre-trained</span>
<span class="sd">    models, corpus and leaderboard. Here we bring in classification task of CLUE, which are AFQMC, TNEWS, IFLYTEK,</span>
<span class="sd">    CMNLI, WSC and CSL.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_files (str or list[str]): String or list of files to be read or glob strings to search for a pattern of</span>
<span class="sd">            files. The list will be sorted in a lexicographical order.</span>
<span class="sd">        task (str, optional): The kind of task, one of &#39;AFQMC&#39;, &#39;TNEWS&#39;, &#39;IFLYTEK&#39;, &#39;CMNLI&#39;, &#39;WSC&#39; and &#39;CSL&#39;.</span>
<span class="sd">            (default=AFQMC).</span>
<span class="sd">        usage (str, optional): Need train, test or eval data (default=&quot;train&quot;).</span>
<span class="sd">        num_samples (int, optional): number of samples(rows) to read (default=None, reads the full dataset).</span>
<span class="sd">        num_parallel_workers (int, optional): number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, Shuffle level, optional): perform reshuffling of the data every epoch (default=Shuffle.GLOBAL).</span>
<span class="sd">            If shuffle is False, no shuffling will be performed;</span>
<span class="sd">            If shuffle is True, the behavior is the same as setting shuffle to be Shuffle.GLOBAL</span>
<span class="sd">            Otherwise, there are two levels of shuffling:</span>

<span class="sd">            - Shuffle.GLOBAL: Shuffle both the files and samples.</span>

<span class="sd">            - Shuffle.FILES: Shuffle files only.</span>

<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_files = [&quot;/path/to/1&quot;, &quot;/path/to/2&quot;] # contains 1 or multiple text files</span>
<span class="sd">        &gt;&gt;&gt; dataset = ds.CLUEDataset(dataset_files=dataset_files, task=&#39;AFQMC&#39;, usage=&#39;train&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_cluedataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_files</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="s1">&#39;AFQMC&#39;</span><span class="p">,</span> <span class="n">usage</span><span class="o">=</span><span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_files</span><span class="p">(</span><span class="n">dataset_files</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;AFQMC&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;train&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;sentence1&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence1&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence2&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence2&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence1&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence1&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence2&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence2&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;eval&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;sentence1&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence1&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence2&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence2&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="s1">&#39;CMNLI&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;train&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;sentence1&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence1&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence2&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence2&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence1&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence1&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence2&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence2&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;eval&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;sentence1&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence1&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence2&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence2&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="s1">&#39;CSL&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;train&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;abst&#39;</span><span class="p">:</span> <span class="s1">&#39;abst&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;keyword&#39;</span><span class="p">:</span> <span class="s1">&#39;keyword&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;abst&#39;</span><span class="p">:</span> <span class="s1">&#39;abst&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;keyword&#39;</span><span class="p">:</span> <span class="s1">&#39;keyword&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;eval&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;abst&#39;</span><span class="p">:</span> <span class="s1">&#39;abst&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;keyword&#39;</span><span class="p">:</span> <span class="s1">&#39;keyword&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="s1">&#39;IFLYTEK&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;train&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label_des&#39;</span><span class="p">:</span> <span class="s1">&#39;label_des&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence&#39;</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="s1">&#39;eval&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label_des&#39;</span><span class="p">:</span> <span class="s1">&#39;label_des&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence&#39;</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="s1">&#39;TNEWS&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;train&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label_desc&#39;</span><span class="p">:</span> <span class="s1">&#39;label_desc&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;keywords&#39;</span><span class="p">:</span> <span class="s1">&#39;keywords&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;keywords&#39;</span><span class="p">:</span> <span class="s1">&#39;keywords&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;eval&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label_desc&#39;</span><span class="p">:</span> <span class="s1">&#39;label_desc&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;sentence&#39;</span><span class="p">:</span> <span class="s1">&#39;sentence&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;keywords&#39;</span><span class="p">:</span> <span class="s1">&#39;keywords&#39;</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="s1">&#39;WSC&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;train&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;span1_index&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span1_index&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span2_index&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span2_index&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span1_text&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span1_text&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span2_text&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span2_text&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;idx&#39;</span><span class="p">:</span> <span class="s1">&#39;idx&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;text&#39;</span><span class="p">:</span> <span class="s1">&#39;text&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;span1_index&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span1_index&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span2_index&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span2_index&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span1_text&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span1_text&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span2_text&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span2_text&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;idx&#39;</span><span class="p">:</span> <span class="s1">&#39;idx&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;text&#39;</span><span class="p">:</span> <span class="s1">&#39;text&#39;</span>
                <span class="p">},</span>
                <span class="s1">&#39;eval&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;span1_index&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span1_index&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span2_index&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span2_index&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span1_text&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span1_text&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;span2_text&#39;</span><span class="p">:</span> <span class="s1">&#39;target/span2_text&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;idx&#39;</span><span class="p">:</span> <span class="s1">&#39;idx&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;text&#39;</span><span class="p">:</span> <span class="s1">&#39;text&#39;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols_to_keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_dict</span><span class="p">[</span><span class="n">task</span><span class="p">][</span><span class="n">usage</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Shuffle</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shuffle should be of boolean or enum &#39;Shuffle&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">Shuffle</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle_global&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">==</span> <span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">)</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;cols_to_keyword&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols_to_keyword</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="CLUEDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.CLUEDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">ClueOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span><span class="p">)</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num_rows</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="TextFileDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.TextFileDataset">[docs]</a><span class="k">class</span> <span class="nc">TextFileDataset</span><span class="p">(</span><span class="n">SourceDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A source dataset that reads and parses datasets stored on disk in text format.</span>
<span class="sd">    The generated dataset has one columns [&#39;text&#39;].</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_files (str or list[str]): String or list of files to be read or glob strings to search for a pattern of</span>
<span class="sd">            files. The list will be sorted in a lexicographical order.</span>
<span class="sd">        num_samples (int, optional): number of samples(rows) to read (default=None, reads the full dataset).</span>
<span class="sd">        num_parallel_workers (int, optional): number of workers to read the data</span>
<span class="sd">            (default=None, number set in the config).</span>
<span class="sd">        shuffle (bool, Shuffle level, optional): perform reshuffling of the data every epoch (default=Shuffle.GLOBAL).</span>
<span class="sd">            If shuffle is False, no shuffling will be performed;</span>
<span class="sd">            If shuffle is True, the behavior is the same as setting shuffle to be Shuffle.GLOBAL</span>
<span class="sd">            Otherwise, there are two levels of shuffling:</span>

<span class="sd">            - Shuffle.GLOBAL: Shuffle both the files and samples.</span>

<span class="sd">            - Shuffle.FILES: Shuffle files only.</span>

<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided into (default=None).</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This</span>
<span class="sd">            argument should be specified only when num_shards is also specified.</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; dataset_files = [&quot;/path/to/1&quot;, &quot;/path/to/2&quot;] # contains 1 or multiple text files</span>
<span class="sd">        &gt;&gt;&gt; dataset = ds.TextFileDataset(dataset_files=dataset_files)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_textfiledataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_files</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_parallel_workers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_files</span><span class="p">(</span><span class="n">dataset_files</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Shuffle</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shuffle should be of boolean or enum &#39;Shuffle&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">Shuffle</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">=</span> <span class="n">shuffle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">=</span> <span class="n">num_shards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span> <span class="o">=</span> <span class="n">shard_id</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dataset_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle_global&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span> <span class="o">==</span> <span class="n">Shuffle</span><span class="o">.</span><span class="n">GLOBAL</span><span class="p">)</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_level</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;num_shards&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;shard_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shard_id</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="TextFileDataset.get_dataset_size"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.TextFileDataset.get_dataset_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of batches in an epoch.</span>

<span class="sd">        Return:</span>
<span class="sd">            Number, number of batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">TextFileOp</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_files</span><span class="p">)</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">get_num_rows</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span><span class="p">)</span>
            <span class="c1"># If the user gave a num samples in the dataset, then the sampler will limit the rows returned</span>
            <span class="c1"># to that amount.  Account for that here in the row count</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
                <span class="n">num_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
            <span class="k">return</span> <span class="n">num_rows</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_size</span></div>

    <span class="k">def</span> <span class="nf">is_shuffled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_files</span>

    <span class="k">def</span> <span class="nf">is_sharded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_shards</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="kc">False</span></div>


<span class="k">class</span> <span class="nc">_NumpySlicesDataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mainly for dealing with several kinds of format of python data, and return one row each time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">column_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Convert dict data into tuple</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">data_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_len</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">),)</span>

        <span class="c1"># Init column_name</span>
        <span class="k">if</span> <span class="n">column_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_list</span> <span class="o">=</span> <span class="n">column_list</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">column_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">column_num</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;column_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">data_row</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="n">data_res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data_row</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_res</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">process_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the dict like data into tuple format, when input is a tuple of dict then compose it into a dict first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert pandas like dict(has &quot;values&quot; column) into General dict</span>
        <span class="n">data_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">data_col</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="n">data_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data_col</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">):</span>
            <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data_keys</span><span class="p">:</span>
                <span class="n">item1</span> <span class="o">=</span> <span class="n">input_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">item1</span><span class="o">.</span><span class="n">values</span>
            <span class="n">input_data</span> <span class="o">=</span> <span class="n">new_dict</span>

        <span class="c1"># Convert the data in dict into tuple</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_list</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">),)</span>

        <span class="k">return</span> <span class="n">data</span>


<div class="viewcode-block" id="NumpySlicesDataset"><a class="viewcode-back" href="../../../../api/python/mindspore/mindspore.dataset.html#mindspore.dataset.NumpySlicesDataset">[docs]</a><span class="k">class</span> <span class="nc">NumpySlicesDataset</span><span class="p">(</span><span class="n">GeneratorDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a dataset with given data slices, mainly for loading python data into dataset.</span>

<span class="sd">    This dataset can take in a sampler. sampler and shuffle are mutually exclusive. Table</span>
<span class="sd">    below shows what input args are allowed and their expected behavior.</span>

<span class="sd">    .. list-table:: Expected Order Behavior of Using &#39;sampler&#39; and &#39;shuffle&#39;</span>
<span class="sd">       :widths: 25 25 50</span>
<span class="sd">       :header-rows: 1</span>

<span class="sd">       * - Parameter &#39;sampler&#39;</span>
<span class="sd">         - Parameter &#39;shuffle&#39;</span>
<span class="sd">         - Expected Order Behavior</span>
<span class="sd">       * - None</span>
<span class="sd">         - None</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - True</span>
<span class="sd">         - random order</span>
<span class="sd">       * - None</span>
<span class="sd">         - False</span>
<span class="sd">         - sequential order</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - None</span>
<span class="sd">         - order defined by sampler</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - True</span>
<span class="sd">         - not allowed</span>
<span class="sd">       * - Sampler object</span>
<span class="sd">         - False</span>
<span class="sd">         - not allowed</span>

<span class="sd">    Args:</span>
<span class="sd">        data (list, tuple or dict) Input of Given data, supported data type includes list, tuple, dict and other numpy</span>
<span class="sd">            format. Input data will be sliced in first dimension and generate many rows, large data is not recommend to</span>
<span class="sd">            load in this way as data is loading into memory.</span>
<span class="sd">        column_names (list[str], optional): List of column names of the dataset (default=None). If column_names not</span>
<span class="sd">            provided, when data is dict, column_names will be its key, otherwise it will be like column_1, column_2 ...</span>
<span class="sd">        num_samples (int, optional): The number of samples to be included in the dataset (default=None, all images).</span>
<span class="sd">        num_parallel_workers (int, optional): Number of subprocesses used to fetch the dataset in parallel (default=1).</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset. Random accessible input is required.</span>
<span class="sd">            (default=None, expected order behavior shown in the table).</span>
<span class="sd">        sampler (Sampler/Iterable, optional): Object used to choose samples from the dataset. Random accessible input is</span>
<span class="sd">            required (default=None, expected order behavior shown in the table).</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset should be divided into (default=None).</span>
<span class="sd">            This argument should be specified only when &#39;num_samples&#39; is &quot;None&quot;. Random accessible input is required.</span>
<span class="sd">        shard_id (int, optional): The shard ID within num_shards (default=None). This argument should be specified only</span>
<span class="sd">            when num_shards is also specified. Random accessible input is required.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset as ds</span>
<span class="sd">        &gt;&gt;&gt; # 1) Input data can be a list</span>
<span class="sd">        &gt;&gt;&gt; data = [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; dataset1 = ds.NumpySlicesDataset(data, column_names=[&quot;column_1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # 2) Input data can be a dict, and column_names will be its key</span>
<span class="sd">        &gt;&gt;&gt; data = {&quot;a&quot;: [1, 2], &quot;b&quot;: [3, 4]}</span>
<span class="sd">        &gt;&gt;&gt; dataset2 = ds.NumpySlicesDataset(data)</span>
<span class="sd">        &gt;&gt;&gt; # 3) Input data can be a tuple of lists (or numpy arrays), each tuple element refers to data in each column</span>
<span class="sd">        &gt;&gt;&gt; data = ([1, 2], [3, 4], [5, 6])</span>
<span class="sd">        &gt;&gt;&gt; dataset3 = ds.NumpySlicesDataset(data, column_names=[&quot;column_1&quot;, &quot;column_2&quot;, &quot;column_3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # 4) Load data from csv file</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; df = pd.read_csv(&quot;file.csv&quot;)</span>
<span class="sd">        &gt;&gt;&gt; dataset4 = ds.NumpySlicesDataset(dict(df), shuffle=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_numpyslicesdataset</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sampler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">_NumpySlicesDataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">column_names</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">column_list</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
                         <span class="n">num_parallel_workers</span><span class="o">=</span><span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span><span class="p">,</span>
                         <span class="n">num_shards</span><span class="o">=</span><span class="n">num_shards</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="n">shard_id</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">BuildVocabDataset</span><span class="p">(</span><span class="n">DatasetOp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a vocab from a dataset. This would collect all the unique words in a dataset and return a vocab</span>
<span class="sd">    which contains top_k most frequent words (if top_k is specified)</span>
<span class="sd">    This function is not meant to be called directly by user. To build vocab, please use the function</span>
<span class="sd">    text.Vocab.from_dataset()</span>

<span class="sd">    Args:</span>
<span class="sd">        vocab(Vocab): text.vocab object.</span>
<span class="sd">        columns(str or list, optional): column names to get words from. It can be a list of column names (Default is</span>
<span class="sd">            None, all columns are used, return error if any column isn&#39;t string).</span>
<span class="sd">        freq_range(tuple, optional): A tuple of integers (min_frequency, max_frequency). Words within the frequency</span>
<span class="sd">            range would be kept. 0 &lt;= min_frequency &lt;= max_frequency &lt;= total_words. min_frequency/max_frequency</span>
<span class="sd">            can be None, which corresponds to 0/total_words separately (default=None, all words are included).</span>
<span class="sd">        top_k(int, optional): top_k &gt; 0. Number of words to be built into vocab. top_k most frequent words are</span>
<span class="sd">            taken. The top_k is taken after freq_range. If not enough top_k, all words will be taken (default=None,</span>
<span class="sd">            all words are included).</span>
<span class="sd">        special_tokens(list, optional):  a list of strings, each one is a special token. for example</span>
<span class="sd">            special_tokens=[&quot;&lt;pad&gt;&quot;,&quot;&lt;unk&gt;&quot;] (default=None, no special tokens will be added).</span>
<span class="sd">        special_first(bool, optional): whether special_tokens will be prepended/appended to vocab, If special_tokens</span>
<span class="sd">            is specified and special_first is set to None, special_tokens will be prepended. (default=None).</span>
<span class="sd">        prefetch_size (int, optional): prefetch number of records ahead of the user&#39;s request (default=None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dataset</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">freq_range</span><span class="p">,</span> <span class="n">top_k</span><span class="p">,</span> <span class="n">special_tokens</span><span class="p">,</span> <span class="n">special_first</span><span class="p">,</span>
                 <span class="n">prefetch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span> <span class="o">=</span> <span class="n">prefetch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="n">vocab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_range</span> <span class="o">=</span> <span class="n">freq_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_k</span> <span class="o">=</span> <span class="n">top_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_tokens</span> <span class="o">=</span> <span class="n">special_tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_first</span> <span class="o">=</span> <span class="n">special_first</span>
        <span class="n">input_dataset</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;vocab&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;freq_range&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_range</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;prefetch_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;top_k&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_k</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;special_tokens&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_tokens</span>
        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;special_first&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_first</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">memodict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memodict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">new_op</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">memodict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_op</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">prefetch_size</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefetch_size</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">freq_range</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_range</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">top_k</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_k</span><span class="p">,</span> <span class="n">memodict</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">special_tokens</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_tokens</span><span class="p">)</span>
        <span class="n">new_op</span><span class="o">.</span><span class="n">special_first</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_first</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_op</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>