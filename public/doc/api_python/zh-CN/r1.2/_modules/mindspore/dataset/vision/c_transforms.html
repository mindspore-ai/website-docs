<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.dataset.vision.c_transforms &mdash; MindSpore master documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">MindSpore Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.compression.html">mindspore.compression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.context.html">mindspore.context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.dataset.config.html">mindspore.dataset.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.dataset.text.html">mindspore.dataset.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.dataset.vision.html">mindspore.dataset.vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.explainer.html">mindspore.explainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.profiler.html">mindspore.profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore/mindspore.train.html">mindspore.train</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">MindArmour Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.html">mindarmour</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.adv_robustness.attacks.html">mindarmour.adv_robustness.attacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.adv_robustness.defenses.html">mindarmour.adv_robustness.defenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.adv_robustness.detectors.html">mindarmour.adv_robustness.detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.adv_robustness.evaluations.html">mindarmour.adv_robustness.evaluations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.fuzz_testing.html">mindarmour.fuzz_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.privacy.diff_privacy.html">mindarmour.privacy.diff_privacy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.privacy.evaluation.html">mindarmour.privacy.evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.privacy.sup_privacy.html">mindarmour.privacy.sup_privacy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindarmour/mindarmour.utils.html">mindarmour.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">MindSpore Hub Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore_hub/mindspore_hub.html">mindspore_hub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">MindSpore Serving Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindspore_serving/mindspore_serving.html">mindspore_serving</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">MindQuantum Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../mindquantum/mindquantum.html">mindquantum</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>mindspore.dataset.vision.c_transforms</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mindspore.dataset.vision.c_transforms</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019-2021 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ==============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The module vision.c_transforms is inherited from _c_dataengine</span>
<span class="sd">and is implemented based on OpenCV in C++. It&#39;s a high performance module to</span>
<span class="sd">process images. Users can apply suitable augmentations on image data</span>
<span class="sd">to improve their training models.</span>

<span class="sd">.. Note::</span>
<span class="sd">    A constructor&#39;s arguments for every class in this module must be saved into the</span>
<span class="sd">    class attributes (self.xxx) to support save() and load().</span>

<span class="sd">Examples:</span>
<span class="sd">    &gt;&gt;&gt; from mindspore.dataset.vision import Border, Inter</span>
<span class="sd">    &gt;&gt;&gt; image_folder_dataset_dir = &quot;/path/to/image_folder_dataset_directory&quot;</span>
<span class="sd">    &gt;&gt;&gt; # create a dataset that reads all files in dataset_dir with 8 threads</span>
<span class="sd">    &gt;&gt;&gt; image_folder_dataset = ds.ImageFolderDataset(image_folder_dataset_dir,</span>
<span class="sd">    ...                                              num_parallel_workers=8)</span>
<span class="sd">    &gt;&gt;&gt; # create a list of transformations to be applied to the image data</span>
<span class="sd">    &gt;&gt;&gt; transforms_list = [c_vision.Decode(),</span>
<span class="sd">    ...                    c_vision.Resize((256, 256), interpolation=Inter.LINEAR),</span>
<span class="sd">    ...                    c_vision.RandomCrop(200, padding_mode=Border.EDGE),</span>
<span class="sd">    ...                    c_vision.RandomRotation((0, 15)),</span>
<span class="sd">    ...                    c_vision.Normalize((100, 115.0, 121.0), (71.0, 68.0, 70.0)),</span>
<span class="sd">    ...                    c_vision.HWC2CHW()]</span>
<span class="sd">    &gt;&gt;&gt; onehot_op = c_transforms.OneHot(num_classes=10)</span>
<span class="sd">    &gt;&gt;&gt; # apply the transformation to the dataset through data1.map()</span>
<span class="sd">    &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">    ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=onehot_op,</span>
<span class="sd">    ...                                                 input_columns=&quot;label&quot;)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="nn">mindspore._c_dataengine</span> <span class="k">as</span> <span class="nn">cde</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">Inter</span><span class="p">,</span> <span class="n">Border</span><span class="p">,</span> <span class="n">ImageBatchFormat</span>
<span class="kn">from</span> <span class="nn">.validators</span> <span class="kn">import</span> <span class="n">check_prob</span><span class="p">,</span> <span class="n">check_crop</span><span class="p">,</span> <span class="n">check_resize_interpolation</span><span class="p">,</span> <span class="n">check_random_resize_crop</span><span class="p">,</span> \
    <span class="n">check_mix_up_batch_c</span><span class="p">,</span> <span class="n">check_normalize_c</span><span class="p">,</span> <span class="n">check_normalizepad_c</span><span class="p">,</span> <span class="n">check_random_crop</span><span class="p">,</span> <span class="n">check_random_color_adjust</span><span class="p">,</span> \
    <span class="n">check_random_rotation</span><span class="p">,</span> <span class="n">check_range</span><span class="p">,</span> <span class="n">check_resize</span><span class="p">,</span> <span class="n">check_rescale</span><span class="p">,</span> <span class="n">check_pad</span><span class="p">,</span> <span class="n">check_cutout</span><span class="p">,</span> \
    <span class="n">check_uniform_augment_cpp</span><span class="p">,</span> \
    <span class="n">check_bounding_box_augment_cpp</span><span class="p">,</span> <span class="n">check_random_select_subpolicy_op</span><span class="p">,</span> <span class="n">check_auto_contrast</span><span class="p">,</span> <span class="n">check_random_affine</span><span class="p">,</span> \
    <span class="n">check_random_solarize</span><span class="p">,</span> <span class="n">check_soft_dvpp_decode_random_crop_resize_jpeg</span><span class="p">,</span> <span class="n">check_positive_degrees</span><span class="p">,</span> <span class="n">FLOAT_MAX_INTEGER</span><span class="p">,</span> \
    <span class="n">check_cut_mix_batch_c</span><span class="p">,</span> <span class="n">check_posterize</span>
<span class="kn">from</span> <span class="nn">..transforms.c_transforms</span> <span class="kn">import</span> <span class="n">TensorOperation</span>


<span class="k">class</span> <span class="nc">ImageTensorOperation</span><span class="p">(</span><span class="n">TensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of Image Tensor Ops</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">input_tensor_list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">input_tensor_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input should be NumPy or PIL image, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tensor</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">input_tensor_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;ImageTensorOperation has to implement parse() method.&quot;</span><span class="p">)</span>


<span class="n">DE_C_BORDER_TYPE</span> <span class="o">=</span> <span class="p">{</span><span class="n">Border</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">BorderType</span><span class="o">.</span><span class="n">DE_BORDER_CONSTANT</span><span class="p">,</span>
                    <span class="n">Border</span><span class="o">.</span><span class="n">EDGE</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">BorderType</span><span class="o">.</span><span class="n">DE_BORDER_EDGE</span><span class="p">,</span>
                    <span class="n">Border</span><span class="o">.</span><span class="n">REFLECT</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">BorderType</span><span class="o">.</span><span class="n">DE_BORDER_REFLECT</span><span class="p">,</span>
                    <span class="n">Border</span><span class="o">.</span><span class="n">SYMMETRIC</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">BorderType</span><span class="o">.</span><span class="n">DE_BORDER_SYMMETRIC</span><span class="p">}</span>

<span class="n">DE_C_IMAGE_BATCH_FORMAT</span> <span class="o">=</span> <span class="p">{</span><span class="n">ImageBatchFormat</span><span class="o">.</span><span class="n">NHWC</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">ImageBatchFormat</span><span class="o">.</span><span class="n">DE_IMAGE_BATCH_FORMAT_NHWC</span><span class="p">,</span>
                           <span class="n">ImageBatchFormat</span><span class="o">.</span><span class="n">NCHW</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">ImageBatchFormat</span><span class="o">.</span><span class="n">DE_IMAGE_BATCH_FORMAT_NCHW</span><span class="p">}</span>

<span class="n">DE_C_INTER_MODE</span> <span class="o">=</span> <span class="p">{</span><span class="n">Inter</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">InterpolationMode</span><span class="o">.</span><span class="n">DE_INTER_NEAREST_NEIGHBOUR</span><span class="p">,</span>
                   <span class="n">Inter</span><span class="o">.</span><span class="n">LINEAR</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">InterpolationMode</span><span class="o">.</span><span class="n">DE_INTER_LINEAR</span><span class="p">,</span>
                   <span class="n">Inter</span><span class="o">.</span><span class="n">CUBIC</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">InterpolationMode</span><span class="o">.</span><span class="n">DE_INTER_CUBIC</span><span class="p">,</span>
                   <span class="n">Inter</span><span class="o">.</span><span class="n">AREA</span><span class="p">:</span> <span class="n">cde</span><span class="o">.</span><span class="n">InterpolationMode</span><span class="o">.</span><span class="n">DE_INTER_AREA</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">parse_padding</span><span class="p">(</span><span class="n">padding</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Parses and prepares the padding tuple&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="p">[</span><span class="n">padding</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">top</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">padding</span>


<div class="viewcode-block" id="AutoContrast"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.AutoContrast.html#mindspore.dataset.vision.c_transforms.AutoContrast">[docs]</a><span class="k">class</span> <span class="nc">AutoContrast</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply automatic contrast on input image.</span>

<span class="sd">    Args:</span>
<span class="sd">        cutoff (float, optional): Percent of pixels to cut off from the histogram,</span>
<span class="sd">            the value must be in the range [0.0, 50.0) (default=0.0).</span>
<span class="sd">        ignore (Union[int, sequence], optional): Pixel values to ignore (default=None).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.AutoContrast(cutoff=10.0, ignore=[10, 20])]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_auto_contrast</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignore</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="n">ignore</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">AutoContrastOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">)</span></div>


<div class="viewcode-block" id="BoundingBoxAugment"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.BoundingBoxAugment.html#mindspore.dataset.vision.c_transforms.BoundingBoxAugment">[docs]</a><span class="k">class</span> <span class="nc">BoundingBoxAugment</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a given image transform on a random selection of bounding box regions of a given image.</span>

<span class="sd">    Args:</span>
<span class="sd">        transform: C++ transformation function to be applied on random selection</span>
<span class="sd">            of bounding box regions of a given image.</span>
<span class="sd">        ratio (float, optional): Ratio of bounding boxes to apply augmentation on.</span>
<span class="sd">            Range: [0, 1] (default=0.3).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # set bounding box operation with ratio of 1 to apply rotation on all bounding boxes</span>
<span class="sd">        &gt;&gt;&gt; bbox_aug_op = c_vision.BoundingBoxAugment(c_vision.RandomRotation(90), 1)</span>
<span class="sd">        &gt;&gt;&gt; # map to apply ops</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=[bbox_aug_op],</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;, &quot;bbox&quot;],</span>
<span class="sd">        ...                                                 output_columns=[&quot;image&quot;, &quot;bbox&quot;],</span>
<span class="sd">        ...                                                 column_order=[&quot;image&quot;, &quot;bbox&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_bounding_box_augment_cpp</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="s1">&#39;parse&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">BoundingBoxAugmentOperation</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">)</span></div>


<div class="viewcode-block" id="CenterCrop"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.CenterCrop.html#mindspore.dataset.vision.c_transforms.CenterCrop">[docs]</a><span class="k">class</span> <span class="nc">CenterCrop</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image at the center to the given size.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the cropped image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # crop image to a square</span>
<span class="sd">        &gt;&gt;&gt; transforms_list1 = [c_vision.Decode(), c_vision.CenterCrop(50)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list1,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # crop image to portrait style</span>
<span class="sd">        &gt;&gt;&gt; transforms_list2 = [c_vision.Decode(), c_vision.CenterCrop((60, 40))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=transforms_list2,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">CenterCropOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="CutMixBatch"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.CutMixBatch.html#mindspore.dataset.vision.c_transforms.CutMixBatch">[docs]</a><span class="k">class</span> <span class="nc">CutMixBatch</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply CutMix transformation on input batch of images and labels.</span>
<span class="sd">    Note that you need to make labels into one-hot format and batch before calling this function.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_batch_format (Image Batch Format): The method of padding. Can be any of</span>
<span class="sd">            [ImageBatchFormat.NHWC, ImageBatchFormat.NCHW]</span>
<span class="sd">        alpha (float, optional): hyperparameter of beta distribution (default = 1.0).</span>
<span class="sd">        prob (float, optional): The probability by which CutMix is applied to each image (default = 1.0).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import ImageBatchFormat</span>
<span class="sd">        &gt;&gt;&gt; onehot_op = c_transforms.OneHot(num_classes=10)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset= image_folder_dataset.map(operations=onehot_op,</span>
<span class="sd">        ...                                                input_columns=[&quot;label&quot;])</span>
<span class="sd">        &gt;&gt;&gt; cutmix_batch_op = c_vision.CutMixBatch(ImageBatchFormat.NHWC, 1.0, 0.5)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.batch(5)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=cutmix_batch_op,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;, &quot;label&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_cut_mix_batch_c</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_batch_format</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_batch_format</span> <span class="o">=</span> <span class="n">image_batch_format</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">CutMixBatchOperation</span><span class="p">(</span><span class="n">DE_C_IMAGE_BATCH_FORMAT</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image_batch_format</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="CutOut"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.CutOut.html#mindspore.dataset.vision.c_transforms.CutOut">[docs]</a><span class="k">class</span> <span class="nc">CutOut</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly cut (mask) out a given number of square patches from the input NumPy image array.</span>

<span class="sd">    Args:</span>
<span class="sd">        length (int): The side length of each square patch.</span>
<span class="sd">        num_patches (int, optional): Number of patches to be cut out of an image (default=1).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.CutOut(80, num_patches=10)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_cutout</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_patches</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_patches</span> <span class="o">=</span> <span class="n">num_patches</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">CutOutOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_patches</span><span class="p">)</span></div>


<div class="viewcode-block" id="Decode"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.Decode.html#mindspore.dataset.vision.c_transforms.Decode">[docs]</a><span class="k">class</span> <span class="nc">Decode</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decode the input image in RGB mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        rgb (bool, optional): Mode of decoding input image (default=True).</span>
<span class="sd">            If True means format of decoded image is RGB else BGR(deprecated).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomHorizontalFlip()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rgb</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">rgb</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (NumPy): Image to be decoded.</span>

<span class="sd">        Returns:</span>
<span class="sd">            img (NumPy), Decoded image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input should be an encoded image in 1-D NumPy format, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">DecodeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rgb</span><span class="p">)</span></div>


<div class="viewcode-block" id="Equalize"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.Equalize.html#mindspore.dataset.vision.c_transforms.Equalize">[docs]</a><span class="k">class</span> <span class="nc">Equalize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply histogram equalization on input image.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.Equalize()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">EqualizeOperation</span><span class="p">()</span></div>


<div class="viewcode-block" id="HWC2CHW"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.HWC2CHW.html#mindspore.dataset.vision.c_transforms.HWC2CHW">[docs]</a><span class="k">class</span> <span class="nc">HWC2CHW</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpose the input image; shape (H, W, C) to shape (C, H, W).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(),</span>
<span class="sd">        ...                    c_vision.RandomHorizontalFlip(0.75),</span>
<span class="sd">        ...                    c_vision.RandomCrop(512),</span>
<span class="sd">        ...                    c_vision.HWC2CHW()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">HwcToChwOperation</span><span class="p">()</span></div>


<div class="viewcode-block" id="Invert"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.Invert.html#mindspore.dataset.vision.c_transforms.Invert">[docs]</a><span class="k">class</span> <span class="nc">Invert</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply invert on input image in RGB mode.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.Invert()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">InvertOperation</span><span class="p">()</span></div>


<div class="viewcode-block" id="MixUpBatch"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.MixUpBatch.html#mindspore.dataset.vision.c_transforms.MixUpBatch">[docs]</a><span class="k">class</span> <span class="nc">MixUpBatch</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply MixUp transformation on input batch of images and labels. Each image is</span>
<span class="sd">    multiplied by a random weight (lambda) and then added to a randomly selected image from the batch</span>
<span class="sd">    multiplied by (1 - lambda). The same formula is also applied to the one-hot labels.</span>
<span class="sd">    Note that you need to make labels into one-hot format and batch before calling this function.</span>

<span class="sd">    Args:</span>
<span class="sd">        alpha (float, optional): Hyperparameter of beta distribution (default = 1.0).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; onehot_op = c_transforms.OneHot(num_classes=10)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset= image_folder_dataset.map(operations=onehot_op,</span>
<span class="sd">        ...                                                input_columns=[&quot;label&quot;])</span>
<span class="sd">        &gt;&gt;&gt; mixup_batch_op = c_vision.MixUpBatch(alpha=0.9)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.batch(5)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=mixup_batch_op,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;, &quot;label&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mix_up_batch_c</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">MixUpBatchOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span></div>


<div class="viewcode-block" id="Normalize"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.Normalize.html#mindspore.dataset.vision.c_transforms.Normalize">[docs]</a><span class="k">class</span> <span class="nc">Normalize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the input image with respect to mean and standard deviation.</span>

<span class="sd">    Args:</span>
<span class="sd">        mean (sequence): List or tuple of mean values for each channel, with respect to channel order.</span>
<span class="sd">            The mean values must be in range [0.0, 255.0].</span>
<span class="sd">        std (sequence): List or tuple of standard deviations for each channel, with respect to channel order.</span>
<span class="sd">            The standard deviation values must be in range (0.0, 255.0].</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; normalize_op = c_vision.Normalize(mean=[121.0, 115.0, 100.0], std=[70.0, 68.0, 71.0])</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, normalize_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_normalize_c</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="p">[</span><span class="n">mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">std</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">std</span> <span class="o">=</span> <span class="p">[</span><span class="n">std</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">std</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">NormalizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">NormalizePad</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the input image with respect to mean and standard deviation then pad an extra channel with value zero.</span>

<span class="sd">    Args:</span>
<span class="sd">        mean (sequence): List or tuple of mean values for each channel, with respect to channel order.</span>
<span class="sd">            The mean values must be in range (0.0, 255.0].</span>
<span class="sd">        std (sequence): List or tuple of standard deviations for each channel, with respect to channel order.</span>
<span class="sd">            The standard deviation values must be in range (0.0, 255.0].</span>
<span class="sd">        dtype (str): Set the output data type of normalized image (default is &quot;float32&quot;).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; normalize_pad_op = c_vision.NormalizePad(mean=[121.0, 115.0, 100.0],</span>
<span class="sd">        ...                                          std=[70.0, 68.0, 71.0],</span>
<span class="sd">        ...                                          dtype=&quot;float32&quot;)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, normalize_pad_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_normalizepad_c</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">NormalizePadOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<div class="viewcode-block" id="Pad"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.Pad.html#mindspore.dataset.vision.c_transforms.Pad">[docs]</a><span class="k">class</span> <span class="nc">Pad</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad the image according to padding parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        padding (Union[int, sequence]): The number of pixels to pad the image.</span>
<span class="sd">            If a single number is provided, it pads all borders with this value.</span>
<span class="sd">            If a tuple or list of 2 values are provided, it pads the (left and top)</span>
<span class="sd">            with the first value and (right and bottom) with the second value.</span>
<span class="sd">            If 4 values are provided as a list or tuple,</span>
<span class="sd">            it pads the left, top, right and bottom respectively.</span>
<span class="sd">        fill_value (Union[int, tuple], optional): The pixel intensity of the borders, only valid for</span>
<span class="sd">            padding_mode Border.CONSTANT. If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>
<span class="sd">        padding_mode (Border mode, optional): The method of padding (default=Border.CONSTANT). Can be any of</span>
<span class="sd">            [Border.CONSTANT, Border.EDGE, Border.REFLECT, Border.SYMMETRIC].</span>

<span class="sd">            - Border.CONSTANT, means it fills the border with constant values.</span>

<span class="sd">            - Border.EDGE, means it pads with the last value on the edge.</span>

<span class="sd">            - Border.REFLECT, means it reflects the values on the edge omitting the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">            - Border.SYMMETRIC, means it reflects the values on the edge repeating the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Border</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.Pad([100, 100, 100, 100])]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_pad</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">Border</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">):</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">parse_padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">padding_mode</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">PadOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">DE_C_BORDER_TYPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">])</span></div>


<div class="viewcode-block" id="RandomAffine"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomAffine.html#mindspore.dataset.vision.c_transforms.RandomAffine">[docs]</a><span class="k">class</span> <span class="nc">RandomAffine</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply Random affine transformation to the input image.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees (int or float or sequence): Range of the rotation degrees.</span>
<span class="sd">            If degrees is a number, the range will be (-degrees, degrees).</span>
<span class="sd">            If degrees is a sequence, it should be (min, max).</span>
<span class="sd">        translate (sequence, optional): Sequence (tx_min, tx_max, ty_min, ty_max) of minimum/maximum translation in</span>
<span class="sd">            x(horizontal) and y(vertical) directions (default=None).</span>
<span class="sd">            The horizontal and vertical shift is selected randomly from the range:</span>
<span class="sd">            (tx_min*width, tx_max*width) and (ty_min*height, ty_max*height), respectively.</span>
<span class="sd">            If a tuple or list of size 2, then a translate parallel to the X axis in the range of</span>
<span class="sd">            (translate[0], translate[1]) is applied.</span>
<span class="sd">            If a tuple of list of size 4, then a translate parallel to the X axis in the range of</span>
<span class="sd">            (translate[0], translate[1]) and a translate parallel to the Y axis in the range of</span>
<span class="sd">            (translate[2], translate[3]) are applied.</span>
<span class="sd">            If None, no translation is applied.</span>
<span class="sd">        scale (sequence, optional): Scaling factor interval (default=None, original scale is used).</span>
<span class="sd">        shear (int or float or sequence, optional): Range of shear factor (default=None).</span>
<span class="sd">            If a number, then a shear parallel to the X axis in the range of (-shear, +shear) is applied.</span>
<span class="sd">            If a tuple or list of size 2, then a shear parallel to the X axis in the range of (shear[0], shear[1])</span>
<span class="sd">            is applied.</span>
<span class="sd">            If a tuple of list of size 4, then a shear parallel to X axis in the range of (shear[0], shear[1])</span>
<span class="sd">            and a shear parallel to Y axis in the range of (shear[2], shear[3]) is applied.</span>
<span class="sd">            If None, no shear is applied.</span>
<span class="sd">        resample (Inter mode, optional): An optional resampling filter (default=Inter.NEAREST).</span>
<span class="sd">            If omitted, or if the image has mode &quot;1&quot; or &quot;P&quot;, it is set to be Inter.NEAREST.</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means resample method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means resample method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means resample method is bicubic interpolation.</span>

<span class="sd">        fill_value (tuple or int, optional): Optional fill_value to fill the area outside the transform</span>
<span class="sd">            in the output image. There must be three elements in tuple and the value of single element is [0, 255].</span>
<span class="sd">            Used only in Pillow versions &gt; 5.0.0 (default=0, filling is performed).</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If degrees is negative.</span>
<span class="sd">        ValueError: If translation value is not between -1 and 1.</span>
<span class="sd">        ValueError: If scale is not positive.</span>
<span class="sd">        ValueError: If shear is a number but is not positive.</span>
<span class="sd">        TypeError: If degrees is not a number or a list or a tuple.</span>
<span class="sd">            If degrees is a list or tuple, its length is not 2.</span>
<span class="sd">        TypeError: If translate is specified but is not list or a tuple of length 2 or 4.</span>
<span class="sd">        TypeError: If scale is not a list or tuple of length 2.&#39;&#39;</span>
<span class="sd">        TypeError: If shear is not a list or tuple of length 2 or 4.</span>
<span class="sd">        TypeError: If fill_value is not a single integer or a 3-tuple.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; random_affine_op = c_vision.RandomAffine(degrees=15,</span>
<span class="sd">        ...                                          translate=(-0.1, 0.1, 0, 0),</span>
<span class="sd">        ...                                          scale=(0.9, 1.1),</span>
<span class="sd">        ...                                          resample=Inter.NEAREST)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, random_affine_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_affine</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># Parameter checking</span>
        <span class="k">if</span> <span class="n">shear</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
                <span class="n">shear</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">shear</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">shear</span> <span class="o">=</span> <span class="p">[</span><span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">shear</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shear</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">degrees</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

        <span class="c1"># translation</span>
        <span class="k">if</span> <span class="n">translate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">translate</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># scale</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># shear</span>
        <span class="k">if</span> <span class="n">shear</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">shear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resample</span> <span class="o">=</span> <span class="n">DE_C_INTER_MODE</span><span class="p">[</span><span class="n">resample</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomAffineOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomColor"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomColor.html#mindspore.dataset.vision.c_transforms.RandomColor">[docs]</a><span class="k">class</span> <span class="nc">RandomColor</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust the color of the input image by a fixed or random degree.</span>
<span class="sd">    This operation works only with 3-channel color images.</span>

<span class="sd">    Args:</span>
<span class="sd">         degrees (sequence, optional): Range of random color adjustment degrees.</span>
<span class="sd">            It should be in (min, max) format. If min=max, then it is a</span>
<span class="sd">            single fixed magnitude operation (default=(0.1, 1.9)).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomColor((0.5, 2.0))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_positive_degrees</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomColorOperation</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomColorAdjust"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomColorAdjust.html#mindspore.dataset.vision.c_transforms.RandomColorAdjust">[docs]</a><span class="k">class</span> <span class="nc">RandomColorAdjust</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly adjust the brightness, contrast, saturation, and hue of the input image.</span>

<span class="sd">    Args:</span>
<span class="sd">        brightness (Union[float, list, tuple], optional): Brightness adjustment factor (default=(1, 1)).</span>
<span class="sd">            Cannot be negative.</span>
<span class="sd">            If it is a float, the factor is uniformly chosen from the range [max(0, 1-brightness), 1+brightness].</span>
<span class="sd">            If it is a sequence, it should be [min, max] for the range.</span>
<span class="sd">        contrast (Union[float, list, tuple], optional): Contrast adjustment factor (default=(1, 1)).</span>
<span class="sd">            Cannot be negative.</span>
<span class="sd">            If it is a float, the factor is uniformly chosen from the range [max(0, 1-contrast), 1+contrast].</span>
<span class="sd">            If it is a sequence, it should be [min, max] for the range.</span>
<span class="sd">        saturation (Union[float, list, tuple], optional): Saturation adjustment factor (default=(1, 1)).</span>
<span class="sd">            Cannot be negative.</span>
<span class="sd">            If it is a float, the factor is uniformly chosen from the range [max(0, 1-saturation), 1+saturation].</span>
<span class="sd">            If it is a sequence, it should be [min, max] for the range.</span>
<span class="sd">        hue (Union[float, list, tuple], optional): Hue adjustment factor (default=(0, 0)).</span>
<span class="sd">            If it is a float, the range will be [-hue, hue]. Value should be 0 &lt;= hue &lt;= 0.5.</span>
<span class="sd">            If it is a sequence, it should be [min, max] where -0.5 &lt;= min &lt;= max &lt;= 0.5.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; transform_op = c_vision.RandomColorAdjust(brightness=(0.5, 1),</span>
<span class="sd">        ...                                           contrast=(0.4, 1),</span>
<span class="sd">        ...                                           saturation=(0.3, 1))</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, transform_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_color_adjust</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">brightness</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">contrast</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">saturation</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">hue</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="n">brightness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_values</span><span class="p">(</span><span class="n">brightness</span><span class="p">)</span>
        <span class="n">contrast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_values</span><span class="p">(</span><span class="n">contrast</span><span class="p">)</span>
        <span class="n">saturation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_values</span><span class="p">(</span><span class="n">saturation</span><span class="p">)</span>
        <span class="n">hue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_values</span><span class="p">(</span><span class="n">hue</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">non_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">brightness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contrast</span> <span class="o">=</span> <span class="n">contrast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saturation</span> <span class="o">=</span> <span class="n">saturation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hue</span> <span class="o">=</span> <span class="n">hue</span>

<div class="viewcode-block" id="RandomColorAdjust.expand_values"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomColorAdjust.html#mindspore.dataset.vision.c_transforms.RandomColorAdjust.expand_values">[docs]</a>    <span class="k">def</span> <span class="nf">expand_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">FLOAT_MAX_INTEGER</span><span class="p">),</span> <span class="n">non_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expand the value parameter to return 2 elements.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">center</span> <span class="o">-</span> <span class="n">value</span><span class="p">,</span> <span class="n">center</span> <span class="o">+</span> <span class="n">value</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">non_negative</span><span class="p">:</span>
                <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">check_range</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">bound</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomColorAdjustOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">brightness</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contrast</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">saturation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hue</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomCrop"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomCrop.html#mindspore.dataset.vision.c_transforms.RandomCrop">[docs]</a><span class="k">class</span> <span class="nc">RandomCrop</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image at a random location.</span>


<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the cropped image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        padding (Union[int, sequence], optional): The number of pixels to pad the image (default=None).</span>
<span class="sd">            If padding is not None, pad image firstly with padding values.</span>
<span class="sd">            If a single number is provided, pad all borders with this value.</span>
<span class="sd">            If a tuple or list of 2 values are provided, pad the (left and top)</span>
<span class="sd">            with the first value and (right and bottom) with the second value.</span>
<span class="sd">            If 4 values are provided as a list or tuple,</span>
<span class="sd">            pad the left, top, right and bottom respectively.</span>
<span class="sd">        pad_if_needed (bool, optional): Pad the image if either side is smaller than</span>
<span class="sd">            the given output size (default=False).</span>
<span class="sd">        fill_value (Union[int, tuple], optional): The pixel intensity of the borders, only valid for</span>
<span class="sd">            padding_mode Border.CONSTANT. If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>
<span class="sd">        padding_mode (Border mode, optional): The method of padding (default=Border.CONSTANT). It can be any of</span>
<span class="sd">            [Border.CONSTANT, Border.EDGE, Border.REFLECT, Border.SYMMETRIC].</span>

<span class="sd">            - Border.CONSTANT, means it fills the border with constant values.</span>

<span class="sd">            - Border.EDGE, means it pads with the last value on the edge.</span>

<span class="sd">            - Border.REFLECT, means it reflects the values on the edge omitting the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">            - Border.SYMMETRIC, means it reflects the values on the edge repeating the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Border</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; random_crop_op = c_vision.RandomCrop(512, [200, 200, 200, 200], padding_mode=Border.EDGE)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, random_crop_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_if_needed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">Border</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">parse_padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span> <span class="o">=</span> <span class="n">pad_if_needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">border_type</span> <span class="o">=</span> <span class="n">DE_C_BORDER_TYPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomCropOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">border_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomCropDecodeResize"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomCropDecodeResize.html#mindspore.dataset.vision.c_transforms.RandomCropDecodeResize">[docs]</a><span class="k">class</span> <span class="nc">RandomCropDecodeResize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A combination of `Crop`, `Decode` and `Resize`. It will get better performance for JPEG images.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The size of the output image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        scale (tuple, optional): Range [min, max) of respective size of the</span>
<span class="sd">            original size to be cropped (default=(0.08, 1.0)).</span>
<span class="sd">        ratio (tuple, optional): Range [min, max) of aspect ratio to be</span>
<span class="sd">            cropped (default=(3. / 4., 4. / 3.)).</span>
<span class="sd">        interpolation (Inter mode, optional): Image interpolation mode (default=Inter.BILINEAR).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">        max_attempts (int, optional): The maximum number of attempts to propose a valid crop_area (default=10).</span>
<span class="sd">            If exceeded, fall back to use center_crop instead.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; resize_crop_decode_op = c_vision.RandomCropDecodeResize(size=(50, 75),</span>
<span class="sd">        ...                                                         scale=(0.25, 0.5),</span>
<span class="sd">        ...                                                         interpolation=Inter.NEAREST,</span>
<span class="sd">        ...                                                         max_attempts=5)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [resize_crop_decode_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_resize_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">4.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">),</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span> <span class="o">=</span> <span class="n">max_attempts</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomCropDecodeResizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span>
                                                   <span class="n">DE_C_INTER_MODE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input should be an encoded image in 1-D NumPy format, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input should be an encoded image with uint8 type in 1-D NumPy format, &quot;</span> <span class="o">+</span>
                            <span class="s2">&quot;got format:</span><span class="si">{}</span><span class="s2">, dtype:</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomCropWithBBox"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomCropWithBBox.html#mindspore.dataset.vision.c_transforms.RandomCropWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomCropWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image at a random location and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the cropped image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        padding (Union[int, sequence], optional): The number of pixels to pad the image (default=None).</span>
<span class="sd">            If padding is not None, first pad image with padding values.</span>
<span class="sd">            If a single number is provided, pad all borders with this value.</span>
<span class="sd">            If a tuple or list of 2 values are provided, pad the (left and top)</span>
<span class="sd">            with the first value and (right and bottom) with the second value.</span>
<span class="sd">            If 4 values are provided as a list or tuple, pad the left, top, right and bottom respectively.</span>
<span class="sd">        pad_if_needed (bool, optional): Pad the image if either side is smaller than</span>
<span class="sd">            the given output size (default=False).</span>
<span class="sd">        fill_value (Union[int, tuple], optional): The pixel intensity of the borders, only valid for</span>
<span class="sd">            padding_mode Border.CONSTANT. If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>
<span class="sd">        padding_mode (Border mode, optional): The method of padding (default=Border.CONSTANT). It can be any of</span>
<span class="sd">            [Border.CONSTANT, Border.EDGE, Border.REFLECT, Border.SYMMETRIC].</span>

<span class="sd">            - Border.CONSTANT, means it fills the border with constant values.</span>

<span class="sd">            - Border.EDGE, means it pads with the last value on the edge.</span>

<span class="sd">            - Border.REFLECT, means it reflects the values on the edge omitting the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">            - Border.SYMMETRIC, means it reflects the values on the edge repeating the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; random_crop_with_bbox_op = c_vision.RandomCropWithBBox([512, 512], [200, 200, 200, 200])</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, random_crop_with_bbox_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_if_needed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">Border</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">parse_padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span> <span class="o">=</span> <span class="n">pad_if_needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">border_type</span> <span class="o">=</span> <span class="n">DE_C_BORDER_TYPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomCropWithBBoxOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
                                               <span class="n">border_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomHorizontalFlip"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomHorizontalFlip.html#mindspore.dataset.vision.c_transforms.RandomHorizontalFlip">[docs]</a><span class="k">class</span> <span class="nc">RandomHorizontalFlip</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly flip the input image horizontally with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being flipped (default=0.5).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomHorizontalFlip(0.75)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomHorizontalFlipOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomHorizontalFlipWithBBox"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomHorizontalFlipWithBBox.html#mindspore.dataset.vision.c_transforms.RandomHorizontalFlipWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomHorizontalFlipWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flip the input image horizontally, randomly with a given probability and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being flipped (default=0.5).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomHorizontalFlipWithBBox(0.70)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomHorizontalFlipWithBBoxOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomPosterize"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomPosterize.html#mindspore.dataset.vision.c_transforms.RandomPosterize">[docs]</a><span class="k">class</span> <span class="nc">RandomPosterize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduce the number of bits for each color channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        bits (sequence or int, optional): Range of random posterize to compress image.</span>
<span class="sd">            Bits values must be in range of [1,8], and include at</span>
<span class="sd">            least one integer value in the given range. It must be in</span>
<span class="sd">            (min, max) or integer format. If min=max, then it is a single fixed</span>
<span class="sd">            magnitude operation (default=(8, 8)).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomPosterize((6, 8))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_posterize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bits</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomPosterizeOperation</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomResizedCrop"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomResizedCrop.html#mindspore.dataset.vision.c_transforms.RandomResizedCrop">[docs]</a><span class="k">class</span> <span class="nc">RandomResizedCrop</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image to a random size and aspect ratio.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The size of the output image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        scale (tuple, optional): Range [min, max) of respective size of the original</span>
<span class="sd">            size to be cropped (default=(0.08, 1.0)).</span>
<span class="sd">        ratio (tuple, optional): Range [min, max) of aspect ratio to be cropped</span>
<span class="sd">            (default=(3. / 4., 4. / 3.)).</span>
<span class="sd">        interpolation (Inter mode, optional): Image interpolation mode (default=Inter.BILINEAR).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">        max_attempts (int, optional): The maximum number of attempts to propose a valid</span>
<span class="sd">            crop_area (default=10). If exceeded, fall back to use center_crop instead.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; resize_crop_op = c_vision.RandomResizedCrop(size=(50, 75), scale=(0.25, 0.5),</span>
<span class="sd">        ...                                             interpolation=Inter.BILINEAR)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, resize_crop_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_resize_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">4.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">),</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span> <span class="o">=</span> <span class="n">max_attempts</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomResizedCropOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span> <span class="n">DE_C_INTER_MODE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomResizedCropWithBBox"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomResizedCropWithBBox.html#mindspore.dataset.vision.c_transforms.RandomResizedCropWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomResizedCropWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image to a random size and aspect ratio and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The size of the output image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        scale (tuple, optional): Range (min, max) of respective size of the original</span>
<span class="sd">            size to be cropped (default=(0.08, 1.0)).</span>
<span class="sd">        ratio (tuple, optional): Range (min, max) of aspect ratio to be cropped</span>
<span class="sd">            (default=(3. / 4., 4. / 3.)).</span>
<span class="sd">        interpolation (Inter mode, optional): Image interpolation mode (default=Inter.BILINEAR).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">        max_attempts (int, optional): The maximum number of attempts to propose a valid</span>
<span class="sd">            crop area (default=10). If exceeded, fall back to use center crop instead.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; bbox_op = c_vision.RandomResizedCropWithBBox(size=50, interpolation=Inter.NEAREST)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, bbox_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_resize_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">4.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">),</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span> <span class="o">=</span> <span class="n">max_attempts</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomResizedCropWithBBoxOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span>
                                                      <span class="n">DE_C_INTER_MODE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomResize"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomResize.html#mindspore.dataset.vision.c_transforms.RandomResize">[docs]</a><span class="k">class</span> <span class="nc">RandomResize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor operation to resize the input image using a randomly selected interpolation mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the resized image.</span>
<span class="sd">            If size is an integer, smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # randomly resize image, keeping aspect ratio</span>
<span class="sd">        &gt;&gt;&gt; transforms_list1 = [c_vision.Decode(), c_vision.RandomResize(50)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list1,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # randomly resize image to landscape style</span>
<span class="sd">        &gt;&gt;&gt; transforms_list2 = [c_vision.Decode(), c_vision.RandomResize((40, 60))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=transforms_list2,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomResizeOperation</span><span class="p">(</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomResizeWithBBox"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomResizeWithBBox.html#mindspore.dataset.vision.c_transforms.RandomResizeWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomResizeWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor operation to resize the input image using a randomly selected interpolation mode and adjust</span>
<span class="sd">    bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the resized image.</span>
<span class="sd">            If size is an integer, smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # randomly resize image with bounding boxes, keeping aspect ratio</span>
<span class="sd">        &gt;&gt;&gt; transforms_list1 = [c_vision.Decode(), c_vision.RandomResizeWithBBox(60)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list1,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # randomly resize image with bounding boxes to portrait style</span>
<span class="sd">        &gt;&gt;&gt; transforms_list2 = [c_vision.Decode(), c_vision.RandomResizeWithBBox((80, 60))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=transforms_list2,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomResizeWithBBoxOperation</span><span class="p">(</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomRotation"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomRotation.html#mindspore.dataset.vision.c_transforms.RandomRotation">[docs]</a><span class="k">class</span> <span class="nc">RandomRotation</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate the input image by a random angle.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees (Union[int, float, sequence): Range of random rotation degrees.</span>
<span class="sd">            If degrees is a number, the range will be converted to (-degrees, degrees).</span>
<span class="sd">            If degrees is a sequence, it should be (min, max).</span>
<span class="sd">        resample (Inter mode, optional): An optional resampling filter (default=Inter.NEAREST).</span>
<span class="sd">            If omitted, or if the image has mode &quot;1&quot; or &quot;P&quot;, it is set to be Inter.NEAREST.</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means resample method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means resample method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means resample method is bicubic interpolation.</span>

<span class="sd">        expand (bool, optional):  Optional expansion flag (default=False). If set to True, expand the output</span>
<span class="sd">            image to make it large enough to hold the entire rotated image.</span>
<span class="sd">            If set to False or omitted, make the output image the same size as the input.</span>
<span class="sd">            Note that the expand flag assumes rotation around the center and no translation.</span>
<span class="sd">        center (tuple, optional): Optional center of rotation (a 2-tuple) (default=None).</span>
<span class="sd">            Origin is the top left corner. None sets to the center of the image.</span>
<span class="sd">        fill_value (Union[int, tuple], optional): Optional fill color for the area outside the rotated image.</span>
<span class="sd">            If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(),</span>
<span class="sd">        ...                    c_vision.RandomRotation(degrees=5.0,</span>
<span class="sd">        ...                    resample=Inter.NEAREST,</span>
<span class="sd">        ...                    expand=True)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_rotation</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="n">degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">360</span><span class="p">,</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">360</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">degrees</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">360</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resample</span> <span class="o">=</span> <span class="n">resample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expand</span> <span class="o">=</span> <span class="n">expand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># pylint false positive</span>
        <span class="c1"># pylint: disable=E1130</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span>
        <span class="n">interpolation</span> <span class="o">=</span> <span class="n">DE_C_INTER_MODE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">]</span>
        <span class="n">expand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomRotationOperation</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">expand</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomSelectSubpolicy"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomSelectSubpolicy.html#mindspore.dataset.vision.c_transforms.RandomSelectSubpolicy">[docs]</a><span class="k">class</span> <span class="nc">RandomSelectSubpolicy</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose a random sub-policy from a list to be applied on the input image. A sub-policy is a list of tuples</span>
<span class="sd">    (op, prob), where op is a TensorOp operation and prob is the probability that this op will be applied. Once</span>
<span class="sd">    a sub-policy is selected, each op within the subpolicy with be applied in sequence according to its probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        policy (list(list(tuple(TensorOp, float))): List of sub-policies to choose from.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; policy = [[(c_vision.RandomRotation((45, 45)), 0.5),</span>
<span class="sd">        ...            (c_vision.RandomVerticalFlip(), 1),</span>
<span class="sd">        ...            (c_vision.RandomColorAdjust(), 0.8)],</span>
<span class="sd">        ...           [(c_vision.RandomRotation((90, 90)), 1),</span>
<span class="sd">        ...            (c_vision.RandomColorAdjust(), 0.2)]]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=c_vision.RandomSelectSubpolicy(policy),</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_select_subpolicy_op</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">policy</span>

<div class="viewcode-block" id="RandomSelectSubpolicy.parse"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomSelectSubpolicy.html#mindspore.dataset.vision.c_transforms.RandomSelectSubpolicy.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a C++ representation of the operator for execution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">list_one</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy</span><span class="p">:</span>
            <span class="n">policy_one</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">list_two</span> <span class="ow">in</span> <span class="n">list_one</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">list_two</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">list_two</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;parse&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">policy_one</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">list_two</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parse</span><span class="p">(),</span> <span class="n">list_two</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">policy_one</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">list_two</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">list_two</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">policy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">policy_one</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomSelectSubpolicyOperation</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomSharpness"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomSharpness.html#mindspore.dataset.vision.c_transforms.RandomSharpness">[docs]</a><span class="k">class</span> <span class="nc">RandomSharpness</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust the sharpness of the input image by a fixed or random degree. Degree of 0.0 gives a blurred image,</span>
<span class="sd">    degree of 1.0 gives the original image, and degree of 2.0 gives a sharpened image.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees (Union[list, tuple], optional): Range of random sharpness adjustment degrees. It should be in</span>
<span class="sd">            (min, max) format. If min=max, then it is a single fixed magnitude operation (default = (0.1, 1.9)).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError : If degrees is not a list or tuple.</span>
<span class="sd">        ValueError: If degrees is negative.</span>
<span class="sd">        ValueError: If degrees is in (max, min) format instead of (min, max).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomSharpness(degrees=(0.2, 1.9))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_positive_degrees</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomSharpnessOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomSolarize"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomSolarize.html#mindspore.dataset.vision.c_transforms.RandomSolarize">[docs]</a><span class="k">class</span> <span class="nc">RandomSolarize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly invert the pixel values of input image within given range.</span>

<span class="sd">    Args:</span>
<span class="sd">        threshold (tuple, optional): Range of random solarize threshold (default=(0, 255)).</span>
<span class="sd">            Threshold values should always be in (min, max) format,</span>
<span class="sd">            where min &lt;= max, min and max are integers in the range (0, 255).</span>
<span class="sd">            If min=max, then invert all pixel values above min(max).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomSolarize(threshold=(10,100))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_solarize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomSolarizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomVerticalFlip"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomVerticalFlip.html#mindspore.dataset.vision.c_transforms.RandomVerticalFlip">[docs]</a><span class="k">class</span> <span class="nc">RandomVerticalFlip</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly flip the input image vertically with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being flipped (default=0.5).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomVerticalFlip(0.25)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomVerticalFlipOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomVerticalFlipWithBBox"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.RandomVerticalFlipWithBBox.html#mindspore.dataset.vision.c_transforms.RandomVerticalFlipWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomVerticalFlipWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flip the input image vertically, randomly with a given probability and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being flipped (default=0.5).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.RandomVerticalFlipWithBBox(0.20)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomVerticalFlipWithBBoxOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rescale"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.Rescale.html#mindspore.dataset.vision.c_transforms.Rescale">[docs]</a><span class="k">class</span> <span class="nc">Rescale</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor operation to rescale the input image.</span>

<span class="sd">    Args:</span>
<span class="sd">        rescale (float): Rescale factor.</span>
<span class="sd">        shift (float): Shift factor.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.Decode(), c_vision.Rescale(1.0 / 255.0, -1.0)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_rescale</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rescale</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="n">rescale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RescaleOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span></div>


<div class="viewcode-block" id="Resize"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.Resize.html#mindspore.dataset.vision.c_transforms.Resize">[docs]</a><span class="k">class</span> <span class="nc">Resize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the input image to the given size.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the resized image.</span>
<span class="sd">            If size is an integer, the smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        interpolation (Inter mode, optional): Image interpolation mode (default=Inter.LINEAR).</span>
<span class="sd">            It can be any of [Inter.LINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.LINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">            - Inter.AREA, means interpolation method is pixel area interpolation.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; resize_op = c_vision.Resize([100, 75], Inter.BICUBIC)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, resize_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize_interpolation</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">LINEAR</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">ResizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">DE_C_INTER_MODE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">])</span></div>


<div class="viewcode-block" id="ResizeWithBBox"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.ResizeWithBBox.html#mindspore.dataset.vision.c_transforms.ResizeWithBBox">[docs]</a><span class="k">class</span> <span class="nc">ResizeWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the input image to the given size and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the resized image.</span>
<span class="sd">            If size is an integer, smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        interpolation (Inter mode, optional): Image interpolation mode (default=Inter.LINEAR).</span>
<span class="sd">            It can be any of [Inter.LINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.LINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = c_vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; bbox_op = c_vision.ResizeWithBBox(50, Inter.NEAREST)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, bbox_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize_interpolation</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">LINEAR</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">ResizeWithBBoxOperation</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">DE_C_INTER_MODE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">])</span></div>


<div class="viewcode-block" id="SoftDvppDecodeRandomCropResizeJpeg"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.SoftDvppDecodeRandomCropResizeJpeg.html#mindspore.dataset.vision.c_transforms.SoftDvppDecodeRandomCropResizeJpeg">[docs]</a><span class="k">class</span> <span class="nc">SoftDvppDecodeRandomCropResizeJpeg</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor operation to decode, random crop and resize JPEG image using the simulation algorithm of</span>
<span class="sd">    Ascend series chip DVPP module.</span>

<span class="sd">    The usage scenario is consistent with SoftDvppDecodeResizeJpeg.</span>
<span class="sd">    The input image size should be in range [32*32, 8192*8192].</span>
<span class="sd">    The zoom-out and zoom-in multiples of the image length and width should in the range [1/32, 16].</span>
<span class="sd">    Only images with an even resolution can be output. The output of odd resolution is not supported.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The size of the output image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        scale (tuple, optional): Range [min, max) of respective size of the</span>
<span class="sd">            original size to be cropped (default=(0.08, 1.0)).</span>
<span class="sd">        ratio (tuple, optional): Range [min, max) of aspect ratio to be</span>
<span class="sd">            cropped (default=(3. / 4., 4. / 3.)).</span>
<span class="sd">        max_attempts (int, optional): The maximum number of attempts to propose a valid crop_area (default=10).</span>
<span class="sd">            If exceeded, fall back to use center_crop instead.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # decode, randomly crop and resize image, keeping aspect ratio</span>
<span class="sd">        &gt;&gt;&gt; transforms_list1 = [c_vision.Decode(), c_vision.SoftDvppDecodeRandomCropResizeJpeg(90)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list1,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # decode, randomly crop and resize to landscape style</span>
<span class="sd">        &gt;&gt;&gt; transforms_list2 = [c_vision.Decode(), c_vision.SoftDvppDecodeRandomCropResizeJpeg((80, 100))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=transforms_list2,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_soft_dvpp_decode_random_crop_resize_jpeg</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">4.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">),</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span> <span class="o">=</span> <span class="n">max_attempts</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">SoftDvppDecodeRandomCropResizeJpegOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span></div>


<div class="viewcode-block" id="SoftDvppDecodeResizeJpeg"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.SoftDvppDecodeResizeJpeg.html#mindspore.dataset.vision.c_transforms.SoftDvppDecodeResizeJpeg">[docs]</a><span class="k">class</span> <span class="nc">SoftDvppDecodeResizeJpeg</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor operation to decode and resize JPEG image using the simulation algorithm of</span>
<span class="sd">    Ascend series chip DVPP module.</span>

<span class="sd">    It is recommended to use this algorithm in the following scenarios:</span>
<span class="sd">    When training, the DVPP of the Ascend chip is not used,</span>
<span class="sd">    and the DVPP of the Ascend chip is used during inference,</span>
<span class="sd">    and the accuracy of inference is lower than the accuracy of training;</span>
<span class="sd">    and the input image size should be in range [32*32, 8192*8192].</span>
<span class="sd">    The zoom-out and zoom-in multiples of the image length and width should in the range [1/32, 16].</span>
<span class="sd">    Only images with an even resolution can be output. The output of odd resolution is not supported.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the resized image.</span>
<span class="sd">            If size is an integer, smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # decode and resize image, keeping aspect ratio</span>
<span class="sd">        &gt;&gt;&gt; transforms_list1 = [c_vision.Decode(), c_vision.SoftDvppDecodeResizeJpeg(70)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list1,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # decode and resize to portrait style</span>
<span class="sd">        &gt;&gt;&gt; transforms_list2 = [c_vision.Decode(), c_vision.SoftDvppDecodeResizeJpeg((80, 60))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=transforms_list2,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">SoftDvppDecodeResizeJpegOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="UniformAugment"><a class="viewcode-back" href="../../../../mindspore/dataset_vision/mindspore.dataset.vision.c_transforms.UniformAugment.html#mindspore.dataset.vision.c_transforms.UniformAugment">[docs]</a><span class="k">class</span> <span class="nc">UniformAugment</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor operation to perform randomly selected augmentation.</span>

<span class="sd">    Args:</span>
<span class="sd">        transforms: List of C++ operations (Python operations are not accepted).</span>
<span class="sd">        num_ops (int, optional): Number of operations to be selected and applied (default=2).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset.vision.py_transforms as py_vision</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [c_vision.RandomHorizontalFlip(),</span>
<span class="sd">        ...                    c_vision.RandomVerticalFlip(),</span>
<span class="sd">        ...                    c_vision.RandomColorAdjust(),</span>
<span class="sd">        ...                    c_vision.RandomRotation(degrees=45)]</span>
<span class="sd">        &gt;&gt;&gt; uni_aug_op = c_vision.UniformAugment(transforms=transforms_list, num_ops=2)</span>
<span class="sd">        &gt;&gt;&gt; transforms_all = [c_vision.Decode(), c_vision.Resize(size=[224, 224]),</span>
<span class="sd">        ...                   uni_aug_op, py_vision.ToTensor()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset.map(operations=transforms_all,</span>
<span class="sd">        ...                                                   input_columns=&quot;image&quot;,</span>
<span class="sd">        ...                                                   num_parallel_workers=1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_uniform_augment_cpp</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="n">num_ops</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ops</span> <span class="o">=</span> <span class="n">num_ops</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;parse&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">transforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">parse</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">UniformAugOperation</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ops</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>