

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mindspore.common.tensor &mdash; MindSpore master documentation</title>
  

  
   
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">MindSpore Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.compression.html">mindspore.compression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.context.html">mindspore.context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.config.html">mindspore.dataset.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.text.html">mindspore.dataset.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.vision.html">mindspore.dataset.vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.explainer.html">mindspore.explainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.profiler.html">mindspore.profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.train.html">mindspore.train</a></li>
</ul>
<p class="caption"><span class="caption-text">MindSpore C++ API</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://www.mindspore.cn/lite/api/en/r1.3/api_cpp/class_list.html">Lite</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mindspore.common.tensor</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mindspore.common.tensor</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020-2021 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>
<span class="sd">&quot;&quot;&quot;Tensor implementation.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">mindspore.communication.management</span> <span class="kn">import</span> <span class="n">get_rank</span><span class="p">,</span> <span class="n">get_group_size</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dtype</span> <span class="k">as</span> <span class="n">mstype</span>
<span class="kn">from</span> <span class="nn">._register_for_tensor</span> <span class="kn">import</span> <span class="n">tensor_operator_registry</span>
<span class="kn">from</span> <span class="nn">.._c_expression</span> <span class="kn">import</span> <span class="n">Tensor</span> <span class="k">as</span> <span class="n">Tensor_</span>
<span class="kn">from</span> <span class="nn">.._c_expression</span> <span class="kn">import</span> <span class="n">PynativeExecutor_</span>
<span class="kn">from</span> <span class="nn">.._checkparam</span> <span class="kn">import</span> <span class="n">Validator</span> <span class="k">as</span> <span class="n">validator</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Tensor&#39;</span><span class="p">,</span> <span class="s1">&#39;RowTensor&#39;</span><span class="p">,</span> <span class="s1">&#39;SparseTensor&#39;</span><span class="p">]</span>
<span class="n">np_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>


<div class="viewcode-block" id="Tensor"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor">[docs]</a><span class="k">class</span> <span class="nc">Tensor</span><span class="p">(</span><span class="n">Tensor_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor is used for data storage.</span>

<span class="sd">    Tensor inherits tensor object in C++.</span>
<span class="sd">    Some functions are implemented in C++ and some functions are implemented in Python.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_data (Union[Tensor, float, int, bool, tuple, list, numpy.ndarray]): Input data of the tensor.</span>
<span class="sd">        dtype (:class:`mindspore.dtype`): Input data should be None, bool or numeric type defined in `mindspore.dtype`.</span>
<span class="sd">            The argument is used to define the data type of the output tensor. If it is None, the data type of the</span>
<span class="sd">            output tensor will be the same as the `input_data`. Default: None.</span>
<span class="sd">        shape (Union[tuple, list, int]): A list of integers, a tuple of integers or an integer as the shape of</span>
<span class="sd">            output. If `input_data` is available, `shape` doesn&#39;t need to be set. Default: None.</span>
<span class="sd">        init (Initializer): The information of init data.</span>
<span class="sd">            &#39;init&#39; is used for delayed initialization in parallel mode. Usually, it is not recommended to use</span>
<span class="sd">            &#39;init&#39; interface to initialize parameters in other conditions. If &#39;init&#39; interface is used to initialize</span>
<span class="sd">            parameters, the `Tensor.init_data` API needs to be called to convert `Tensor` to the actual data.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor. If `dtype` and `shape` are not set, return a tensor with the same dtype and shape as `input_data`.</span>
<span class="sd">        If `dtype` or `shape` is set, the dtype or shape of the output Tensor is consistent with the setting.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common.initializer import One</span>
<span class="sd">        &gt;&gt;&gt; # initialize a tensor with input data</span>
<span class="sd">        &gt;&gt;&gt; t1 = Tensor(np.zeros([1, 2, 3]), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; assert isinstance(t1, Tensor)</span>
<span class="sd">        &gt;&gt;&gt; assert t1.shape == (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; assert t1.dtype == ms.float32</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # initialize a tensor with a float scalar</span>
<span class="sd">        &gt;&gt;&gt; t2 = Tensor(0.1)</span>
<span class="sd">        &gt;&gt;&gt; assert isinstance(t2, Tensor)</span>
<span class="sd">        &gt;&gt;&gt; assert t2.dtype == ms.float64</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; # initialize a tensor with init</span>
<span class="sd">        &gt;&gt;&gt; t3 = Tensor(shape = (1, 3), dtype=ms.float32, init=One())</span>
<span class="sd">        &gt;&gt;&gt; assert isinstance(t3, Tensor)</span>
<span class="sd">        &gt;&gt;&gt; assert t3.shape == (1, 3)</span>
<span class="sd">        &gt;&gt;&gt; assert t3.dtype == ms.float32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># If input data is numpy number, convert it to np array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">np_types</span><span class="p">):</span>
            <span class="n">input_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>

        <span class="n">_check_tensor_input</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">init</span><span class="p">)</span>

        <span class="c1"># If input_data is tuple/list/numpy.ndarray, it&#39;s support in check_type method.</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;input_data&#39;</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span>
                                       <span class="p">(</span><span class="n">Tensor_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">complex</span><span class="p">),</span> <span class="s1">&#39;Tensor&#39;</span><span class="p">)</span>
            <span class="n">valid_dtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">input_data</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_dtypes</span> <span class="ow">and</span> \
                <span class="n">input_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>  <span class="c1"># Support dtype np.str_</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For Tensor, the input_data is a numpy array, &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;but it&#39;s data type: </span><span class="si">{</span><span class="n">input_data</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> is not in supported list:</span><span class="se">\</span>
<span class="s2">                                </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">valid_dtypes</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_dtypes</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For Tensor, the input_data is </span><span class="si">{</span><span class="n">input_data</span><span class="si">}</span><span class="s2"> that contain unsupported element.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">validator</span><span class="o">.</span><span class="n">check_type_name</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">number_type</span> <span class="o">+</span> <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">string</span><span class="p">),</span> <span class="s2">&quot;Tensor&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">input_data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;FORC&#39;</span><span class="p">]):</span>
                <span class="n">input_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tensor_</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Tensor_</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Tensor_</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="p">):</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">_virtual_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_flag</span>  <span class="c1"># pylint:disable=w0212</span>
        <span class="k">return</span> <span class="n">new_obj</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span><span class="p">:</span>
            <span class="n">Tensor_</span><span class="o">.</span><span class="n">data_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Tensor_</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># bool type is not supported for `Equal` operator in backend.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__eq__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1">#  bool type is not supported for `NotEqual` operator in backend.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__ne__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__neg__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__logical_not__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The truth value of an array with several elements is ambiguous.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int8&quot;</span>
                <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int16&quot;</span>
                <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int32&quot;</span>
                <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int64&quot;</span>
                <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only integer tensors of a single element can be converted to an index.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only integer tensors of a single element can be converted to an index.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">)(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__mod__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__mod__&#39;</span><span class="p">)(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mod__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__floordiv__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__floordiv__&#39;</span><span class="p">)(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__floordiv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__lt__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__le__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__setitem__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_value</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__gt__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__ge__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not support len of a 0-D tensor&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">type_none</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Unknown Tensor type!&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the shape of the tensor as a tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the dtype of the tensor (:class:`mindspore.dtype`).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the total number of elements in tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of tensor dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;tensor is inited.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of one tensor element in bytes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_itemsize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">strides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple of bytes to step in each dimension when traversing a tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strides</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the total number of bytes taken by the tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbytes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the transposed tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">virtual_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used to mark whether the tensor is virtual. If the tensor is virtual, return True.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_flag</span>

    <span class="nd">@virtual_flag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">virtual_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The setter of virtual_flag.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;virtual_flag must be bool.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_flag</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Tensor.from_numpy"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.from_numpy">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_numpy</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert numpy array to Tensor without copy data.</span>

<span class="sd">        Args:</span>
<span class="sd">            array (numpy.array): The input array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same data type as input array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">Tensor_</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">array</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">assign_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">PynativeExecutor_</span><span class="o">.</span><span class="n">get_instance</span><span class="p">()</span><span class="o">.</span><span class="n">execute_all_task</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_value_cpp</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Tensor.item"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.item">[docs]</a>    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getitem from the Tensor with the index.</span>

<span class="sd">        Note:</span>
<span class="sd">            Tensor.item returns a Tensor scalar instead of a Python scalar.</span>

<span class="sd">        Args:</span>
<span class="sd">            index (Union[None, int, tuple(int)]): The index in Tensor. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Tensor scalar, dtype is the same with the original Tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the length of the `index` is not euqal to self.ndim.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([[1,2,3],[4,5,6]], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; x = x.item((0,1))</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            2.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="Tensor.itemset"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.itemset">[docs]</a>    <span class="k">def</span> <span class="nf">itemset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert scalar into a tensor (scalar is cast to tensors dtype, if possible).</span>

<span class="sd">        There must be at least 1 argument, and define the last argument as item.</span>
<span class="sd">        Then, tensor.itemset(\*args) is equivalent to :math:`tensor[args] = item`.</span>

<span class="sd">        Args:</span>
<span class="sd">            args (Union[(numbers.Number), (int/tuple(int), numbers.Number)]): The arguments that</span>
<span class="sd">                specify the index and value. If `args` contain one argument (a scalar),</span>
<span class="sd">                it is only used in case tensor is of size 1. If `args` contain two</span>
<span class="sd">                arguments, the last argument is the value to be set and must be a</span>
<span class="sd">                scalar, the first argument specifies a single tensor element location.</span>
<span class="sd">                It is either an int or a tuple.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new Tensor, with value set by :math:`tensor[args] = item`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the length of the first argument is not euqal to self.ndim.</span>
<span class="sd">            IndexError: If only one argument is provided, and the original Tensor is not scalar.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([[1,2,3],[4,5,6]], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; x = x.itemset((0,1), 4)</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            [[1. 4. 3.]</span>
<span class="sd">            [4. 5. 6.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;itemset&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="Tensor.asnumpy"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.asnumpy">[docs]</a>    <span class="k">def</span> <span class="nf">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert tensor to numpy array.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">PynativeExecutor_</span><span class="o">.</span><span class="n">get_instance</span><span class="p">()</span><span class="o">.</span><span class="n">execute_all_task</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Tensor_</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.flush_from_cache"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.flush_from_cache">[docs]</a>    <span class="k">def</span> <span class="nf">flush_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush cache data to host if tensor is cache enable.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">Tensor_</span><span class="o">.</span><span class="n">_flush_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.all"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.all">[docs]</a>    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(),</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check all array elements along a given axis evaluate to True.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)): Dimensions of reduction,</span>
<span class="sd">                when the axis is None or empty tuple, reduce all dimensions. Default: ().</span>
<span class="sd">            keep_dims (bool): Whether to keep the reduced dimensions. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, if all array elements along the given axis evaluate to True, its value is True,</span>
<span class="sd">            otherwise its value is False. If the axis is None or empty tuple, reduce all dimensions.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor([True, True, False])</span>
<span class="sd">            &gt;&gt;&gt; output = a.all()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)(</span><span class="n">keep_dims</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.any"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.any">[docs]</a>    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(),</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check any array element along a given axis evaluate to True.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)): Dimensions of reduction,</span>
<span class="sd">                when the axis is None or empty tuple, reduce all dimensions. Default: ().</span>
<span class="sd">            keep_dims (bool): Whether to keep the reduced dimensions. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, if any array element along the given axis evaluates to True, its value is True,</span>
<span class="sd">            otherwise its value is False. If the axis is None or empty tuple, reduce all dimensions.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor([True, True, False])</span>
<span class="sd">            &gt;&gt;&gt; output = a.any()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">)(</span><span class="n">keep_dims</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.view"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.view">[docs]</a>    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reshape the tensor according to the input shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            shape (Union[tuple(int), int]): Dimension of the output tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same dimension as the input shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape variable should not be empty&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only one tuple is needed, but got </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.expand_as"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.expand_as">[docs]</a>    <span class="k">def</span> <span class="nf">expand_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the dimension of target tensor to the dimension of input tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (Tensor): The input tensor. The shape of input tensor must obey</span>
<span class="sd">                the broadcasting rule.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same dimension as input tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.abs"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.abs">[docs]</a>    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return absolute value element-wisely.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with absolute value element-wisely.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor([1.1, -2.1]).astype(&quot;float32&quot;)</span>
<span class="sd">            &gt;&gt;&gt; output = a.abs()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [1.1 2.1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;abs&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.mean"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(),</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce a dimension of a tensor by averaging all elements in the dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int), list(int)]): Dimensions of reduction,</span>
<span class="sd">                when the axis is None or empty tuple, reduce all dimensions. Default: ().</span>
<span class="sd">            keep_dims (bool): Whether to keep the reduced dimensions. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same data type as input tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.array([1, 2, 3], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = input_x.mean()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)(</span><span class="n">keep_dims</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.transpose"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a view of the tensor with axes transposed.</span>

<span class="sd">        - For a 1-D tensor this has no effect, as a transposed vector is simply the same vector.</span>
<span class="sd">        - For a 2-D tensor, this is a standard matrix transpose.</span>
<span class="sd">        - For an n-D tensor, if axes are given, their order indicates how the axes are permuted.</span>

<span class="sd">        If axes are not provided and ``tensor.shape = (i[0], i[1],...i[n-2], i[n-1])``,</span>
<span class="sd">        then ``tensor.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.</span>

<span class="sd">        Args:</span>
<span class="sd">            axes(Union[None, tuple(int), list(int), int], optional): If axes is None or</span>
<span class="sd">                blank, the method will reverse the order of the axes. If axes is tuple(int)</span>
<span class="sd">                or list(int), tensor.transpose() will transpose the tensor to the new axes order.</span>
<span class="sd">                If axes is int, this form is simply intended as a convenience alternative to the</span>
<span class="sd">                tuple/list form.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same dimension as input tensor, with axes suitably permuted.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input arguments have types not specified above.</span>
<span class="sd">            ValueError: If the number of `axes` is not euqal to a.ndim.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((1,2,3), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; x = x.transpose()</span>
<span class="sd">            &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">            (3, 2, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_transpose_axis</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transpose&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.reshape"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.reshape">[docs]</a>    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a new shape to a tensor without changing its data.</span>

<span class="sd">        Args:</span>
<span class="sd">            shape(Union[int, tuple(int), list(int)]): The new shape should be compatible</span>
<span class="sd">                with the original shape. If an integer, then the result will be a 1-D</span>
<span class="sd">                array of that length. One shape dimension can be -1. In this case, the</span>
<span class="sd">                value is inferred from the length of the array and remaining dimensions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with new specified shape.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If new_shape is not integer, list or tuple, or `x` is not tensor.</span>
<span class="sd">            ValueError: If new_shape is not compatible with the original shape.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor([[-0.1, 0.3, 3.6], [0.4, 0.5, -3.2]], dtype=mstype.float32)</span>
<span class="sd">            &gt;&gt;&gt; output = x.reshape((3, 2))</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[-0.1  0.3]</span>
<span class="sd">            [ 3.6  0.4]</span>
<span class="sd">            [ 0.5 -3.2]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_reshape_shp</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.ravel"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.ravel">[docs]</a>    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a contiguous flattened tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, a 1-D tensor, containing the same elements of the input.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((2,3,4), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = x.ravel()</span>
<span class="sd">            &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">            (24,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">reshape_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()</span>
        <span class="k">return</span> <span class="n">reshape_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span></div>

<div class="viewcode-block" id="Tensor.flatten"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the tensor collapsed into one dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (str, optional): Can choose between &#39;C&#39; and &#39;F&#39;. &#39;C&#39; means to</span>
<span class="sd">                flatten in row-major (C-style) order. &#39;F&#39; means to flatten in column-major</span>
<span class="sd">                (Fortran-style) order. Only &#39;C&#39; and &#39;F&#39; are supported. Default: &#39;C&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same data type as input.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `order` is not string type.</span>
<span class="sd">            ValueError: If `order` is string type, but not &#39;C&#39; or &#39;F&#39;.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((2,3,4), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = x.flatten()</span>
<span class="sd">            &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">            (24,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">reshape_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()</span>
        <span class="n">trans_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transpose&#39;</span><span class="p">)()</span>

        <span class="n">order</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_flatten_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reshape_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">reshape_op</span><span class="p">(</span><span class="n">trans_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span></div>

<div class="viewcode-block" id="Tensor.swapaxes"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.swapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interchange two axes of a tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis1 (int): First axis.</span>
<span class="sd">            axis2 (int): Second axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Transposed tensor, has the same data type as the input.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `axis1` or `axis2` is not integer.</span>
<span class="sd">            ValueError: If `axis1` or `axis2` is not in the range of :math:`[-ndim, ndim-1]`.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((2,3,4), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = x.swapaxes(0, 2)</span>
<span class="sd">            &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">            (4,3,2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_swapaxes_axis</span><span class="p">((</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis1</span> <span class="o">==</span> <span class="n">axis2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">axis1</span> <span class="o">&gt;</span> <span class="n">axis2</span><span class="p">:</span>
            <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span> <span class="o">=</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">axis1</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">axis2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">new_perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">axis1</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">:</span><span class="n">axis2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">axis2</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">:</span><span class="n">axis1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">axis1</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">:</span><span class="n">axis2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">axis2</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">:</span><span class="n">axis1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transpose&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_perm</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.squeeze"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.squeeze">[docs]</a>    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove single-dimensional entries from the shape of a tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, list(int), tuple(int)], optional): Selects a subset of the entries of</span>
<span class="sd">                length one in the shape. If an axis is selected with shape entry greater than one,</span>
<span class="sd">                an error is raised. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with all or a subset of the dimensions of length 1 removed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input arguments have types not specified above.</span>
<span class="sd">            ValueError: If specified axis has shape entry :math:`&gt; 1`.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((1,2,2,1), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; x = x.squeeze()</span>
<span class="sd">            &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">            (2, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;squeeze&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">prepare_shape_for_squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.astype"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the tensor, cast to a specified type.</span>

<span class="sd">        Args:</span>
<span class="sd">            dtype (Union[:class:`mindspore.dtype`, str]): Designated tensor dtype, can be in format</span>
<span class="sd">                of :class:`mindspore.dtype.float32` or `float32`.</span>
<span class="sd">                Default: :class:`mindspore.dtype.float32`.</span>
<span class="sd">            copy (bool, optional): By default, astype always returns a newly allocated</span>
<span class="sd">                tensor. If this is set to false, the input tensor is returned instead</span>
<span class="sd">                of a copy if possible. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with the designated dtype.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `dtype` has types not specified above, or values cannot be understood.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((1,2,2,1), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; x = x.astype(&quot;int32&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(x.dtype)</span>
<span class="sd">            Int32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_astype_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cast&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.argmax"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.argmax">[docs]</a>    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of the maximum values along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int, optional): By default, the index is into</span>
<span class="sd">                the flattened tensor, otherwise along the specified axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, indices into the input tensor. It has the same</span>
<span class="sd">            shape as self.shape with the dimension along axis removed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the axis is out of range.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(10, 16).reshape(2, 3).astype(&quot;float32&quot;))</span>
<span class="sd">            &gt;&gt;&gt; print(a.argmax())</span>
<span class="sd">            5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># P.Argmax only supports float</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;argmax&#39;</span><span class="p">)(</span><span class="n">axis</span><span class="p">)(</span><span class="n">a</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.argmin"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.argmin">[docs]</a>    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of the minimum values along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int, optional): By default, the index is into</span>
<span class="sd">                the flattened tensor, otherwise along the specified axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, indices into the input tensor. It has the same</span>
<span class="sd">            shape as self.shape with the dimension along axis removed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the axis is out of range.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(10, 16).reshape(2, 3).astype(&quot;float32&quot;))</span>
<span class="sd">            &gt;&gt;&gt; print(a.argmin())</span>
<span class="sd">            0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># P.Argmax only supports float</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="c1"># P.Argmin is currently not supported</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;argmax&#39;</span><span class="p">)(</span><span class="n">axis</span><span class="p">)(</span><span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__neg__&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">))</span></div>

<div class="viewcode-block" id="Tensor.cumsum"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.cumsum">[docs]</a>    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative sum of the elements along a given axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            If ``self.dtype`` is :class:`int8`, :class:`int16` or :class:`bool`, the result</span>
<span class="sd">            `dtype` will be elevated to :class:`int32`, :class:`int64` is not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int, optional): Axis along which the cumulative sum is computed. The</span>
<span class="sd">                default (None) is to compute the cumsum over the flattened array.</span>
<span class="sd">            dtype (:class:`mindspore.dtype`, optional): If not specified, stay the same as original,</span>
<span class="sd">                tensor, unless it has an integer dtype with a precision less than :class:`float32`.</span>
<span class="sd">                In that case, :class:`float32` is used. Default: None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the axis is out of range.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.ones((3,3)).astype(&quot;float32&quot;))</span>
<span class="sd">            &gt;&gt;&gt; output = a.cumsum(axis=0)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[1. 1. 1.]</span>
<span class="sd">            [2. 2. 2.]</span>
<span class="sd">            [3. 3. 3.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">original_dtype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># If original tensor is int, and has precision less then int32, convert to int32</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int16</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">original_dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cumsum&#39;</span><span class="p">)()(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cumsum&#39;</span><span class="p">)()(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.copy"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the tensor.</span>

<span class="sd">        Note:</span>
<span class="sd">            The current implementation does not support `order` argument.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Copied tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.ones((3,3)).astype(&quot;float32&quot;))</span>
<span class="sd">            &gt;&gt;&gt; output = a.copy()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[1. 1. 1.]</span>
<span class="sd">            [1. 1. 1.]</span>
<span class="sd">            [1. 1. 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">origin_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">logical_not_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;logical_not&#39;</span><span class="p">)()</span>
        <span class="k">if</span> <span class="n">origin_dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">logical_not_op</span><span class="p">(</span><span class="n">logical_not_op</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">origin_dtype</span> <span class="o">!=</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mf">1.0</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">origin_dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="Tensor.max"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum of a tensor or maximum along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple of ints], optional): Axis or</span>
<span class="sd">                axes along which to operate. By default, flattened input is used. If</span>
<span class="sd">                this is a tuple of ints, the maximum is selected over multiple axes,</span>
<span class="sd">                instead of a single axis or all the axes as before. Default: None.</span>
<span class="sd">            keepdims (bool, optional):</span>
<span class="sd">                If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">                result as dimensions with size one. With this option, the result will</span>
<span class="sd">                broadcast correctly against the input array. Default: False.</span>
<span class="sd">            initial (scalar, optional):</span>
<span class="sd">                The minimum value of an output element. Must be present to allow</span>
<span class="sd">                computation on empty slice. Default: None.</span>
<span class="sd">            where (bool Tensor, optional):</span>
<span class="sd">                A boolean array which is broadcasted to match the dimensions of array,</span>
<span class="sd">                and selects elements to include in the reduction. If non-default value</span>
<span class="sd">                is passed, initial must also be provided. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor or scalar, maximum of input tensor. If `axis` is None, the result is a scalar</span>
<span class="sd">            value. If `axis` is given, the result is an array of dimension ``self.ndim - 1``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: if arguments have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4).reshape((2, 2)).astype(&#39;float32&#39;))</span>
<span class="sd">            &gt;&gt;&gt; output = a.max()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reduce_</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduce&quot;</span><span class="p">)</span>
        <span class="n">reduce_max</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduce_max&quot;</span><span class="p">)</span>
        <span class="n">maximum</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;maximum&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduce_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduce_max</span><span class="p">(</span><span class="n">keepdims</span><span class="p">),</span> <span class="n">cmp_fn</span><span class="o">=</span><span class="n">maximum</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                       <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.min"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum of a tensor or minimum along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple of ints], optional): Axis or</span>
<span class="sd">                axes along which to operate. By default, flattened input is used. If</span>
<span class="sd">                this is a tuple of ints, the minimum is selected over multiple axes,</span>
<span class="sd">                instead of a single axis or all the axes as before. Default: None.</span>
<span class="sd">            keepdims (bool, optional):</span>
<span class="sd">                If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">                result as dimensions with size one. With this option, the result will</span>
<span class="sd">                broadcast correctly against the input array. Default: False.</span>
<span class="sd">            initial (scalar, optional):</span>
<span class="sd">                The maximum value of an output element. Must be present to allow</span>
<span class="sd">                computation on empty slice. Default: None.</span>
<span class="sd">            where (bool Tensor, optional):</span>
<span class="sd">                A boolean array which is broadcasted to match the dimensions of array,</span>
<span class="sd">                and selects elements to include in the reduction. If non-default value</span>
<span class="sd">                is passed, initial must also be provided. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor or scalar, minimum of input tensor. If the axis is None, the result is a scalar</span>
<span class="sd">            value. If `axis` is given, the result is an array of dimension ``self.ndim - 1``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: if arguments have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.numpy as np</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4).reshape((2,2)).astype(&#39;float32&#39;))</span>
<span class="sd">            &gt;&gt;&gt; output = a.min()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reduce_</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduce&quot;</span><span class="p">)</span>
        <span class="n">reduce_min</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduce_min&quot;</span><span class="p">)</span>
        <span class="n">minimum</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;minimum&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduce_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduce_min</span><span class="p">(</span><span class="n">keepdims</span><span class="p">),</span> <span class="n">cmp_fn</span><span class="o">=</span><span class="n">minimum</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                       <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.fill"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.fill">[docs]</a>    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill the array with a scalar value.</span>

<span class="sd">        Note:</span>
<span class="sd">            Unlike Numpy, tensor.fill() will always returns a new tensor, instead of</span>
<span class="sd">            filling the original tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            value (Union[None, int, float, bool]): All elements of a will be assigned this value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with the original dtype and shape as input tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input arguments have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4).reshape((2,2)).astype(&#39;float32&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(a.fill(1.0))</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">            [1. 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If None is used as value, the original Tensor&#39;s dtype must be float.&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tile&quot;</span><span class="p">)()(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input value must be a scalar.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fill&quot;</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.ptp"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.ptp">[docs]</a>    <span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the function comes from the acronym for peak to peak.</span>

<span class="sd">        Note:</span>
<span class="sd">            Numpy arguments `dtype` and `out` are not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Axis or axes along which the range is computed.</span>
<span class="sd">                The default is to compute the variance of the flattened array. Default: None.</span>
<span class="sd">            keepdims (bool): If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">                dimensions with size one. With this option, the result will broadcast correctly against the array.</span>
<span class="sd">                Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: if `self` is not a tensor, or `axis` and `keepdims` have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor([[4.0, 9.0, 2.0, 10.0], [6.0, 9.0, 7.0, 12.0]]).astype(&quot;float32&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(x.ptp(axis=1))</span>
<span class="sd">            [8. 6.]</span>
<span class="sd">            &gt;&gt;&gt; print(x.ptp(axis=0))</span>
<span class="sd">            [2. 0. 5. 2.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keepdims</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;keepdims should be boolean&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_type</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_valid</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.clip"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clips (limits) the values in a Tensor.</span>

<span class="sd">        Given an interval, values outside the interval are clipped to the interval edges.</span>
<span class="sd">        For example, if an interval of :math:`[0, 1]` is specified, values smaller than 0 become 0,</span>
<span class="sd">        and values larger than 1 become 1.</span>

<span class="sd">        Note:</span>
<span class="sd">            Currently, clip with `xmin=nan` or `xmax=nan` is not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            xmin (Tensor, scalar, None): Minimum value. If None, clipping is not performed</span>
<span class="sd">                on lower interval edge. Not more than one of `xmin` and `xmax` may be None.</span>
<span class="sd">            xmax (Tensor, scalar, None): Maximum value. If None, clipping is not performed</span>
<span class="sd">                on upper interval edge. Not more than one of `xmin` and `xmax` may be None.</span>
<span class="sd">                If `xmin` or `xmax` are tensors, then the three tensors will be broadcasted</span>
<span class="sd">                to match their shapes.</span>
<span class="sd">            dtype (:class:`mindspore.dtype`, optional): Overrides the dtype of the</span>
<span class="sd">                output Tensor. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, a tensor with the elements of input tensor, but where values</span>
<span class="sd">            &lt; `xmin` are replaced with `xmin`, and those &gt; `xmax` with `xmax`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If inputs have types not specified above.</span>
<span class="sd">            ValueError: If the shapes of `x1` and `x2` cannot broadcast, or both `xmin` and `xmax` are `None`.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor([1, 2, 3, -4, 0, 3, 2, 0]).astype(&quot;float32&quot;)</span>
<span class="sd">            &gt;&gt;&gt; output = x.clip(0, 2)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [1. 2. 2. 0. 0. 2. 2. 0.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of max or min must be given.&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># F.maximum/minimum does not support when both operands are scalar</span>
        <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">xmin</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;maximum&quot;</span><span class="p">)()(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;maximum&quot;</span><span class="p">)()(</span><span class="n">x</span><span class="p">,</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">xmax</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;minimum&quot;</span><span class="p">)()(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">xmax</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;minimum&quot;</span><span class="p">)()(</span><span class="n">x</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

    <span class="k">def</span> <span class="nf">_init_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_data</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Tensor.init_data"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.init_data">[docs]</a>    <span class="k">def</span> <span class="nf">init_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opt_shard_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the tensor format data of this Tensor.</span>
<span class="sd">        The init_data function can be called once for the same tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            slice_index (int): Slice index of a parameter&#39;s slices.</span>
<span class="sd">                It is used when initialize a slice of a parameter, it guarantees that devices</span>
<span class="sd">                using the same slice can generate the same tensor. Default: None.</span>
<span class="sd">            shape (list[int]): Shape of the slice, it is used when initialize a slice of the parameter. Default: None.</span>
<span class="sd">            opt_shard_group(str): Optimizer shard group which is used in auto or semi auto parallel mode</span>
<span class="sd">                to get one shard of a parameter&#39;s slice. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Initialized Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.common.initializer as init</span>
<span class="sd">            &gt;&gt;&gt; x = init.initializer(init.Constant(1), [2, 2], ms.float32)</span>
<span class="sd">            &gt;&gt;&gt; out = x.init_data()</span>
<span class="sd">            &gt;&gt;&gt; print(out)</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">             [1. 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;init_data must be set Tensor.init, init can&#39;t be None&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">dtype_to_nptype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">seed_context</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Set and restore seed.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">init</span>
                <span class="kn">from</span> <span class="nn">.seed</span> <span class="kn">import</span> <span class="n">get_seed</span>
                <span class="n">global_seed</span> <span class="o">=</span> <span class="n">get_seed</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_np_seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">get_state</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">need_set_seed</span> <span class="o">=</span> <span class="p">((</span><span class="n">slice_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">global_seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span>

            <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">need_set_seed</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">seed</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">slice_index</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">slice_index</span>

            <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">need_set_seed</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_np_seed</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span>

        <span class="k">with</span> <span class="n">seed_context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opt_shard_group</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">get_rank</span><span class="p">(</span><span class="n">opt_shard_group</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">get_group_size</span><span class="p">(</span><span class="n">opt_shard_group</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">)[</span><span class="n">rank</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_value</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Tensor.to_tensor"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.to_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">to_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opt_shard_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return init_data() and get the tensor format data of this Tensor.</span>

<span class="sd">        Note:</span>
<span class="sd">            The usage of `to_tensor` is deprecated. Please use `init_data`.</span>

<span class="sd">        Args:</span>
<span class="sd">            slice_index (int): Slice index of a parameter&#39;s slices.</span>
<span class="sd">                It is used when initialize a slice of a parameter, it guarantees that devices</span>
<span class="sd">                using the same slice can generate the same tensor. Default: None.</span>
<span class="sd">            shape (list[int]): Shape of the slice, it is used when initialize a slice of the parameter. Default: None.</span>
<span class="sd">            opt_shard_group(str): Optimizer shard group which is used in auto or semi auto parallel mode</span>
<span class="sd">                to get one shard of a parameter&#39;s slice. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Initialized Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.common.initializer as init</span>
<span class="sd">            &gt;&gt;&gt; x = init.initializer(init.Constant(1), [2, 2], ms.float32)</span>
<span class="sd">            &gt;&gt;&gt; out = x.to_tensor()</span>
<span class="sd">            &gt;&gt;&gt; print(out)</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">             [1. 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN_DEPRECATED: The usage of to_tensor is deprecated.&quot;</span>
                       <span class="s2">&quot; Please use init_data&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_data</span><span class="p">(</span><span class="n">slice_index</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">opt_shard_group</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.resize"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes shape and size of array in-place.</span>

<span class="sd">        Note:</span>
<span class="sd">            Instead of changing the size of the input array and returns nothing as in numpy,</span>
<span class="sd">            this method returns a new Tensor with the input size.</span>
<span class="sd">            Numpy argument `refcheck` is not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_shape (Union[ints, tuple of ints]): Shape of resized array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([[0, 1], [2, 3]]))</span>
<span class="sd">            &gt;&gt;&gt; x = x.resize(2, 3)</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            [[0 1 2]</span>
<span class="sd">            [3 0 0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">flattened</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">cur_size</span> <span class="o">=</span> <span class="n">flattened</span><span class="o">.</span><span class="n">size</span>
        <span class="n">new_size</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape_mul&#39;</span><span class="p">)(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="n">diff_size</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">-</span> <span class="n">cur_size</span>
        <span class="k">if</span> <span class="n">diff_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pad_val</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">diff_size</span><span class="p">,),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">)((</span><span class="n">flattened</span><span class="p">,</span> <span class="n">pad_val</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">flattened</span><span class="p">[:</span><span class="n">new_size</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.diagonal"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return specified diagonals.</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (int, optional): Offset of the diagonal from the main diagonal.</span>
<span class="sd">                Can be positive or negative. Defaults to main diagonal.</span>
<span class="sd">            axis1 (int, optional): Axis to be used as the first axis of the 2-D</span>
<span class="sd">                sub-arrays from which the diagonals should be taken. Defaults to</span>
<span class="sd">                first axis (0).</span>
<span class="sd">            axis2 (int, optional): Axis to be used as the second axis of the 2-D</span>
<span class="sd">                sub-arrays from which the diagonals should be taken. Defaults to</span>
<span class="sd">                second axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, if `a` is 2-D, then `a` 1-D array containing the diagonal.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the input tensor has less than two dimensions.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4).reshape(2, 2))</span>
<span class="sd">            &gt;&gt;&gt; print(a)</span>
<span class="sd">            [[0 1]</span>
<span class="sd">            [2 3]]</span>
<span class="sd">            &gt;&gt;&gt; output = a.diagonal()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [0 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;diagonal requires an array of at least two dimensions&#39;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_valid</span><span class="p">((</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">),</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">perm</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span>
        <span class="n">perm</span> <span class="o">+=</span> <span class="n">axes</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;eye&#39;</span><span class="p">)(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">offset</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">n</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">e_left</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">e_right</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="o">-</span><span class="n">offset</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="mi">1</span><span class="p">)((</span><span class="n">e_left</span><span class="p">,</span> <span class="n">e_right</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">e_upper</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">e_lower</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">offset</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">)((</span><span class="n">e_upper</span><span class="p">,</span> <span class="n">e_lower</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">shape</span><span class="p">)(</span><span class="n">e</span><span class="p">)</span>

        <span class="n">prod</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reduce_sum&#39;</span><span class="p">)(</span><span class="n">prod</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">begin</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">begin</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="n">last_dim_begin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">begin</span> <span class="o">+=</span> <span class="p">(</span><span class="n">last_dim_begin</span><span class="p">,)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">last_dim_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">))</span> <span class="o">-</span> <span class="n">last_dim_begin</span>
        <span class="k">if</span> <span class="n">last_dim_end</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">([])</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="p">(</span><span class="n">last_dim_end</span><span class="p">,)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tensor_slice&#39;</span><span class="p">)(</span><span class="n">res</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.trace"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sum along diagonals of the array.</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (int, optional): Offset of the diagonal from the main diagonal.</span>
<span class="sd">                Can be positive or negative. Defaults to main diagonal.</span>
<span class="sd">            axis1 (int, optional): Axis to be used as the first axis of the 2-D</span>
<span class="sd">                sub-arrays from which the diagonals should be taken. Defaults to</span>
<span class="sd">                first axis (0).</span>
<span class="sd">            axis2 (int, optional): Axis to be used as the second axis of the 2-D</span>
<span class="sd">                sub-arrays from which the diagonals should be taken. Defaults to</span>
<span class="sd">                second axis.</span>
<span class="sd">            dtype (:class:`mindspore.dtype`, optional): defaults to None. Overrides the dtype of the</span>
<span class="sd">                output Tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, sum_along_diagonals.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the input tensor has less than two dimensions.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.eye(3, dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(x.trace())</span>
<span class="sd">            3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reduce_sum&#39;</span><span class="p">)(</span><span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.take"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.take">[docs]</a>    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes elements from an array along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices (Tensor): The indices with shape `(Nj...)` of the values to extract.</span>
<span class="sd">            axis (int, optional): The axis over which to select values. By default,</span>
<span class="sd">                the flattened input array is used. Default: `None`.</span>
<span class="sd">            mode (raise, wrap, clip, optional):</span>

<span class="sd">                - edge: Pads with the edge values of `arr`.</span>
<span class="sd">                - raise: Raises an error;</span>
<span class="sd">                - wrap: Wraps around;</span>
<span class="sd">                - clip: Clips to the range. `clip` mode means that all indices that are</span>
<span class="sd">                  too large are replaced by the index that addresses the last element</span>
<span class="sd">                  along that axis. Note that this disables indexing with negative numbers.</span>

<span class="sd">                Default: `clip`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, the indexed result.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if `axis` is out of range, or `mode` has values other than (raise, wrap, clip)</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.array([4, 3, 5, 7, 6, 8]))</span>
<span class="sd">            &gt;&gt;&gt; indices = Tensor(np.array([0, 1, 4]))</span>
<span class="sd">            &gt;&gt;&gt; output = a.take(indices)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [4 3 6]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="s1">&#39;clip&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raise should be one of &quot;raise&quot;, &quot;wrap&quot;, or &quot;clip&quot;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="n">ndim</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span>

        <span class="n">shape_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">shape_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">size_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check_indices&#39;</span><span class="p">)(</span><span class="n">shape_a</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">indices</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="c1"># reshapes indices to shape (Ni..., Nj..., Nk)</span>
        <span class="n">shape_ni</span> <span class="o">=</span> <span class="n">shape_a</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">shape_nk</span> <span class="o">=</span> <span class="n">shape_a</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">shape_out</span> <span class="o">=</span> <span class="n">shape_ni</span> <span class="o">+</span> <span class="n">shape_indices</span> <span class="o">+</span> <span class="n">shape_nk</span>
        <span class="n">shape_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">size_indices</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_indices</span><span class="p">)</span>
        <span class="n">shape_indices</span> <span class="o">=</span> <span class="n">shape_ni</span> <span class="o">+</span> <span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape_nk</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">shape_indices</span><span class="p">)(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gather_d&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_out</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.choose"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.choose">[docs]</a>    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an array from an index array and a list of arrays to choose from.</span>

<span class="sd">        Args:</span>
<span class="sd">            choices (Union[tuple, list, Tensor]): Choice arrays. `a` and all of the `choices` must</span>
<span class="sd">                be broadcasted to the same shape. If `choices` is itself an array, then</span>
<span class="sd">                its outermost dimension (i.e., the one corresponding to ``choices.shape[0]``)</span>
<span class="sd">                is taken as defining the sequence.</span>
<span class="sd">            mode (raise, wrap, clip, optional): Specifies how indices outside</span>
<span class="sd">                ``[0, n-1]`` will be treated:</span>

<span class="sd">                raise  raise an error (default);</span>

<span class="sd">                wrap  wrap around;</span>

<span class="sd">                clip  clip to the range. clip mode means that all indices that are</span>
<span class="sd">                too large are replaced by the index that addresses the last element</span>
<span class="sd">                along that axis. Note that this disables indexing with negative numbers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, the merged result.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the input tensor and any of the `choices` cannot be broadcast.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; choices = [[0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33]]</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([2, 3, 1, 0]))</span>
<span class="sd">            &gt;&gt;&gt; print(x.choose(choices))</span>
<span class="sd">            [20 31 12  3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">shape_choice</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">infer_out_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">choices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)((</span><span class="n">choices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">shape_choice</span><span class="p">)(</span><span class="n">choices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># broadcasts choices to the same shape if choices is a sequence</span>
            <span class="n">choicelist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">choice</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">choice</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_tensor&#39;</span><span class="p">)(</span><span class="n">choice</span><span class="p">)</span>
                <span class="n">shapes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">choice</span><span class="o">.</span><span class="n">shape</span><span class="p">,)</span>
                <span class="n">choicelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
            <span class="n">shape_choice</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">infer_out_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">shapes</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choicelist</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">shape_choice</span><span class="p">)(</span><span class="n">choice</span><span class="p">))</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stack&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">)(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">choices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;input cannot be scalars&#39;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">shape_choice</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">choices</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># adjusts dtype for F.tensor_mul and F.gather_nd</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check_indices&#39;</span><span class="p">)(</span><span class="n">choices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">allow_negative_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">grids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
            <span class="n">dim_grid</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">dim_shape</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">expanded_shape</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">dim_grid</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)(</span><span class="n">dim_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim_shape</span><span class="p">))</span>
            <span class="n">grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim_grid</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stack&#39;</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">)(</span><span class="n">grids</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">)((</span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">grid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gather_nd&#39;</span><span class="p">)(</span><span class="n">choices</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.searchsorted"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.searchsorted">[docs]</a>    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds indices where elements should be inserted to maintain order.</span>

<span class="sd">        Args:</span>
<span class="sd">            v (Union[int, float, bool, list, tuple, Tensor]): Values to insert into `a`.</span>
<span class="sd">            side (&#39;left&#39;, &#39;right&#39;, optional): If left, the index of the first suitable</span>
<span class="sd">                location found is given. If right, return the last such index. If there is</span>
<span class="sd">                no suitable index, return either 0 or N (where N is the length of `a`).</span>
<span class="sd">                Default: `left`.</span>
<span class="sd">            sorter (Union[int, float, bool, list, tuple, Tensor]): 1-D optional array of</span>
<span class="sd">                integer indices that sort array `a` into ascending order. They are typically</span>
<span class="sd">                the result of argsort.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, array of insertion points with the same shape as `v`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if argument for `side` or `sorter` is invalid.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([1, 2, 3, 4, 5]))</span>
<span class="sd">            &gt;&gt;&gt; print(x.searchsorted(3))</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">side</span><span class="si">}</span><span class="s1"> is an invalid value for keyword &quot;side&quot;&#39;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_tensor&#39;</span><span class="p">)(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sorter</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sorter</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sorter must be 1-D array with the same size as `a`&#39;</span><span class="p">)</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_tensor&#39;</span><span class="p">)(</span><span class="n">sorter</span><span class="p">)</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">sorter</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sorter</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gather_nd&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">sorter</span><span class="p">)</span>
        <span class="n">less_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__le__&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__lt__&#39;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">sort_range</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">validator</span><span class="o">.</span><span class="n">get_log2_size</span><span class="p">(</span>
            <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape_mul&#39;</span><span class="p">)(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sort_range</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">less_op</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gather_nd&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">mid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mid</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;select&#39;</span><span class="p">)(</span><span class="n">mask</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;select&#39;</span><span class="p">)(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">j</span></div>

<div class="viewcode-block" id="Tensor.var"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.var">[docs]</a>    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the variance along the specified axis.</span>

<span class="sd">        The variance is the average of the squared deviations from the mean, i.e.,</span>
<span class="sd">        :math:`var = mean(abs(x - x.mean())**2)`.</span>

<span class="sd">        Return the variance, which is computed for the flattened array by default,</span>
<span class="sd">        otherwise over the specified axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            Numpy arguments `dtype`, `out` and `where` are not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Axis or axes along which the variance is computed.</span>
<span class="sd">                The default is to compute the variance of the flattened array. Default: `None`.</span>
<span class="sd">            ddof (int): Means Delta Degrees of Freedom. Default: 0.</span>
<span class="sd">                The divisor used in calculations is :math:`N - ddof`, where :math:`N` represents the number of elements.</span>
<span class="sd">            keepdims (bool): Default: `False`.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Returns:</span>
<span class="sd">            Standard deviation tensor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.array([1., 2., 3., 4.], np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = input_x.var()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            1.25</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ddof</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;integer argument expected, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ddof</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keepdims</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;integer argument expected, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">keepdims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_and_canonicalize_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">x_mean</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)(</span><span class="kc">True</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">x_sub</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_mean</span><span class="p">)</span>
        <span class="n">x_pow</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)(</span><span class="n">x_sub</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">x_sum</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)(</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))(</span><span class="n">x_pow</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="p">():</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">nums</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">)(</span><span class="n">x_sum</span><span class="p">,</span> <span class="n">nums</span> <span class="o">-</span> <span class="n">ddof</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.std"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the standard deviation along the specified axis.</span>
<span class="sd">        The standard deviation is the square root of the average of the squared deviations</span>
<span class="sd">        from the mean, i.e., :math:`std = sqrt(mean(abs(x - x.mean())**2))`.</span>

<span class="sd">        Return the standard deviation, which is computed for the flattened array by default,</span>
<span class="sd">        otherwise over the specified axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            Numpy arguments `dtype`, `out` and `where` are not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Axis or axes along which the standard</span>
<span class="sd">                deviation is computed. Default: `None`.</span>

<span class="sd">                If `None`, compute the standard deviation of the flattened array.</span>
<span class="sd">            ddof (int): Means Delta Degrees of Freedom. The divisor used in calculations is :math:`N - ddof`,</span>
<span class="sd">                where :math:`N` represents the number of elements. Default: 0.</span>
<span class="sd">            keepdims: Default: `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Standard deviation tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.array([1, 2, 3, 4], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = input_x.std()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            1.118034</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)(</span><span class="n">x_var</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.sum"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sum of array elements over a given axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            Numpy arguments `out`, `where`, `casting`, `order`, `subok`, `signature`, and</span>
<span class="sd">            `extobj` are not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Axis or axes along which a sum is performed. Default: None.</span>
<span class="sd">                If None, sum all of the elements of the input array.</span>
<span class="sd">                If the axis is negative, it counts from the last to the first axis.</span>
<span class="sd">                If the axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple</span>
<span class="sd">                instead of a single axis or all the axes as before.</span>
<span class="sd">            dtype (:class:`mindspore.dtype`, optional): defaults to None. Overrides the dtype of the</span>
<span class="sd">                output Tensor.</span>
<span class="sd">            keepdims (bool): If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">                dimensions with size one. With this option, the result will broadcast correctly against the input array.</span>
<span class="sd">                If the default value is passed, then keepdims will not be passed through to the sum method of</span>
<span class="sd">                sub-classes of ndarray, however any non-default value will be. If the sub-class method does not</span>
<span class="sd">                implement keepdims any exceptions will be raised. Default: `False`.</span>
<span class="sd">            initial (scalar): Starting value for the sum. Default: `None`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor. A tensor with the same shape as input, with the specified axis removed.</span>
<span class="sd">            If input tensor is a 0-d array, or if the axis is None, a scalar is returned.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input is not array_like, or `axis` is not int or tuple of ints,</span>
<span class="sd">                or `keepdims` is not integer, or `initial` is not scalar.</span>
<span class="sd">            ValueError: If any axis is out of range or duplicate axes exist.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.array([-1, 0, 1]).astype(np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(input_x.sum())</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.arange(10).reshape(2, 5).astype(np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(input_x.sum(axis=1))</span>
<span class="sd">            [10. 35.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keepdims</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;integer argument expected, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">keepdims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;initial argument should be a scalar.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_and_canonicalize_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_type_support</span><span class="p">(</span><span class="n">input_x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;GPU&#39;</span><span class="p">,</span>
                                            <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">)):</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_tensor&#39;</span><span class="p">)([</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)(</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">initial</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.repeat"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.Tensor.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeat elements of an array.</span>

<span class="sd">        Args:</span>
<span class="sd">            repeats (Union[int, tuple, list]): The number of repetitions for each element.</span>
<span class="sd">                `repeats` is broadcasted to fit the shape of the given axis.</span>
<span class="sd">            axis (int, optional): The axis along which to repeat values. By default,</span>
<span class="sd">                use the flattened input tensor, and return a flat output tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same shape as input tensor except along the given axis.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the axis is out of range.</span>
<span class="sd">            TypeError: if arguments have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array(3))</span>
<span class="sd">            &gt;&gt;&gt; print(x.repeat(4))</span>
<span class="sd">            [3 3 3 3]</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([[1, 2],[3, 4]]))</span>
<span class="sd">            &gt;&gt;&gt; print(x.repeat(2))</span>
<span class="sd">            [1 1 2 2 3 3 4 4]</span>
<span class="sd">            &gt;&gt;&gt; print(x.repeat(3, axis=1))</span>
<span class="sd">            [[1 1 1 2 2 2]</span>
<span class="sd">            [3 3 3 4 4 4]]</span>
<span class="sd">            &gt;&gt;&gt; print(x.repeat([1,2], axis=0))</span>
<span class="sd">            [[1 2]</span>
<span class="sd">            [3 4]</span>
<span class="sd">            [3 4]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">repeats</span> <span class="o">=</span> <span class="p">(</span><span class="n">repeats</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Each element in </span><span class="si">{</span><span class="n">repeats</span><span class="si">}</span><span class="s2"> should be integer, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">input_x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;axes should be integers, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">input_x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="n">input_x</span><span class="o">.</span><span class="n">ndim</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">repeats</span> <span class="o">=</span> <span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">repeats</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Tensor_</span><span class="p">(</span><span class="n">input_x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;repeat_elements&#39;</span><span class="p">)(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;operands could not be broadcast together&#39;</span><span class="p">)</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;split&#39;</span><span class="p">)(</span><span class="n">axis</span><span class="p">,</span> <span class="n">size</span><span class="p">)(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">repeated_subs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sub</span><span class="p">,</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">repeats</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rep</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">repeated_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;repeat_elements&#39;</span><span class="p">)(</span><span class="n">sub</span><span class="p">,</span> <span class="n">rep</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="n">axis</span><span class="p">)(</span><span class="n">repeated_subs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RowTensor"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.RowTensor">[docs]</a><span class="k">class</span> <span class="nc">RowTensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sparse representation of a set of tensor slices at given indices.</span>

<span class="sd">    An RowTensor is typically used to represent a subset of a larger</span>
<span class="sd">    tensor dense of shape [L0, D1, .. , DN] where L0 &gt;&gt; D0.</span>

<span class="sd">    The values in indices are the indices in the first dimension of the slices</span>
<span class="sd">    that have been extracted from the larger tensor.</span>

<span class="sd">    The dense tensor dense represented by an RowTensor slices has</span>
<span class="sd">    `dense[slices.indices[i], :, :, :, ...] = slices.values[i, :, :, :, ...]`.</span>

<span class="sd">    RowTensor can only be used in the `Cell`&#39;s construct method.</span>

<span class="sd">    It is not supported in pynative mode at the moment.</span>

<span class="sd">    Args:</span>
<span class="sd">        indices (Tensor): A 1-D integer Tensor of shape [D0].</span>
<span class="sd">        values (Tensor): A Tensor of any dtype of shape [D0, D1, ..., Dn].</span>
<span class="sd">        dense_shape (tuple(int)): An integer tuple which contains the shape</span>
<span class="sd">            of the corresponding dense tensor.</span>

<span class="sd">    Returns:</span>
<span class="sd">        RowTensor, composed of `indices`, `values`, and `dense_shape`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import RowTensor</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self, dense_shape):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.dense_shape = dense_shape</span>
<span class="sd">        ...     def construct(self, indices, values):</span>
<span class="sd">        ...         x = RowTensor(indices, values, self.dense_shape)</span>
<span class="sd">        ...         return x.values, x.indices, x.dense_shape</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([0])</span>
<span class="sd">        &gt;&gt;&gt; values = Tensor([[1, 2]], dtype=ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; out = Net((3, 2))(indices, values)</span>
<span class="sd">        &gt;&gt;&gt; print(out[0])</span>
<span class="sd">        [[1. 2.]]</span>
<span class="sd">        &gt;&gt;&gt; print(out[1])</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt; print(out[2])</span>
<span class="sd">        (3, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dense_shape</span><span class="p">):</span>
        <span class="s2">&quot;Init RowTensor&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dense_shape</span> <span class="o">=</span> <span class="n">dense_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dense_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dense_shape</span></div>


<div class="viewcode-block" id="SparseTensor"><a class="viewcode-back" href="../../../api_python/mindspore.html#mindspore.SparseTensor">[docs]</a><span class="k">class</span> <span class="nc">SparseTensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sparse representation of a set of nonzero elememts from a tensor at given indices.</span>

<span class="sd">    SparseTensor can only be used in the `Cell`&#39;s construct method.</span>

<span class="sd">    Pynative mode not supported at the moment.</span>

<span class="sd">    For a tensor dense, its SparseTensor(indices, values, dense_shape) has</span>
<span class="sd">    `dense[indices[i]] = values[i]`.</span>

<span class="sd">    Args:</span>
<span class="sd">        indices (Tensor): A 2-D integer Tensor of shape `[N, ndims]`,</span>
<span class="sd">            where N and ndims are the number of `values` and number of dimensions in</span>
<span class="sd">            the SparseTensor, respectively.</span>
<span class="sd">        values (Tensor): A 1-D tensor of any type and shape `[N]`, which</span>
<span class="sd">            supplies the values for each element in `indices`.</span>
<span class="sd">        dense_shape (tuple(int)): A integer tuple of size `ndims`,</span>
<span class="sd">            which specifies the dense_shape of the sparse tensor.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SparseTensor, composed of `indices`, `values`, and `dense_shape`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import SparseTensor</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self, dense_shape):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.dense_shape = dense_shape</span>
<span class="sd">        ...     def construct(self, indices, values):</span>
<span class="sd">        ...         x = SparseTensor(indices, values, self.dense_shape)</span>
<span class="sd">        ...         return x.values, x.indices, x.dense_shape</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([[0, 1], [1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; values = Tensor([1, 2], dtype=ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; out = Net((3, 4))(indices, values)</span>
<span class="sd">        &gt;&gt;&gt; print(out[0])</span>
<span class="sd">        [1. 2.]</span>
<span class="sd">        &gt;&gt;&gt; print(out[1])</span>
<span class="sd">        [[0 1]</span>
<span class="sd">         [1 2]]</span>
<span class="sd">        &gt;&gt;&gt; print(out[2])</span>
<span class="sd">        (3, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dense_shape</span><span class="p">):</span>
        <span class="s2">&quot;Init SparseTensor&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dense_shape</span> <span class="o">=</span> <span class="n">dense_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dense_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dense_shape</span></div>


<span class="k">def</span> <span class="nf">_vm_compare</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implement `vm_compare` for tensor.&quot;&quot;&quot;</span>
    <span class="n">obj_str</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">obj_str</span> <span class="o">==</span> <span class="s2">&quot;shape&quot;</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">obj_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">obj_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">fn</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">obj_str</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj_str</span> <span class="o">=</span> <span class="s2">&quot;__r&quot;</span> <span class="o">+</span> <span class="n">obj_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">obj_str</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_check_tensor_input</span><span class="p">(</span><span class="n">input_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check the tensor input.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">input_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If input_data is available, shape doesn&#39;t need to be set&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;init, dtype and shape must have values at the same time.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">input_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input_data and init can not be None at the same time.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">input_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">input_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">input_data</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input_data can not contain zero dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> \
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input_data can not contain zero dimension.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="s2">&quot;__enable_zero_dim__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">init</span><span class="o">.</span><span class="n">__enable_zero_dim__</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape can not contain zero value.&quot;</span><span class="p">)</span>


<span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;vm_compare&#39;</span><span class="p">,</span> <span class="n">_vm_compare</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, MindSpore.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>