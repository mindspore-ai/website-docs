<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.nn.layer.basic &mdash; MindSpore master documentation</title><link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">MindSpore Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.compression.html">mindspore.compression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.context.html">mindspore.context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.audio.html">mindspore.dataset.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.config.html">mindspore.dataset.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.text.html">mindspore.dataset.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.vision.html">mindspore.dataset.vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.parallel.html">mindspore.parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.parallel.nn.html">mindspore.parallel.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.profiler.html">mindspore.profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.boost.html">mindspore.boost (experimental)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">MindSpore C++ API</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://www.mindspore.cn/lite/api/zh-CN/r1.5/api_cpp/mindspore.html">MindSpore Liteâ†—</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>mindspore.nn.layer.basic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mindspore.nn.layer.basic</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020-2021 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>

<span class="sd">&quot;&quot;&quot;basic&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">mindspore.common.dtype</span> <span class="k">as</span> <span class="nn">mstype</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.composite.multitype_ops</span> <span class="kn">import</span> <span class="n">_constexpr_utils</span> <span class="k">as</span> <span class="n">const_utils</span>
<span class="kn">from</span> <span class="nn">mindspore.common.seed</span> <span class="kn">import</span> <span class="n">_get_graph_seed</span>
<span class="kn">from</span> <span class="nn">mindspore.common.tensor</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">mindspore.common.initializer</span> <span class="kn">import</span> <span class="n">initializer</span>
<span class="kn">from</span> <span class="nn">mindspore.ops</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">P</span>
<span class="kn">from</span> <span class="nn">mindspore.ops</span> <span class="kn">import</span> <span class="n">functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.functional</span> <span class="kn">import</span> <span class="n">identity</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.operations</span> <span class="kn">import</span> <span class="n">_inner_ops</span> <span class="k">as</span> <span class="n">inner</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.primitive</span> <span class="kn">import</span> <span class="n">constexpr</span><span class="p">,</span> <span class="n">Primitive</span>
<span class="kn">from</span> <span class="nn">mindspore.common.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">mindspore._extends</span> <span class="kn">import</span> <span class="n">cell_attr_register</span>
<span class="kn">from</span> <span class="nn">mindspore._checkparam</span> <span class="kn">import</span> <span class="n">Rel</span><span class="p">,</span> <span class="n">Validator</span>
<span class="kn">from</span> <span class="nn">..cell</span> <span class="kn">import</span> <span class="n">Cell</span>
<span class="kn">from</span> <span class="nn">.activation</span> <span class="kn">import</span> <span class="n">get_activation</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dropout&#39;</span><span class="p">,</span> <span class="s1">&#39;Flatten&#39;</span><span class="p">,</span> <span class="s1">&#39;Dense&#39;</span><span class="p">,</span> <span class="s1">&#39;ClipByNorm&#39;</span><span class="p">,</span> <span class="s1">&#39;Norm&#39;</span><span class="p">,</span> <span class="s1">&#39;OneHot&#39;</span><span class="p">,</span> <span class="s1">&#39;Pad&#39;</span><span class="p">,</span> <span class="s1">&#39;Unfold&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Tril&#39;</span><span class="p">,</span> <span class="s1">&#39;Triu&#39;</span><span class="p">,</span> <span class="s1">&#39;ResizeBilinear&#39;</span><span class="p">,</span> <span class="s1">&#39;MatrixDiag&#39;</span><span class="p">,</span> <span class="s1">&#39;MatrixDiagPart&#39;</span><span class="p">,</span> <span class="s1">&#39;MatrixSetDiag&#39;</span><span class="p">,</span> <span class="s1">&#39;L1Regularizer&#39;</span><span class="p">,</span> <span class="s1">&#39;Roll&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="L1Regularizer"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.L1Regularizer.html#mindspore.nn.L1Regularizer">[docs]</a><span class="k">class</span> <span class="nc">L1Regularizer</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies l1 regularization to weights.</span>

<span class="sd">    l1 regularization makes weights sparsity</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{loss}=\lambda * \text{reduce_sum}(\text{abs}(\omega))</span>

<span class="sd">    Note:</span>
<span class="sd">        scale(regularization factor) should be a number which greater than 0</span>

<span class="sd">    Args:</span>
<span class="sd">        scale (int, float): l1 regularization factor which greater than 0.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **weights** (Tensor) - The input of L1Regularizer with data type of float16 or float32.</span>
<span class="sd">          The shape is :math:`(N,*)` where :math:`*` means, any number of additional dimensions.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, which dtype is higher precision data type between mindspore.float32 and weights dtype,</span>
<span class="sd">        and Tensor shape is ()</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `scale` is neither an int nor float.</span>
<span class="sd">        ValueError: If `scale` is not greater than 0.</span>
<span class="sd">        ValueError: If `scale` is math.inf or math.nan.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; scale = 0.5</span>
<span class="sd">        &gt;&gt;&gt; net = nn.L1Regularizer(scale)</span>
<span class="sd">        &gt;&gt;&gt; weights = Tensor(np.array([[1.0, -2.0], [-3.0, 4.0]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; output = net(weights)</span>
<span class="sd">        &gt;&gt;&gt; print(output.asnumpy())</span>
<span class="sd">        5.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize L1Regularizer.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1Regularizer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;scale&#39; should be greater than 0, but got </span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;scale&#39; can not be INF or NAN, but got </span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abs</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Abs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ReduceSum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">const_utils</span><span class="o">.</span><span class="n">check_type_valid</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">number_type</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">)</span>
        <span class="n">l1_regularization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">l1_regularization</span></div>


<div class="viewcode-block" id="Dropout"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Dropout.html#mindspore.nn.Dropout">[docs]</a><span class="k">class</span> <span class="nc">Dropout</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dropout layer for the input.</span>

<span class="sd">    Randomly set some elements of the input tensor to zero with probability :math:`1 - keep\_prob` during training</span>
<span class="sd">    using samples from a Bernoulli distribution.</span>

<span class="sd">    The outputs are scaled by a factor of :math:`\frac{1}{keep\_prob}`    during training so</span>
<span class="sd">    that the output layer remains at a similar scale. During inference, this</span>
<span class="sd">    layer returns the same tensor as the `x`.</span>

<span class="sd">    This technique is proposed in paper `Dropout: A Simple Way to Prevent Neural Networks from Overfitting</span>
<span class="sd">    &lt;http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf&gt;`_ and proved to be effective to reduce</span>
<span class="sd">    over-fitting and prevents neurons from co-adaptation. See more details in `Improving neural networks by</span>
<span class="sd">    preventing co-adaptation of feature detectors</span>
<span class="sd">    &lt;https://arxiv.org/pdf/1207.0580.pdf&gt;`_.</span>

<span class="sd">    Note:</span>
<span class="sd">        Each channel will be zeroed out independently on every construct call.</span>

<span class="sd">    Args:</span>
<span class="sd">        keep_prob (float): The keep rate, greater than 0 and less equal than 1. E.g. rate=0.9,</span>
<span class="sd">                   dropping out 10% of input units. Default: 0.5.</span>
<span class="sd">        dtype (:class:`mindspore.dtype`): Data type of `x`. Default: mindspore.float32.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The input of Dropout with data type of float16 or float32.</span>
<span class="sd">          The shape is :math:`(N,*)` where :math:`*` means, any number of additional dimensions.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, output tensor with the same shape as the `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `keep_prob` is not a float.</span>
<span class="sd">        TypeError: If dtype of `x` is not neither float16 nor float32.</span>
<span class="sd">        ValueError: If `keep_prob` is not in range (0, 1].</span>
<span class="sd">        ValueError: If length of shape of `x` is less than 1.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.ones([2, 2, 3]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Dropout(keep_prob=0.8)</span>
<span class="sd">        &gt;&gt;&gt; net.set_train()</span>
<span class="sd">        Dropout&lt;keep_prob=0.8&gt;</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 2, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dropout.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dropout</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;keep_prob&#39;</span><span class="p">,</span> <span class="n">keep_prob</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_prob</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">keep_prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;keep_prob&#39; should be a number in range (0, 1], &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">keep_prob</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_subclass</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">number_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span> <span class="o">=</span> <span class="n">keep_prob</span>
        <span class="n">seed0</span><span class="p">,</span> <span class="n">seed1</span> <span class="o">=</span> <span class="n">_get_graph_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;dropout&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed0</span> <span class="o">=</span> <span class="n">seed0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed1</span> <span class="o">=</span> <span class="n">seed1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">keep_prob</span><span class="p">,</span> <span class="n">seed0</span><span class="p">,</span> <span class="n">seed1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">extend_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;keep_prob=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="Flatten"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Flatten.html#mindspore.nn.Flatten">[docs]</a><span class="k">class</span> <span class="nc">Flatten</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flatten layer for the input.</span>

<span class="sd">    Flattens a tensor without changing dimension of batch size on the 0-th axis.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - Tensor of shape :math:`(N, \ldots)` to be flattened. The data type is Number.</span>
<span class="sd">          The shape is :math:`(N,*)` where :math:`*` means, any number of additional dimensions</span>
<span class="sd">          and the shape can&#39;t be ().</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, the shape of the output tensor is :math:`(N, X)`, where :math:`X` is</span>
<span class="sd">        the product of the remaining dimensions.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `x` is not a subclass of Tensor.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[[1.2, 1.2], [2.1, 2.1]], [[2.2, 2.2], [3.2, 3.2]]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Flatten()</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[1.2 1.2 2.1 2.1]</span>
<span class="sd">         [2.2 2.2 3.2 3.2]]</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;before flatten the x shape is {x.shape}&quot;)</span>
<span class="sd">        before flatten the x shape is  (2, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;after flatten the output shape is {output.shape}&quot;)</span>
<span class="sd">        after flatten the output shape is (2, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Flatten.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Flatten</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">check_dense_input_shape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prim_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">msg_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39;, the&quot;</span> <span class="k">if</span> <span class="n">prim_name</span> <span class="k">else</span> <span class="s2">&quot;The&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> dimension of &#39;x&#39; should not be less than 2, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Dense"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Dense.html#mindspore.nn.Dense">[docs]</a><span class="k">class</span> <span class="nc">Dense</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The dense connected layer.</span>

<span class="sd">    Applies dense connected layer for the input. This layer implements the operation as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{outputs} = \text{activation}(\text{X} * \text{kernel} + \text{bias}),</span>

<span class="sd">    where :math:`X` is the input tensors, :math:`\text{activation}` is the activation function passed as the activation</span>
<span class="sd">    argument (if passed in), :math:`\text{kernel}` is a weight matrix with the same</span>
<span class="sd">    data type as the :math:`X` created by the layer, and :math:`\text{bias}` is a bias vector</span>
<span class="sd">    with the same data type as the :math:`X` created by the layer (only if has_bias is True).</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): The number of channels in the input space.</span>
<span class="sd">        out_channels (int): The number of channels in the output space.</span>
<span class="sd">        weight_init (Union[Tensor, str, Initializer, numbers.Number]): The trainable weight_init parameter. The dtype</span>
<span class="sd">            is same as `x`. The values of str refer to the function `initializer`. Default: &#39;normal&#39;.</span>
<span class="sd">        bias_init (Union[Tensor, str, Initializer, numbers.Number]): The trainable bias_init parameter. The dtype is</span>
<span class="sd">            same as `x`. The values of str refer to the function `initializer`. Default: &#39;zeros&#39;.</span>
<span class="sd">        has_bias (bool): Specifies whether the layer uses a bias vector. Default: True.</span>
<span class="sd">        activation (Union[str, Cell, Primitive]): activate function applied to the output of the fully connected layer,</span>
<span class="sd">            eg. &#39;ReLU&#39;.Default: None.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - Tensor of shape :math:`(*, in\_channels)`. The `in_channels` in `Args` should be equal</span>
<span class="sd">          to :math:`in\_channels` in `Inputs`.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor of shape :math:`(*, out\_channels)`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `in_channels` or `out_channels` is not an int.</span>
<span class="sd">        TypeError: If `has_bias` is not a bool.</span>
<span class="sd">        TypeError: If `activation` is not one of str, Cell, Primitive, None.</span>
<span class="sd">        ValueError: If length of shape of `weight_init` is not equal to 2 or shape[0] of `weight_init`</span>
<span class="sd">                    is not equal to `out_channels` or shape[1] of `weight_init` is not equal to `in_channels`.</span>
<span class="sd">        ValueError: If length of shape of `bias_init` is not equal to 1</span>
<span class="sd">                    or shape[0] of `bias_init` is not equal to `out_channels`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[180, 234, 154], [244, 48, 247]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Dense(3, 4)</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@cell_attr_register</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;has_bias&#39;</span><span class="p">,</span> <span class="s1">&#39;activation&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_channels</span><span class="p">,</span>
                 <span class="n">out_channels</span><span class="p">,</span>
                 <span class="n">weight_init</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span>
                 <span class="n">bias_init</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">,</span>
                 <span class="n">has_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">activation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dense.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dense</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_channels</span> <span class="o">=</span> <span class="n">Validator</span><span class="o">.</span><span class="n">check_positive_int</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="s2">&quot;in_channels&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_channels</span> <span class="o">=</span> <span class="n">Validator</span><span class="o">.</span><span class="n">check_positive_int</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="s2">&quot;out_channels&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span> <span class="o">=</span> <span class="n">Validator</span><span class="o">.</span><span class="n">check_bool</span><span class="p">(</span><span class="n">has_bias</span><span class="p">,</span> <span class="s2">&quot;has_bias&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight_init</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">weight_init</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">weight_init</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out_channels</span> <span class="ow">or</span> \
                    <span class="n">weight_init</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">in_channels</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, weight init shape error. The ndim of &#39;weight_init&#39; should &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;be equal to 2, and the first dim should be equal to &#39;out_channels&#39;, and the &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;second dim should be equal to &#39;in_channels&#39;. But got &#39;weight_init&#39;: </span><span class="si">{</span><span class="n">weight_init</span><span class="si">}</span><span class="s2">, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;&#39;out_channels&#39;: </span><span class="si">{</span><span class="n">out_channels</span><span class="si">}</span><span class="s2">, &#39;in_channels&#39;: </span><span class="si">{</span><span class="n">in_channels</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">initializer</span><span class="p">(</span><span class="n">weight_init</span><span class="p">,</span> <span class="p">[</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bias_init</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bias_init</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">bias_init</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out_channels</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, bias init shape error. The ndim of &#39;bias_init&#39; should &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;be equal to 1, and the first dim should be equal to &#39;out_channels&#39;. But got &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;&#39;bias_init&#39;: </span><span class="si">{</span><span class="n">bias_init</span><span class="si">}</span><span class="s2">, &#39;out_channels&#39;: </span><span class="si">{</span><span class="n">out_channels</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">initializer</span><span class="p">(</span><span class="n">bias_init</span><span class="p">,</span> <span class="p">[</span><span class="n">out_channels</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;bias&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias_add</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">BiasAdd</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matmul</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">MatMul</span><span class="p">(</span><span class="n">transpose_b</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">get_activation</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">activation</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">activation</span>
        <span class="k">if</span> <span class="n">activation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span> <span class="p">(</span><span class="n">Cell</span><span class="p">,</span> <span class="n">Primitive</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;activation&#39; must be str or Cell or Primitive, but got &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_op</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">check_dense_input_shape</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_flag</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">extend_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;input_channels=</span><span class="si">{}</span><span class="s1">, output_channels=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_channels</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, has_bias=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_flag</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, activation=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_is_equal_one</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_dtype_check</span><span class="p">(</span><span class="n">x_dtype</span><span class="p">,</span> <span class="n">prim_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">msg_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39;, the&quot;</span> <span class="k">if</span> <span class="n">prim_name</span> <span class="k">else</span> <span class="s2">&quot;The&quot;</span>
    <span class="k">if</span> <span class="n">x_dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> x_dtype must be float32 or float16, but got </span><span class="si">{</span><span class="n">x_dtype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_is_float_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_need_reduce_all</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="p">():</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="ClipByNorm"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.ClipByNorm.html#mindspore.nn.ClipByNorm">[docs]</a><span class="k">class</span> <span class="nc">ClipByNorm</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clips tensor values to a maximum :math:`L_2`-norm.</span>

<span class="sd">    The output of this layer remains the same if the :math:`L_2`-norm of the input tensor</span>
<span class="sd">    is not greater than the argument clip_norm. Otherwise the tensor will be normalized as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{output}(X) = \frac{\text{clip_norm} * X}{L_2(X)},</span>

<span class="sd">    where :math:`L_2(X)` is the :math:`L_2`-norm of :math:`X`.</span>

<span class="sd">    Args:</span>
<span class="sd">        axis (Union[None, int, tuple(int)]): Compute the L2-norm along the Specific dimension.</span>
<span class="sd">                                            Default: None, all dimensions to calculate.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - Tensor of shape N-D. The type must be float32 or float16.</span>
<span class="sd">        - **clip_norm** (Tensor) - A scalar Tensor of shape :math:`()` or :math:`(1)`.</span>
<span class="sd">          Or a tensor shape can be broadcast to input shape.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, clipped tensor with the same shape as the `x`, whose type is float32.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `axis` is not one of None, int, tuple.</span>
<span class="sd">        TypeError: If dtype of `x` is neither float32 nor float16.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; net = nn.ClipByNorm()</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.random.randint(0, 10, [4, 16]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; clip_norm = Tensor(np.array([100]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; output = net(x, clip_norm)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (4, 16)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize ClipByNorm.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ClipByNorm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
                <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s2">&quot;axis[</span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ReduceSum</span><span class="p">(</span><span class="n">keep_dims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Select</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">greater_</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Greater</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Maximum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Fill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expand_dims</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">clip_norm</span><span class="p">):</span>
        <span class="n">mul_x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">l2sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">mul_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">greater_</span><span class="p">(</span><span class="n">l2sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ones_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">l2sum_safe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">l2sum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ones_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">l2sum</span><span class="p">)))</span>
        <span class="n">l2norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">l2sum_safe</span><span class="p">),</span> <span class="n">l2sum</span><span class="p">)</span>

        <span class="n">_dtype_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_is_equal_one</span><span class="p">(</span><span class="n">clip_norm</span><span class="p">):</span>
            <span class="n">intermediate</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">intermediate</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">clip_norm</span>

        <span class="n">max_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_op</span><span class="p">(</span><span class="n">l2norm</span><span class="p">,</span> <span class="n">clip_norm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_need_reduce_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
            <span class="n">max_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">max_norm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">values_clip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">intermediate</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="n">max_norm</span>
        <span class="n">values_clip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">values_clip</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">values_clip</span> <span class="o">=</span> <span class="n">identity</span><span class="p">(</span><span class="n">values_clip</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values_clip</span></div>


<div class="viewcode-block" id="Norm"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Norm.html#mindspore.nn.Norm">[docs]</a><span class="k">class</span> <span class="nc">Norm</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the norm of vectors, currently including Euclidean norm, i.e., :math:`L_2`-norm.</span>

<span class="sd">    .. math::</span>

<span class="sd">        norm(x) = \sqrt{\sum_{i=1}^{n} (x_i^2)}</span>

<span class="sd">    Args:</span>
<span class="sd">        axis (Union[tuple, int]): The axis over which to compute vector norms. Default: ().</span>
<span class="sd">        keep_dims (bool): If true, the axis indicated in `axis` are kept with size 1. Otherwise,</span>
<span class="sd">                   the dimensions in `axis` are removed from the output shape. Default: False.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - Tensor which is not empty. The data type should be float16 or float32.</span>
<span class="sd">          :math:`(N,*)` where :math:`*` means, any number of additional dimensions.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, output tensor with dimensions in &#39;axis&#39; reduced to 1 will be returned if &#39;keep_dims&#39; is True;</span>
<span class="sd">        otherwise a Tensor with dimensions in &#39;axis&#39; removed is returned. The data type is the same with `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `axis` is neither an int nor a tuple.</span>
<span class="sd">        TypeError: If `keep_dims` is not a bool.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Norm(axis=0)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[4, 4, 9, 1], [2, 1, 3, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">        (2, 4)</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [4.472136 4.1231055 9.486833 6.0827627]</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (4,)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Norm(axis=0, keep_dims=True)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[4, 4, 9, 1], [2, 1, 3, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">        (2, 4)</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [4.472136 4.1231055 9.486833 6.0827627]</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (1, 4)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Norm(axis=1)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[4, 4, 9, 1], [2, 1, 3, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">        (2, 4)</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [10.677078 7.071068]</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2,)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(),</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Norm.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Norm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s2">&quot;keep_dims&quot;</span><span class="p">,</span> <span class="n">keep_dims</span><span class="p">,</span> <span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_dims</span> <span class="o">=</span> <span class="n">keep_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ReduceSum</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_dims</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">extend_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;axis=</span><span class="si">{}</span><span class="s1">, keep_dims=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_dims</span><span class="p">)</span></div>


<div class="viewcode-block" id="OneHot"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.OneHot.html#mindspore.nn.OneHot">[docs]</a><span class="k">class</span> <span class="nc">OneHot</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a one-hot tensor.</span>

<span class="sd">    The locations represented by indices in argument `indices` take value on_value,</span>
<span class="sd">    while all other locations take value off_value.</span>

<span class="sd">    Note:</span>
<span class="sd">        If the input indices is rank :math:`N`, the output will have rank :math:`N+1`. The new</span>
<span class="sd">        axis is created at dimension `axis`.</span>

<span class="sd">    If `indices` is a scalar, the output shape will be a vector of length `depth`.</span>

<span class="sd">    If `indices` is a vector of length `features`, the output shape will be:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        features * depth if axis == -1</span>

<span class="sd">        depth * features if axis == 0</span>

<span class="sd">    If `indices` is a matrix with shape `[batch, features]`, the output shape will be:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        batch * features * depth if axis == -1</span>

<span class="sd">        batch * depth * features if axis == 1</span>

<span class="sd">        depth * batch * features if axis == 0</span>

<span class="sd">    Args:</span>
<span class="sd">        axis (int): Features x depth if axis is -1, depth x features</span>
<span class="sd">                    if axis is 0. Default: -1.</span>
<span class="sd">        depth (int): A scalar defining the depth of the one hot dimension. Default: 1.</span>
<span class="sd">        on_value (float): A scalar defining the value to fill in output[i][j]</span>
<span class="sd">                          when indices[j] = i. Default: 1.0.</span>
<span class="sd">        off_value (float): A scalar defining the value to fill in output[i][j]</span>
<span class="sd">                           when indices[j] != i. Default: 0.0.</span>
<span class="sd">        dtype (:class:`mindspore.dtype`): Data type of &#39;on_value&#39; and &#39;off_value&#39;, not the</span>
<span class="sd">                                          data type of indices. Default: mindspore.float32.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **indices** (Tensor) - A tensor of indices with data type of int32 or int64.</span>
<span class="sd">          The shape is :math:`(N,*)` where :math:`*` means, any number of additional dimensions.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, the one-hot tensor of data type `dtype` with dimension at `axis` expanded to `depth` and filled with</span>
<span class="sd">        on_value and off_value. The dimension of the `Outputs` is equal to the dimension of the `indices` plus one.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `axis` or `depth` is not an int.</span>
<span class="sd">        TypeError: If dtype of `indices` is neither int32 nor int64.</span>
<span class="sd">        ValueError: If `axis` is not in range [-1, len(indices_shape)].</span>
<span class="sd">        ValueError: If `depth` is less than 0.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # 1st sample: add new coordinates at axis 1</span>
<span class="sd">        &gt;&gt;&gt; net = nn.OneHot(depth=4, axis=1)</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([[1, 3], [0, 2]], dtype=mindspore.int32)</span>
<span class="sd">        &gt;&gt;&gt; output = net(indices)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[[0. 0.]</span>
<span class="sd">          [1. 0.]</span>
<span class="sd">          [0. 0.]</span>
<span class="sd">          [0. 1.]]</span>
<span class="sd">         [[1. 0.]</span>
<span class="sd">          [0. 0.]</span>
<span class="sd">          [0. 1.]</span>
<span class="sd">          [0. 0.]]]</span>
<span class="sd">        &gt;&gt;&gt; # The results are shown below:</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 4, 2)</span>
<span class="sd">        &gt;&gt;&gt; # 2nd sample: add new coordinates at axis 0</span>
<span class="sd">        &gt;&gt;&gt; net = nn.OneHot(depth=4, axis=0)</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([[1, 3], [0, 2]], dtype=mindspore.int32)</span>
<span class="sd">        &gt;&gt;&gt; output = net(indices)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[[0. 0.]</span>
<span class="sd">          [1. 0.]]</span>
<span class="sd">         [[1. 0.]</span>
<span class="sd">          [0. 0.]]</span>
<span class="sd">         [[0. 0.]</span>
<span class="sd">          [0. 1.]]</span>
<span class="sd">         [[0. 1.]</span>
<span class="sd">          [0. 0.]]]</span>
<span class="sd">        &gt;&gt;&gt; # The results are shown below:</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (4, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; # 3rd sample: add new coordinates at the last dimension.</span>
<span class="sd">        &gt;&gt;&gt; net = nn.OneHot(depth=4, axis=-1)</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([[1, 3], [0, 2]], dtype=mindspore.int32)</span>
<span class="sd">        &gt;&gt;&gt; output = net(indices)</span>
<span class="sd">        &gt;&gt;&gt; # The results are shown below:</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[[0. 1. 0. 0.]</span>
<span class="sd">          [0. 0. 0. 1.]]</span>
<span class="sd">         [[1. 0. 0. 0.]</span>
<span class="sd">          [0. 0. 1. 0.]]]</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 2, 4)</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([1, 3, 0, 2], dtype=mindspore.int32)</span>
<span class="sd">        &gt;&gt;&gt; output = net(indices)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[0. 1. 0. 0.]</span>
<span class="sd">         [0. 0. 0. 1.]</span>
<span class="sd">         [1. 0. 0. 0.]</span>
<span class="sd">         [0. 0. 1. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (4, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">off_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize OneHot.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OneHot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onehot</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">OneHot</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_value</span> <span class="o">=</span> <span class="n">on_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">off_value</span> <span class="o">=</span> <span class="n">off_value</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onehot</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">off_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span></div>


<div class="viewcode-block" id="Pad"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Pad.html#mindspore.nn.Pad">[docs]</a><span class="k">class</span> <span class="nc">Pad</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pads the input tensor according to the paddings and mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        paddings (tuple): The shape of parameter `paddings` is (N, 2). N is the rank of input data. All elements of</span>
<span class="sd">            paddings are int type. For `D` th dimension of the `x`, paddings[D, 0] indicates how many sizes to be</span>
<span class="sd">            extended ahead of the `D` th dimension of the input tensor, and paddings[D, 1] indicates how many sizes to</span>
<span class="sd">            be extended behind of the `D` th dimension of the input tensor. The padded size of each dimension D of the</span>
<span class="sd">            output is: :math:`paddings[D, 0] + input\_x.dim\_size(D) + paddings[D, 1]`,</span>
<span class="sd">            e.g.:</span>

<span class="sd">            .. code-block::</span>

<span class="sd">                mode = &quot;CONSTANT&quot;.</span>
<span class="sd">                paddings = [[1,1], [2,2]].</span>
<span class="sd">                x = [[1,2,3], [4,5,6], [7,8,9]].</span>
<span class="sd">                # The above can be seen: 1st dimension of `x` is 3, 2nd dimension of `x` is 3.</span>
<span class="sd">                # Substitute into the formula to get:</span>
<span class="sd">                # 1st dimension of output is paddings[0][0] + 3 + paddings[0][1] = 1 + 3 + 1 = 5.</span>
<span class="sd">                # 2nd dimension of output is paddings[1][0] + 3 + paddings[1][1] = 2 + 3 + 2 = 7.</span>
<span class="sd">                # So the shape of output is (5, 7).</span>

<span class="sd">        mode (str): Specifies padding mode. The optional values are &quot;CONSTANT&quot;, &quot;REFLECT&quot;, &quot;SYMMETRIC&quot;.</span>
<span class="sd">            Default: &quot;CONSTANT&quot;.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The input tensor.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, the tensor after padding.</span>

<span class="sd">        - If `mode` is &quot;CONSTANT&quot;, it fills the edge with 0, regardless of the values of the `x`.</span>
<span class="sd">          If the `x` is [[1,2,3], [4,5,6], [7,8,9]] and `paddings` is [[1,1], [2,2]], then the</span>
<span class="sd">          Outputs is [[0,0,0,0,0,0,0], [0,0,1,2,3,0,0], [0,0,4,5,6,0,0], [0,0,7,8,9,0,0], [0,0,0,0,0,0,0]].</span>
<span class="sd">        - If `mode` is &quot;REFLECT&quot;, it uses a way of symmetrical copying through the axis of symmetry to fill in.</span>
<span class="sd">          If the `x` is [[1,2,3], [4,5,6], [7,8,9]] and `paddings` is [[1,1], [2,2]], then the</span>
<span class="sd">          Outputs is [[6,5,4,5,6,5,4], [3,2,1,2,3,2,1], [6,5,4,5,6,5,4], [9,8,7,8,9,8,7], [6,5,4,5,6,5,4]].</span>
<span class="sd">        - If `mode` is &quot;SYMMETRIC&quot;, the filling method is similar to the &quot;REFLECT&quot;. It is also copied</span>
<span class="sd">          according to the symmetry axis, except that it includes the symmetry axis. If the `x`</span>
<span class="sd">          is [[1,2,3], [4,5,6], [7,8,9]] and `paddings` is [[1,1], [2,2]], then the Outputs is</span>
<span class="sd">          [[2,1,1,2,3,3,2], [2,1,1,2,3,3,2], [5,4,4,5,6,6,5], [8,7,7,8,9,9,8], [8,7,7,8,9,9,8]].</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `paddings` is not a tuple.</span>
<span class="sd">        ValueError: If length of `paddings` is more than 4 or its shape is not (n, 2).</span>
<span class="sd">        ValueError: If `mode` is not one of &#39;CONSTANT&#39;, &#39;REFLECT&#39;, &#39;SYMMETRIC&#39;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; # If `mode` is &quot;CONSTANT&quot;</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.pad = nn.Pad(paddings=((1, 1), (2, 2)), mode=&quot;CONSTANT&quot;)</span>
<span class="sd">        ...     def construct(self, x):</span>
<span class="sd">        ...         return self.pad(x)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2, 3], [4, 5, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; pad = Net()</span>
<span class="sd">        &gt;&gt;&gt; output = pad(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[0. 0. 0. 0. 0. 0. 0.]</span>
<span class="sd">         [0. 0. 1. 2. 3. 0. 0.]</span>
<span class="sd">         [0. 0. 4. 5. 6. 0. 0.]</span>
<span class="sd">         [0. 0. 0. 0. 0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; # Another way to call</span>
<span class="sd">        &gt;&gt;&gt; pad = ops.Pad(paddings=((1, 1), (2, 2)))</span>
<span class="sd">        &gt;&gt;&gt; # From the above code, we can see following:</span>
<span class="sd">        &gt;&gt;&gt; # &quot;paddings=((1, 1), (2, 2))&quot;,</span>
<span class="sd">        &gt;&gt;&gt; # paddings[0][0] = 1, indicates a row of values is filled top of the input data in the 1st dimension.</span>
<span class="sd">        &gt;&gt;&gt; # Shown as follows:</span>
<span class="sd">        &gt;&gt;&gt; # [[0. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [1. 2. 3.]</span>
<span class="sd">        &gt;&gt;&gt; #  [4. 5. 6.]]</span>
<span class="sd">        &gt;&gt;&gt; # paddings[0][1] = 1 indicates a row of values is filled below input data in the 1st dimension.</span>
<span class="sd">        &gt;&gt;&gt; # Shown as follows:</span>
<span class="sd">        &gt;&gt;&gt; # [[0. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [1. 2. 3.]</span>
<span class="sd">        &gt;&gt;&gt; #  [4. 5. 6.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; # paddings[1][0] = 2, indicates 2 rows of values is filled in front of input data in the 2nd dimension.</span>
<span class="sd">        &gt;&gt;&gt; # Shown as follows:</span>
<span class="sd">        &gt;&gt;&gt; # [[0. 0. 0. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 1. 2. 3.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 4. 5. 6.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; # paddings[1][1] = 2, indicates 2 rows of values is filled in front of input data in the 2nd dimension.</span>
<span class="sd">        &gt;&gt;&gt; # Shown as follows:</span>
<span class="sd">        &gt;&gt;&gt; # [[0. 0. 0. 0. 0. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 1. 2. 3. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 4. 5. 6. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 0. 0. 0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; output = pad(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[0. 0. 0. 0. 0. 0. 0.]</span>
<span class="sd">         [0. 0. 1. 2. 3. 0. 0.]</span>
<span class="sd">         [0. 0. 4. 5. 6. 0. 0.]</span>
<span class="sd">         [0. 0. 0. 0. 0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; # if mode is &quot;REFLECT&quot;</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.pad = nn.Pad(paddings=((1, 1), (2, 2)), mode=&quot;REFLECT&quot;)</span>
<span class="sd">        ...     def construct(self, x):</span>
<span class="sd">        ...         return self.pad(x)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2, 3], [4, 5, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; pad = Net()</span>
<span class="sd">        &gt;&gt;&gt; output = pad(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[6. 5. 4. 5. 6. 5. 4.]</span>
<span class="sd">         [3. 2. 1. 2. 3. 2. 1.]</span>
<span class="sd">         [6. 5. 4. 5. 6. 5. 4.]</span>
<span class="sd">         [3. 2. 1. 2. 3. 2. 1.]]</span>
<span class="sd">        &gt;&gt;&gt; # if mode is &quot;SYMMETRIC&quot;</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.pad = nn.Pad(paddings=((1, 1), (2, 2)), mode=&quot;SYMMETRIC&quot;)</span>
<span class="sd">        ...     def construct(self, x):</span>
<span class="sd">        ...         return self.pad(x)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2, 3], [4, 5, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; pad = Net()</span>
<span class="sd">        &gt;&gt;&gt; output = pad(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[2. 1. 1. 2. 3. 3. 2.]</span>
<span class="sd">         [2. 1. 1. 2. 3. 3. 2.]</span>
<span class="sd">         [5. 4. 4. 5. 6. 6. 5.]</span>
<span class="sd">         [5. 4. 4. 5. 6. 6. 5.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paddings</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;CONSTANT&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Pad.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Pad</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paddings</span> <span class="o">=</span> <span class="n">paddings</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;CONSTANT&quot;</span><span class="p">,</span> <span class="s2">&quot;REFLECT&quot;</span><span class="p">,</span> <span class="s2">&quot;SYMMETRIC&quot;</span><span class="p">],</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paddings</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the type of &#39;paddings&#39; must be tuple, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">paddings</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">paddings</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the dimension of &#39;paddings&#39; must be (n, 2), &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">paddings</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paddings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, only &#39;paddings&#39; up to 4 dims is supported, but got &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">paddings</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;CONSTANT&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paddings</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">paddings</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paddings</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">MirrorPad</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;CONSTANT&quot;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paddings</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">bilinear</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">,</span> <span class="n">prim_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check input and calculate shape&quot;&quot;&quot;</span>
    <span class="n">msg_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39;, the&quot;</span> <span class="k">if</span> <span class="n">prim_name</span> <span class="k">else</span> <span class="s2">&quot;The&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">align_corners</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> type of &#39;align_corners&#39; should be boolean, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">align_corners</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> &#39;size&#39; and &#39;scale&#39; both none.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> &#39;size&#39; and &#39;scale&#39; both not none.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> &#39;size&#39; must be tuple or list or None, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;size[0]&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;size[1]&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;scale factor&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span>


<div class="viewcode-block" id="ResizeBilinear"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.ResizeBilinear.html#mindspore.nn.ResizeBilinear">[docs]</a><span class="k">class</span> <span class="nc">ResizeBilinear</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples the input tensor to the given size or scale_factor by using bilinear interpolate.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - Tensor to be resized. Input tensor must be a 4-D tensor with shape</span>
<span class="sd">          :math:`(batch, channels, height, width)`, with data type of float16 or float32.</span>
<span class="sd">        - **size** (Union[tuple[int], list[int]]): A tuple or list of 2 int elements</span>
<span class="sd">          :math:`(new\_height, new\_width)`,the new size of the tensor.</span>
<span class="sd">          One and only one of size and scale_factor can be set to None. Default: None.</span>
<span class="sd">        - **scale_factor** (int): The scale factor of new size of the tensor. The value should be positive integer.</span>
<span class="sd">          One and only one of size and scale_factor can be set to None. Default: None.</span>
<span class="sd">        - **align_corners** (bool): If true, rescale input by :math:`(new\_height - 1) / (height - 1)`, which exactly</span>
<span class="sd">          aligns the 4 corners of images and resized images. If false, rescale by :math:`new\_height / height`.</span>
<span class="sd">          Default: False.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Resized tensor.</span>
<span class="sd">        If size is set, the result is 4-D tensor with shape :math:`(batch, channels, new\_height, new\_width)`,</span>
<span class="sd">        and the data type is the same as `x`.</span>
<span class="sd">        If scale is set, the result is 4-D tensor with shape</span>
<span class="sd">        :math:`(batch, channels, scale\_factor * height, scale\_factor * width)` and the data type is the same as `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not one of tuple, list, None.</span>
<span class="sd">        TypeError: If `scale_factor` is neither int nor None.</span>
<span class="sd">        TypeError: If `align_corners` is not a bool.</span>
<span class="sd">        TypeError: If dtype of `x` is neither float16 nor float32.</span>
<span class="sd">        ValueError: If `size` and `scale_factor` are both None or not None.</span>
<span class="sd">        ValueError: If length of shape of `x` is not equal to 4.</span>
<span class="sd">        ValueError: If `scale_factor` is an int which is less than 0.</span>
<span class="sd">        ValueError: If `size` is a list or tuple whose length is not equal to 2.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``CPU`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([[[[1, 2, 3, 4], [5, 6, 7, 8]]]], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; resize_bilinear = nn.ResizeBilinear()</span>
<span class="sd">        &gt;&gt;&gt; result = resize_bilinear(x, size=(5,5))</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[[[1. 2. 3. 4.]</span>
<span class="sd">           [5. 6. 7. 8.]]]]</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[[[1.        1.8       2.6       3.4       4.       ]</span>
<span class="sd">           [2.6       3.4       4.2000003 5.        5.6000004]</span>
<span class="sd">           [4.2       5.0000005 5.8       6.6       7.2      ]</span>
<span class="sd">           [5.        5.8       6.6       7.4       8.       ]</span>
<span class="sd">           [5.        5.8       6.6       7.4000006 8.       ]]]]</span>
<span class="sd">        &gt;&gt;&gt; print(result.shape)</span>
<span class="sd">        (1, 1, 5, 5)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize ResizeBilinear.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResizeBilinear</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">resize_bilinear</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ResizeBilinear</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resize_bilinear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="Unfold"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Unfold.html#mindspore.nn.Unfold">[docs]</a><span class="k">class</span> <span class="nc">Unfold</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts patches from images.</span>
<span class="sd">    The input tensor must be a 4-D tensor and the data format is NCHW.</span>

<span class="sd">    Args:</span>
<span class="sd">        ksizes (Union[tuple[int], list[int]]): The size of sliding window, must be a tuple or a list of integers,</span>
<span class="sd">            and the format is [1, ksize_row, ksize_col, 1].</span>
<span class="sd">        strides (Union[tuple[int], list[int]]): Distance between the centers of the two consecutive patches,</span>
<span class="sd">            must be a tuple or list of int, and the format is [1, stride_row, stride_col, 1].</span>
<span class="sd">        rates (Union[tuple[int], list[int]]): In each extracted patch, the gap between the corresponding dimension</span>
<span class="sd">            pixel positions, must be a tuple or a list of integers, and the format is [1, rate_row, rate_col, 1].</span>
<span class="sd">        padding (str): The type of padding algorithm, is a string whose value is &quot;same&quot; or &quot;valid&quot;, not case sensitive.</span>
<span class="sd">            Default: &quot;valid&quot;.</span>

<span class="sd">            - same: Means that the patch can take the part beyond the original image, and this part is filled with 0.</span>

<span class="sd">            - valid: Means that the taken patch area must be completely covered in the original image.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - A 4-D tensor whose shape is [in_batch, in_depth, in_row, in_col] and</span>
<span class="sd">          data type is number.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, a 4-D tensor whose data type is same as `x`,</span>
<span class="sd">        and the shape is [out_batch, out_depth, out_row, out_col] where `out_batch` is the same as the `in_batch`.</span>

<span class="sd">        :math:`out\_depth = ksize\_row * ksize\_col * in\_depth`</span>

<span class="sd">        :math:`out\_row = (in\_row - (ksize\_row + (ksize\_row - 1) * (rate\_row - 1))) // stride\_row + 1`</span>

<span class="sd">        :math:`out\_col = (in\_col - (ksize\_col + (ksize\_col - 1) * (rate\_col - 1))) // stride\_col + 1`</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `ksizes`, `strides` or `rates` is neither a tuple nor list.</span>
<span class="sd">        ValueError: If shape of `ksizes`, `strides` or `rates` is not (1, x_row, x_col, 1).</span>
<span class="sd">        ValueError: If the second and third element of `ksizes`, `strides` or `rates` is less than 1.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; net = Unfold(ksizes=[1, 2, 2, 1], strides=[1, 2, 2, 1], rates=[1, 2, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; # As stated in the above code:</span>
<span class="sd">        &gt;&gt;&gt; # ksize_row = 2, ksize_col = 2, rate_row = 2, rate_col = 2, stride_row = 2, stride_col = 2.</span>
<span class="sd">        &gt;&gt;&gt; image = Tensor(np.ones([2, 3, 6, 6]), dtype=mstype.float16)</span>
<span class="sd">        &gt;&gt;&gt; # in_batch = 2, in_depth = 3, in_row = 6, in_col = 6.</span>
<span class="sd">        &gt;&gt;&gt; # Substituting the formula to get:</span>
<span class="sd">        &gt;&gt;&gt; # out_batch = in_batch = 2</span>
<span class="sd">        &gt;&gt;&gt; # out_depth = 2 * 2 * 3 = 12</span>
<span class="sd">        &gt;&gt;&gt; # out_row = (6 - (2 + (2 - 1) * (2 - 1))) // 2 + 1 = 2</span>
<span class="sd">        &gt;&gt;&gt; # out_col = (6 - (2 + (2 - 1) * (2 - 1))) // 2 + 1 = 2</span>
<span class="sd">        &gt;&gt;&gt; output = net(image)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 12, 2, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ksizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Unfold.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Unfold</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_check_tuple_or_list</span><span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="n">arg_val</span><span class="p">,</span> <span class="n">prim_name</span><span class="p">):</span>
            <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">,</span> <span class="n">ksizes</span><span class="p">,</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">arg_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">arg_val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39; the format of &#39;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">s&#39; should be [1, </span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_row, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_col, 1], but got </span><span class="si">{</span><span class="n">arg_val</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_val</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_val</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arg_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">arg_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39; the </span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_row and </span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_col in &#39;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">s&#39; should be &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;an positive integer number, but got </span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_row is </span><span class="si">{</span><span class="n">arg_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_col is </span><span class="si">{</span><span class="n">arg_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">_check_tuple_or_list</span><span class="p">(</span><span class="s2">&quot;ksize&quot;</span><span class="p">,</span> <span class="n">ksizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">_check_tuple_or_list</span><span class="p">(</span><span class="s2">&quot;stride&quot;</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">_check_tuple_or_list</span><span class="p">(</span><span class="s2">&quot;rate&quot;</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">ksizes</span> <span class="o">=</span> <span class="n">ksizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ksizes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">ksizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ksizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strides</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">strides</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">strides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rates</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">rates</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rates</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extract_image_patches</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">ExtractImagePatches</span><span class="p">(</span><span class="n">ksizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_image_patches</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">tril</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;x rank&quot;</span><span class="p">,</span> <span class="s2">&quot;tril&quot;</span><span class="p">)</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_is_int</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k value&quot;</span><span class="p">,</span> <span class="s2">&quot;tril&quot;</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>


<div class="viewcode-block" id="Tril"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Tril.html#mindspore.nn.Tril">[docs]</a><span class="k">class</span> <span class="nc">Tril</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tensor with elements above the kth diagonal zeroed.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The input tensor. The data type is Number.</span>
<span class="sd">          :math:`(N,*)` where :math:`*` means, any number of additional dimensions.</span>
<span class="sd">        - **k** (Int) - The index of diagonal. Default: 0</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, has the same shape and type as input `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `k` is not an int.</span>
<span class="sd">        ValueError: If length of shape of `x` is less than 1.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[ 1,  2,  3,  4],</span>
<span class="sd">        ...                      [ 5,  6,  7,  8],</span>
<span class="sd">        ...                      [10, 11, 12, 13],</span>
<span class="sd">        ...                      [14, 15, 16, 17]]))</span>
<span class="sd">        &gt;&gt;&gt; tril = nn.Tril()</span>
<span class="sd">        &gt;&gt;&gt; result = tril(x)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[ 1  0  0  0]</span>
<span class="sd">         [ 5  6  0  0]</span>
<span class="sd">         [10 11 12  0]</span>
<span class="sd">         [14 15 16 17]]</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[ 1,  2,  3,  4],</span>
<span class="sd">        ...                      [ 5,  6,  7,  8],</span>
<span class="sd">        ...                      [10, 11, 12, 13],</span>
<span class="sd">        ...                      [14, 15, 16, 17]]))</span>
<span class="sd">        &gt;&gt;&gt; tril = nn.Tril()</span>
<span class="sd">        &gt;&gt;&gt; result = tril(x, 1)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[ 1  2  0  0]</span>
<span class="sd">         [ 5  6  7  0]</span>
<span class="sd">         [10 11 12 13]</span>
<span class="sd">         [14 15 16 17]]</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[ 1,  2,  3,  4],</span>
<span class="sd">        ...                      [ 5,  6,  7,  8],</span>
<span class="sd">        ...                      [10, 11, 12, 13],</span>
<span class="sd">        ...                      [14, 15, 16, 17]]))</span>
<span class="sd">        &gt;&gt;&gt; tril = nn.Tril()</span>
<span class="sd">        &gt;&gt;&gt; result = tril(x, 2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[ 1  2  3  0]</span>
<span class="sd">         [ 5  6  7  8]</span>
<span class="sd">         [10 11 12 13]</span>
<span class="sd">         [14 15 16 17]]</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[ 1,  2,  3,  4],</span>
<span class="sd">        ...                      [ 5,  6,  7,  8],</span>
<span class="sd">        ...                      [10, 11, 12, 13],</span>
<span class="sd">        ...                      [14, 15, 16, 17]]))</span>
<span class="sd">        &gt;&gt;&gt; tril = nn.Tril()</span>
<span class="sd">        &gt;&gt;&gt; result = tril(x, -1)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[ 0  0  0  0]</span>
<span class="sd">         [ 5  0  0  0]</span>
<span class="sd">         [10 11  0  0]</span>
<span class="sd">         [14 15 16  0]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Tril.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Tril</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">tril</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">assist</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">triu</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;x rank&quot;</span><span class="p">,</span> <span class="s2">&quot;triu&quot;</span><span class="p">)</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_is_int</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k value&quot;</span><span class="p">,</span> <span class="s2">&quot;triu&quot;</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>


<div class="viewcode-block" id="Triu"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Triu.html#mindspore.nn.Triu">[docs]</a><span class="k">class</span> <span class="nc">Triu</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tensor with elements below the kth diagonal zeroed.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The input tensor. The data type is Number.</span>
<span class="sd">          :math:`(N,*)` where :math:`*` means, any number of additional dimensions.</span>
<span class="sd">        - **k** (Int) - The index of diagonal. Default: 0</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, has the same type and shape as input `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `k` is not an int.</span>
<span class="sd">        ValueError: If length of shape of `x` is less than 1.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[ 1,  2,  3,  4],</span>
<span class="sd">        ...                      [ 5,  6,  7,  8],</span>
<span class="sd">        ...                      [10, 11, 12, 13],</span>
<span class="sd">        ...                      [14, 15, 16, 17]]))</span>
<span class="sd">        &gt;&gt;&gt; triu = nn.Triu()</span>
<span class="sd">        &gt;&gt;&gt; result = triu(x)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[ 1  2  3  4]</span>
<span class="sd">         [ 0  6  7  8]</span>
<span class="sd">         [ 0  0 12 13]</span>
<span class="sd">         [ 0  0  0 17]]</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[ 1,  2,  3,  4],</span>
<span class="sd">        ...                      [ 5,  6,  7,  8],</span>
<span class="sd">        ...                      [10, 11, 12, 13],</span>
<span class="sd">        ...                      [14, 15, 16, 17]]))</span>
<span class="sd">        &gt;&gt;&gt; triu = nn.Triu()</span>
<span class="sd">        &gt;&gt;&gt; result = triu(x, 1)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[ 0  2  3  4]</span>
<span class="sd">         [ 0  0  7  8]</span>
<span class="sd">         [ 0  0  0 13]</span>
<span class="sd">         [ 0  0  0  0]]</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[ 1,  2,  3,  4],</span>
<span class="sd">        ...                      [ 5,  6,  7,  8],</span>
<span class="sd">        ...                      [10, 11, 12, 13],</span>
<span class="sd">        ...                      [14, 15, 16, 17]]))</span>
<span class="sd">        &gt;&gt;&gt; triu = nn.Triu()</span>
<span class="sd">        &gt;&gt;&gt; result = triu(x, 2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[ 0  0  3  4]</span>
<span class="sd">         [ 0  0  0  8]</span>
<span class="sd">         [ 0  0  0  0]</span>
<span class="sd">         [ 0  0  0  0]]</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[ 1,  2,  3,  4],</span>
<span class="sd">        ...                      [ 5,  6,  7,  8],</span>
<span class="sd">        ...                      [10, 11, 12, 13],</span>
<span class="sd">        ...                      [14, 15, 16, 17]]))</span>
<span class="sd">        &gt;&gt;&gt; triu = nn.Triu()</span>
<span class="sd">        &gt;&gt;&gt; result = triu(x, -1)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[ 1  2  3  4]</span>
<span class="sd">         [ 5  6  7  8]</span>
<span class="sd">         [ 0 11 12 13]</span>
<span class="sd">         [ 0  0 16 17]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Triu.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Triu</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">triu</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">assist</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_get_matrix_diag_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">):</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;x rank&quot;</span><span class="p">,</span> <span class="s2">&quot;_get_matrix_diag_assist&quot;</span><span class="p">)</span>
    <span class="n">base_eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">assist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">base_eye</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],))</span>
    <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">assist</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_get_matrix_diag_part_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">):</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;x rank&quot;</span><span class="p">,</span> <span class="s2">&quot;_get_matrix_diag_part_assist&quot;</span><span class="p">)</span>
    <span class="n">base_eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">assist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">base_eye</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">assist</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>


<div class="viewcode-block" id="MatrixDiag"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.MatrixDiag.html#mindspore.nn.MatrixDiag">[docs]</a><span class="k">class</span> <span class="nc">MatrixDiag</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a batched diagonal tensor with a given batched diagonal values.</span>

<span class="sd">    Assume `x` has :math:`k` dimensions :math:`[I, J, K, ..., N]`, then the output is a tensor of rank</span>
<span class="sd">    :math:`k+1` with dimensions :math:`[I, J, K, ..., N, N]` where:</span>
<span class="sd">    :math:`output[i, j, k, ..., m, n] = 1\{m=n\} * x[i, j, k, ..., n]`</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The diagonal values. It can be one of the following data types:</span>
<span class="sd">          float32, float16, int32, int8, and uint8.</span>
<span class="sd">          The shape is :math:`(N,*)` where :math:`*` means, any number of additional dimensions.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, has the same type as input `x`. The shape must be x.shape + (x.shape[-1], ).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If dtype of `x` is not one of float32, float16, int32, int8 or uint8.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([1, -1]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; matrix_diag = nn.MatrixDiag()</span>
<span class="sd">        &gt;&gt;&gt; output = matrix_diag(x)</span>
<span class="sd">        &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">        (2,)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[ 1.  0.]</span>
<span class="sd">         [ 0. -1.]]</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 2)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, -1], [1, -1]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; matrix_diag = nn.MatrixDiag()</span>
<span class="sd">        &gt;&gt;&gt; output = matrix_diag(x)</span>
<span class="sd">        &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">        (2, 2)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[[ 1.  0.]</span>
<span class="sd">          [ 0. -1.]]</span>
<span class="sd">         [[ 1.  0.]</span>
<span class="sd">          [ 0. -1.]]]</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, -1, 1], [1, -1, 1]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; matrix_diag = nn.MatrixDiag()</span>
<span class="sd">        &gt;&gt;&gt; output = matrix_diag(x)</span>
<span class="sd">        &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[[ 1.  0.  0.]</span>
<span class="sd">          [ 0. -1.  0.]</span>
<span class="sd">          [ 0.  0.  1.]</span>
<span class="sd">         [[ 1.  0.  0.]</span>
<span class="sd">          [ 0. -1.  0.]</span>
<span class="sd">          [ 0.  0.  1.]]]</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 3, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize MatrixDiag.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatrixDiag</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_diag</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">MatrixDiag</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">x_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">_get_matrix_diag_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>
        <span class="n">out_matrix_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_diag</span><span class="p">(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">assist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_matrix_diag</span></div>


<div class="viewcode-block" id="MatrixDiagPart"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.MatrixDiagPart.html#mindspore.nn.MatrixDiagPart">[docs]</a><span class="k">class</span> <span class="nc">MatrixDiagPart</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the batched diagonal part of a batched tensor.</span>

<span class="sd">    Assume `x` has :math:`k` dimensions :math:`[I, J, K, ..., M, N]`, then the output is a tensor of rank</span>
<span class="sd">    :math:`k-1` with dimensions :math:`[I, J, K, ..., min(M, N)]` where:</span>
<span class="sd">    :math:`output[i, j, k, ..., n] = x[i, j, k, ..., n, n]`</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The batched tensor. It can be one of the following data types:</span>
<span class="sd">          float32, float16, int32, int8, and uint8.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, has the same type as input `x`. The shape must be x.shape[:-2] + [min(x.shape[-2:])].</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If dtype of `x` is not one of float32, float16, int32, int8 or uint8.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([[[-1, 0], [0, 1]],</span>
<span class="sd">        ...             [[-1, 0], [0, 1]],</span>
<span class="sd">        ...             [[-1, 0], [0, 1]]], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; matrix_diag_part = nn.MatrixDiagPart()</span>
<span class="sd">        &gt;&gt;&gt; output = matrix_diag_part(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[-1.  1.]</span>
<span class="sd">         [-1.  1.]</span>
<span class="sd">         [-1.  1.]]</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([[-1, 0, 0, 1],</span>
<span class="sd">        ...             [-1, 0, 0, 1],</span>
<span class="sd">        ...             [-1, 0, 0, 1],</span>
<span class="sd">        ...             [-1, 0, 0, 1]], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; matrix_diag_part = nn.MatrixDiagPart()</span>
<span class="sd">        &gt;&gt;&gt; output = matrix_diag_part(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [-1 0 0 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize MatrixDiagPart.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatrixDiagPart</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_diag_part</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">MatrixDiagPart</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">x_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">_get_matrix_diag_part_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>
        <span class="n">out_matrix_diag_part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_diag_part</span><span class="p">(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">assist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_matrix_diag_part</span></div>


<div class="viewcode-block" id="MatrixSetDiag"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.MatrixSetDiag.html#mindspore.nn.MatrixSetDiag">[docs]</a><span class="k">class</span> <span class="nc">MatrixSetDiag</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modifies the batched diagonal part of a batched tensor.</span>

<span class="sd">    Assume `x` has :math:`k+1` dimensions :math:`[I, J, K, ..., M, N]` and `diagonal` has :math:`k`</span>
<span class="sd">    dimensions :math:`[I, J, K, ..., min(M, N)]`. Then the output is a tensor of rank :math:`k+1` with dimensions</span>
<span class="sd">    :math:`[I, J, K, ..., M, N]` where:</span>

<span class="sd">    .. math::</span>
<span class="sd">        output[i, j, k, ..., m, n] = diagnoal[i, j, k, ..., n]\ for\ m == n</span>

<span class="sd">    .. math::</span>
<span class="sd">        output[i, j, k, ..., m, n] = x[i, j, k, ..., m, n]\ for\ m != n</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The batched tensor. Rank k+1, where k &gt;= 1. It can be one of the following data types:</span>
<span class="sd">          float32, float16, int32, int8, and uint8.</span>
<span class="sd">        - **diagonal** (Tensor) - The diagonal values. Must have the same type as input `x`. Rank k, where k &gt;= 1.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, has the same type and shape as input `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If dtype of `x` or `diagonal` is not one of float32, float16, int32, int8 or uint8.</span>
<span class="sd">        ValueError: If length of shape of `x` is less than 2.</span>
<span class="sd">        ValueError: If x_shape[-2] &lt; x_shape[-1] and x_shape[:-1] != diagonal_shape.</span>
<span class="sd">        ValueError: If x_shape[-2] &gt;= x_shape[-1] and x_shape[:-2] + x_shape[-1:] != diagonal_shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([[[-1, 0], [0, 1]], [[-1, 0], [0, 1]], [[-1, 0], [0, 1]]], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; diagonal = Tensor([[-1., 2.], [-1., 1.], [-1., 1.]], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; matrix_set_diag = nn.MatrixSetDiag()</span>
<span class="sd">        &gt;&gt;&gt; output = matrix_set_diag(x, diagonal)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[[-1.  0.]</span>
<span class="sd">          [ 0.  2.]]</span>
<span class="sd">         [[-1.  0.]</span>
<span class="sd">          [ 0.  1.]]</span>
<span class="sd">         [[-1.  0.]</span>
<span class="sd">          [ 0.  1.]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize MatrixSetDiag.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatrixSetDiag</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_set_diag</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">MatrixSetDiag</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">):</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">x_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">_get_matrix_diag_part_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>
        <span class="n">out_matrix_set_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_set_diag</span><span class="p">(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">,</span> <span class="n">assist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_matrix_set_diag</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_check_input_dim</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">):</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">INC_LEFT</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">)</span>


<div class="viewcode-block" id="Roll"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Roll.html#mindspore.nn.Roll">[docs]</a><span class="k">class</span> <span class="nc">Roll</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rolls the elements of a tensor along an axis.</span>

<span class="sd">    The elements are shifted positively (towards larger indices) by the offset of `shift` along the dimension of `axis`.</span>
<span class="sd">    Negative `shift` values will shift elements in the opposite direction. Elements that roll passed the last position</span>
<span class="sd">    will wrap around to the first and vice versa. Multiple shifts along multiple axes may be specified.</span>

<span class="sd">    Args:</span>
<span class="sd">        shift (Union[list(int), tuple(int), int]): Specifies the number of places by which elements are shifted</span>
<span class="sd">            positively (towards larger indices) along the specified dimension. Negative shifts will roll the elements</span>
<span class="sd">            in the opposite direction.</span>
<span class="sd">        axis (Union[list(int), tuple(int), int]): Specifies the dimension indexes of shape to be rolled.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **input_x** (Tensor) - Input tensor.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, has the same shape and type as `input_x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `shift` is not an int, a tuple or a list.</span>
<span class="sd">        TypeError: If `axis` is not an int, a tuple or a list.</span>
<span class="sd">        TypeError: If element of `shift` is not an int.</span>
<span class="sd">        TypeError: If element of `axis` is not an int.</span>
<span class="sd">        ValueError: If axis is out of the range [-len(input_x.shape), len(input_x.shape)).</span>
<span class="sd">        ValueError: If length of shape of `shift` is not equal to length of shape of `axis`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; input_x = Tensor(np.array([0, 1, 2, 3, 4]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; op = nn.Roll(shift=2, axis=0)</span>
<span class="sd">        &gt;&gt;&gt; output = op(input_x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [3. 4. 0. 1. 2.]</span>
<span class="sd">        &gt;&gt;&gt; input_x = Tensor(np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; op = nn.Roll(shift=[1, -2], axis=[0, 1])</span>
<span class="sd">        &gt;&gt;&gt; output = op(input_x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[7. 8. 9. 5. 6.]</span>
<span class="sd">         [2. 3. 4. 0. 1.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Roll&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Roll</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s2">&quot;shift&quot;</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">inner</span><span class="o">.</span><span class="n">Roll</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the shape of &#39;shift&#39; and the shape of &#39;axis&#39; must be &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;the same, but got the length of &#39;shift&#39; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span><span class="si">}</span><span class="s2"> and the length of &#39;axis&#39;&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">inner</span><span class="o">.</span><span class="n">Roll</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_op</span><span class="p">(</span><span class="n">input_x</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">single_op_roll</span><span class="p">,</span> <span class="n">single_axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">op_list</span><span class="p">:</span>
            <span class="n">_check_input_dim</span><span class="p">(</span><span class="n">single_axis</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">single_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">single_axis</span> <span class="o">+=</span> <span class="n">dim</span>
            <span class="n">transpose_perm</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">transpose_perm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">transpose_perm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">transpose_perm</span><span class="p">[</span><span class="n">single_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_axis</span><span class="p">,</span> <span class="mi">0</span>

            <span class="n">input_x</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">transpose_perm</span><span class="p">)</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="n">single_op_roll</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">transpose_perm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">input_x</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>