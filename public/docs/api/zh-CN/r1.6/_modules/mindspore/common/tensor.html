<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.common.tensor &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script><script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/js/theme.js"></script><script src="../../../_static/underscore.js"></script><script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">MindSpore Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.compression.html">mindspore.compression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.context.html">mindspore.context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.audio.html">mindspore.dataset.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.config.html">mindspore.dataset.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.text.html">mindspore.dataset.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.dataset.vision.html">mindspore.dataset.vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.nn.transformer.html">mindspore.nn.transformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.parallel.html">mindspore.parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.parallel.nn.html">mindspore.parallel.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.profiler.html">mindspore.profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.scipy.html">mindspore.scipy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_python/mindspore.boost.html">mindspore.boost (experimental)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">MindSpore C++ API</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://www.mindspore.cn/lite/api/zh-CN/r1.6/api_cpp/mindspore.html">MindSpore Liteâ†—</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>mindspore.common.tensor</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mindspore.common.tensor</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020-2021 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>
<span class="sd">&quot;&quot;&quot;Tensor implementation.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">mindspore.communication.management</span> <span class="kn">import</span> <span class="n">get_rank</span><span class="p">,</span> <span class="n">get_group_size</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dtype</span> <span class="k">as</span> <span class="n">mstype</span>
<span class="kn">from</span> <span class="nn">._register_for_tensor</span> <span class="kn">import</span> <span class="n">tensor_operator_registry</span>
<span class="kn">from</span> <span class="nn">.._c_expression</span> <span class="kn">import</span> <span class="n">Tensor</span> <span class="k">as</span> <span class="n">Tensor_</span>
<span class="kn">from</span> <span class="nn">.._c_expression</span> <span class="kn">import</span> <span class="n">CSRTensor</span> <span class="k">as</span> <span class="n">CSRTensor_</span>
<span class="kn">from</span> <span class="nn">.._c_expression</span> <span class="kn">import</span> <span class="n">PynativeExecutor_</span>
<span class="kn">from</span> <span class="nn">.._checkparam</span> <span class="kn">import</span> <span class="n">Validator</span> <span class="k">as</span> <span class="n">validator</span>
<span class="kn">from</span> <span class="nn">.._checkparam</span> <span class="kn">import</span> <span class="n">Rel</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Tensor&#39;</span><span class="p">,</span> <span class="s1">&#39;RowTensor&#39;</span><span class="p">,</span> <span class="s1">&#39;SparseTensor&#39;</span><span class="p">,</span> <span class="s1">&#39;CSRTensor&#39;</span><span class="p">]</span>
<span class="n">np_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>


<div class="viewcode-block" id="Tensor"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor">[docs]</a><span class="k">class</span> <span class="nc">Tensor</span><span class="p">(</span><span class="n">Tensor_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor is a data structure that stores an n-dimensional array.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_data (Union[Tensor, float, int, bool, tuple, list, numpy.ndarray]): The data to be stored. It can be</span>
<span class="sd">            another Tensor, Python number or NumPy ndarray. Default: None.</span>
<span class="sd">        dtype (:class:`mindspore.dtype`): Used to indicate the data type of the output Tensor. The argument should</span>
<span class="sd">            be defined in `mindspore.dtype`. If it is None, the data type of the output Tensor will be the same</span>
<span class="sd">            as the `input_data`. Default: None.</span>
<span class="sd">        shape (Union[tuple, list, int]): Used to indicate the shape of the output Tensor. The argument should be</span>
<span class="sd">            a list of integers, a tuple of integers or an integer. If `input_data` is available,</span>
<span class="sd">            `shape` doesn&#39;t need to be set. Default: None.</span>
<span class="sd">        init (Initializer): The information of init data.</span>
<span class="sd">            &#39;init&#39; is used for delayed initialization in parallel mode. Usually, it is not recommended to use</span>
<span class="sd">            &#39;init&#39; interface to initialize Tensor in the other conditions. If &#39;init&#39; interface is used to initialize</span>
<span class="sd">            Tensor, the `Tensor.init_data` API needs to be called to convert `Tensor` to the actual data.</span>
<span class="sd">            Default: None.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common.initializer import One</span>
<span class="sd">        &gt;&gt;&gt; # initialize a tensor with numpy.ndarray</span>
<span class="sd">        &gt;&gt;&gt; t1 = Tensor(np.zeros([1, 2, 3]), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; print(t1)</span>
<span class="sd">        [[[0. 0. 0.]</span>
<span class="sd">        [0. 0. 0.]]]</span>
<span class="sd">        &gt;&gt;&gt; print(type(t1))</span>
<span class="sd">        &lt;class &#39;mindspore.common.tensor.Tensor&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(t1.shape)</span>
<span class="sd">        (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; print(t1.dtype)</span>
<span class="sd">        Float32</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # initialize a tensor with a float scalar</span>
<span class="sd">        &gt;&gt;&gt; t2 = Tensor(0.1)</span>
<span class="sd">        &gt;&gt;&gt; print(t2)</span>
<span class="sd">        0.1</span>
<span class="sd">        &gt;&gt;&gt; print(type(t2))</span>
<span class="sd">        &lt;class &#39;mindspore.common.tensor.Tensor&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(t2.shape)</span>
<span class="sd">        ()</span>
<span class="sd">        &gt;&gt;&gt; print(t2.dtype)</span>
<span class="sd">        Float32</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # initialize a tensor with a tuple</span>
<span class="sd">        &gt;&gt;&gt; t3 = Tensor((1, 2))</span>
<span class="sd">        &gt;&gt;&gt; print(t3)</span>
<span class="sd">        [1 2]</span>
<span class="sd">        &gt;&gt;&gt; print(type(t3))</span>
<span class="sd">        &lt;class &#39;mindspore.common.tensor.Tensor&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(t3.shape)</span>
<span class="sd">        (2,)</span>
<span class="sd">        &gt;&gt;&gt; print(t3.dtype)</span>
<span class="sd">        Int64</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; # initialize a tensor with init</span>
<span class="sd">        &gt;&gt;&gt; t4 = Tensor(shape = (1, 3), dtype=ms.float32, init=One())</span>
<span class="sd">        &gt;&gt;&gt; print(t4)</span>
<span class="sd">        [[1. 1. 1.]]</span>
<span class="sd">        &gt;&gt;&gt; print(type(t4))</span>
<span class="sd">        &lt;class &#39;mindspore.common.tensor.Tensor&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(t4.shape)</span>
<span class="sd">        (1, 3)</span>
<span class="sd">        &gt;&gt;&gt; print(t4.dtype)</span>
<span class="sd">        Float32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># If input data is numpy number, convert it to np array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">np_types</span><span class="p">):</span>
            <span class="n">input_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>

        <span class="n">_check_tensor_input</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">init</span><span class="p">)</span>

        <span class="c1"># If input_data is tuple/list/numpy.ndarray, it&#39;s support in check_type method.</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;input_data&#39;</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span>
                                       <span class="p">(</span><span class="n">Tensor_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">complex</span><span class="p">),</span> <span class="s1">&#39;Tensor&#39;</span><span class="p">)</span>
            <span class="n">valid_dtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">input_data</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_dtypes</span> <span class="ow">and</span> \
                <span class="n">input_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>  <span class="c1"># Support dtype np.str_</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For Tensor, the input_data is a numpy array, &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;but it&#39;s data type: </span><span class="si">{</span><span class="n">input_data</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> is not in supported list: &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="vm">__name__</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">valid_dtypes</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_dtypes</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For Tensor, the input_data is </span><span class="si">{</span><span class="n">input_data</span><span class="si">}</span><span class="s2"> that contain unsupported element.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">validator</span><span class="o">.</span><span class="n">check_type_name</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">number_type</span> <span class="o">+</span> <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">string</span><span class="p">),</span> <span class="s2">&quot;Tensor&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_default_dtype</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">input_data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;FORC&#39;</span><span class="p">]):</span>
                <span class="n">input_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tensor_</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Tensor_</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Tensor_</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">virtual_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># if cur Tensor is a index value of another Tensor,</span>
        <span class="c1"># parent_tensor_ set to another Tensor</span>
        <span class="c1"># index_of_parent_ will set to the index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_tensor_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_of_parent_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_set_default_dtype</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">return</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="p">):</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">virtual_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_flag</span>
        <span class="k">return</span> <span class="n">new_obj</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">PynativeExecutor_</span><span class="o">.</span><span class="n">get_instance</span><span class="p">()</span><span class="o">.</span><span class="n">execute_lazy_task</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span><span class="p">:</span>
            <span class="n">Tensor_</span><span class="o">.</span><span class="n">data_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Tensor_</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># bool type is not supported for `Equal` operator in backend.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__eq__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1">#  bool type is not supported for `NotEqual` operator in backend.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__ne__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__neg__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__logical_not__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The truth value of an array with several elements is ambiguous.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int8&quot;</span>
                <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int16&quot;</span>
                <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int32&quot;</span>
                <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int64&quot;</span>
                <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only integer tensors of a single element can be converted to an index.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only integer tensors of a single element can be converted to an index.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">)(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__mod__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__mod__&#39;</span><span class="p">)(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mod__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__floordiv__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__floordiv__&#39;</span><span class="p">)(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__floordiv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__lt__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__le__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">parent_tensor_</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">out</span><span class="o">.</span><span class="n">index_of_parent_</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__setitem__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_value</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_tensor_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_of_parent_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_tensor_</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_of_parent_</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__gt__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__ge__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not support len of a 0-D tensor&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">type_none</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Unknown Tensor type!&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the tensor as a tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the dtype of the tensor (:class:`mindspore.dtype`).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the total number of elements in tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of tensor dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether tensor is initialized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the length of one tensor element in bytes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_itemsize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">strides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the tuple of bytes to step in each dimension when traversing a tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strides</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the total number of bytes taken by the tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbytes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the transposed tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<div class="viewcode-block" id="Tensor.from_numpy"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.from_numpy">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_numpy</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert numpy array to Tensor without copy data.</span>

<span class="sd">        Args:</span>
<span class="sd">            array (numpy.array): The input array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same data type as input array.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = np.array([1, 2])</span>
<span class="sd">            &gt;&gt;&gt; output = Tensor.from_numpy(x)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [1 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">Tensor_</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">array</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">assign_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">PynativeExecutor_</span><span class="o">.</span><span class="n">get_instance</span><span class="p">()</span><span class="o">.</span><span class="n">execute_lazy_task</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_value_cpp</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Tensor.item"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.item">[docs]</a>    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the item at the specified index of the tensor.</span>

<span class="sd">        Note:</span>
<span class="sd">            Tensor.item returns a Tensor scalar instead of a Python scalar.</span>

<span class="sd">        Args:</span>
<span class="sd">            index (Union[None, int, tuple(int)]): The index in Tensor. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Tensor scalar, dtype is the same with the original Tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the length of the `index` is not equal to self.ndim.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([[1,2,3],[4,5,6]], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; x = x.item((0,1))</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            2.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="Tensor.itemset"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.itemset">[docs]</a>    <span class="k">def</span> <span class="nf">itemset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert scalar into a tensor (scalar is cast to tensor&#39;s dtype, if possible).</span>

<span class="sd">        There must be at least 1 argument, and define the last argument as item.</span>
<span class="sd">        Then, tensor.itemset(\*args) is equivalent to :math:`tensor[args] = item`.</span>

<span class="sd">        Args:</span>
<span class="sd">            args (Union[(numbers.Number), (int/tuple(int), numbers.Number)]): The arguments that</span>
<span class="sd">                specify the index and value. If `args` contain one argument (a scalar),</span>
<span class="sd">                it is only used in case tensor is of size 1. If `args` contain two</span>
<span class="sd">                arguments, the last argument is the value to be set and must be a</span>
<span class="sd">                scalar, the first argument specifies a single tensor element location.</span>
<span class="sd">                It is either an int or a tuple.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new tensor that doesn&#39;t affect the original tensor, with value set by :math:`tensor[args] = item`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the length of the first argument is not equal to self.ndim.</span>
<span class="sd">            IndexError: If only one argument is provided, and the original Tensor is not scalar.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([[1,2,3],[4,5,6]], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(x.itemset((0,1), 4))</span>
<span class="sd">            [[1. 4. 3.]</span>
<span class="sd">            [4. 5. 6.]]</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            [[1. 2. 3.]</span>
<span class="sd">            [4. 5. 6.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;itemset&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="Tensor.asnumpy"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.asnumpy">[docs]</a>    <span class="k">def</span> <span class="nf">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tensor to numpy array. Returns self tensor as a NumPy ndarray. This tensor and the returned ndarray</span>
<span class="sd">        share the same underlying storage. Changes to self tensor will be reflected in the ndarray.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A numpy ndarray which shares the same underlying storage with the tensor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([1, 2], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; y = x.asnumpy()</span>
<span class="sd">            &gt;&gt;&gt; y[0] = 11</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            [11.  2.]</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            [11.  2.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">PynativeExecutor_</span><span class="o">.</span><span class="n">get_instance</span><span class="p">()</span><span class="o">.</span><span class="n">execute_lazy_task</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Tensor_</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.flush_from_cache"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.flush_from_cache">[docs]</a>    <span class="k">def</span> <span class="nf">flush_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flush cache data to host if tensor is cache enable.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([1, 2], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; y = x.flush_from_cache()</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">Tensor_</span><span class="o">.</span><span class="n">_flush_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.all"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.all">[docs]</a>    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(),</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check all tensor elements along a given axis evaluate to True.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Dimensions of reduction.</span>
<span class="sd">                When the axis is None or empty tuple, reduce all dimensions. When the axis is int or</span>
<span class="sd">                tuple(int), if the dimension of Tensor is dim, the value range is [-dim, dim). Default: ().</span>
<span class="sd">            keep_dims (bool): Whether to keep the reduced dimensions. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, if all tensor elements along the given axis evaluate to True, its value is True,</span>
<span class="sd">            otherwise its value is False. If the axis is None or empty tuple, reduce all dimensions.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.any`: Check any tensor element along a given axis evaluate to True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor([True, True, False])</span>
<span class="sd">            &gt;&gt;&gt; output = a.all()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)(</span><span class="n">keep_dims</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.any"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.any">[docs]</a>    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(),</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check any tensor element along a given axis evaluate to True.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Dimensions of reduction.</span>
<span class="sd">                When the axis is None or empty tuple, reduce all dimensions. When the axis is int or</span>
<span class="sd">                tuple(int), if the dimension of Tensor is dim, the value range is [-dim, dim). Default: ().</span>
<span class="sd">            keep_dims (bool): Whether to keep the reduced dimensions. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, if any tensor element along the given axis evaluates to True, its value is True,</span>
<span class="sd">            otherwise its value is False. If the axis is None or empty tuple, reduce all dimensions.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.all`: Check all tensor elements along a given axis evaluate to True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor([True, True, False])</span>
<span class="sd">            &gt;&gt;&gt; output = a.any()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">)(</span><span class="n">keep_dims</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.view"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.view">[docs]</a>    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reshape the tensor according to the input shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            shape (Union[tuple(int), int]): Dimension of the output tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same dimension as the input shape.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.array([[1, 2, 3], [2, 3, 4]], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = a.view((3, 2))</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[1. 2.]</span>
<span class="sd">            [3. 2.]</span>
<span class="sd">            [3. 4.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape variable should not be empty&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only one tuple is needed, but got </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.expand_as"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.expand_as">[docs]</a>    <span class="k">def</span> <span class="nf">expand_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the dimension of target tensor to the dimension of input tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (Tensor): The input tensor. The shape of the input tensor must obey</span>
<span class="sd">                the broadcasting rule.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same dimension as input tensor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor([1, 2, 3], dtype=mstype.float32)</span>
<span class="sd">            &gt;&gt;&gt; y = Tensor(np.ones((2, 3)), dtype=mstype.float32)</span>
<span class="sd">            &gt;&gt;&gt; output = x.expand_as(y)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[1. 2. 3.]</span>
<span class="sd">            [1. 2. 3.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.abs"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.abs">[docs]</a>    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return absolute value element-wisely.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor([1.1, -2.1]).astype(&quot;float32&quot;)</span>
<span class="sd">            &gt;&gt;&gt; output = a.abs()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [1.1 2.1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;abs&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.mean"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(),</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce a dimension of a tensor by averaging all elements in the dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int), list(int)]): Dimensions of reduction.</span>
<span class="sd">                When the axis is None or empty tuple, reduce all dimensions. When the axis is int, tuple(int) or</span>
<span class="sd">                list(int), if the dimension of Tensor is dim, the value range is [-dim, dim). Default: ().</span>
<span class="sd">            keep_dims (bool): Whether to keep the reduced dimensions. Default: False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same data type as input tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.std`: Compute the standard deviation along the specified axis.</span>

<span class="sd">            :func:`mindspore.Tensor.var`: Compute the variance along the specified axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.array([1, 2, 3], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = input_x.mean()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)(</span><span class="n">keep_dims</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.transpose"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tensor with axes transposed.</span>

<span class="sd">        - For a 1-D tensor, this has no effect, as a transposed vector is simply the same vector.</span>
<span class="sd">        - For a 2-D tensor, this is a standard matrix transpose.</span>
<span class="sd">        - For an n-D tensor, if axes are given, their order indicates how the axes are permuted.</span>

<span class="sd">        If axes are not provided and ``tensor.shape = (i[0], i[1],...i[n-2], i[n-1])``,</span>
<span class="sd">        then ``tensor.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.</span>

<span class="sd">        Args:</span>
<span class="sd">            axes(Union[None, tuple(int), list(int), int], optional): If axes is None or</span>
<span class="sd">                blank, the method will reverse the order of the axes. If axes is tuple(int)</span>
<span class="sd">                or list(int), tensor.transpose() will transpose the tensor to the new axes order.</span>
<span class="sd">                If axes is int, this form is simply intended as a convenience alternative to the</span>
<span class="sd">                tuple/list form.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same dimension as input tensor, with axes suitably permuted.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input arguments have types not specified above.</span>
<span class="sd">            ValueError: If the number of `axes` is not equal to Tensor&#39;s ndim.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((1,2,3), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; x = x.transpose()</span>
<span class="sd">            &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">            (3, 2, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_transpose_axis</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transpose&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.reshape"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.reshape">[docs]</a>    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a new shape to a tensor without changing its data.</span>

<span class="sd">        Args:</span>
<span class="sd">            shape(Union[int, tuple(int), list(int)]): The new shape should be compatible</span>
<span class="sd">                with the original shape. If an integer, then the result will be a 1-D</span>
<span class="sd">                tensor of that length. One shape dimension can be -1. In this case, the</span>
<span class="sd">                value is inferred from the length of the tensor and remaining dimensions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with new specified shape.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If new shape is not integer, list or tuple.</span>
<span class="sd">            ValueError: If new shape is not compatible with the original shape.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor([[-0.1, 0.3, 3.6], [0.4, 0.5, -3.2]], dtype=mstype.float32)</span>
<span class="sd">            &gt;&gt;&gt; output = x.reshape((3, 2))</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[-0.1  0.3]</span>
<span class="sd">            [ 3.6  0.4]</span>
<span class="sd">            [ 0.5 -3.2]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_reshape_shp</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.ravel"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.ravel">[docs]</a>    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a contiguous flattened tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, a 1-D tensor, containing the same elements of the input.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.reshape`: Give a new shape to a tensor without changing its data.</span>

<span class="sd">            :func:`mindspore.Tensor.flatten`: Return a copy of the tensor collapsed into one dimension.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((2,3,4), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = x.ravel()</span>
<span class="sd">            &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">            (24,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">reshape_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()</span>
        <span class="k">return</span> <span class="n">reshape_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span></div>

<div class="viewcode-block" id="Tensor.flatten"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the tensor collapsed into one dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            order (str, optional): Can choose between &#39;C&#39; and &#39;F&#39;. &#39;C&#39; means to</span>
<span class="sd">                flatten in row-major (C-style) order. &#39;F&#39; means to flatten in column-major</span>
<span class="sd">                (Fortran-style) order. Default: &#39;C&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same data type as input.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `order` is not string type.</span>
<span class="sd">            ValueError: If `order` is string type, but not &#39;C&#39; or &#39;F&#39;.</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.reshape`: Give a new shape to a tensor without changing its data.</span>

<span class="sd">            :func:`mindspore.Tensor.ravel`: Return a contiguous flattened tensor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((2,3,4), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = x.flatten()</span>
<span class="sd">            &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">            (24,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">reshape_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()</span>
        <span class="n">trans_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transpose&#39;</span><span class="p">)()</span>

        <span class="n">order</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_flatten_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reshape_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">reshape_op</span><span class="p">(</span><span class="n">trans_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span></div>

<div class="viewcode-block" id="Tensor.narrow"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.narrow">[docs]</a>    <span class="k">def</span> <span class="nf">narrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a narrowed tensor from input tensor.</span>
<span class="sd">        The dimension axis is input from start to start + length.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int): the axis along which to narrow.</span>
<span class="sd">            start (int): the starting dimension.</span>
<span class="sd">            length (int): the distance to the ending dimension.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor.</span>

<span class="sd">            - output (Tensors) - The narrowed tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If the input is not a tensor or tuple or list of tensors.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], mindspore.int32)</span>
<span class="sd">            &gt;&gt;&gt; output = x.narrow(0, 0, 2)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[ 1 2 3]</span>
<span class="sd">             [ 4 5 6]]</span>
<span class="sd">            &gt;&gt;&gt; output = x.narrow(1, 1, 2)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[ 2 3]</span>
<span class="sd">             [ 5 6]</span>
<span class="sd">             [ 8 9]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;narrow&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.swapaxes"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.swapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interchange two axes of a tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis1 (int): First axis.</span>
<span class="sd">            axis2 (int): Second axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Transposed tensor, has the same data type as the input.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `axis1` or `axis2` is not integer.</span>
<span class="sd">            ValueError: If `axis1` or `axis2` is not in the range of :math:`[-ndim, ndim-1]`.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((2,3,4), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = x.swapaxes(0, 2)</span>
<span class="sd">            &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">            (4,3,2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_swapaxes_axis</span><span class="p">((</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis1</span> <span class="o">==</span> <span class="n">axis2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">axis1</span> <span class="o">&gt;</span> <span class="n">axis2</span><span class="p">:</span>
            <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span> <span class="o">=</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">axis1</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">axis2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">new_perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">axis1</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">:</span><span class="n">axis2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">axis2</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">:</span><span class="n">axis1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">axis1</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">:</span><span class="n">axis2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">axis2</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">:</span><span class="n">axis1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transpose&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_perm</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.squeeze"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.squeeze">[docs]</a>    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the dimension of shape 1 from the Tensor</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, list(int), tuple(int)], optional): Selects a subset of the entries of</span>
<span class="sd">                length one in the shape. If an axis is selected with shape entry greater than one,</span>
<span class="sd">                an error is raised. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with all or a subset of the dimensions of length 1 removed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input arguments have types not specified above.</span>
<span class="sd">            ValueError: If axis is greater than one.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.expand_as`: Expand the dimension of target tensor to the dimension of input tensor.</span>

<span class="sd">            :func:`mindspore.Tensor.reshape`: Give a new shape to a tensor without changing its data.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((1,2,2), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            [[[1. 1.]</span>
<span class="sd">            [1. 1.]]]</span>
<span class="sd">            &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">            (1, 2, 2)</span>
<span class="sd">            &gt;&gt;&gt; y = x.squeeze()</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">            [1. 1.]]</span>
<span class="sd">            &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">            (2, 2)</span>
<span class="sd">            &gt;&gt;&gt; y = x.squeeze(axis=0)</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">            [1. 1.]]</span>
<span class="sd">            &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">            (2, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;squeeze&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">prepare_shape_for_squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">)()(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.expand_dims"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.expand_dims">[docs]</a>    <span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a dimension of shape 1 at the specified axis of Tensor</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int): the axis at which to insert the singleton dimension.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with inserted dimension of length 1.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If axis is not an int.</span>
<span class="sd">            ValueError: If axis is not in range [-self.ndim - 1, self.ndim + 1).</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((2,2), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(x)</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">            [1. 1.]]</span>
<span class="sd">            &gt;&gt;&gt; print(x.shape)</span>
<span class="sd">            (2, 2)</span>
<span class="sd">            &gt;&gt;&gt; y = x.expand_dims(axis=0)</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            [[[1. 1.]</span>
<span class="sd">            [1. 1.]]]</span>
<span class="sd">            &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">            (1, 2, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_is_int</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">)</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_int_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Rel</span><span class="o">.</span><span class="n">INC_LEFT</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;expand_dims&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.astype"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the tensor, cast to a specified type.</span>

<span class="sd">        Args:</span>
<span class="sd">            dtype (Union[:class:`mindspore.dtype`, str]): Designated tensor dtype, can be in format</span>
<span class="sd">                of :class:`mindspore.dtype.float32` or `float32`.</span>
<span class="sd">            copy (bool, optional): By default, astype always returns a newly allocated</span>
<span class="sd">                tensor. If this is set to false, the input tensor is returned instead</span>
<span class="sd">                of a copy. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with the designated dtype.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If the specified dtype cannot be understood.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.ones((1,2,2,1), dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; x = x.astype(&quot;int32&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(x.dtype)</span>
<span class="sd">            Int32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_check</span><span class="p">()</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_astype_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cast&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.argmax"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.argmax">[docs]</a>    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of the maximum values along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int, optional): By default, the index is into</span>
<span class="sd">                the flattened tensor, otherwise along the specified axis. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, indices into the input tensor. It has the same</span>
<span class="sd">            shape as self.shape with the dimension along axis removed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the axis is out of range.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.argmin`: Return the indices of the minimum values along an axis.</span>

<span class="sd">            :func:`mindspore.Tensor.min`: Return the minimum of a tensor or minimum along an axis.</span>

<span class="sd">            :func:`mindspore.Tensor.max`: Return the maximum of a tensor or maximum along an axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(10, 16).reshape(2, 3).astype(&quot;float32&quot;))</span>
<span class="sd">            &gt;&gt;&gt; print(a.argmax())</span>
<span class="sd">            5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># P.Argmax only supports float</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;argmax&#39;</span><span class="p">)(</span><span class="n">axis</span><span class="p">)(</span><span class="n">a</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.argmin"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.argmin">[docs]</a>    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of the minimum values along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int, optional): By default, the index is into</span>
<span class="sd">                the flattened tensor, otherwise along the specified axis. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, indices into the input tensor. It has the same</span>
<span class="sd">            shape as self.shape with the dimension along axis removed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the axis is out of range.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.argmax`: Return the indices of the maximum values along an axis.</span>

<span class="sd">            :func:`mindspore.Tensor.min`: Return the minimum of a tensor or minimum along an axis.</span>

<span class="sd">            :func:`mindspore.Tensor.max`: Return the maximum of a tensor or maximum along an axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(10, 16).reshape(2, 3).astype(&quot;float32&quot;))</span>
<span class="sd">            &gt;&gt;&gt; print(a.argmin())</span>
<span class="sd">            0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># P.Argmin only supports float</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="c1"># P.Argmin is currently not supported</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;argmax&#39;</span><span class="p">)(</span><span class="n">axis</span><span class="p">)(</span><span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__neg__&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">))</span></div>

<div class="viewcode-block" id="Tensor.cumsum"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.cumsum">[docs]</a>    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative sum of the elements along a given axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            If ``self.dtype`` is :class:`int8`, :class:`int16` or :class:`bool`, the result</span>
<span class="sd">            `dtype` will be elevated to :class:`int32`, :class:`int64` is not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int, optional): Axis along which the cumulative sum is computed. The</span>
<span class="sd">                default (None) is to compute the cumsum over the flattened array.</span>
<span class="sd">            dtype (:class:`mindspore.dtype`, optional): If not specified, stay the same as original</span>
<span class="sd">                tensor, unless it has an integer dtype with a precision less than :class:`float32`.</span>
<span class="sd">                In that case, :class:`float32` is used. Default: None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the axis is out of range.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.sum`: Return sum of tensor elements over a given axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.ones((3,3)).astype(&quot;float32&quot;))</span>
<span class="sd">            &gt;&gt;&gt; output = a.cumsum(axis=0)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[1. 1. 1.]</span>
<span class="sd">            [2. 2. 2.]</span>
<span class="sd">            [3. 3. 3.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">original_dtype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># If original tensor is int, and has precision less then int32, convert to int32</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int16</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">original_dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cumsum&#39;</span><span class="p">)()(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cumsum&#39;</span><span class="p">)()(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.copy"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the tensor.</span>

<span class="sd">        Note:</span>
<span class="sd">            The current implementation does not support `order` argument.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Copied tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.ones((3,3)).astype(&quot;float32&quot;))</span>
<span class="sd">            &gt;&gt;&gt; output = a.copy()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [[1. 1. 1.]</span>
<span class="sd">            [1. 1. 1.]</span>
<span class="sd">            [1. 1. 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">origin_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">logical_not_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;logical_not&#39;</span><span class="p">)()</span>
        <span class="k">if</span> <span class="n">origin_dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">logical_not_op</span><span class="p">(</span><span class="n">logical_not_op</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">origin_dtype</span> <span class="o">!=</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mf">1.0</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">origin_dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="Tensor.max"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum of a tensor or maximum along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple of ints], optional): Axis or</span>
<span class="sd">                axes along which to operate. By default, flattened input is used. If</span>
<span class="sd">                this is a tuple of ints, the maximum is selected over multiple axes,</span>
<span class="sd">                instead of a single axis or all the axes as before. Default: None.</span>
<span class="sd">            keepdims (bool, optional):</span>
<span class="sd">                If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">                result as dimensions with size one. With this option, the result will</span>
<span class="sd">                broadcast correctly against the input array. Default: False.</span>
<span class="sd">            initial (scalar, optional):</span>
<span class="sd">                The minimum value of an output element. Must be present to allow</span>
<span class="sd">                computation on empty slice. Default: None.</span>
<span class="sd">            where (bool Tensor, optional):</span>
<span class="sd">                A boolean tensor which is broadcasted to match the dimensions of array,</span>
<span class="sd">                and selects elements to include in the reduction. If non-default value</span>
<span class="sd">                is passed, initial must also be provided. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor or scalar, maximum of input tensor. If `axis` is None, the result is a scalar</span>
<span class="sd">            value. If `axis` is given, the result is a tensor of dimension ``self.ndim - 1``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If arguments have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.argmin`: Return the indices of the minimum values along an axis.</span>

<span class="sd">            :func:`mindspore.Tensor.argmax`: Return the indices of the maximum values along an axis.</span>

<span class="sd">            :func:`mindspore.Tensor.min`: Return the minimum of a tensor or minimum along an axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4).reshape((2, 2)).astype(&#39;float32&#39;))</span>
<span class="sd">            &gt;&gt;&gt; output = a.max()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reduce_</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduce&quot;</span><span class="p">)</span>
        <span class="n">reduce_max</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduce_max&quot;</span><span class="p">)</span>
        <span class="n">maximum</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;maximum&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduce_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduce_max</span><span class="p">(</span><span class="n">keepdims</span><span class="p">),</span> <span class="n">cmp_fn</span><span class="o">=</span><span class="n">maximum</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                       <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.min"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum of a tensor or minimum along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple of ints], optional): Axis or</span>
<span class="sd">                axes along which to operate. By default, flattened input is used. If</span>
<span class="sd">                this is a tuple of ints, the minimum is selected over multiple axes,</span>
<span class="sd">                instead of a single axis or all the axes as before. Default: None.</span>
<span class="sd">            keepdims (bool, optional):</span>
<span class="sd">                If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">                result as dimensions with size one. With this option, the result will</span>
<span class="sd">                broadcast correctly against the input tensor. Default: False.</span>
<span class="sd">            initial (scalar, optional):</span>
<span class="sd">                The maximum value of an output element. Must be present to allow</span>
<span class="sd">                computation on empty slice. Default: None.</span>
<span class="sd">            where (bool Tensor, optional):</span>
<span class="sd">                A boolean tensor which is broadcasted to match the dimensions of tensor,</span>
<span class="sd">                and selects elements to include in the reduction. If non-default value</span>
<span class="sd">                is passed, initial must also be provided. Default: True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor or scalar, minimum of input tensor. If the axis is None, the result is a scalar</span>
<span class="sd">            value. If `axis` is given, the result is a tensor of dimension ``self.ndim - 1``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If arguments have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.argmin`: Return the indices of the minimum values along an axis.</span>

<span class="sd">            :func:`mindspore.Tensor.argmax`: Return the indices of the maximum values along an axis.</span>

<span class="sd">            :func:`mindspore.Tensor.max`: Return the maximum of a tensor or maximum along an axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.numpy as np</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4).reshape((2,2)).astype(&#39;float32&#39;))</span>
<span class="sd">            &gt;&gt;&gt; output = a.min()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reduce_</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduce&quot;</span><span class="p">)</span>
        <span class="n">reduce_min</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduce_min&quot;</span><span class="p">)</span>
        <span class="n">minimum</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;minimum&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduce_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduce_min</span><span class="p">(</span><span class="n">keepdims</span><span class="p">),</span> <span class="n">cmp_fn</span><span class="o">=</span><span class="n">minimum</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                       <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.fill"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.fill">[docs]</a>    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill the tensor with a scalar value.</span>

<span class="sd">        Note:</span>
<span class="sd">            Unlike Numpy, tensor.fill() will always return a new tensor, instead of</span>
<span class="sd">            filling the original tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            value (Union[None, int, float, bool]): All elements of a will be assigned this value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, with the original dtype and shape.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input arguments have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4).reshape((2,2)).astype(&#39;float32&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(a.fill(1.0))</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">            [1. 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.fill&#39;, if the argument &#39;value&#39; is None, the type of the original &quot;</span>
                                <span class="s2">&quot;tensor must be float, but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tile&quot;</span><span class="p">)()(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.fill&#39;, the type of the argument &#39;value&#39; must be int, float or bool, &quot;</span>
                            <span class="s2">&quot;but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fill&quot;</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.masked_fill"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.masked_fill">[docs]</a>    <span class="k">def</span> <span class="nf">masked_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills elements of self tensor with value where mask is True.</span>
<span class="sd">        The shape of mask must be equal to the shape of the underlying tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            mask (Tensor[bool]): The boolean mask.</span>
<span class="sd">            value (Union[int, float]): The value to fill in with, which only supports a float or an int number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same type and shape as self.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If mask is not a tensor.</span>
<span class="sd">            TypeError: If mask is not bool.</span>
<span class="sd">            TypeError: If value is neither int nor float number.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4)).astype(&#39;float32&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(a)</span>
<span class="sd">            [0. 1. 2. 3.]</span>
<span class="sd">            &gt;&gt;&gt; mask = Tensor([False, False, True, True])</span>
<span class="sd">            &gt;&gt;&gt; print(a.masked_fill(mask, 0.0))</span>
<span class="sd">            [0. 1. 0. 0.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.masked_fill&#39;, the type of the argument &#39;mask&#39; must be Tensor, but &quot;</span>
                            <span class="s2">&quot;got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">)))</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_type_name</span><span class="p">(</span><span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span><span class="p">],</span> <span class="s2">&quot;Tensor&quot;</span><span class="p">)</span>
        <span class="n">mask_shape</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">infer_out_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">mask_shape</span><span class="p">)(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="s2">&quot;Tensor&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;masked_fill&quot;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.ptp"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.ptp">[docs]</a>    <span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the function comes from the acronym for &quot;peak to peak&quot;.</span>

<span class="sd">        Note:</span>
<span class="sd">            Numpy argument `out` is not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Axis or axes along which the range is computed.</span>
<span class="sd">                The default is to compute the variance of the flattened tensor. Default: None.</span>
<span class="sd">            keepdims (bool): If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">                dimensions with size one. With this option, the result will broadcast correctly against the tensor.</span>
<span class="sd">                Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `self` is not a tensor, or `axis` and `keepdims` have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor([[4.0, 9.0, 2.0, 10.0], [6.0, 9.0, 7.0, 12.0]]).astype(&quot;float32&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(x.ptp(axis=1))</span>
<span class="sd">            [8. 6.]</span>
<span class="sd">            &gt;&gt;&gt; print(x.ptp(axis=0))</span>
<span class="sd">            [2. 0. 5. 2.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keepdims</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.ptp&#39;, the type of the argument &#39;keepdims&#39; must be bool, &quot;</span>
                            <span class="s2">&quot;but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">keepdims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_type</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_valid</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.clip"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clips (limits) the values in a Tensor.</span>

<span class="sd">        Given an interval, values outside the interval are clipped to the interval edges.</span>
<span class="sd">        For example, if an interval of :math:`[0, 1]` is specified, values smaller than 0 become 0,</span>
<span class="sd">        and values larger than 1 become 1.</span>

<span class="sd">        Note:</span>
<span class="sd">            Currently, clip with `xmin=nan` or `xmax=nan` is not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            xmin (Tensor, scalar, None): Minimum value. If None, clipping is not performed</span>
<span class="sd">                on the lower interval edge. Not more than one of `xmin` and `xmax` may be None.</span>
<span class="sd">            xmax (Tensor, scalar, None): Maximum value. If None, clipping is not performed</span>
<span class="sd">                on the upper interval edge. Not more than one of `xmin` and `xmax` may be None.</span>
<span class="sd">                If `xmin` or `xmax` are tensors, then `xmin`, `xmax` and the given tensor</span>
<span class="sd">                will be broadcasted to match their shapes.</span>
<span class="sd">            dtype (:class:`mindspore.dtype`, optional): Overrides the dtype of the</span>
<span class="sd">                output Tensor. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, a tensor with the elements of the input tensor, but where values</span>
<span class="sd">            &lt; `xmin` are replaced with `xmin`, and those &gt; `xmax` with `xmax`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If inputs have types not specified above.</span>
<span class="sd">            ValueError: If the shapes of `x1` and `x2` cannot broadcast, or both `xmin` and `xmax` are `None`.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor([1, 2, 3, -4, 0, 3, 2, 0]).astype(&quot;float32&quot;)</span>
<span class="sd">            &gt;&gt;&gt; y = x.clip(0, 2)</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            [1. 2. 2. 0. 0. 2. 2. 0.]</span>
<span class="sd">            &gt;&gt;&gt; t = Tensor([1, 1, 1, 1, 1, 1, 1, 1])</span>
<span class="sd">            &gt;&gt;&gt; y = x.clip(t, 2)</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            [1. 2. 2. 1. 1. 2. 2. 1.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.clip&#39;, the argument &#39;xmin&#39; and &#39;xman&#39; cannot all be None.&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># F.maximum/minimum does not support when both operands are scalar</span>
        <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">xmin</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;maximum&quot;</span><span class="p">)()(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;maximum&quot;</span><span class="p">)()(</span><span class="n">x</span><span class="p">,</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">xmax</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;minimum&quot;</span><span class="p">)()(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">xmax</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;minimum&quot;</span><span class="p">)()(</span><span class="n">x</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

    <span class="k">def</span> <span class="nf">_init_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_data</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Tensor.init_data"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.init_data">[docs]</a>    <span class="k">def</span> <span class="nf">init_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opt_shard_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the tensor format data of this Tensor.</span>
<span class="sd">        The init_data function can be called once for the same tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            slice_index (int): Slice index of a parameter&#39;s slices.</span>
<span class="sd">                It is used when initialize a slice of a parameter, it guarantees that devices</span>
<span class="sd">                using the same slice can generate the same tensor. Default: None.</span>
<span class="sd">            shape (list[int]): Shape of the slice, it is used when initialize a slice of the parameter. Default: None.</span>
<span class="sd">            opt_shard_group(str): Optimizer shard group which is used in auto or semi auto parallel mode</span>
<span class="sd">                to get one shard of a parameter&#39;s slice. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Initialized Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.common.initializer as init</span>
<span class="sd">            &gt;&gt;&gt; x = init.initializer(init.Constant(1), [2, 2], ms.float32)</span>
<span class="sd">            &gt;&gt;&gt; out = x.init_data()</span>
<span class="sd">            &gt;&gt;&gt; print(out)</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">             [1. 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;init_data must be set Tensor.init, init can&#39;t be None&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">dtype_to_nptype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">seed_context</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Set and restore seed.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">init</span>
                <span class="kn">from</span> <span class="nn">.seed</span> <span class="kn">import</span> <span class="n">get_seed</span>
                <span class="n">global_seed</span> <span class="o">=</span> <span class="n">get_seed</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_np_seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">get_state</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">need_set_seed</span> <span class="o">=</span> <span class="p">((</span><span class="n">slice_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">global_seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span>

            <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">need_set_seed</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">seed</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">slice_index</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">slice_index</span>

            <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">need_set_seed</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_np_seed</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span>

        <span class="k">with</span> <span class="n">seed_context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opt_shard_group</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">get_rank</span><span class="p">(</span><span class="n">opt_shard_group</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">get_group_size</span><span class="p">(</span><span class="n">opt_shard_group</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">)[</span><span class="n">rank</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_value</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Tensor.to_tensor"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.to_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">to_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opt_shard_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return init_data() and get the tensor format data of this Tensor.</span>

<span class="sd">        Note:</span>
<span class="sd">            The usage of `to_tensor` is deprecated. Please use `init_data`.</span>

<span class="sd">        Args:</span>
<span class="sd">            slice_index (int): Slice index of a parameter&#39;s slices.</span>
<span class="sd">                It is used when initialize a slice of a parameter, it guarantees that devices</span>
<span class="sd">                using the same slice can generate the same tensor. Default: None.</span>
<span class="sd">            shape (list[int]): Shape of the slice, it is used when initialize a slice of the parameter. Default: None.</span>
<span class="sd">            opt_shard_group(str): Optimizer shard group which is used in auto or semi auto parallel mode</span>
<span class="sd">                to get one shard of a parameter&#39;s slice. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Initialized Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">            &gt;&gt;&gt; import mindspore.common.initializer as init</span>
<span class="sd">            &gt;&gt;&gt; x = init.initializer(init.Constant(1), [2, 2], ms.float32)</span>
<span class="sd">            &gt;&gt;&gt; out = x.to_tensor()</span>
<span class="sd">            &gt;&gt;&gt; print(out)</span>
<span class="sd">            [[1. 1.]</span>
<span class="sd">             [1. 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARN_DEPRECATED: The usage of to_tensor is deprecated.&quot;</span>
                       <span class="s2">&quot; Please use init_data&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_data</span><span class="p">(</span><span class="n">slice_index</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">opt_shard_group</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.resize"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes shape and size of tensor in-place.</span>

<span class="sd">        If the shape of the new tensor is larger than the shape of the original tensor, the new tensor will be filled</span>
<span class="sd">        with 0. And if the shape of the new tensor is smaller than the shape of the original tensor, the new tensor is</span>
<span class="sd">        filled with the elements of the original tensor in order.</span>

<span class="sd">        Note:</span>
<span class="sd">            Instead of changing the size of the input tensor and returns nothing as in numpy,</span>
<span class="sd">            this method returns a new Tensor with the input size.</span>
<span class="sd">            Numpy argument `refcheck` is not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_shape (Union[ints, tuple of ints]): Shape of resized tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.reshape`: Give a new shape to a tensor without changing its data.</span>

<span class="sd">            :func:`mindspore.Tensor.repeat`: Repeat elements of a tensor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([[1, 2, 3], [4, 5, 6]], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; y = x.resize(3, 3)</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            [[1. 2. 3.]</span>
<span class="sd">            [4. 5. 6.]</span>
<span class="sd">            [0. 0. 0.]]</span>
<span class="sd">            &gt;&gt;&gt; y = x.resize(2, 2)</span>
<span class="sd">            &gt;&gt;&gt; print(y)</span>
<span class="sd">            [[1. 2.]</span>
<span class="sd">            [3. 4.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">flattened</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">cur_size</span> <span class="o">=</span> <span class="n">flattened</span><span class="o">.</span><span class="n">size</span>
        <span class="n">new_size</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape_mul&#39;</span><span class="p">)(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="n">diff_size</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">-</span> <span class="n">cur_size</span>
        <span class="k">if</span> <span class="n">diff_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pad_val</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">diff_size</span><span class="p">,),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">)((</span><span class="n">flattened</span><span class="p">,</span> <span class="n">pad_val</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">flattened</span><span class="p">[:</span><span class="n">new_size</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.diagonal"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return specified diagonals.</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (int, optional): Offset of the diagonal from the main diagonal.</span>
<span class="sd">                Can be positive or negative. Defaults to main diagonal.</span>
<span class="sd">            axis1 (int, optional): Axis to be used as the first axis of the 2-D</span>
<span class="sd">                sub-arrays from which the diagonals should be taken. Defaults to</span>
<span class="sd">                first axis (0).</span>
<span class="sd">            axis2 (int, optional): Axis to be used as the second axis of the 2-D</span>
<span class="sd">                sub-arrays from which the diagonals should be taken. Defaults to</span>
<span class="sd">                second axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, if Tensor is 2-D, return a 1-D Tensor containing the diagonal.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input tensor has less than two dimensions.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.trace`: Return the sum along diagonals of the tensor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.arange(4).reshape(2, 2))</span>
<span class="sd">            &gt;&gt;&gt; print(a)</span>
<span class="sd">            [[0 1]</span>
<span class="sd">            [2 3]]</span>
<span class="sd">            &gt;&gt;&gt; output = a.diagonal()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [0 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.diagonal&#39;, the original tensor requires at least two dimensions, &quot;</span>
                             <span class="s2">&quot;but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_valid</span><span class="p">((</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">),</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">perm</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span>
        <span class="n">perm</span> <span class="o">+=</span> <span class="n">axes</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;eye&#39;</span><span class="p">)(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">offset</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">n</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">e_left</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">e_right</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="o">-</span><span class="n">offset</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="mi">1</span><span class="p">)((</span><span class="n">e_left</span><span class="p">,</span> <span class="n">e_right</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">e_upper</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">e_lower</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">offset</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">)((</span><span class="n">e_upper</span><span class="p">,</span> <span class="n">e_lower</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">shape</span><span class="p">)(</span><span class="n">e</span><span class="p">)</span>

        <span class="n">prod</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reduce_sum&#39;</span><span class="p">)(</span><span class="n">prod</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">begin</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">begin</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="n">last_dim_begin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">begin</span> <span class="o">+=</span> <span class="p">(</span><span class="n">last_dim_begin</span><span class="p">,)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">last_dim_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">))</span> <span class="o">-</span> <span class="n">last_dim_begin</span>
        <span class="k">if</span> <span class="n">last_dim_end</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">([])</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="p">(</span><span class="n">last_dim_end</span><span class="p">,)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tensor_slice&#39;</span><span class="p">)(</span><span class="n">res</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.trace"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sum along diagonals of the tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (int, optional): Offset of the diagonal from the main diagonal.</span>
<span class="sd">                Can be positive or negative. Defaults to main diagonal.</span>
<span class="sd">            axis1 (int, optional): Axis to be used as the first axis of the 2-D</span>
<span class="sd">                sub-arrays from which the diagonals should be taken. Defaults to</span>
<span class="sd">                first axis (0).</span>
<span class="sd">            axis2 (int, optional): Axis to be used as the second axis of the 2-D</span>
<span class="sd">                sub-arrays from which the diagonals should be taken. Defaults to</span>
<span class="sd">                second axis.</span>
<span class="sd">            dtype (:class:`mindspore.dtype`, optional): defaults to None. Overrides the dtype of the</span>
<span class="sd">                output Tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, the sum along diagonals.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input tensor has less than two dimensions.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.diagonal`: Return specified diagonals.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.eye(3, dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(x.trace())</span>
<span class="sd">            3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reduce_sum&#39;</span><span class="p">)(</span><span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.take"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.take">[docs]</a>    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes elements from a tensor along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices (Tensor): The indices with shape `(Nj...)` of the values to extract.</span>
<span class="sd">            axis (int, optional): The axis over which to select values. By default,</span>
<span class="sd">                the flattened input tensor is used. Default: `None`.</span>
<span class="sd">            mode (&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;, optional): Default: &quot;clip&quot;.</span>

<span class="sd">                &#39;raise&#39; â€“ Raises an error;</span>

<span class="sd">                &#39;wrap&#39; â€“ Wraps around;</span>

<span class="sd">                &#39;clip&#39; â€“ Clips to the range. &#39;clip&#39; mode means that all indices that are</span>
<span class="sd">                too large are replaced by the index that addresses the last element</span>
<span class="sd">                along that axis. Note that this disables indexing with negative numbers.</span>

<span class="sd">                Default: &#39;clip&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, the indexed result.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `axis` is out of range, or `mode` has values other than (&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;)</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; a = Tensor(np.array([4, 3, 5, 7, 6, 8]))</span>
<span class="sd">            &gt;&gt;&gt; indices = Tensor(np.array([0, 1, 4]))</span>
<span class="sd">            &gt;&gt;&gt; output = a.take(indices)</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            [4 3 6]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="s1">&#39;clip&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;Tensor.take&#39;, the argument &#39;mode&#39; should be one of in [&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;],&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; but got </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="n">ndim</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span>

        <span class="n">shape_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">shape_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">size_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check_indices&#39;</span><span class="p">)(</span><span class="n">shape_a</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">indices</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="c1"># reshapes indices to shape (Ni..., Nj..., Nk)</span>
        <span class="n">shape_ni</span> <span class="o">=</span> <span class="n">shape_a</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">shape_nk</span> <span class="o">=</span> <span class="n">shape_a</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">shape_out</span> <span class="o">=</span> <span class="n">shape_ni</span> <span class="o">+</span> <span class="n">shape_indices</span> <span class="o">+</span> <span class="n">shape_nk</span>
        <span class="n">shape_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">size_indices</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_indices</span><span class="p">)</span>
        <span class="n">shape_indices</span> <span class="o">=</span> <span class="n">shape_ni</span> <span class="o">+</span> <span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape_nk</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">shape_indices</span><span class="p">)(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gather_d&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_out</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.choose"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.choose">[docs]</a>    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a tensor from an index tensor and a list of tensors to choose from.</span>

<span class="sd">        Args:</span>
<span class="sd">            choices (Union[tuple, list, Tensor]): Choice tensors. The input tensor and all of the</span>
<span class="sd">                `choices` must be broadcasted to the same shape. If `choices` is itself a tensor,</span>
<span class="sd">                then its outermost dimension (i.e., the one corresponding to ``choices.shape[0]``)</span>
<span class="sd">                is taken as defining the &quot;sequence&quot;.</span>
<span class="sd">            mode (&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;, optional): Specifies how indices outside</span>
<span class="sd">                ``[0, n-1]`` will be treated:</span>

<span class="sd">                &#39;raise&#39; â€“ Raises an error;</span>

<span class="sd">                &#39;wrap&#39; â€“ Wraps around;</span>

<span class="sd">                &#39;clip&#39; â€“ Clips to the range. &#39;clip&#39; mode means that values greater than n-1 are mapped to n-1.</span>
<span class="sd">                Note that this disables indexing with negative numbers.</span>

<span class="sd">                Default: &#39;clip&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, the merged result.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input tensor and any of the `choices` cannot be broadcast.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; choices = [[0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33]]</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([2, 3, 1, 0]))</span>
<span class="sd">            &gt;&gt;&gt; print(x.choose(choices))</span>
<span class="sd">            [20 31 12  3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">shape_choice</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">infer_out_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">choices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)((</span><span class="n">choices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">shape_choice</span><span class="p">)(</span><span class="n">choices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># broadcasts choices to the same shape if choices is a sequence</span>
            <span class="n">choicelist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">choice</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">choice</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_tensor&#39;</span><span class="p">)(</span><span class="n">choice</span><span class="p">)</span>
                <span class="n">shapes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">choice</span><span class="o">.</span><span class="n">shape</span><span class="p">,)</span>
                <span class="n">choicelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
            <span class="n">shape_choice</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">infer_out_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">shapes</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choicelist</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">shape_choice</span><span class="p">)(</span><span class="n">choice</span><span class="p">))</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stack&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">)(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">choices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;Tensor.choose&#39;, the original tensor and the argument &#39;choices&#39; cannot be scalars.&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; Their dimensions should all be &gt; 0, but got the original tensor&#39;s dimension &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">, &#39;choices&#39; dimension </span><span class="si">{</span><span class="n">choices</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">shape_choice</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">choices</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># adjusts dtype for F.tensor_mul and F.gather_nd</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check_indices&#39;</span><span class="p">)(</span><span class="n">choices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">allow_negative_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">grids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
            <span class="n">dim_grid</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">dim_shape</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">expanded_shape</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">dim_grid</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;broadcast_to&#39;</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)(</span><span class="n">dim_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim_shape</span><span class="p">))</span>
            <span class="n">grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim_grid</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stack&#39;</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">)(</span><span class="n">grids</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">)((</span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">grid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gather_nd&#39;</span><span class="p">)(</span><span class="n">choices</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.searchsorted"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.searchsorted">[docs]</a>    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds indices where elements should be inserted to maintain order.</span>

<span class="sd">        Args:</span>
<span class="sd">            v (Union[int, float, bool, list, tuple, Tensor]): Values to insert into the tensor.</span>
<span class="sd">            side (&#39;left&#39;, &#39;right&#39;, optional): If &#39;left&#39;, the index of the first suitable</span>
<span class="sd">                location found is given. If &#39;right&#39;, return the last such index. If there is</span>
<span class="sd">                no suitable index, return either 0 or N (where N is the length of the tensor).</span>
<span class="sd">                Default: &#39;left&#39;.</span>
<span class="sd">            sorter (Union[int, float, bool, list, tuple, Tensor]): 1-D optional tensor of</span>
<span class="sd">                integer indices that sort the tensor into ascending order. They are typically</span>
<span class="sd">                the result of argsort. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, array of insertion points with the same shape as `v`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If argument for `side` or `sorter` is invalid.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([1, 2, 3, 4, 5]))</span>
<span class="sd">            &gt;&gt;&gt; print(x.searchsorted(3))</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;Tensor.searchsorted&#39;, the argument &#39;side&#39; should be one of in &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;[&#39;left&#39;, &#39;right&#39;], but got </span><span class="si">{</span><span class="n">side</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_tensor&#39;</span><span class="p">)(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sorter</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sorter</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sorter must be 1-D array with the same size as the Tensor&#39;</span><span class="p">)</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_tensor&#39;</span><span class="p">)(</span><span class="n">sorter</span><span class="p">)</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">sorter</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sorter</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gather_nd&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">sorter</span><span class="p">)</span>
        <span class="n">less_op</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__le__&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__lt__&#39;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">sort_range</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">validator</span><span class="o">.</span><span class="n">get_log2_size</span><span class="p">(</span>
            <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape_mul&#39;</span><span class="p">)(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sort_range</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">less_op</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gather_nd&#39;</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">mid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mid</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;select&#39;</span><span class="p">)(</span><span class="n">mask</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;select&#39;</span><span class="p">)(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">j</span></div>

<div class="viewcode-block" id="Tensor.var"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.var">[docs]</a>    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the variance along the specified axis.</span>

<span class="sd">        The variance is the average of the squared deviations from the mean, i.e.,</span>
<span class="sd">        :math:`var = mean(abs(x - x.mean())**2)`.</span>

<span class="sd">        Return the variance, which is computed for the flattened array by default,</span>
<span class="sd">        otherwise over the specified axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            Numpy arguments `dtype`, `out` and `where` are not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Axis or axes along which the variance is computed.</span>
<span class="sd">                The default is to compute the variance of the flattened array. Default: `None`.</span>
<span class="sd">            ddof (int): Means Delta Degrees of Freedom. Default: 0.</span>
<span class="sd">                The divisor used in calculations is :math:`N - ddof`, where :math:`N` represents the number of elements.</span>
<span class="sd">            keepdims (bool): Default: `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Variance tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.mean`: Reduce a dimension of a tensor by averaging all elements in the dimension.</span>

<span class="sd">            :func:`mindspore.Tensor.std`: Compute the standard deviation along the specified axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.array([1., 2., 3., 4.], np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = input_x.var()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            1.25</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ddof</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.var&#39;, the type of the argument &#39;ddof&#39; must be int, but got &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ddof</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keepdims</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.var&#39;, the type of the argument &#39;keepdims&#39; must be bool, but &quot;</span>
                            <span class="s2">&quot;got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">keepdims</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_and_canonicalize_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">x_mean</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)(</span><span class="kc">True</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">x_sub</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_mean</span><span class="p">)</span>
        <span class="n">x_pow</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)(</span><span class="n">x_sub</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">x_sum</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)(</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))(</span><span class="n">x_pow</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="p">():</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">nums</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">)(</span><span class="n">x_sum</span><span class="p">,</span> <span class="n">nums</span> <span class="o">-</span> <span class="n">ddof</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.std"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the standard deviation along the specified axis.</span>

<span class="sd">        The standard deviation is the square root of the average of the squared deviations</span>
<span class="sd">        from the mean, i.e., :math:`std = sqrt(mean(abs(x - x.mean())**2))`.</span>

<span class="sd">        Return the standard deviation, which is computed for the flattened array by default,</span>
<span class="sd">        otherwise over the specified axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            Numpy arguments `dtype`, `out` and `where` are not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Axis or axes along which the standard</span>
<span class="sd">                deviation is computed. Default: `None`.</span>

<span class="sd">                If `None`, compute the standard deviation of the flattened array.</span>
<span class="sd">            ddof (int): Means Delta Degrees of Freedom. The divisor used in calculations is :math:`N - ddof`,</span>
<span class="sd">                where :math:`N` represents the number of elements. Default: 0.</span>
<span class="sd">            keepdims: Default: `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Standard deviation tensor.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.mean`: Reduce a dimension of a tensor by averaging all elements in the dimension.</span>

<span class="sd">            :func:`mindspore.Tensor.var`: Compute the variance along the specified axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.array([1, 2, 3, 4], dtype=np.float32))</span>
<span class="sd">            &gt;&gt;&gt; output = input_x.std()</span>
<span class="sd">            &gt;&gt;&gt; print(output)</span>
<span class="sd">            1.118034</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)(</span><span class="n">x_var</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.sum"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sum of tensor elements over a given axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            Numpy arguments `out`, `where`, `casting`, `order`, `subok`, `signature`, and</span>
<span class="sd">            `extobj` are not supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Union[None, int, tuple(int)]): Axis or axes along which a sum is performed. Default: None.</span>
<span class="sd">                If None, sum all the elements of the input tensor.</span>
<span class="sd">                If the axis is negative, it counts from the last to the first axis.</span>
<span class="sd">                If the axis is a tuple of ints, a sum is performed on all the axes specified in the tuple</span>
<span class="sd">                instead of a single axis or all the axes as before.</span>
<span class="sd">            dtype (:class:`mindspore.dtype`, optional): defaults to None. Overrides the dtype of the</span>
<span class="sd">                output Tensor.</span>
<span class="sd">            keepdims (bool): If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">                dimensions with size one. With this option, the result will broadcast correctly against the input array.</span>
<span class="sd">                If the default value is passed, then keepdims will not be passed through to the sum method of</span>
<span class="sd">                sub-classes of ndarray, however any non-default value will be. If the sub-class method does not</span>
<span class="sd">                implement keepdims any exceptions will be raised. Default: `False`.</span>
<span class="sd">            initial (scalar): Starting value for the sum. Default: `None`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor. A tensor with the same shape as input, with the specified axis removed.</span>
<span class="sd">            If the input tensor is a 0-d array, or if the axis is None, a scalar is returned.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input is not array_like, or `axis` is not int or tuple of ints,</span>
<span class="sd">                or `keepdims` is not integer, or `initial` is not scalar.</span>
<span class="sd">            ValueError: If any axis is out of range or duplicate axes exist.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.cumsum`: Return the cumulative sum of the elements along a given axis.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.array([-1, 0, 1]).astype(np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(input_x.sum())</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; input_x = Tensor(np.arange(10).reshape(2, 5).astype(np.float32))</span>
<span class="sd">            &gt;&gt;&gt; print(input_x.sum(axis=1))</span>
<span class="sd">            [10. 35.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">mstype</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keepdims</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.sum&#39;, the type of the argument &#39;keepdims&#39; must be int, but &quot;</span>
                            <span class="s2">&quot;got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">keepdims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For &#39;Tensor.sum&#39;, when the argument &#39;initial&#39; is not None, it must be int, &quot;</span>
                            <span class="s2">&quot;float or bool, but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">initial</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_and_canonicalize_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">validator</span><span class="o">.</span><span class="n">check_type_support</span><span class="p">(</span><span class="n">input_x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;GPU&#39;</span><span class="p">,</span>
                                            <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">)):</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;make_tensor&#39;</span><span class="p">)([</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)(</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">initial</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.repeat"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.Tensor.html#mindspore.Tensor.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeat elements of a tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            repeats (Union[int, tuple, list]): The number of repetitions for each element.</span>
<span class="sd">                `repeats` is broadcasted to fit the shape of the given axis.</span>
<span class="sd">            axis (int, optional): The axis along which to repeat values. By default,</span>
<span class="sd">                use the flattened input tensor, and return a flat output tensor. Default: None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor, has the same shape as input tensor except along the given axis.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the axis is out of range.</span>
<span class="sd">            TypeError: If arguments have types not specified above.</span>

<span class="sd">        Supported Platforms:</span>
<span class="sd">            ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`mindspore.Tensor.reshape`: Give a new shape to a tensor without changing its data.</span>

<span class="sd">            :func:`mindspore.Tensor.resize`: Changes shape and size of tensor in-place.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array(3))</span>
<span class="sd">            &gt;&gt;&gt; print(x.repeat(4))</span>
<span class="sd">            [3 3 3 3]</span>
<span class="sd">            &gt;&gt;&gt; x = Tensor(np.array([[1, 2],[3, 4]]))</span>
<span class="sd">            &gt;&gt;&gt; print(x.repeat(2))</span>
<span class="sd">            [1 1 2 2 3 3 4 4]</span>
<span class="sd">            &gt;&gt;&gt; print(x.repeat(3, axis=1))</span>
<span class="sd">            [[1 1 1 2 2 2]</span>
<span class="sd">            [3 3 3 4 4 4]]</span>
<span class="sd">            &gt;&gt;&gt; print(x.repeat([1,2], axis=0))</span>
<span class="sd">            [[1 2]</span>
<span class="sd">            [3 4]</span>
<span class="sd">            [3 4]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">repeats</span> <span class="o">=</span> <span class="p">(</span><span class="n">repeats</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">repeats</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;Tensor.repeat&#39;, each element in </span><span class="si">{</span><span class="n">repeats</span><span class="si">}</span><span class="s2"> should be int, but got &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">input_x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;Tensor.repeat&#39;, the argument &#39;axis&#39; should be int, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">validator</span><span class="o">.</span><span class="n">check_axis_in_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">input_x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="n">input_x</span><span class="o">.</span><span class="n">ndim</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">repeats</span> <span class="o">=</span> <span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">repeats</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Tensor_</span><span class="p">(</span><span class="n">input_x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;repeat_elements&#39;</span><span class="p">)(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;Tensor.repeat&#39;, the length of &#39;repeats&#39; must be the same as the shape of the &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;original tensor in the &#39;axis&#39; dimension, but got the length of &#39;repeats&#39; &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span><span class="si">}</span><span class="s2">, the shape of the original tensor in the &#39;axis&#39; dimension </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;split&#39;</span><span class="p">)(</span><span class="n">axis</span><span class="p">,</span> <span class="n">size</span><span class="p">)(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">repeated_subs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sub</span><span class="p">,</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">repeats</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rep</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">repeated_subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;repeat_elements&#39;</span><span class="p">)(</span><span class="n">sub</span><span class="p">,</span> <span class="n">rep</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">)(</span><span class="n">axis</span><span class="p">)(</span><span class="n">repeated_subs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RowTensor"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.RowTensor.html#mindspore.RowTensor">[docs]</a><span class="k">class</span> <span class="nc">RowTensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sparse representation of a set of tensor slices at given indices.</span>

<span class="sd">    An RowTensor is typically used to represent a subset of a larger</span>
<span class="sd">    tensor dense of shape [L0, D1, .. , DN] where L0 &gt;&gt; D0.</span>

<span class="sd">    The values in indices are the indices in the first dimension of the slices</span>
<span class="sd">    that have been extracted from the larger tensor.</span>

<span class="sd">    The dense tensor dense represented by an RowTensor slices has</span>
<span class="sd">    `dense[slices.indices[i], :, :, :, ...] = slices.values[i, :, :, :, ...]`.</span>

<span class="sd">    For example, if indices is [0], values is [[1, 2]], dense_shape is</span>
<span class="sd">    (3, 2), then the dense representation of the row tensor will be:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        [[1, 2],</span>
<span class="sd">         [0, 0],</span>
<span class="sd">         [0, 0]]</span>

<span class="sd">    RowTensor can only be used in the `Cell`&#39;s construct method.</span>

<span class="sd">    Note:</span>
<span class="sd">        RowTensor is not supported in pynative mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        indices (Tensor): A 1-D integer Tensor of shape [D0].</span>
<span class="sd">        values (Tensor): A Tensor of any dtype of shape [D0, D1, ..., Dn].</span>
<span class="sd">        dense_shape (tuple(int)): An integer tuple which contains the shape</span>
<span class="sd">            of the corresponding dense tensor.</span>

<span class="sd">    Returns:</span>
<span class="sd">        RowTensor, composed of `indices`, `values`, and `dense_shape`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor, RowTensor</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self, dense_shape):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.dense_shape = dense_shape</span>
<span class="sd">        ...     def construct(self, indices, values):</span>
<span class="sd">        ...         x = RowTensor(indices, values, self.dense_shape)</span>
<span class="sd">        ...         return x.values, x.indices, x.dense_shape</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([0])</span>
<span class="sd">        &gt;&gt;&gt; values = Tensor([[1, 2]], dtype=ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; out = Net((3, 2))(indices, values)</span>
<span class="sd">        &gt;&gt;&gt; print(out[0])</span>
<span class="sd">        [[1. 2.]]</span>
<span class="sd">        &gt;&gt;&gt; print(out[1])</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt; print(out[2])</span>
<span class="sd">        (3, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dense_shape</span><span class="p">):</span>
        <span class="s2">&quot;Init RowTensor&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dense_shape</span> <span class="o">=</span> <span class="n">dense_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dense_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dense_shape</span></div>


<div class="viewcode-block" id="SparseTensor"><a class="viewcode-back" href="../../../api_python/mindspore/mindspore.SparseTensor.html#mindspore.SparseTensor">[docs]</a><span class="k">class</span> <span class="nc">SparseTensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sparse representation of a set of nonzero elements from a tensor at given indices.</span>

<span class="sd">    SparseTensor can only be used in the `Cell`&#39;s construct method.</span>

<span class="sd">    For a tensor dense, its SparseTensor(indices, values, dense_shape) has</span>
<span class="sd">    `dense[indices[i]] = values[i]`.</span>

<span class="sd">    For example, if indices is [[0, 1], [1, 2]], values is [1, 2], dense_shape is</span>
<span class="sd">    (3, 4), then the dense representation of the sparse tensor will be:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        [[0, 1, 0, 0],</span>
<span class="sd">         [0, 0, 2, 0],</span>
<span class="sd">         [0, 0, 0, 0]]</span>

<span class="sd">    Note:</span>
<span class="sd">        SparseTensor is not supported in Pynative mode at the moment.</span>

<span class="sd">    Args:</span>
<span class="sd">        indices (Tensor): A 2-D integer Tensor of shape `[N, ndims]`,</span>
<span class="sd">            where N and ndims are the number of `values` and number of dimensions in</span>
<span class="sd">            the SparseTensor, respectively.</span>
<span class="sd">        values (Tensor): A 1-D tensor of any type and shape `[N]`, which</span>
<span class="sd">            supplies the values for each element in `indices`.</span>
<span class="sd">        dense_shape (tuple(int)): A integer tuple of size `ndims`,</span>
<span class="sd">            which specifies the dense_shape of the sparse tensor.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SparseTensor, composed of `indices`, `values`, and `dense_shape`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor, SparseTensor</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self, dense_shape):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.dense_shape = dense_shape</span>
<span class="sd">        ...     def construct(self, indices, values):</span>
<span class="sd">        ...         x = SparseTensor(indices, values, self.dense_shape)</span>
<span class="sd">        ...         return x.values, x.indices, x.dense_shape</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([[0, 1], [1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; values = Tensor([1, 2], dtype=ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; out = Net((3, 4))(indices, values)</span>
<span class="sd">        &gt;&gt;&gt; print(out[0])</span>
<span class="sd">        [1. 2.]</span>
<span class="sd">        &gt;&gt;&gt; print(out[1])</span>
<span class="sd">        [[0 1]</span>
<span class="sd">         [1 2]]</span>
<span class="sd">        &gt;&gt;&gt; print(out[2])</span>
<span class="sd">        (3, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dense_shape</span><span class="p">):</span>
        <span class="s2">&quot;Init SparseTensor&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dense_shape</span> <span class="o">=</span> <span class="n">dense_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__indices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dense_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dense_shape</span></div>


<span class="k">class</span> <span class="nc">CSRTensor</span><span class="p">(</span><span class="n">CSRTensor_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a sparse tensor in CSR (Compressed Sparse Row) format, with specified</span>
<span class="sd">    values indicated by `values` and row and column positions indicated by `indptr`</span>
<span class="sd">    and `indices`.</span>

<span class="sd">    Alternatively, CSRTensor can be initialized by passing another CSRTensor as input.</span>
<span class="sd">    Currently this constructor can only be supported in PyNative Mode.</span>

<span class="sd">    Note:</span>
<span class="sd">        This is an experimental feature and is subjected to change.</span>

<span class="sd">    Args:</span>
<span class="sd">        indptr (Tensor): 1-D Tensor of size `shape[0] + 1`, which indicates the</span>
<span class="sd">            start and end point for `values` in each row. Default: None. If provided,</span>
<span class="sd">            must be :class:`mindspore.int16`, :class:`mindspore.int32` or :class:`mindspore.int64`.</span>
<span class="sd">        indices (Tensor): 1-D Tensor, which has the same length as `values`. `indices`</span>
<span class="sd">            indicates the which column `values` should be placed. Default: None. If provided,</span>
<span class="sd">            must be :class:`mindspore.int16`, :class:`mindspore.int32` or :class:`mindspore.int64`.</span>
<span class="sd">        values (Tensor): 1-D Tensor, which has the same length as `indices`. `values`</span>
<span class="sd">            stores the data for CSRTensor. Default: None.</span>
<span class="sd">        shape (Tuple): A tuple indicates the shape of the CSRTensor, its length must</span>
<span class="sd">            be `2`, as only 2-D CSRTensor is currently supported, and `shape[0]` must</span>
<span class="sd">            equal to `indptr[0] - 1`, which all equal to number of rows of the CSRTensor.</span>
<span class="sd">        csr_tensor (CSRTensor): A CSRTensor object.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        CSRTensor, with shape defined by `shape`, and dtype inferred from `value`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor, CSRTensor</span>
<span class="sd">        &gt;&gt;&gt; # initialize a csr_tensor with indptr, indices, values and shape</span>
<span class="sd">        &gt;&gt;&gt; indptr = Tensor([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; indices = Tensor([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; values = Tensor([1, 2], dtype=ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; shape = (2, 4)</span>
<span class="sd">        &gt;&gt;&gt; csr_tensor = CSRTensor(indptr, indices, values, shape)</span>
<span class="sd">        &gt;&gt;&gt; # initialize a csr_tensor from another csr_tensor</span>
<span class="sd">        &gt;&gt;&gt; csr_tensor_2 = CSRTensor(csr_tensor=csr_tensor)</span>
<span class="sd">        &gt;&gt;&gt; # access a data member of CSRTensor</span>
<span class="sd">        &gt;&gt;&gt; print(indptr == csr_tensor.indptr)</span>
<span class="sd">        [ True  True  True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indptr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">csr_tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Case 1: directly init a CSRTensor from another CSRTensor</span>
        <span class="k">if</span> <span class="n">indptr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">csr_tensor</span><span class="p">,</span> <span class="p">(</span><span class="n">CSRTensor</span><span class="p">,</span> <span class="n">CSRTensor_</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If only one input provided, it must be a CSRTensor.&quot;</span><span class="p">)</span>
            <span class="n">CSRTensor_</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">csr_tensor</span><span class="p">)</span>
        <span class="c1"># Case 2: init a CSRTensor from indptr, indices, values and shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">indptr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Inputs must follow: CSRTensor(indptr, indices, values, shape).&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">indptr</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> \
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Inputs must follow: CSRTensor(tensor, tensor, tensor, tuple).&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">indptr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape length should be 2, shape[0] should equal to indptr.shape[0] - 1&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indptr</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indptr must have integer data type.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indices must have integer data type.&quot;</span><span class="p">)</span>
            <span class="n">CSRTensor_</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Avoid PyTest Segfault when CSRTensor is not initialized.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_finished</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CSRTensor_</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;csr_mul&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CSRTensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indptr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indptr</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="k">def</span> <span class="nf">to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>


<span class="k">def</span> <span class="nf">_vm_compare</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implement `vm_compare` for tensor.&quot;&quot;&quot;</span>
    <span class="n">obj_str</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">obj_str</span> <span class="o">==</span> <span class="s2">&quot;shape&quot;</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">obj_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">obj_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">fn</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">obj_str</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj_str</span> <span class="o">=</span> <span class="s2">&quot;__r&quot;</span> <span class="o">+</span> <span class="n">obj_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">obj_str</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_check_tensor_input</span><span class="p">(</span><span class="n">input_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check the tensor input.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">input_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If input_data is available, shape doesn&#39;t need to be set&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;init, dtype and shape must have values at the same time.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">input_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input_data and init can not be None at the same time.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">input_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">input_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">input_data</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input_data can not contain zero dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> \
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input_data can not contain zero dimension.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="s2">&quot;__enable_zero_dim__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">init</span><span class="o">.</span><span class="n">__enable_zero_dim__</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape can not contain zero value.&quot;</span><span class="p">)</span>


<span class="n">tensor_operator_registry</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;vm_compare&#39;</span><span class="p">,</span> <span class="n">_vm_compare</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>