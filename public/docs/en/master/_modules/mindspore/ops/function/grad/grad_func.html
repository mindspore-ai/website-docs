<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.ops.function.grad.grad_func &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script>
      <link rel="stylesheet" href="../../../../../_static/css/bootstrap.min.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/training.css" type="text/css" /><link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script><script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/js/theme.js"></script><script src="../../../../../_static/underscore.js"></script><script src="../../../../../_static/doctools.js"></script><script src="../../../../../_static/js/training.js"></script><script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/overview.html">MindSpore Design Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/programming_paradigm.html">Functional and Object-Oriented Fusion Programming Paradigm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/dynamic_graph_and_static_graph.html">Combination of Dynamic and Static Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/distributed_training_design.html">Distributed Parallel Native</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/data_engine.html">High Performance Data Processing Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/all_scenarios.html">Full-scenarios Unified Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/graph_fusion_engine.html">Graph-Kernel Fusion Acceleration Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/pluggable_device.html">Third-Party Hardware Interconnection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../design/glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../note/official_models.html">Official Models</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.ops.primitive.html">mindspore.ops.primitive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.amp.html">mindspore.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.rewrite.html">mindspore.rewrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.boost.html">mindspore.boost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.scipy.html">mindspore.scipy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api_python/mindspore.experimental.html">mindspore.experimental</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Mapping</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../note/api_mapping/pytorch_api_mapping.html">PyTorch and MindSpore API Mapping Table</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Migration Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/overview.html">Overview of Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/enveriment_preparation.html">Environment Preparation and Information Acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/analysis_and_preparation.html">Model Analysis and Preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/typical_api_comparision.html">Differences between PyTorch and MindSpore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/model_development/model_development.html">Constructing MindSpore Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/debug_and_tune.html">Debugging and Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/sample_code.html">Network Migration Debugging Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/migrator_with_tools.html">Application Practice Guide for Network Migration Tool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../migration_guide/faq.html">FAQs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Syntax Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../note/static_graph_syntax_support.html">Static Graph Syntax Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../note/static_graph_syntax/operators.html">Static Graph Syntax - Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../note/static_graph_syntax/statements.html">Static Graph Syntax - Python Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../note/static_graph_syntax/python_builtin_functions.html">Static Graph Syntax - Python Built-in Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../note/index_support.html">Tensor Index Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Environment Variables</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../note/env_var_list.html">Environment Variables</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/data_processing.html">Data Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/implement_problem.html">Implement Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/network_compilation.html">Network Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/operators_compile.html">Operators Compile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/usage_migrate_3rd.html">Migration from a Third-party Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/performance_tuning.html">Performance Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/precision_tuning.html">Precision Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/distributed_parallel.html">Distributed Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/feature_advice.html">Feature Advice</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
      <li>mindspore.ops.function.grad.grad_func</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mindspore.ops.function.grad.grad_func</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2022 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>

<span class="sd">&quot;&quot;&quot;Defines gradient related operators with functional form.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mindspore.common</span> <span class="kn">import</span> <span class="n">jit</span><span class="p">,</span> <span class="n">mutable</span>
<span class="kn">from</span> <span class="nn">mindspore.common</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">mindspore.common</span> <span class="kn">import</span> <span class="n">dtype</span> <span class="k">as</span> <span class="n">mstype</span>
<span class="kn">from</span> <span class="nn">mindspore.nn.cell</span> <span class="kn">import</span> <span class="n">Cell</span>
<span class="kn">from</span> <span class="nn">mindspore.nn.grad.cell_grad</span> <span class="kn">import</span> <span class="n">_LinearizeInner</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.primitive</span> <span class="kn">import</span> <span class="n">constexpr</span><span class="p">,</span> <span class="n">_primexpr</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.function.array_func</span> <span class="kn">import</span> <span class="n">ones</span><span class="p">,</span> <span class="n">expand_dims</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">reshape</span><span class="p">,</span> <span class="n">broadcast_to</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">zeros</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.composite</span> <span class="kn">import</span> <span class="n">_Vmap</span><span class="p">,</span> <span class="n">_Grad</span><span class="p">,</span> <span class="n">_TaylorOperation</span><span class="p">,</span> <span class="n">GradOperation</span>
<span class="kn">from</span> <span class="nn">mindspore.ops</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">P</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.operations</span> <span class="kn">import</span> <span class="n">_inner_ops</span> <span class="k">as</span> <span class="n">inner</span>

<span class="n">cast</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
<span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>
<span class="n">oneslike</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">OnesLike</span><span class="p">()</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_check_has_aux_type</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The &#39;has_aux&#39; must be bool type.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_raise_type_error</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The inputs type must be a Tensor, tuple or list of Tensors.&quot;</span><span class="p">)</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_check_duplicate_grad_position</span><span class="p">(</span><span class="n">grad_position</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if `grad_position` has duplicate positions when `grad_position` has more than one numbers.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">grad_position</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad_position</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are duplicate positions in `grad_position`, please check it&quot;</span><span class="p">)</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_convert_grad_position_type</span><span class="p">(</span><span class="n">grad_position</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check and convert the type and size of grad position index.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grad_position</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">_check_duplicate_grad_position</span><span class="p">(</span><span class="n">grad_position</span><span class="p">)</span>
        <span class="n">_grad_position</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grad_position</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_grad_position</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">_grad_position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;F.grad&#39;, the element in &#39;grad_position&#39; must be int.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The element in grad_position must be &gt;= 0.&quot;</span><span class="p">)</span>
        <span class="n">grad_position</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_grad_position</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grad_position</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">grad_position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grad_position must be &gt;= 0.&quot;</span><span class="p">)</span>
        <span class="n">grad_position</span> <span class="o">=</span> <span class="p">(</span><span class="n">grad_position</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;F.grad&#39;, the &#39;grad_position&#39; must be int or tuple.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grad_position</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_check_grad_position</span><span class="p">(</span><span class="n">grad_position</span><span class="p">,</span> <span class="n">args_num</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check and convert grad position index.&quot;&quot;&quot;</span>
    <span class="n">grad_position</span> <span class="o">=</span> <span class="n">_convert_grad_position_type</span><span class="p">(</span><span class="n">grad_position</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">gp</span> <span class="ow">in</span> <span class="n">grad_position</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">gp</span> <span class="o">&gt;=</span> <span class="n">args_num</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The element in grad_position must belong to [0, args_num).&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grad_position</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_get_grad_op</span><span class="p">(</span><span class="n">get_by_list</span><span class="p">,</span> <span class="n">get_by_position</span><span class="p">,</span> <span class="n">has_aux</span><span class="p">,</span> <span class="n">get_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_Grad</span><span class="p">(</span><span class="n">get_by_list</span><span class="o">=</span><span class="n">get_by_list</span><span class="p">,</span> <span class="n">get_by_position</span><span class="o">=</span><span class="n">get_by_position</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="n">has_aux</span><span class="p">,</span> <span class="n">get_value</span><span class="o">=</span><span class="n">get_value</span><span class="p">,</span>
                 <span class="n">return_ids</span><span class="o">=</span><span class="n">return_ids</span><span class="p">)</span>


<div class="viewcode-block" id="grad"><a class="viewcode-back" href="../../../../../api_python/mindspore/mindspore.grad.html#mindspore.grad">[docs]</a><span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">grad_position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper function to generate the gradient function for the input function.</span>

<span class="sd">    As for gradient, three typical cases are included:</span>

<span class="sd">    1. gradient with respect to inputs. In this case, `grad_position` is not None while `weights` is None.</span>
<span class="sd">    2. gradient with respect to weights. In this case, `grad_position` is None while `weights` is not None.</span>
<span class="sd">    3. gradient with respect to inputs and weights. In this case, `grad_position` and `weights` are not None.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Cell, Function]): Function to do GradOperation.</span>
<span class="sd">        grad_position (Union[NoneType, int, tuple[int]]): Index to specify which inputs to be differentiated.</span>
<span class="sd">            If int, get the gradient with respect to single input.</span>
<span class="sd">            If tuple, get the gradients with respect to selected inputs. `grad_position` begins with 0.</span>
<span class="sd">            If None, none derivative of any input will be figured out, and in this case, `weights` is required.</span>
<span class="sd">            Default: ``0`` .</span>
<span class="sd">        weights (Union[ParameterTuple, Parameter, list[Parameter]]): The parameters of the training network that need to</span>
<span class="sd">            calculate the gradient. `weights` can be got through `weights = net.trainable_params()` .</span>
<span class="sd">            Default: ``None`` .</span>
<span class="sd">        has_aux (bool): If ``True`` , only the first output of `fn` contributes the gradient of `fn`, while the other</span>
<span class="sd">            outputs will be returned straightly. It means the `fn` must return more than one outputs in this case.</span>
<span class="sd">            Default: ``False`` .</span>
<span class="sd">        return_ids(bool): Whether return the tuple made by gradients and the index to specify which inputs</span>
<span class="sd">            to be differentiated or the name of parameters of the training network that need to calculate the gradient.</span>
<span class="sd">            If ``True`` , the output gradients will be replaced by the tuples made by gradients and the index to specify</span>
<span class="sd">            which inputs to be differentiated or the name of parameters of the training network.</span>
<span class="sd">            Default: ``False`` .</span>

<span class="sd">    Returns:</span>
<span class="sd">        Function, the gradient function to calculate gradient for the input function or cell.</span>
<span class="sd">        For example, as for `out1, out2 = fn(*args)`, when `has_aux` is set ``True`` , gradient function will return</span>
<span class="sd">        outputs like `(gradient, out2)` and `out2` does not contribute to the differentiation, otherwise `gradient`.</span>
<span class="sd">        When return_ids is set to ``True`` , The format of the output will be the same with the output of grad when</span>
<span class="sd">        return_ids is set to false, but every gradient in the output will be replaced by a tuple of position id or</span>
<span class="sd">        parameter name and its gradient.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If both `grad_position` and `weights` are None.</span>
<span class="sd">        TypeError: If type of Args does not belong to required ones.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor, ops, nn, grad</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Cell object to be differentiated</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def construct(self, x, y, z):</span>
<span class="sd">        ...         return x * y * z</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([1, 2], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor([-2, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; z = Tensor([0, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = Net()</span>
<span class="sd">        &gt;&gt;&gt; output = grad(net, grad_position=(1, 2))(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        (Tensor(shape=[2], dtype=Float32, value=[ 0.00000000e+00,  6.00000000e+00]),</span>
<span class="sd">         Tensor(shape=[2], dtype=Float32, value=[-2.00000000e+00,  6.00000000e+00]))</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Function object to be differentiated</span>
<span class="sd">        &gt;&gt;&gt; def fn(x, y, z):</span>
<span class="sd">        ...     res = x * ops.exp(y) * ops.pow(z, 2)</span>
<span class="sd">        ...     return res, z</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([3, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor([0, 0], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; z = Tensor([5, 5], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; gradient, aux = grad(fn, (1, 2), None, True)(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; print(gradient)</span>
<span class="sd">        (Tensor(shape=[2], dtype=Float32, value= [ 7.50000000e+01,  7.50000000e+01]),</span>
<span class="sd">         Tensor(shape=[2], dtype=Float32, value= [ 3.00000000e+01,  3.00000000e+01]))</span>
<span class="sd">        &gt;&gt;&gt; print(aux)</span>
<span class="sd">        (Tensor(shape=[2], dtype=Float32, value= [ 5.00000000e+00,  5.00000000e+00]),)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # For given network to be differentiated with both inputs and weights, there are 4 cases.</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Dense(10, 1)</span>
<span class="sd">        &gt;&gt;&gt; loss_fn = nn.MSELoss()</span>
<span class="sd">        &gt;&gt;&gt; def forward(inputs, labels):</span>
<span class="sd">        ...     logits = net(inputs)</span>
<span class="sd">        ...     loss = loss_fn(logits, labels)</span>
<span class="sd">        ...     return loss, logits</span>
<span class="sd">        &gt;&gt;&gt; inputs = Tensor(np.random.randn(16, 10).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; labels = Tensor(np.random.randn(16, 1).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; weights = net.trainable_params()</span>
<span class="sd">        &gt;&gt;&gt; # Case 1: gradient with respect to inputs.</span>
<span class="sd">        &gt;&gt;&gt; # Aux value does not contribute to the gradient.</span>
<span class="sd">        &gt;&gt;&gt; grad_fn = grad(forward, grad_position=(0, 1), weights=None, has_aux=True)</span>
<span class="sd">        &gt;&gt;&gt; inputs_gradient, (aux_logits,) = grad_fn(inputs, labels)</span>
<span class="sd">        &gt;&gt;&gt; print(len(inputs_gradient))</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; print(aux_logits.shape)</span>
<span class="sd">        (16, 1)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Case 2: gradient with respect to weights.</span>
<span class="sd">        &gt;&gt;&gt; grad_fn = grad(forward, grad_position=None, weights=weights, has_aux=True)</span>
<span class="sd">        &gt;&gt;&gt; params_gradient, (aux_logits,) = grad_fn(inputs, labels)</span>
<span class="sd">        &gt;&gt;&gt; print(len(weights), len(params_gradient))</span>
<span class="sd">        2 2</span>
<span class="sd">        &gt;&gt;&gt; print(aux_logits.shape)</span>
<span class="sd">        (16, 1)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Case 3: gradient with respect to inputs and weights.</span>
<span class="sd">        &gt;&gt;&gt; grad_fn = grad(forward, grad_position=0, weights=weights, has_aux=False)</span>
<span class="sd">        &gt;&gt;&gt; inputs_gradient, params_gradient = grad_fn(inputs, labels)</span>
<span class="sd">        &gt;&gt;&gt; print(len(weights), len(params_gradient))</span>
<span class="sd">        2 2</span>
<span class="sd">        &gt;&gt;&gt; # Case 4: return the gradient with ids.</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor, ops</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import grad</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Cell object to be differentiated</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def construct(self, x, y, z):</span>
<span class="sd">        ...         return x * y * z</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([1, 2], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor([-2, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; z = Tensor([0, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = Net()</span>
<span class="sd">        &gt;&gt;&gt; output = grad(net, grad_position=(1, 2), return_ids = True)(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        ((1, Tensor(shape=[2], dtype=Float32, value=[ 0.00000000e+00,  6.00000000e+00])),</span>
<span class="sd">         (2, Tensor(shape=[2], dtype=Float32, value=[-2.00000000e+00,  6.00000000e+00])))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">grad_position</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`grad_position` and `weight` can not be None at the same time.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">grad_position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_get_grad_op</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">has_aux</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_ids</span><span class="p">)(</span><span class="n">fn</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="n">grad_position</span> <span class="o">=</span> <span class="n">_convert_grad_position_type</span><span class="p">(</span><span class="n">grad_position</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_get_grad_op</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">has_aux</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_ids</span><span class="p">)(</span><span class="n">fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_get_grad_op</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">has_aux</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_ids</span><span class="p">)(</span><span class="n">fn</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">)</span></div>


<div class="viewcode-block" id="value_and_grad"><a class="viewcode-back" href="../../../../../api_python/mindspore/mindspore.value_and_grad.html#mindspore.value_and_grad">[docs]</a><span class="k">def</span> <span class="nf">value_and_grad</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">grad_position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper function to generate the function to calculate forward output and gradient for the input function.</span>

<span class="sd">    As for gradient, three typical cases are included:</span>

<span class="sd">    1. gradient with respect to inputs. In this case, `grad_position` is not None while `weights` is None.</span>
<span class="sd">    2. gradient with respect to weights. In this case, `grad_position` is None while `weights` is not None.</span>
<span class="sd">    3. gradient with respect to inputs and weights. In this case, `grad_position` and `weights` are not None.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Cell, Function]): Function to do GradOperation.</span>
<span class="sd">        grad_position (Union[NoneType, int, tuple[int]]): Index to specify which inputs to be differentiated.</span>
<span class="sd">            If int, get the gradient with respect to single input.</span>
<span class="sd">            If tuple, get the gradients with respect to selected inputs. `grad_position` begins with 0.</span>
<span class="sd">            If None, none derivative of any input will be solved, and in this case, `weights` is required.</span>
<span class="sd">            Default: ``0`` .</span>
<span class="sd">        weights (Union[ParameterTuple, Parameter, list[Parameter]]): The parameters of the training network that need to</span>
<span class="sd">            calculate the gradient. `weights` can be got through `weights = net.trainable_params()` .</span>
<span class="sd">            Default: ``None`` .</span>
<span class="sd">        has_aux (bool): If ``True`` , only the first output of `fn` contributes the gradient of `fn`, while the other</span>
<span class="sd">            outputs will be returned straightly. It means the `fn` must return more than one outputs in this case.</span>
<span class="sd">            Default: ``False`` .</span>
<span class="sd">        return_ids(bool): Whether return the tuple made by gradients and the index to specify which inputs</span>
<span class="sd">            to be differentiated or the name of parameters of the training network that need to calculate the gradient.</span>
<span class="sd">            If ``True`` , the output gradients will be replaced by the tuples made by gradients and the index to specify</span>
<span class="sd">            which inputs to be differentiated or the name of parameters of the training network.</span>
<span class="sd">            Default: ``False`` .</span>

<span class="sd">    Returns:</span>
<span class="sd">        Function, returns the gradient function to calculate forward output and gradient for the input function or cell.</span>
<span class="sd">        For example, as for `out1, out2 = fn(*args)` , gradient function will return outputs like</span>
<span class="sd">        `((out1, out2), gradient)` . When `has_aux` is set True, only `out1` contributes to the differentiation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If both `grad_position` and `weights` are None.</span>
<span class="sd">        TypeError: If type of Args does not belong to required ones.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor, ops, nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import value_and_grad</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Cell object to be differentiated</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def construct(self, x, y, z):</span>
<span class="sd">        ...         return x * y * z</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([1, 2], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor([-2, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; z = Tensor([0, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = Net()</span>
<span class="sd">        &gt;&gt;&gt; grad_fn = value_and_grad(net, grad_position=1)</span>
<span class="sd">        &gt;&gt;&gt; output, inputs_gradient = grad_fn(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [-0. 18.]</span>
<span class="sd">        &gt;&gt;&gt; print(inputs_gradient)</span>
<span class="sd">        [0. 6.]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Function object to be differentiated</span>
<span class="sd">        &gt;&gt;&gt; def fn(x, y, z):</span>
<span class="sd">        ...     res = x * ops.exp(y) * ops.pow(z, 2)</span>
<span class="sd">        ...     return res, z</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([3, 3]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor(np.array([0, 0]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; z = Tensor(np.array([5, 5]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; output, inputs_gradient = value_and_grad(fn, grad_position=(1, 2), weights=None, has_aux=True)(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        (Tensor(shape=[2], dtype=Float32, value= [ 7.50000000e+01,  7.50000000e+01]),</span>
<span class="sd">         Tensor(shape=[2], dtype=Float32, value= [ 5.00000000e+00,  5.00000000e+00]))</span>
<span class="sd">        &gt;&gt;&gt; print(inputs_gradient)</span>
<span class="sd">        (Tensor(shape=[2], dtype=Float32, value= [ 7.50000000e+01,  7.50000000e+01]),</span>
<span class="sd">         Tensor(shape=[2], dtype=Float32, value= [ 3.00000000e+01,  3.00000000e+01]))</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # For given network to be differentiated with both inputs and weights, there are 3 cases.</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Dense(10, 1)</span>
<span class="sd">        &gt;&gt;&gt; loss_fn = nn.MSELoss()</span>
<span class="sd">        &gt;&gt;&gt; def forward(inputs, labels):</span>
<span class="sd">        ...     logits = net(inputs)</span>
<span class="sd">        ...     loss = loss_fn(logits, labels)</span>
<span class="sd">        ...     return loss, logits</span>
<span class="sd">        &gt;&gt;&gt; inputs = Tensor(np.random.randn(16, 10).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; labels = Tensor(np.random.randn(16, 1).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; weights = net.trainable_params()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Case 1: gradient with respect to inputs.</span>
<span class="sd">        &gt;&gt;&gt; # For has_aux is set True, only loss contributes to the gradient.</span>
<span class="sd">        &gt;&gt;&gt; grad_fn = value_and_grad(forward, grad_position=0, weights=None, has_aux=True)</span>
<span class="sd">        &gt;&gt;&gt; (loss, logits), inputs_gradient = grad_fn(inputs, labels)</span>
<span class="sd">        &gt;&gt;&gt; print(logits.shape)</span>
<span class="sd">        (16, 1)</span>
<span class="sd">        &gt;&gt;&gt; print(inputs.shape, inputs_gradient.shape)</span>
<span class="sd">        (16, 10) (16, 10)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Case 2: gradient with respect to weights.</span>
<span class="sd">        &gt;&gt;&gt; # For has_aux is set True, only loss contributes to the gradient.</span>
<span class="sd">        &gt;&gt;&gt; grad_fn = value_and_grad(forward, grad_position=None, weights=weights, has_aux=True)</span>
<span class="sd">        &gt;&gt;&gt; (loss, logits), params_gradient = grad_fn(inputs, labels)</span>
<span class="sd">        &gt;&gt;&gt; print(logits.shape)</span>
<span class="sd">        (16, 1)</span>
<span class="sd">        &gt;&gt;&gt; print(len(weights), len(params_gradient))</span>
<span class="sd">        2 2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Case 3: gradient with respect to inputs and weights.</span>
<span class="sd">        &gt;&gt;&gt; # For has_aux is set False, both loss and logits contribute to the gradient.</span>
<span class="sd">        &gt;&gt;&gt; grad_fn = value_and_grad(forward, grad_position=0, weights=weights, has_aux=False)</span>
<span class="sd">        &gt;&gt;&gt; (loss, logits), (inputs_gradient, params_gradient) = grad_fn(inputs, labels)</span>
<span class="sd">        &gt;&gt;&gt; print(logits.shape)</span>
<span class="sd">        (16, 1)</span>
<span class="sd">        &gt;&gt;&gt; print(inputs.shape, inputs_gradient.shape)</span>
<span class="sd">        (16, 10) (16, 10)</span>
<span class="sd">        &gt;&gt;&gt; print(len(weights), len(params_gradient))</span>
<span class="sd">        2 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">grad_position</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`grad_position` and `weight` can not be None at the same time.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">grad_position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_get_grad_op</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">has_aux</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_ids</span><span class="p">)(</span><span class="n">fn</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="n">grad_position</span> <span class="o">=</span> <span class="n">_convert_grad_position_type</span><span class="p">(</span><span class="n">grad_position</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_get_grad_op</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">has_aux</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_ids</span><span class="p">)(</span><span class="n">fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_get_grad_op</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">has_aux</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_ids</span><span class="p">)(</span><span class="n">fn</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_grad"><a class="viewcode-back" href="../../../../../api_python/mindspore/mindspore.get_grad.html#mindspore.get_grad">[docs]</a><span class="k">def</span> <span class="nf">get_grad</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When `return_ids` of :func:`mindspore.grad` is set to True, use its return value as gradients. Then find</span>
<span class="sd">    the specific gradient from `gradients` according to `identifier` .</span>

<span class="sd">    As for gradient, two typical cases are included:</span>

<span class="sd">    1. `identifier` is the position of the specific tensor to get gradient.</span>
<span class="sd">    2. `identifier` is a parameter of a network.</span>

<span class="sd">    Args:</span>
<span class="sd">        gradients (Union[tuple[int, Tensor], tuple[tuple, tuple]]): The return value of :func:`mindspore.grad`</span>
<span class="sd">            when `return_ids` is set to True.</span>
<span class="sd">        identifier (Union[int, Parameter]): The position number of a tensor, or a parameter that is used in</span>
<span class="sd">            :func:`mindspore.grad`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The gradient of the tensor on the position or in the parameter that specified by the `identifier`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If gradient is not found.</span>
<span class="sd">        TypeError: If type of Args does not belong to required ones.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor, nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import grad, get_grad</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;  # Cell object to be differentiated</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def construct(self, x, y, z):</span>
<span class="sd">        ...         return x * y * z</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([1, 2], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor([-2, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; z = Tensor([0, 3], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = Net()</span>
<span class="sd">        &gt;&gt;&gt; out_grad = grad(net, grad_position=(1, 2), return_ids=True)(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; output = get_grad(out_grad, 1)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [0. 6.]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">inner</span><span class="o">.</span><span class="n">GetGrad</span><span class="p">()(</span><span class="n">gradients</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_trans_jet_inputs</span><span class="p">(</span><span class="n">primals_item</span><span class="p">,</span> <span class="n">series_item</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Trans inputs of jet&quot;&quot;&quot;</span>
    <span class="n">value_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype</span><span class="p">(</span><span class="n">primals_item</span><span class="p">)</span> <span class="ow">in</span> <span class="n">value_type</span> <span class="ow">or</span> <span class="n">dtype</span><span class="p">(</span><span class="n">primals_item</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">(</span><span class="n">series_item</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For `F.jet`, the elements&#39; types of primals and series must be the same and belong to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`mstype.int32, mstype.int64, mstype.float32, mstype.float64`, but got other dtype.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="p">(</span><span class="n">primals_item</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int64</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">primals_item</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">cast</span><span class="p">(</span><span class="n">series_item</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">primals_item</span><span class="p">,</span> <span class="n">series_item</span>


<span class="k">def</span> <span class="nf">_check_jet_inputs</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check inputs of jet&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">))</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;F.jet&#39;, the &#39;primals&#39; and `series` must be both Tensor or tuple.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">primals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">return</span> <span class="n">_trans_jet_inputs</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">series</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">primals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">series</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_trans_jet_inputs</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">series</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;In series, the shape of each element must be the same as the primals.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">primals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The lengths of primals and series must be the same.&quot;</span><span class="p">)</span>
    <span class="n">check_primals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">check_series</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">series</span><span class="p">):</span>
        <span class="n">trans_primals_item</span><span class="p">,</span> <span class="n">trans_series_item</span> <span class="o">=</span> <span class="n">_trans_jet_inputs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">check_primals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trans_primals_item</span><span class="p">)</span>
        <span class="n">check_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trans_series_item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">check_primals</span><span class="p">,</span> <span class="n">check_series</span>


<span class="n">_taylor</span> <span class="o">=</span> <span class="n">_TaylorOperation</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_preprocess_jet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">concat_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Concat</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">concat_op</span><span class="p">((</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>


<div class="viewcode-block" id="jet"><a class="viewcode-back" href="../../../../../api_python/ops/mindspore.ops.jet.html#mindspore.jet">[docs]</a><span class="k">def</span> <span class="nf">jet</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is designed to calculate the higher order differentiation of given composite function. To figure out</span>
<span class="sd">    first to `n`-th order differentiations, original inputs and first to `n`-th order derivative of original inputs</span>
<span class="sd">    must be provided together. Generally, it is recommended to set the values of given first order derivative to 1,</span>
<span class="sd">    while the other to 0, which is like the derivative of origin input with respect to itself.</span>

<span class="sd">    Note:</span>
<span class="sd">        If `primals` is Tensor of int type, it will be converted to Tensor of float type.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Cell, function]): Function to do TaylorOperation.</span>
<span class="sd">        primals (Union[Tensor, tuple[Tensor]]): The inputs to `fn`.</span>
<span class="sd">        series (Union[Tensor, tuple[Tensor]]): If tuple, the length and type of series should be the same as inputs.</span>
<span class="sd">            For each Tensor, the length of first dimension `i` represents the `1` to `i+1`-th order of derivative of</span>
<span class="sd">            output with respect to the inputs will be figured out.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, tuple of out_primals and out_series.</span>

<span class="sd">        - **out_primals** (Union[Tensor, list[Tensor]]) - The output of `fn(primals)`.</span>
<span class="sd">        - **out_series** (Union[Tensor, list[Tensor]]) - The `1` to `i+1`-th order of derivative of output with respect</span>
<span class="sd">          to the inputs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `primals` is not a tensor or tuple of tensors.</span>
<span class="sd">        TypeError: If type of `primals` is not the same as type of `series`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.ops as ops</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; ms.set_context(mode=ms.GRAPH_MODE)</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super().__init__()</span>
<span class="sd">        ...         self.sin = ops.Sin()</span>
<span class="sd">        ...         self.exp = ops.Exp()</span>
<span class="sd">        ...     def construct(self, x):</span>
<span class="sd">        ...         out1 = self.sin(x)</span>
<span class="sd">        ...         out2 = self.exp(out1)</span>
<span class="sd">        ...         return out2</span>
<span class="sd">        &gt;&gt;&gt; primals = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; series = Tensor(np.array([[[1, 1], [1, 1]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; net = Net()</span>
<span class="sd">        &gt;&gt;&gt; out_primals, out_series = ops.jet(net, primals, series)</span>
<span class="sd">        &gt;&gt;&gt; print(out_primals, out_series)</span>
<span class="sd">        [[2.319777  2.4825778]</span>
<span class="sd">         [1.1515628 0.4691642]] [[[ 1.2533808  -1.0331168 ]</span>
<span class="sd">          [-1.1400385  -0.3066662 ]]</span>
<span class="sd">         [[-1.2748207  -1.8274734 ]</span>
<span class="sd">          [ 0.966121    0.55551505]]</span>
<span class="sd">         [[-4.0515366   3.6724353 ]</span>
<span class="sd">          [ 0.5053504  -0.52061415]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">primals</span><span class="p">,</span> <span class="n">series</span> <span class="o">=</span> <span class="n">_check_jet_inputs</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">series</span><span class="p">)</span>
    <span class="n">derivative_fn</span> <span class="o">=</span> <span class="n">_taylor</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">primals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_preprocess_jet</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">series</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">derivative_fn</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">_preprocess_jet</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">series</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">derivative_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">out_primals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_series</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="n">out_primals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">out_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_primals</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out_series</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">out_primals</span><span class="p">,</span> <span class="n">out_series</span></div>


<span class="k">def</span> <span class="nf">_trans_derivative_inputs</span><span class="p">(</span><span class="n">primals_item</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Trans inputs of derivative&quot;&quot;&quot;</span>
    <span class="n">value_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype</span><span class="p">(</span><span class="n">primals_item</span><span class="p">)</span> <span class="ow">in</span> <span class="n">value_type</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For `F.derivative`, the elements of primals must belong to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`mstype.int32, mstype.int64, mstype.float32, mstype.float64`, but got other dtype.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="p">(</span><span class="n">primals_item</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">int64</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">primals_item</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">primals_item</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_check_derivative_order</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;check input order of derivative&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For `F.derivative`, the type of order must be int.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For `F.derivative`, value of order should not be less than 1, but got </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_preprocess_derivate_order_one</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">concat_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Concat</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">concat_op</span><span class="p">((</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>


<span class="k">def</span> <span class="nf">_preprocess_derivate_order_more</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">concat_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Concat</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">concat_op</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">zeros</span><span class="p">((</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>


<div class="viewcode-block" id="derivative"><a class="viewcode-back" href="../../../../../api_python/ops/mindspore.ops.derivative.html#mindspore.derivative">[docs]</a><span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is designed to calculate the higher order differentiation of given composite function. To figure out</span>
<span class="sd">    `order`-th order differentiations, original inputs and order must be provided together. In particular, the value of</span>
<span class="sd">    input first order derivative is set to 1, while the other to 0.</span>

<span class="sd">    Note:</span>
<span class="sd">        If `primals` is Tensor of int type, it will be converted to Tensor of float type.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Cell, function]): Function to do TaylorOperation.</span>
<span class="sd">        primals (Union[Tensor, tuple[Tensor]]): The inputs to `fn`.</span>
<span class="sd">        order (int): For each Tensor, the `order`-th order of derivative of output with respect to the inputs will be</span>
<span class="sd">            figured out.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, tuple of out_primals and out_series.</span>

<span class="sd">        - **out_primals** (Union[Tensor, list[Tensor]]) - The output of `fn(primals)`.</span>
<span class="sd">        - **out_series** (Union[Tensor, list[Tensor]]) - The `order`-th order of derivative of output with respect</span>
<span class="sd">          to the inputs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `primals` is not a tensor or tuple of tensors.</span>
<span class="sd">        TypeError: If `order` is not int.</span>
<span class="sd">        ValueError: If `order` is less than 1.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.ops as ops</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; ms.set_context(mode=ms.GRAPH_MODE)</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super().__init__()</span>
<span class="sd">        ...         self.sin = ops.Sin()</span>
<span class="sd">        ...         self.exp = ops.Exp()</span>
<span class="sd">        ...     def construct(self, x):</span>
<span class="sd">        ...         out1 = self.sin(x)</span>
<span class="sd">        ...         out2 = self.exp(out1)</span>
<span class="sd">        ...         return out2</span>
<span class="sd">        &gt;&gt;&gt; primals = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; order = 3</span>
<span class="sd">        &gt;&gt;&gt; net = Net()</span>
<span class="sd">        &gt;&gt;&gt; out_primals, out_series = ops.derivative(net, primals, order)</span>
<span class="sd">        &gt;&gt;&gt; print(out_primals, out_series)</span>
<span class="sd">        [[2.319777  2.4825778]</span>
<span class="sd">         [1.1515628 0.4691642]] [[-4.0515366   3.6724353 ]</span>
<span class="sd">         [ 0.5053504  -0.52061415]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">derivative_fn</span> <span class="o">=</span> <span class="n">_taylor</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">concat_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Concat</span><span class="p">()</span>
    <span class="n">series_one</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">_check_derivative_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">trans_primals</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_trans_derivative_inputs</span><span class="p">,</span> <span class="n">primals</span><span class="p">)</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_preprocess_derivate_order_one</span><span class="p">,</span> <span class="n">trans_primals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">processed_inputs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                <span class="n">processed_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_preprocess_derivate_order_more</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">derivative_fn</span><span class="p">(</span><span class="o">*</span><span class="n">processed_inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">derivative_fn</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">primals</span> <span class="o">=</span> <span class="n">_trans_derivative_inputs</span><span class="p">(</span><span class="n">primals</span><span class="p">)</span>
        <span class="n">series</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">,)</span> <span class="o">+</span> <span class="n">primals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="n">primals</span><span class="p">))</span>
        <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">series_one</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">concat_op</span><span class="p">((</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">series</span><span class="p">))</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">derivative_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">out_primals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_series</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="n">out_primals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">out_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_primals</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out_series</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out_primals</span><span class="p">,</span> <span class="n">out_series</span></div>


<span class="n">_grad_single</span> <span class="o">=</span> <span class="n">GradOperation</span><span class="p">(</span><span class="n">sens_param</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">_grad_all</span> <span class="o">=</span> <span class="n">GradOperation</span><span class="p">(</span><span class="n">sens_param</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_check_jvp_input_v_len</span><span class="p">(</span><span class="n">inputs_len</span><span class="p">,</span> <span class="n">v_len</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">inputs_len</span> <span class="o">!=</span> <span class="n">v_len</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;v has invalid length: should be </span><span class="si">{</span><span class="n">inputs_len</span><span class="si">}</span><span class="s1">, but got </span><span class="si">{</span><span class="n">v_len</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="jvp"><a class="viewcode-back" href="../../../../../api_python/mindspore/mindspore.jvp.html#mindspore.jvp">[docs]</a><span class="k">def</span> <span class="nf">jvp</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the jacobian-vector-product of the given network. `jvp` matches</span>
<span class="sd">    `forward-mode differentiation</span>
<span class="sd">    &lt;https://www.mindspore.cn/docs/en/master/design/programming_paradigm.html#forward-mode-ad&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Function, Cell]): The function or net that takes Tensor inputs and returns single Tensor or tuple of</span>
<span class="sd">            Tensors.</span>
<span class="sd">        inputs (Union[Tensor, tuple[Tensor], list[Tensor]]): The inputs to `fn` .</span>
<span class="sd">        v (Union[Tensor, tuple[Tensor], list[Tensor]]): The vector in jacobian-vector-product. The shape and type of `v`</span>
<span class="sd">            should be the same as `inputs` .</span>
<span class="sd">        has_aux (bool): If ``True`` , only the first output of `fn` contributes the gradient of `fn`, while the other</span>
<span class="sd">            outputs will be returned straightly. It means the `fn` must return more than one outputs in this case.</span>
<span class="sd">            Default: ``False`` .</span>

<span class="sd">    Returns:</span>
<span class="sd">        - **net_output** (Union[Tensor, tuple[Tensor]]) - The output of `fn(inputs)` . Specially, when `has_aux` is set</span>
<span class="sd">          ``True`` , `netout` is the first output of `fn(inputs)` .</span>
<span class="sd">        - **jvp** (Union[Tensor, tuple[Tensor]]) - The result of jacobian-vector-product.</span>
<span class="sd">        - **aux_value** (Union[Tensor, tuple[Tensor]], optional) - When `has_aux` is ``True`` , `aux_value` will be</span>
<span class="sd">          returned. It means the second to last outputs of `fn(inputs)` . Specially, `aux_value` does not contribute to</span>
<span class="sd">          gradient.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: `inputs` or `v` does not belong to required types.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import jvp</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def construct(self, x, y):</span>
<span class="sd">        ...         return x**3 + y</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; v = Tensor(np.array([[1, 1], [1, 1]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; output = jvp(Net(), (x, y), (v, v))</span>
<span class="sd">        &gt;&gt;&gt; print(output[0])</span>
<span class="sd">        [[ 2. 10.]</span>
<span class="sd">         [30. 68.]]</span>
<span class="sd">        &gt;&gt;&gt; print(output[1])</span>
<span class="sd">        [[ 4. 13.]</span>
<span class="sd">         [28. 49.]]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def fn(x, y):</span>
<span class="sd">        ...     return x ** 3 + y, y</span>
<span class="sd">        &gt;&gt;&gt; output, jvp_out, aux = jvp(fn, (x, y), (v, v), has_aux=True)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[ 2. 10.]</span>
<span class="sd">         [30. 68.]]</span>
<span class="sd">        &gt;&gt;&gt; print(jvp_out)</span>
<span class="sd">        [[ 4. 13.]</span>
<span class="sd">         [28. 49.]]</span>
<span class="sd">        &gt;&gt;&gt; print(aux)</span>
<span class="sd">        [[ 1. 2.]</span>
<span class="sd">         [3. 4.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_has_aux_type</span><span class="p">(</span><span class="n">has_aux</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">aux_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When &#39;has_aux&#39; is True, origin &#39;fn&#39; requires more than one outputs.&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">grad_single</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">first_grad_single_value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">aux_fn</span><span class="p">)(</span><span class="o">*</span><span class="n">first_grad_single_value</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">fn</span><span class="p">)(</span><span class="o">*</span><span class="n">first_grad_single_value</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">grad_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">first_grad</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_grad_all</span><span class="p">(</span><span class="n">aux_fn</span><span class="p">)(</span><span class="o">*</span><span class="n">first_grad</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_grad_all</span><span class="p">(</span><span class="n">fn</span><span class="p">)(</span><span class="o">*</span><span class="n">first_grad</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_wrap_container_inner</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">):</span>
        <span class="n">jvp_inputs</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">aux_fn</span><span class="p">(</span><span class="o">*</span><span class="n">jvp_inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">jvp_inputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">mutable</span><span class="p">(</span><span class="n">oneslike</span><span class="p">(</span><span class="n">item</span><span class="p">)),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">mutable</span><span class="p">(</span><span class="n">oneslike</span><span class="p">(</span><span class="n">outputs</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jvp_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">second_grad_net</span> <span class="o">=</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">grad_single</span><span class="p">)</span>
            <span class="n">gradient_outputs</span> <span class="o">=</span> <span class="n">second_grad_net</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">jvp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">second_grad_net</span> <span class="o">=</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">grad_all</span><span class="p">)</span>
            <span class="n">gradient_outputs</span> <span class="o">=</span> <span class="n">second_grad_net</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">jvp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">jvp_inputs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gradient_outputs</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gradient_outputs</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">gradient_outputs</span>

    <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
        <span class="nd">@jit</span><span class="p">(</span><span class="n">hash_args</span><span class="o">=</span><span class="n">aux_fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_wrap_container</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_wrap_container_inner</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nd">@jit</span><span class="p">(</span><span class="n">hash_args</span><span class="o">=</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_wrap_container</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_wrap_container_inner</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">_raise_type_error</span><span class="p">()</span>

    <span class="n">inputs_len</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">v_len</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">inputs_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">v_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">_check_jvp_input_v_len</span><span class="p">(</span><span class="n">inputs_len</span><span class="p">,</span> <span class="n">v_len</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">_wrap_container</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_wrap_container</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">linearize</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produces a linear approximation to fun using jvp() and partial eval.</span>
<span class="sd">    This function is mainly useful if you want to apply jvp multiple times.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Function, Cell]): The function or net that takes Tensor inputs and returns single tensor or tuple of</span>
<span class="sd">            Tensors.</span>
<span class="sd">        inputs (Union[Tensor, Tuple or List of Tensors]): The inputs to `fn`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, tuple of output and jvp_fn.</span>

<span class="sd">        - **netout** (Tensor or Tuple of Tensors) - The output of &quot;fn(inputs)&quot;.</span>
<span class="sd">        - **jvp_fn** (Function) - The function that evaluates the Jacobian-vector product.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input is not a tensor or tuple or list of tensors.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor, Parameter, ops</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.ops.functional import linearize</span>

<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.matmul = ops.MatMul()</span>
<span class="sd">        ...     def construct(self, x, y):</span>
<span class="sd">        ...         out = self.matmul(x, y)</span>
<span class="sd">        ...         return out</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2, 3], [3, 4, 5]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor(np.array([[1, 2], [3, 4], [5, 6]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; v = (Tensor(np.array([[1, 1, 1], [1, 1, 1]]).astype(np.float32)),</span>
<span class="sd">        ...      Tensor(np.array([[1, 1], [1, 1], [0, 0]]).astype(np.float32)))</span>
<span class="sd">        &gt;&gt;&gt; output, jvp_fn = linearize(Net(), (x, y))</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[22. 28.]</span>
<span class="sd">         [40. 52.]]</span>
<span class="sd">        &gt;&gt;&gt; jvp = jvp_fn(v)</span>
<span class="sd">        &gt;&gt;&gt; print(jvp)</span>
<span class="sd">        [[12. 15.]</span>
<span class="sd">         [16. 19.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">linearize_inner</span> <span class="o">=</span> <span class="n">_LinearizeInner</span><span class="p">()</span>

    <span class="nd">@jit</span><span class="p">(</span><span class="n">hash_args</span><span class="o">=</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_wrap_container</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">vectors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">linearize_inner</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">vectors</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">_raise_type_error</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs</span><span class="p">,)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_wrap_container</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The inputs type must be Tensor.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The inputs type must be Tensor.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="n">_vjp_grad_op</span> <span class="o">=</span> <span class="n">_Grad</span><span class="p">(</span><span class="n">get_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sens_param</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">merge_forward</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">_vjp_grad_op_with_weight</span> <span class="o">=</span> <span class="n">_Grad</span><span class="p">(</span><span class="n">get_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_by_list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sens_param</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">merge_forward</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="vjp"><a class="viewcode-back" href="../../../../../api_python/mindspore/mindspore.vjp.html#mindspore.vjp">[docs]</a><span class="k">def</span> <span class="nf">vjp</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the vector-jacobian-product of the given network. `vjp` matches</span>
<span class="sd">    `reverse-mode differentiation</span>
<span class="sd">    &lt;https://www.mindspore.cn/docs/en/master/design/programming_paradigm.html#reverse-mode-ad&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Function, Cell]): The function or net that takes Tensor inputs and returns single Tensor or tuple of</span>
<span class="sd">            Tensors.</span>
<span class="sd">        inputs (Union[Tensor, tuple[Tensor], list[Tensor]]): The inputs to `fn` .</span>
<span class="sd">        weights (Union[ParameterTuple, Parameter, list[Parameter]]): The parameters of the training network that need to</span>
<span class="sd">            calculate the gradient. `weights` can be got through `weights = net.trainable_params()` .</span>
<span class="sd">            Default: ``None`` .</span>
<span class="sd">        has_aux (bool): If True, only the first output of `fn` contributes the gradient of `fn`, while the other outputs</span>
<span class="sd">            will be returned straightly. It means the `fn` must return more than one outputs in this case.</span>
<span class="sd">            Default: ``False``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Forward outputs and function to calculate vjp.</span>

<span class="sd">        - **net_output** (Union[Tensor, tuple[Tensor]]) - The output of `fn(inputs)`. Specially, when `has_aux` is set</span>
<span class="sd">          True, `netout` is the first output of `fn(inputs)`.</span>
<span class="sd">        - **vjp_fn** (Function) - To calculate vector-jacobian-product. Its inputs are the vectors whose shape and</span>
<span class="sd">          type should be the same as `netout` .</span>
<span class="sd">        - **aux_value** (Union[Tensor, tuple[Tensor]], optional) - When `has_aux` is True, `aux_value` will be returned.</span>
<span class="sd">          It means the second to last outputs of `fn(inputs)`. Specially, `aux_value` does not contribute to gradient.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: `inputs` or `v` does not belong to required types.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import vjp</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def construct(self, x, y):</span>
<span class="sd">        ...         return x**3 + y</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; v = Tensor(np.array([[1, 1], [1, 1]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; outputs, vjp_fn = vjp(Net(), x, y)</span>
<span class="sd">        &gt;&gt;&gt; print(outputs)</span>
<span class="sd">        [[ 2. 10.]</span>
<span class="sd">         [30. 68.]]</span>
<span class="sd">        &gt;&gt;&gt; gradient = vjp_fn(v)</span>
<span class="sd">        &gt;&gt;&gt; print(gradient)</span>
<span class="sd">        (Tensor(shape=[2, 2], dtype=Float32, value=</span>
<span class="sd">        [[ 3.00000000e+00,  1.20000000e+01],</span>
<span class="sd">         [ 2.70000000e+01,  4.80000000e+01]]), Tensor(shape=[2, 2], dtype=Float32, value=</span>
<span class="sd">        [[ 1.00000000e+00,  1.00000000e+00],</span>
<span class="sd">         [ 1.00000000e+00,  1.00000000e+00]]))</span>
<span class="sd">        &gt;&gt;&gt; def fn(x, y):</span>
<span class="sd">        ...     return 2 * x + y, y ** 3</span>
<span class="sd">        &gt;&gt;&gt; outputs, vjp_fn, aux = vjp(fn, x, y, has_aux=True)</span>
<span class="sd">        &gt;&gt;&gt; gradient = vjp_fn(v)</span>
<span class="sd">        &gt;&gt;&gt; print(outputs)</span>
<span class="sd">        [[ 3.  6.]</span>
<span class="sd">         [ 9. 12.]]</span>
<span class="sd">        &gt;&gt;&gt; print(aux)</span>
<span class="sd">        [[ 1.  8.]</span>
<span class="sd">         [27. 64.]]</span>
<span class="sd">        &gt;&gt;&gt; print(gradient)</span>
<span class="sd">        (Tensor(shape=[2, 2], dtype=Float32, value=</span>
<span class="sd">        [[ 2.00000000e+00,  2.00000000e+00],</span>
<span class="sd">         [ 2.00000000e+00,  2.00000000e+00]]), Tensor(shape=[2, 2], dtype=Float32, value=</span>
<span class="sd">        [[ 1.00000000e+00,  1.00000000e+00],</span>
<span class="sd">         [ 1.00000000e+00,  1.00000000e+00]]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">_check_has_aux_type</span><span class="p">(</span><span class="n">has_aux</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">aux_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When &#39;has_aux&#39; is True, origin &#39;fn&#39; requires more than one outputs.&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">wrap_container</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">):</span>
        <span class="n">_check_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="n">fn_</span> <span class="o">=</span> <span class="n">aux_fn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn_</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="n">sens</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sens</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_vjp_grad_op</span><span class="p">(</span><span class="n">fn_</span><span class="p">)(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">sens</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_vjp_grad_op_with_weight</span><span class="p">(</span><span class="n">fn_</span><span class="p">,</span> <span class="n">weights</span><span class="p">)(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">sens</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wrap_container</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wrap_container</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">wrap_container</span></div>


<span class="nd">@_primexpr</span>
<span class="k">def</span> <span class="nf">_jac_generate_target_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For given length = len(x), this method generates target dimension tuple (1, 2, 3,..., length, 0).&quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="n">dim</span> <span class="o">+=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span>
    <span class="n">target_dimension</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">target_dimension</span>


<span class="k">def</span> <span class="nf">_jacfwd_trans_item</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">inputs_shape</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;transfer origin item to derivative of each output with respect to each input.&quot;&quot;&quot;</span>
    <span class="n">output_wrt_input_all</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grad_position</span><span class="p">:</span>
        <span class="n">origin_output_wrt_input</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="n">inputs_shape</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span><span class="n">inputs_shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">target_dimension</span> <span class="o">=</span> <span class="n">_jac_generate_target_dimension</span><span class="p">(</span><span class="n">origin_output_wrt_input</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">origin_output_wrt_input</span><span class="p">,</span> <span class="n">target_dimension</span><span class="p">)</span>
        <span class="n">output_wrt_input</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">inputs_shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">output_wrt_input_all</span> <span class="o">+=</span> <span class="p">(</span><span class="n">output_wrt_input</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">output_wrt_input_all</span>


<span class="k">def</span> <span class="nf">_jac_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;reformat jacobian.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;forward&#39;</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_jacfwd_trans_item</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_jacrev_trans_item</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">jacobian</span> <span class="o">+=</span> <span class="n">func</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">jacobian</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">input_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad_position</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">%</span> <span class="n">input_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The numbers of inputs and outputs do not match.&quot;</span><span class="p">)</span>
    <span class="n">output_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">//</span> <span class="n">input_num</span>
    <span class="k">if</span> <span class="n">input_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">output_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="n">jac</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">output_num</span><span class="p">):</span>
        <span class="n">input_grad</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_num</span><span class="p">):</span>
            <span class="n">input_grad</span> <span class="o">+=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">input_num</span> <span class="o">+</span> <span class="n">j</span><span class="p">],)</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;forward&#39;</span> <span class="k">else</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">output_num</span> <span class="o">+</span> <span class="n">i</span><span class="p">],)</span>
        <span class="n">jac</span> <span class="o">+=</span> <span class="p">(</span><span class="n">input_grad</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">jac</span>


<span class="k">def</span> <span class="nf">_jacfwd_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">inputs_shape</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;reformat forward-computed Jacobian.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_jac_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">inputs_shape</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">,</span> <span class="s1">&#39;forward&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_jacfwd_construct_v</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For input (x1, x2), x1.shape = (a, b), x2.shape = (c, d), this method generates corresponding v (v1, v2),</span>
<span class="sd">    v1.shape = (N, a, b), v2.shape = (N, c, d), while N = a*b + c*d.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">primals</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">inputs_shape</span> <span class="o">=</span> <span class="p">(((),</span> <span class="mi">0</span><span class="p">),)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">items_num</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">cum_num</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="n">size</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">inputs_shape</span> <span class="o">+=</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">num</span><span class="p">),)</span>
        <span class="n">items_num</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">item</span><span class="p">),)</span>
        <span class="n">cum_num</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">item_size</span> <span class="o">=</span> <span class="n">items_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grad_position</span><span class="p">:</span>
            <span class="n">temp2</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span> <span class="o">-</span><span class="n">cum_num</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp2</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">num</span><span class="p">,</span> <span class="n">item_size</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">input_v</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">temp2</span><span class="p">,</span> <span class="p">(</span><span class="n">num</span><span class="p">,)</span> <span class="o">+</span> <span class="n">element</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">primal</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">num</span><span class="p">,)</span> <span class="o">+</span> <span class="n">element</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">+=</span> <span class="p">(</span><span class="n">input_v</span><span class="p">,)</span>
        <span class="n">primals</span> <span class="o">+=</span> <span class="p">(</span><span class="n">primal</span><span class="p">,)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inputs_shape</span>
    <span class="k">return</span> <span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">inputs_shape</span>


<span class="n">_vmap</span> <span class="o">=</span> <span class="n">_Vmap</span><span class="p">()</span>


<div class="viewcode-block" id="jacfwd"><a class="viewcode-back" href="../../../../../api_python/mindspore/mindspore.jacfwd.html#mindspore.jacfwd">[docs]</a><span class="k">def</span> <span class="nf">jacfwd</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">grad_position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Jacobian via forward mode, corresponding to</span>
<span class="sd">    `forward-mode differentiation</span>
<span class="sd">    &lt;https://www.mindspore.cn/docs/en/master/design/programming_paradigm.html#forward-mode-ad&gt;`_.</span>
<span class="sd">    When number of outputs is much greater than that of inputs, it&#39;s better to calculate Jacobian via forward mode than</span>
<span class="sd">    reverse mode to get better performance.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Cell, Function]): Function to do GradOperation.</span>
<span class="sd">        grad_position (Union[int, tuple[int]], optional): If int, get the gradient with respect to single input.</span>
<span class="sd">            If tuple, get the gradients with respect to selected inputs. &#39;grad_position&#39; begins with 0. Default: ``0`` .</span>
<span class="sd">        has_aux (bool, optional): If ``True`` , only the first output of `fn` contributes the gradient of `fn`,</span>
<span class="sd">            while the other outputs will be returned straightly. It means the `fn` must return more than one</span>
<span class="sd">            outputs in this case. Default: ``False`` .</span>

<span class="sd">    Returns:</span>
<span class="sd">        Function, returns the Jacobian function for the input function or cell.</span>
<span class="sd">        For example, as for `out1, out2 = fn(*args)`, when `has_aux` is set ``True`` , gradient function will return</span>
<span class="sd">        outputs like `(Jacobian, out2)` and `out2` does not contribute to the differentiation, otherwise `Jacobian` .</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: `grad_position` or `has_aux` does not belong to required types.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import jacfwd</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; class MultipleInputsMultipleOutputsNet(nn.Cell):</span>
<span class="sd">        ...     def construct(self, x, y, z):</span>
<span class="sd">        ...         return x ** 2 + y ** 2 + z ** 2, x * y * z</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; z = Tensor(np.array([[1, 1], [1, 1]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; net = MultipleInputsMultipleOutputsNet()</span>
<span class="sd">        &gt;&gt;&gt; jac, aux = jacfwd(net, grad_position=0, has_aux=True)(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; print(jac)</span>
<span class="sd">        [[[[ 2.  0.]</span>
<span class="sd">           [ 0.  0.]]</span>
<span class="sd">          [[ 0.  4.]</span>
<span class="sd">           [ 0.  0.]]]</span>
<span class="sd">         [[[ 0.  0.]</span>
<span class="sd">           [ 6.  0.]]</span>
<span class="sd">          [[ 0.  0.]</span>
<span class="sd">           [ 0.  8.]]]]</span>
<span class="sd">        &gt;&gt;&gt; print(aux)</span>
<span class="sd">        [[ 1.  4.]</span>
<span class="sd">         [ 9. 16.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_has_aux_type</span><span class="p">(</span><span class="n">has_aux</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">aux_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When &#39;has_aux&#39; is True, origin &#39;fn&#39; requires more than one outputs.&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">grad_single</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">first_grad_single_value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">aux_fn</span><span class="p">)(</span><span class="o">*</span><span class="n">first_grad_single_value</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">fn</span><span class="p">)(</span><span class="o">*</span><span class="n">first_grad_single_value</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">grad_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">first_grad</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_grad_all</span><span class="p">(</span><span class="n">aux_fn</span><span class="p">)(</span><span class="o">*</span><span class="n">first_grad</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_grad_all</span><span class="p">(</span><span class="n">fn</span><span class="p">)(</span><span class="o">*</span><span class="n">first_grad</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="nd">@jit</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">checked_grad_position</span> <span class="o">=</span> <span class="n">_check_grad_position</span><span class="p">(</span><span class="n">grad_position</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">inputs_shape</span> <span class="o">=</span> <span class="n">_jacfwd_construct_v</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">checked_grad_position</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">inner_fn</span><span class="p">(</span><span class="n">jvp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">):</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">jvp_inputs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="p">()</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">mutable</span><span class="p">(</span><span class="n">oneslike</span><span class="p">(</span><span class="n">item</span><span class="p">)),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">mutable</span><span class="p">(</span><span class="n">oneslike</span><span class="p">(</span><span class="n">outputs</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jvp_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">second_grad_net</span> <span class="o">=</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">grad_single</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">second_grad_net</span> <span class="o">=</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">grad_all</span><span class="p">)</span>
            <span class="n">gradient_outputs</span> <span class="o">=</span> <span class="n">second_grad_net</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">jvp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gradient_outputs</span>

        <span class="k">def</span> <span class="nf">inner_aux_fn</span><span class="p">(</span><span class="n">jvp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">):</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">aux_fn</span><span class="p">(</span><span class="o">*</span><span class="n">jvp_inputs</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">mutable</span><span class="p">(</span><span class="n">oneslike</span><span class="p">(</span><span class="n">outputs</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jvp_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">second_grad_net</span> <span class="o">=</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">grad_single</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">second_grad_net</span> <span class="o">=</span> <span class="n">_grad_single</span><span class="p">(</span><span class="n">grad_all</span><span class="p">)</span>
            <span class="n">gradient_outputs</span> <span class="o">=</span> <span class="n">second_grad_net</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">jvp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gradient_outputs</span>

        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_vmap</span><span class="p">(</span><span class="n">inner_aux_fn</span><span class="p">)(</span><span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">jac_res</span> <span class="o">=</span> <span class="n">_jacfwd_postprocess</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">inputs_shape</span><span class="p">,</span> <span class="n">checked_grad_position</span><span class="p">)</span>
            <span class="n">forward_outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forward_outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">jac_res</span><span class="p">,</span> <span class="n">forward_outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">jac_res</span><span class="p">,</span> <span class="n">forward_outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_vmap</span><span class="p">(</span><span class="n">inner_fn</span><span class="p">)(</span><span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">jac_res</span> <span class="o">=</span> <span class="n">_jacfwd_postprocess</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">inputs_shape</span><span class="p">,</span> <span class="n">checked_grad_position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jac_res</span>

    <span class="k">return</span> <span class="n">wrapped</span></div>


<span class="k">def</span> <span class="nf">_jacrev_trans_item</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">outputs_shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;transfer origin item to derivative of each output with respect to each input.&quot;&quot;&quot;</span>
    <span class="n">output_wrt_input_all</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">origin_output_wrt_input</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="n">outputs_shape</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span><span class="n">outputs_shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">target_dimension</span> <span class="o">=</span> <span class="n">_jac_generate_target_dimension</span><span class="p">(</span><span class="n">origin_output_wrt_input</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">origin_output_wrt_input</span><span class="p">,</span> <span class="n">target_dimension</span><span class="p">)</span>
        <span class="n">output_wrt_input</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">origin_output_wrt_input</span><span class="p">,</span> <span class="n">outputs_shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">output_wrt_input_all</span> <span class="o">+=</span> <span class="p">(</span><span class="n">output_wrt_input</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">output_wrt_input_all</span>


<span class="k">def</span> <span class="nf">_jacrev_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">outputs_shape</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;reformat reverse-computed jacobian.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_jac_postprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">outputs_shape</span><span class="p">,</span> <span class="n">grad_position</span><span class="p">,</span> <span class="s1">&#39;reverse&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_jacrev_construct_v</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For outputs (y1, y2), y1.shape = (a, b), y2.shape = (c, d), this method generates corresponding v (v1, v2),</span>
<span class="sd">    v1.shape = (N, a, b), v2.shape = (N, c, d), while N = a*b + c*d.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">primals</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">outputs_shape</span> <span class="o">=</span> <span class="p">(((),</span> <span class="mi">0</span><span class="p">),)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">items_num</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">cum_num</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="n">item_num</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="n">item_num</span>
        <span class="n">outputs_shape</span> <span class="o">+=</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">num</span><span class="p">),)</span>
        <span class="n">items_num</span> <span class="o">+=</span> <span class="p">(</span><span class="n">item_num</span><span class="p">,)</span>
        <span class="n">cum_num</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
        <span class="n">primal</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">num</span><span class="p">,)</span> <span class="o">+</span> <span class="n">element</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">primals</span> <span class="o">+=</span> <span class="p">(</span><span class="n">primal</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
        <span class="n">item_size</span> <span class="o">=</span> <span class="n">items_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">temp2</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span> <span class="o">-</span><span class="n">cum_num</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">output_v</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">temp2</span><span class="p">,</span> <span class="p">(</span><span class="n">num</span><span class="p">,)</span> <span class="o">+</span> <span class="n">element</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">+=</span> <span class="p">(</span><span class="n">output_v</span><span class="p">,)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">has_aux</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">outputs_shape</span>
    <span class="k">return</span> <span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">outputs_shape</span>


<span class="n">_grad</span> <span class="o">=</span> <span class="n">_Grad</span><span class="p">(</span><span class="n">get_by_position</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sens_param</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="jacrev"><a class="viewcode-back" href="../../../../../api_python/mindspore/mindspore.jacrev.html#mindspore.jacrev">[docs]</a><span class="k">def</span> <span class="nf">jacrev</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">grad_position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Jacobian via reverse mode, corresponding to</span>
<span class="sd">    `reverse-mode differentiation</span>
<span class="sd">    &lt;https://www.mindspore.cn/docs/en/master/design/programming_paradigm.html#reverse-mode-ad&gt;`_.</span>
<span class="sd">    When number of inputs is much greater than that of outputs, it&#39;s better to calculate Jacobian via reverse mode than</span>
<span class="sd">    forward mode to get better performance.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (Union[Cell, Function]): Function to do GradOperation.</span>
<span class="sd">        grad_position (Union[int, tuple[int]], optional): If int, get the gradient with respect to single input.</span>
<span class="sd">            If tuple, get the gradients with respect to selected inputs. &#39;grad_position&#39; begins with 0. Default: ``0`` .</span>
<span class="sd">        has_aux (bool, optional): If ``True`` , only the first output of `fn` contributes the gradient of `fn`,</span>
<span class="sd">            while the other outputs will be returned straightly. It means the `fn` must return more than</span>
<span class="sd">            one outputs in this case. Default: ``False`` .</span>

<span class="sd">    Returns:</span>
<span class="sd">        Function, returns the Jacobian function for the input function or cell.</span>
<span class="sd">        For example, as for `out1, out2 = fn(*args)`, when `has_aux` is set ``True`` , gradient function will return</span>
<span class="sd">        outputs like `(Jacobian, out2)` and `out2` does not contribute to the differentiation, otherwise `Jacobian` .</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: `grad_position` or `has_aux` does not belong to required types.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import jacrev</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; class MultipleInputsMultipleOutputsNet(nn.Cell):</span>
<span class="sd">        ...     def construct(self, x, y, z):</span>
<span class="sd">        ...         return x ** 2 + y ** 2 + z ** 2, x * y * z</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor(np.array([[1, 2], [3, 4]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; z = Tensor(np.array([[1, 1], [1, 1]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; net = MultipleInputsMultipleOutputsNet()</span>
<span class="sd">        &gt;&gt;&gt; jac, aux = jacrev(net, grad_position=0, has_aux=True)(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; print(jac)</span>
<span class="sd">        [[[[ 2.  0.]</span>
<span class="sd">           [ 0.  0.]]</span>
<span class="sd">          [[ 0.  4.]</span>
<span class="sd">           [ 0.  0.]]]</span>
<span class="sd">         [[[ 0.  0.]</span>
<span class="sd">           [ 6.  0.]]</span>
<span class="sd">          [[ 0.  0.]</span>
<span class="sd">           [ 0.  8.]]]]</span>
<span class="sd">        &gt;&gt;&gt; print(aux)</span>
<span class="sd">        [[ 1.  4.]</span>
<span class="sd">         [ 9. 16.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_has_aux_type</span><span class="p">(</span><span class="n">has_aux</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">aux_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When &#39;has_aux&#39; is True, origin &#39;fn&#39; requires more than one outputs.&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@jit</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">checked_grad_position</span> <span class="o">=</span> <span class="n">_check_grad_position</span><span class="p">(</span><span class="n">grad_position</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">outputs_shape</span> <span class="o">=</span> <span class="n">_jacrev_construct_v</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">has_aux</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">inner_fn</span><span class="p">(</span><span class="n">vjp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">):</span>
            <span class="n">gradient_outputs</span> <span class="o">=</span> <span class="n">_grad</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">checked_grad_position</span><span class="p">)(</span><span class="o">*</span><span class="n">vjp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gradient_outputs</span>

        <span class="k">def</span> <span class="nf">inner_aux_fn</span><span class="p">(</span><span class="n">vjp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">):</span>
            <span class="n">gradient_outputs</span> <span class="o">=</span> <span class="n">_grad</span><span class="p">(</span><span class="n">aux_fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">checked_grad_position</span><span class="p">)(</span><span class="o">*</span><span class="n">vjp_inputs</span><span class="p">,</span> <span class="n">vectors</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gradient_outputs</span>

        <span class="k">if</span> <span class="n">has_aux</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_vmap</span><span class="p">(</span><span class="n">inner_aux_fn</span><span class="p">)(</span><span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">jac_res</span> <span class="o">=</span> <span class="n">_jacrev_postprocess</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">outputs_shape</span><span class="p">,</span> <span class="n">checked_grad_position</span><span class="p">)</span>
            <span class="n">forward_outputs</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forward_outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">jac_res</span><span class="p">,</span> <span class="n">forward_outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">jac_res</span><span class="p">,</span> <span class="n">forward_outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">_vmap</span><span class="p">(</span><span class="n">inner_fn</span><span class="p">)(</span><span class="n">primals</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">jac_res</span> <span class="o">=</span> <span class="n">_jacrev_postprocess</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">outputs_shape</span><span class="p">,</span> <span class="n">checked_grad_position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jac_res</span>

    <span class="k">return</span> <span class="n">wrapped</span></div>


<span class="k">def</span> <span class="nf">custom_vjp</span><span class="p">(</span><span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Support vjp to custom bprop for function.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn (function): The `fn` that need to define custom bprop. Default: ``None``.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="k">class</span> <span class="nc">CustomVjp</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The CustomVjp decorates function into cell to support custom bprop.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fwd</span><span class="p">):</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">CustomVjp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fwd</span> <span class="o">=</span> <span class="n">fwd</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bwd</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_flags</span><span class="p">(</span><span class="n">custom_vjp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">defbwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bwd</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bwd</span> <span class="o">=</span> <span class="n">bwd</span>

            <span class="k">def</span> <span class="nf">bprop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bwd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CustomVjp</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">deco</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">deco</span>


<div class="viewcode-block" id="stop_gradient"><a class="viewcode-back" href="../../../../../api_python/ops/mindspore.ops.stop_gradient.html#mindspore.stop_gradient">[docs]</a><span class="k">def</span> <span class="nf">stop_gradient</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    StopGradient is used for eliminating the effect of a value on the gradient, such as truncating</span>
<span class="sd">    the gradient propagation from an output of a function.</span>
<span class="sd">    For more details, please refer to `Stop Gradient</span>
<span class="sd">    &lt;https://www.mindspore.cn/tutorials/en/master/beginner/autograd.html#stop-gradient&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        value (Any): The value whose effect on the gradient to be eliminated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The same as `value`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.ops as ops</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; def net(x, y):</span>
<span class="sd">        ...     out1 = ops.MatMul()(x, y)</span>
<span class="sd">        ...     out2 = ops.MatMul()(x, y)</span>
<span class="sd">        ...     out2 = ops.stop_gradient(out2)</span>
<span class="sd">        ...     return out1, out2</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([[0.5, 0.6, 0.4], [1.2, 1.3, 1.1]], dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; y = Tensor([[0.01, 0.3, 1.1], [0.1, 0.2, 1.3], [2.1, 1.2, 3.3]], dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; grad_fn = ops.grad(net)</span>
<span class="sd">        &gt;&gt;&gt; output = grad_fn(x, y)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[1.4100001 1.6       6.5999994]</span>
<span class="sd">         [1.4100001 1.6       6.5999994]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">P</span><span class="o">.</span><span class="n">StopGradient</span><span class="p">()(</span><span class="n">value</span><span class="p">)</span></div>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;grad&#39;</span><span class="p">,</span>
    <span class="s1">&#39;value_and_grad&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jacfwd&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jacrev&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jet&#39;</span><span class="p">,</span>
    <span class="s1">&#39;derivative&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jvp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;vjp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;linearize&#39;</span><span class="p">,</span>
    <span class="s1">&#39;stop_gradient&#39;</span><span class="p">,</span>
    <span class="s1">&#39;get_grad&#39;</span>
<span class="p">]</span>
<span class="n">__all__</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>