<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.dataset.vision.transforms &mdash; MindSpore master documentation</title>
      <link rel="stylesheet" href="../../../../_static/css/bootstrap.min.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/training.css" type="text/css" /><link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/js/training.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/auto_gradient.html">Functional Differential Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/distributed_training_design.html">Distributed Training Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/mindir.html">MindSpore IR (MindIR)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/thor.html">Second Order Optimizer</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.mindspore.cn/mindinsight/docs/en/r1.8/training_visual_design.html">Design of Visualization↗</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Specification</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/benchmark.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/network_list.html">Network List</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/operator_list.html">Operator List</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/syntax_list.html">Syntax Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.amp.html">mindspore.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.audio.html">mindspore.dataset.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.config.html">mindspore.dataset.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.text.html">mindspore.dataset.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.vision.html">mindspore.dataset.vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.transformer.html">mindspore.nn.transformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.functional.html">mindspore.ops.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.parallel.nn.html">mindspore.parallel.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.scipy.html">mindspore.scipy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.boost.html">mindspore.boost</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.mindspore.cn/lite/api/en/r1.8/api_cpp/mindspore.html">C++ API↗</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Mapping</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/api_mapping/pytorch_api_mapping.html">PyTorch and MindSpore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/api_mapping/tensorflow_api_mapping.html">TensorFlow and MindSpore</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Migration Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/preparation.html">Preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/script_analysis.html">Network Script Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/script_development.html">Network Script Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/neural_network_debug.html">Network Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/performance_optimization.html">Performance Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/inference.html">Inference Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/sample_code.html">Network Migration Debugging Example</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/data_processing.html">Data Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/implement_problem.html">Implement Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/network_compilation.html">Network Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/operators_compile.html">Operators Compile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/usage_migrate_3rd.html">Migration from a Third-party Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/performance_tuning.html">Performance Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/precision_tuning.html">Precision Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/distributed_configure.html">Distributed Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/feature_advice.html">Feature Advice</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>mindspore.dataset.vision.transforms</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mindspore.dataset.vision.transforms</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019-2022 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ==============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The module vision.transforms provides many kinds of image augmentation methods</span>
<span class="sd">and image-related conversion methods</span>
<span class="sd">(e.g. including with PIL.Image.Image and numpy.ndarray).</span>
<span class="sd">to perform various computer vision tasks.</span>
<span class="sd">Users can apply suitable augmentations on image data</span>
<span class="sd">to improve their training models.</span>
<span class="sd">Users can also self-define their own augmentation methods with Python Pillow (PIL)</span>

<span class="sd">For the different methods in this module, implementation is based in C++ and/or Python.</span>
<span class="sd">The C++ implementation is inherited from mindspore._c_dataengine, provides high performance</span>
<span class="sd">and is mainly based on OpenCV.</span>
<span class="sd">The Python implementation is mainly based on PIL.</span>

<span class="sd">.. Note::</span>
<span class="sd">    A constructor&#39;s arguments for every class in this module must be saved into the</span>
<span class="sd">    class attributes (self.xxx) to support save() and load().</span>

<span class="sd">Examples:</span>
<span class="sd">    &gt;&gt;&gt; from mindspore.dataset.vision import Border, Inter</span>
<span class="sd">    &gt;&gt;&gt; image_folder_dataset_dir = &quot;/path/to/image_folder_dataset_directory&quot;</span>
<span class="sd">    &gt;&gt;&gt; # create a dataset that reads all files in dataset_dir with 8 threads</span>
<span class="sd">    &gt;&gt;&gt; image_folder_dataset = ds.ImageFolderDataset(image_folder_dataset_dir,</span>
<span class="sd">    ...                                              num_parallel_workers=8)</span>
<span class="sd">    &gt;&gt;&gt; # create a list of transformations to be applied to the image data</span>
<span class="sd">    &gt;&gt;&gt; transforms_list = [vision.Decode(),</span>
<span class="sd">    ...                    vision.Resize((256, 256), interpolation=Inter.LINEAR),</span>
<span class="sd">    ...                    vision.RandomCrop(200, padding_mode=Border.EDGE),</span>
<span class="sd">    ...                    vision.RandomRotation((0, 15)),</span>
<span class="sd">    ...                    vision.Normalize((100, 115.0, 121.0), (71.0, 68.0, 70.0)),</span>
<span class="sd">    ...                    vision.HWC2CHW()]</span>
<span class="sd">    &gt;&gt;&gt; onehot_op = transforms.OneHot(num_classes=10)</span>
<span class="sd">    &gt;&gt;&gt; # apply the transformation to the dataset through data1.map()</span>
<span class="sd">    &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">    ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=onehot_op,</span>
<span class="sd">    ...                                                 input_columns=&quot;label&quot;)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="kn">import</span> <span class="nn">mindspore._c_dataengine</span> <span class="k">as</span> <span class="nn">cde</span>
<span class="kn">from</span> <span class="nn">mindspore._c_expression</span> <span class="kn">import</span> <span class="n">typing</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">py_transforms_util</span> <span class="k">as</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.py_transforms_util</span> <span class="kn">import</span> <span class="n">is_pil</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">AutoAugmentPolicy</span><span class="p">,</span> <span class="n">Border</span><span class="p">,</span> <span class="n">ConvertMode</span><span class="p">,</span> <span class="n">ImageBatchFormat</span><span class="p">,</span> <span class="n">Inter</span><span class="p">,</span> <span class="n">SliceMode</span><span class="p">,</span> <span class="n">parse_padding</span>
<span class="kn">from</span> <span class="nn">.validators</span> <span class="kn">import</span> <span class="n">check_adjust_gamma</span><span class="p">,</span> <span class="n">check_alpha</span><span class="p">,</span> <span class="n">check_auto_augment</span><span class="p">,</span> <span class="n">check_auto_contrast</span><span class="p">,</span> \
    <span class="n">check_bounding_box_augment_cpp</span><span class="p">,</span> <span class="n">check_center_crop</span><span class="p">,</span> <span class="n">check_convert_color</span><span class="p">,</span> <span class="n">check_crop</span><span class="p">,</span> <span class="n">check_cut_mix_batch_c</span><span class="p">,</span> \
    <span class="n">check_cutout_new</span><span class="p">,</span> <span class="n">check_decode</span><span class="p">,</span> <span class="n">check_five_crop</span><span class="p">,</span> <span class="n">check_gaussian_blur</span><span class="p">,</span> <span class="n">check_hsv_to_rgb</span><span class="p">,</span> <span class="n">check_linear_transform</span><span class="p">,</span> \
    <span class="n">check_mix_up</span><span class="p">,</span> <span class="n">check_mix_up_batch_c</span><span class="p">,</span> <span class="n">check_normalize</span><span class="p">,</span> <span class="n">check_normalizepad</span><span class="p">,</span> <span class="n">check_num_channels</span><span class="p">,</span> <span class="n">check_pad</span><span class="p">,</span> \
    <span class="n">check_pad_to_size</span><span class="p">,</span> <span class="n">check_positive_degrees</span><span class="p">,</span> <span class="n">check_posterize</span><span class="p">,</span> <span class="n">check_prob</span><span class="p">,</span> <span class="n">check_random_adjust_sharpness</span><span class="p">,</span> \
    <span class="n">check_random_affine</span><span class="p">,</span> <span class="n">check_random_auto_contrast</span><span class="p">,</span> <span class="n">check_random_color_adjust</span><span class="p">,</span> <span class="n">check_random_crop</span><span class="p">,</span> \
    <span class="n">check_random_erasing</span><span class="p">,</span> <span class="n">check_random_perspective</span><span class="p">,</span> <span class="n">check_random_resize_crop</span><span class="p">,</span> <span class="n">check_random_rotation</span><span class="p">,</span> \
    <span class="n">check_random_select_subpolicy_op</span><span class="p">,</span> <span class="n">check_random_solarize</span><span class="p">,</span> <span class="n">check_range</span><span class="p">,</span> <span class="n">check_rescale</span><span class="p">,</span> <span class="n">check_resize</span><span class="p">,</span> \
    <span class="n">check_resize_interpolation</span><span class="p">,</span> <span class="n">check_rgb_to_hsv</span><span class="p">,</span> <span class="n">check_rotate</span><span class="p">,</span> <span class="n">check_slice_patches</span><span class="p">,</span> <span class="n">check_ten_crop</span><span class="p">,</span> \
    <span class="n">check_uniform_augment</span><span class="p">,</span> <span class="n">check_to_tensor</span><span class="p">,</span> <span class="n">FLOAT_MAX_INTEGER</span>
<span class="kn">from</span> <span class="nn">..core.datatypes</span> <span class="kn">import</span> <span class="n">mstype_to_detype</span><span class="p">,</span> <span class="n">nptype_to_detype</span>
<span class="kn">from</span> <span class="nn">..transforms.py_transforms_util</span> <span class="kn">import</span> <span class="n">Implementation</span>
<span class="kn">from</span> <span class="nn">..transforms.transforms</span> <span class="kn">import</span> <span class="n">CompoundOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">,</span> <span class="n">TensorOperation</span><span class="p">,</span> <span class="n">TypeCast</span>


<span class="k">class</span> <span class="nc">ImageTensorOperation</span><span class="p">(</span><span class="n">TensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of Image Tensor Ops</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">input_tensor_list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">input_tensor_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input should be NumPy or PIL image, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tensor</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">input_tensor_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Note: subclasses must implement `def parse(self)` so do not make ImageTensorOperation&#39;s parse a staticmethod.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;ImageTensorOperation has to implement parse() method.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="AdjustGamma"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.AdjustGamma.html#mindspore.dataset.vision.AdjustGamma">[docs]</a><span class="k">class</span> <span class="nc">AdjustGamma</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply gamma correction on input image. Input image is expected to be in [..., H, W, C] or [H, W] format.</span>

<span class="sd">    .. math::</span>
<span class="sd">        I_{\text{out}} = 255 \times \text{gain} \times \left(\frac{I_{\text{in}}}{255}\right)^{\gamma}</span>

<span class="sd">    See `Gamma Correction`_ for more details.</span>

<span class="sd">    .. _Gamma Correction: https://en.wikipedia.org/wiki/Gamma_correction</span>

<span class="sd">    Args:</span>
<span class="sd">        gamma (float): Non negative real number.</span>
<span class="sd">            The output image pixel value is exponentially related to the input image pixel value.</span>
<span class="sd">            gamma larger than 1 make the shadows darker,</span>
<span class="sd">            while gamma smaller than 1 make dark regions lighter.</span>
<span class="sd">        gain (float, optional): The constant multiplier (default=1).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `gain` is not of type float.</span>
<span class="sd">        TypeError: If `gamma` is not of type float.</span>
<span class="sd">        ValueError: If `gamma` is less than 0.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;..., H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.AdjustGamma(gamma=10.0, gain=1.0)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_adjust_gamma</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain</span> <span class="o">=</span> <span class="n">gain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">AdjustGammaOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="p">)</span>

<div class="viewcode-block" id="AdjustGamma.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.AdjustGamma.html#mindspore.dataset.vision.AdjustGamma.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be gamma adjusted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, gamma adjusted image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">adjust_gamma</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AutoAugment"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.AutoAugment.html#mindspore.dataset.vision.AutoAugment">[docs]</a><span class="k">class</span> <span class="nc">AutoAugment</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply AutoAugment data augmentation method based on</span>
<span class="sd">    `AutoAugment: Learning Augmentation Strategies from Data &lt;https://arxiv.org/pdf/1805.09501.pdf&gt;`_.</span>
<span class="sd">    This operation works only with 3-channel RGB images.</span>

<span class="sd">    Args:</span>
<span class="sd">        policy (AutoAugmentPolicy, optional): AutoAugment policies learned on different datasets</span>
<span class="sd">            (default=AutoAugmentPolicy.IMAGENET).</span>
<span class="sd">            It can be any of [AutoAugmentPolicy.IMAGENET, AutoAugmentPolicy.CIFAR10, AutoAugmentPolicy.SVHN].</span>
<span class="sd">            Randomly apply 2 operations from a candidate set. See auto augmentation details in AutoAugmentPolicy.</span>

<span class="sd">            - AutoAugmentPolicy.IMAGENET, means to apply AutoAugment learned on ImageNet dataset.</span>

<span class="sd">            - AutoAugmentPolicy.CIFAR10, means to apply AutoAugment learned on Cifar10 dataset.</span>

<span class="sd">            - AutoAugmentPolicy.SVHN, means to apply AutoAugment learned on SVHN dataset.</span>

<span class="sd">        interpolation (Inter, optional): Image interpolation mode for Resize operator (default=Inter.NEAREST).</span>
<span class="sd">            It can be any of [Inter.NEAREST, Inter.BILINEAR, Inter.BICUBIC, Inter.AREA].</span>

<span class="sd">            - Inter.NEAREST: means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BILINEAR: means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.BICUBIC: means the interpolation method is bicubic interpolation.</span>

<span class="sd">            - Inter.AREA: means the interpolation method is area interpolation.</span>

<span class="sd">        fill_value (Union[int, tuple], optional): Pixel fill value for the area outside the transformed image.</span>
<span class="sd">            It can be an int or a 3-tuple. If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels. The fill_value values must be in range [0, 255]</span>
<span class="sd">            (default=0).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `policy` is not of type AutoAugmentPolicy.</span>
<span class="sd">        TypeError: If `interpolation` is not of type Inter.</span>
<span class="sd">        TypeError: If `fill_value` is not an integer or a tuple of length 3.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import AutoAugmentPolicy, Inter</span>

<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.AutoAugment(policy=AutoAugmentPolicy.IMAGENET,</span>
<span class="sd">        ...                                                        interpolation=Inter.NEAREST,</span>
<span class="sd">        ...                                                        fill_value=0)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_auto_augment</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">AutoAugmentPolicy</span><span class="o">.</span><span class="n">IMAGENET</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">policy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">AutoAugmentOperation</span><span class="p">(</span><span class="n">AutoAugmentPolicy</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">policy</span><span class="p">),</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="AutoContrast"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.AutoContrast.html#mindspore.dataset.vision.AutoContrast">[docs]</a><span class="k">class</span> <span class="nc">AutoContrast</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply automatic contrast on input image. This operator calculates histogram of image, reassign cutoff percent</span>
<span class="sd">    of the lightest pixels from histogram to 255, and reassign cutoff percent of the darkest pixels from histogram to 0.</span>

<span class="sd">    Args:</span>
<span class="sd">        cutoff (float, optional): Percent of lightest and darkest pixels to cut off from</span>
<span class="sd">            the histogram of input image. The value must be in the range [0.0, 50.0) (default=0.0).</span>
<span class="sd">        ignore (Union[int, sequence], optional): The background pixel values to ignore,</span>
<span class="sd">            The ignore values must be in range [0, 255] (default=None).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `cutoff` is not of type float.</span>
<span class="sd">        TypeError: If `ignore` is not of type int or sequence.</span>
<span class="sd">        ValueError: If `cutoff` is not in range [0, 50.0).</span>
<span class="sd">        ValueError: If `ignore` is not in range [0, 255].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.AutoContrast(cutoff=10.0, ignore=[10, 20])]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_auto_contrast</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignore</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="n">ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">AutoContrastOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">)</span>

<div class="viewcode-block" id="AutoContrast.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.AutoContrast.html#mindspore.dataset.vision.AutoContrast.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be automatically contrasted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, automatically contrasted image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">auto_contrast</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BoundingBoxAugment"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.BoundingBoxAugment.html#mindspore.dataset.vision.BoundingBoxAugment">[docs]</a><span class="k">class</span> <span class="nc">BoundingBoxAugment</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a given image processing operation on a random selection of bounding box regions of a given image.</span>

<span class="sd">    Args:</span>
<span class="sd">        transform (TensorOperation): Transformation operation to be applied on random selection</span>
<span class="sd">            of bounding box regions of a given image.</span>
<span class="sd">        ratio (float, optional): Ratio of bounding boxes to apply augmentation on.</span>
<span class="sd">            Range: [0, 1] (default=0.3).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `transform` is an image processing operation in :class:`mindspore.dataset.vision.transforms`.</span>
<span class="sd">        TypeError: If `ratio` is not of type float.</span>
<span class="sd">        ValueError: If `ratio` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given bounding box is invalid.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # set bounding box operation with ratio of 1 to apply rotation on all bounding boxes</span>
<span class="sd">        &gt;&gt;&gt; bbox_aug_op = vision.BoundingBoxAugment(vision.RandomRotation(90), 1)</span>
<span class="sd">        &gt;&gt;&gt; # map to apply ops</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=[bbox_aug_op],</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;, &quot;bbox&quot;],</span>
<span class="sd">        ...                                                 output_columns=[&quot;image&quot;, &quot;bbox&quot;],</span>
<span class="sd">        ...                                                 column_order=[&quot;image&quot;, &quot;bbox&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_bounding_box_augment_cpp</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="s1">&#39;parse&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">BoundingBoxAugmentOperation</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">)</span></div>


<div class="viewcode-block" id="CenterCrop"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.CenterCrop.html#mindspore.dataset.vision.CenterCrop">[docs]</a><span class="k">class</span> <span class="nc">CenterCrop</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image at the center to the given size. If input image size is smaller than output size,</span>
<span class="sd">    input image will be padded with 0 before cropping.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The output size of the cropped image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">            The size value(s) must be larger than 0.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type integer or sequence.</span>
<span class="sd">        ValueError: If `size` is less than or equal to 0.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # crop image to a square</span>
<span class="sd">        &gt;&gt;&gt; transforms_list1 = [vision.Decode(), vision.CenterCrop(50)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list1,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # crop image to portrait style</span>
<span class="sd">        &gt;&gt;&gt; transforms_list2 = [vision.Decode(), vision.CenterCrop((60, 40))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=transforms_list2,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_center_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">CenterCropOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<div class="viewcode-block" id="CenterCrop.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.CenterCrop.html#mindspore.dataset.vision.CenterCrop.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be center cropped.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, cropped image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">center_crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertColor"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.ConvertColor.html#mindspore.dataset.vision.ConvertColor">[docs]</a><span class="k">class</span> <span class="nc">ConvertColor</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the color space of the image.</span>

<span class="sd">    Args:</span>
<span class="sd">        convert_mode (ConvertMode): The mode of image channel conversion.</span>

<span class="sd">            - ConvertMode.COLOR_BGR2BGRA, Convert BGR image to BGRA image.</span>

<span class="sd">            - ConvertMode.COLOR_RGB2RGBA, Convert RGB image to RGBA image.</span>

<span class="sd">            - ConvertMode.COLOR_BGRA2BGR, Convert BGRA image to BGR image.</span>

<span class="sd">            - ConvertMode.COLOR_RGBA2RGB, Convert RGBA image to RGB image.</span>

<span class="sd">            - ConvertMode.COLOR_BGR2RGBA, Convert BGR image to RGBA image.</span>

<span class="sd">            - ConvertMode.COLOR_RGB2BGRA, Convert RGB image to BGRA image.</span>

<span class="sd">            - ConvertMode.COLOR_RGBA2BGR, Convert RGBA image to BGR image.</span>

<span class="sd">            - ConvertMode.COLOR_BGRA2RGB, Convert BGRA image to RGB image.</span>

<span class="sd">            - ConvertMode.COLOR_BGR2RGB, Convert BGR image to RGB image.</span>

<span class="sd">            - ConvertMode.COLOR_RGB2BGR, Convert RGB image to BGR image.</span>

<span class="sd">            - ConvertMode.COLOR_BGRA2RGBA, Convert BGRA image to RGBA image.</span>

<span class="sd">            - ConvertMode.COLOR_RGBA2BGRA, Convert RGBA image to BGRA image.</span>

<span class="sd">            - ConvertMode.COLOR_BGR2GRAY, Convert BGR image to GRAY image.</span>

<span class="sd">            - ConvertMode.COLOR_RGB2GRAY, Convert RGB image to GRAY image.</span>

<span class="sd">            - ConvertMode.COLOR_GRAY2BGR, Convert GRAY image to BGR image.</span>

<span class="sd">            - ConvertMode.COLOR_GRAY2RGB, Convert GRAY image to RGB image.</span>

<span class="sd">            - ConvertMode.COLOR_GRAY2BGRA, Convert GRAY image to BGRA image.</span>

<span class="sd">            - ConvertMode.COLOR_GRAY2RGBA, Convert GRAY image to RGBA image.</span>

<span class="sd">            - ConvertMode.COLOR_BGRA2GRAY, Convert BGRA image to GRAY image.</span>

<span class="sd">            - ConvertMode.COLOR_RGBA2GRAY, Convert RGBA image to GRAY image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `convert_mode` is not of type :class:`mindspore.dataset.vision.transforms.ConvertMode`.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.dataset.vision.utils as mode</span>
<span class="sd">        &gt;&gt;&gt; # Convert RGB images to GRAY images</span>
<span class="sd">        &gt;&gt;&gt; convert_op = vision.ConvertColor(mode.ConvertMode.COLOR_RGB2GRAY)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=convert_op,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # Convert RGB images to BGR images</span>
<span class="sd">        &gt;&gt;&gt; convert_op = vision.ConvertColor(mode.ConvertMode.COLOR_RGB2BGR)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=convert_op,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_convert_color</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convert_mode</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_mode</span> <span class="o">=</span> <span class="n">convert_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">ConvertColorOperation</span><span class="p">(</span><span class="n">ConvertMode</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_mode</span><span class="p">))</span></div>


<div class="viewcode-block" id="Crop"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Crop.html#mindspore.dataset.vision.Crop">[docs]</a><span class="k">class</span> <span class="nc">Crop</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image at a specific location.</span>

<span class="sd">    Args:</span>
<span class="sd">        coordinates(sequence): Coordinates of the upper left corner of the cropping image. Must be a sequence of two</span>
<span class="sd">            values, in the form of (top, left).</span>
<span class="sd">        size (Union[int, sequence]): The output size of the cropped image.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">            The size value(s) must be larger than 0.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `coordinates` is not of type sequence.</span>
<span class="sd">        TypeError: If `size` is not of type integer or sequence.</span>
<span class="sd">        ValueError: If `coordinates` is less than 0.</span>
<span class="sd">        ValueError: If `size` is less than or equal to 0.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; crop_op = vision.Crop((0, 0), 32)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, crop_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">CropOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="CutMixBatch"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.CutMixBatch.html#mindspore.dataset.vision.CutMixBatch">[docs]</a><span class="k">class</span> <span class="nc">CutMixBatch</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply CutMix transformation on input batch of images and labels.</span>
<span class="sd">    Note that you need to make labels into one-hot format and batched before calling this operator.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_batch_format (ImageBatchFormat): The method of padding. Can be any of</span>
<span class="sd">            [ImageBatchFormat.NHWC, ImageBatchFormat.NCHW].</span>
<span class="sd">        alpha (float, optional): Hyperparameter of beta distribution, must be larger than 0 (default = 1.0).</span>
<span class="sd">        prob (float, optional): The probability by which CutMix is applied to each image, range: [0, 1] (default = 1.0).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `image_batch_format` is not of type :class:`mindspore.dataset.vision.ImageBatchFormat`.</span>
<span class="sd">        TypeError: If `alpha` is not of type float.</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `alpha` is less than or equal 0.</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import ImageBatchFormat</span>
<span class="sd">        &gt;&gt;&gt; onehot_op = transforms.OneHot(num_classes=10)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset= image_folder_dataset.map(operations=onehot_op,</span>
<span class="sd">        ...                                                input_columns=[&quot;label&quot;])</span>
<span class="sd">        &gt;&gt;&gt; cutmix_batch_op = vision.CutMixBatch(ImageBatchFormat.NHWC, 1.0, 0.5)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.batch(5)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=cutmix_batch_op,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;, &quot;label&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_cut_mix_batch_c</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_batch_format</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_batch_format</span> <span class="o">=</span> <span class="n">image_batch_format</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">CutMixBatchOperation</span><span class="p">(</span><span class="n">ImageBatchFormat</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_batch_format</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="CutOut"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.CutOut.html#mindspore.dataset.vision.CutOut">[docs]</a><span class="k">class</span> <span class="nc">CutOut</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly cut (mask) out a given number of square patches from the input image array.</span>

<span class="sd">    Args:</span>
<span class="sd">        length (int): The side length of each square patch, must be larger than 0.</span>
<span class="sd">        num_patches (int, optional): Number of patches to be cut out of an image, must be larger than 0. (default=1).</span>
<span class="sd">        is_hwc (bool): Whether the input image is in HWC format. True - HWC format, False - CHW format. Default: True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `length` is not of type integer.</span>
<span class="sd">        TypeError: If `is_hwc` is not of type bool.</span>
<span class="sd">        TypeError: If `num_patches` is not of type integer.</span>
<span class="sd">        ValueError: If `length` is less than or equal 0.</span>
<span class="sd">        ValueError: If `num_patches` is less than or equal 0.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.CutOut(80, num_patches=10)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_cutout_new</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_patches</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">is_hwc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_patches</span> <span class="o">=</span> <span class="n">num_patches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span> <span class="o">=</span> <span class="n">is_hwc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">CutOutOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_patches</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Decode"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Decode.html#mindspore.dataset.vision.Decode">[docs]</a><span class="k">class</span> <span class="nc">Decode</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decode the input image in RGB mode.</span>
<span class="sd">    Supported image formats: JPEG, BMP, PNG, TIFF, GIF(need `to_pil=True`), WEBP(need `to_pil=True`).</span>

<span class="sd">    Args:</span>
<span class="sd">        to_pil (bool, optional): decode to PIL Image (default=False).</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If given tensor is not a 1D sequence.</span>
<span class="sd">        RuntimeError: If the input is not raw image bytes.</span>
<span class="sd">        RuntimeError: If the input image is already decoded.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Eager usage</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; raw_image = np.fromfile(&quot;/path/to/image/file&quot;, np.uint8)</span>
<span class="sd">        &gt;&gt;&gt; decoded_image = vision.Decode()(raw_image)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Pipeline usage</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomHorizontalFlip()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_decode</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_pil</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_pil</span> <span class="o">=</span> <span class="n">to_pil</span>
        <span class="k">if</span> <span class="n">to_pil</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call method for input conversion for eager mode with C++ implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Input should be an encoded image in 1-D NumPy format, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<div class="viewcode-block" id="Decode.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Decode.html#mindspore.dataset.vision.Decode.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (NumPy): Image to be decoded.</span>

<span class="sd">        Returns:</span>
<span class="sd">            img (NumPy, PIL Image), Decoded image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">DecodeOperation</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Equalize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Equalize.html#mindspore.dataset.vision.Equalize">[docs]</a><span class="k">class</span> <span class="nc">Equalize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply histogram equalization on input image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.Equalize()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">EqualizeOperation</span><span class="p">()</span>

<div class="viewcode-block" id="Equalize.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Equalize.html#mindspore.dataset.vision.Equalize.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be equalized.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, equalized image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">equalize</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="FiveCrop"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.FiveCrop.html#mindspore.dataset.vision.FiveCrop">[docs]</a><span class="k">class</span> <span class="nc">FiveCrop</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the given image into one central crop and four corners.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The size of the cropped image.</span>
<span class="sd">            If a single integer is provided, a square of size (size, size) will be cropped with this value.</span>
<span class="sd">            If a sequence of length 2 is provided, an image of size (height, width) will be cropped.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type integer or sequence of integer.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True),</span>
<span class="sd">        ...                            vision.FiveCrop(size=200),</span>
<span class="sd">        ...                            # 4D stack of 5 images</span>
<span class="sd">        ...                            lambda *images: numpy.stack([vision.ToTensor()(image) for image in images])])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_five_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="FiveCrop.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.FiveCrop.html#mindspore.dataset.vision.FiveCrop.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be cropped.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple, a tuple of five PIL Image in order of top_left, top_right, bottom_left, bottom_right, center.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">five_crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="GaussianBlur"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.GaussianBlur.html#mindspore.dataset.vision.GaussianBlur">[docs]</a><span class="k">class</span> <span class="nc">GaussianBlur</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Blur input image with the specified Gaussian kernel.</span>

<span class="sd">    Args:</span>
<span class="sd">        kernel_size (Union[int, Sequence[int]]): Size of the Gaussian kernel to use. The value must be positive and odd.</span>
<span class="sd">            If only an integer is provided, the kernel size will be (kernel_size, kernel_size). If a sequence of integer</span>
<span class="sd">            is provided, it must be a sequence of 2 values which represents (width, height).</span>
<span class="sd">        sigma (Union[float, Sequence[float]], optional): Standard deviation of the Gaussian kernel to use</span>
<span class="sd">            (default=None). The value must be positive. If only a float is provided, the sigma will be (sigma, sigma).</span>
<span class="sd">            If a sequence of float is provided, it must be a sequence of 2 values which represents (width, height).</span>
<span class="sd">            If None is provided, the sigma will be calculated as ((kernel_size - 1) * 0.5 - 1) * 0.3 + 0.8.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `kernel_size` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `sigma` is not of type float or Sequence[float].</span>
<span class="sd">        ValueError: If `kernel_size` is not positive and odd.</span>
<span class="sd">        ValueError: If `sigma` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(to_pil=True)), vision.GaussianBlur(3, 3)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_gaussian_blur</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">kernel_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">kernel_size</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">),)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span> <span class="o">=</span> <span class="n">kernel_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">GaussianBlurOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grayscale"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Grayscale.html#mindspore.dataset.vision.Grayscale">[docs]</a><span class="k">class</span> <span class="nc">Grayscale</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input PIL Image to grayscale.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_output_channels (int): The number of channels desired for the output image, must be 1 or 3.</span>
<span class="sd">            If 3 is provided, the returned image will have 3 identical RGB channels. Default: 1.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `num_output_channels` is not of type integer.</span>
<span class="sd">        ValueError: If `num_output_channels` is not 1 or 3.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.Grayscale(3),</span>
<span class="sd">        ...                            vision.ToTensor()])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_num_channels</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_output_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_output_channels</span> <span class="o">=</span> <span class="n">num_output_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="Grayscale.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Grayscale.html#mindspore.dataset.vision.Grayscale.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be converted to grayscale.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, converted grayscale image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">grayscale</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">num_output_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_output_channels</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HorizontalFlip"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.HorizontalFlip.html#mindspore.dataset.vision.HorizontalFlip">[docs]</a><span class="k">class</span> <span class="nc">HorizontalFlip</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flip the input image horizontally.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(to_pil=True)), vision.HorizontalFlip()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">HorizontalFlipOperation</span><span class="p">()</span></div>


<div class="viewcode-block" id="HsvToRgb"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.HsvToRgb.html#mindspore.dataset.vision.HsvToRgb">[docs]</a><span class="k">class</span> <span class="nc">HsvToRgb</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input numpy.ndarray images from HSV to RGB.</span>

<span class="sd">    Args:</span>
<span class="sd">        is_hwc (bool): If True, means the input image is in shape of (H, W, C) or (N, H, W, C).</span>
<span class="sd">            Otherwise, it is in shape of (C, H, W) or (N, C, H, W). Default: False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `is_hwc` is not of type bool.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.CenterCrop(20),</span>
<span class="sd">        ...                            vision.ToTensor(),</span>
<span class="sd">        ...                            vision.HsvToRgb()])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_hsv_to_rgb</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_hwc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span> <span class="o">=</span> <span class="n">is_hwc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="HsvToRgb.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.HsvToRgb.html#mindspore.dataset.vision.HsvToRgb.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hsv_imgs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsv_imgs (numpy.ndarray): HSV images to be converted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, converted RGB images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">hsv_to_rgbs</span><span class="p">(</span><span class="n">hsv_imgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HWC2CHW"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.HWC2CHW.html#mindspore.dataset.vision.HWC2CHW">[docs]</a><span class="k">class</span> <span class="nc">HWC2CHW</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpose the input image from shape (H, W, C) to (C, H, W).</span>
<span class="sd">    If the input image is of shape &lt;H, W&gt;, it will remain unchanged.</span>

<span class="sd">    Note:</span>
<span class="sd">        This operation supports running on Ascend or GPU platforms by Offload.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If shape of the input image is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(),</span>
<span class="sd">        ...                    vision.RandomHorizontalFlip(0.75),</span>
<span class="sd">        ...                    vision.RandomCrop(512),</span>
<span class="sd">        ...                    vision.HWC2CHW()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">HwcToChwOperation</span><span class="p">()</span></div>


<div class="viewcode-block" id="Invert"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Invert.html#mindspore.dataset.vision.Invert">[docs]</a><span class="k">class</span> <span class="nc">Invert</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply invert on input image in RGB mode. This operator will reassign every pixel to (255 - pixel).</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.Invert()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">InvertOperation</span><span class="p">()</span>

<div class="viewcode-block" id="Invert.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Invert.html#mindspore.dataset.vision.Invert.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be color inverted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, color inverted image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">invert_color</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LinearTransformation"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.LinearTransformation.html#mindspore.dataset.vision.LinearTransformation">[docs]</a><span class="k">class</span> <span class="nc">LinearTransformation</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linearly transform the input numpy.ndarray image with a square transformation matrix and a mean vector.</span>

<span class="sd">    It will first flatten the input image and subtract the mean vector from it, then compute the dot</span>
<span class="sd">    product with the transformation matrix, finally reshape it back to its original shape.</span>

<span class="sd">    Args:</span>
<span class="sd">        transformation_matrix (numpy.ndarray): A square transformation matrix in shape of (D, D), where</span>
<span class="sd">            :math:`D = C \times H \times W`.</span>
<span class="sd">        mean_vector (numpy.ndarray): A mean vector in shape of (D,), where :math:`D = C \times H \times W`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `transformation_matrix` is not of type :class:`numpy.ndarray`.</span>
<span class="sd">        TypeError: If `mean_vector` is not of type :class:`numpy.ndarray`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; height, width = 32, 32</span>
<span class="sd">        &gt;&gt;&gt; dim = 3 * height * width</span>
<span class="sd">        &gt;&gt;&gt; transformation_matrix = np.ones([dim, dim])</span>
<span class="sd">        &gt;&gt;&gt; mean_vector = np.zeros(dim)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.Resize((height,width)),</span>
<span class="sd">        ...                            vision.ToTensor(),</span>
<span class="sd">        ...                            vision.LinearTransformation(transformation_matrix, mean_vector)])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_linear_transform</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation_matrix</span><span class="p">,</span> <span class="n">mean_vector</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformation_matrix</span> <span class="o">=</span> <span class="n">transformation_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_vector</span> <span class="o">=</span> <span class="n">mean_vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="LinearTransformation.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.LinearTransformation.html#mindspore.dataset.vision.LinearTransformation.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np_img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            np_img (numpy.ndarray): Image in shape of (C, H, W) to be linearly transformed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, linearly transformed image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">(</span><span class="n">np_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_vector</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MixUp"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.MixUp.html#mindspore.dataset.vision.MixUp">[docs]</a><span class="k">class</span> <span class="nc">MixUp</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly mix up a batch of images together with its labels.</span>

<span class="sd">    Each image will be multiplied by a random weight lambda generated from the Beta distribution and then added</span>
<span class="sd">    to another image multiplied by 1 - lambda. The same transformation will be applied to their labels with the</span>
<span class="sd">    same value of lambda. Make sure that the labels are one-hot encoded in advance.</span>

<span class="sd">    Args:</span>
<span class="sd">        batch_size (int): The number of images in a batch.</span>
<span class="sd">        alpha (float): The alpha and beta parameter for the Beta distribution.</span>
<span class="sd">        is_single (bool, optional): If True, it will randomly mix up [img0, ..., img(n-1), img(n)] with</span>
<span class="sd">            [img1, ..., img(n), img0] in each batch. Otherwise, it will randomly mix up images with the</span>
<span class="sd">            output of the previous batch. Default: True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `batch_size` is not of type integer.</span>
<span class="sd">        TypeError: If `alpha` is not of type float.</span>
<span class="sd">        TypeError: If `is_single` is not of type boolean.</span>
<span class="sd">        ValueError: If `batch_size` is not positive.</span>
<span class="sd">        ValueError: If `alpha` is not positive.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # first decode the image</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=vision.Decode(),</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # then ont hot decode the label</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms.OneHot(10),</span>
<span class="sd">        ...                                                 input_columns=&quot;label&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # batch the samples</span>
<span class="sd">        &gt;&gt;&gt; batch_size = 4</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.batch(batch_size=batch_size)</span>
<span class="sd">        &gt;&gt;&gt; # finally mix up the images and labels</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(</span>
<span class="sd">        ...     operations=py_vision.MixUp(batch_size=batch_size, alpha=0.2),</span>
<span class="sd">        ...     input_columns=[&quot;image&quot;, &quot;label&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mix_up</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">is_single</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_first</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_single</span> <span class="o">=</span> <span class="n">is_single</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call method to apply mix up transformation to image and label.</span>

<span class="sd">        Note: No execute method for MixUp</span>

<span class="sd">        Args:</span>
<span class="sd">            image (numpy.ndarray): Images to be mixed up.</span>
<span class="sd">            label (numpy.ndarray): Labels to be mixed up.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, images after mixing up.</span>
<span class="sd">            numpy.ndarray, labels after mixing up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">mix_up_single</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">mix_up_muti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span></div>


<div class="viewcode-block" id="MixUpBatch"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.MixUpBatch.html#mindspore.dataset.vision.MixUpBatch">[docs]</a><span class="k">class</span> <span class="nc">MixUpBatch</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply MixUp transformation on input batch of images and labels. Each image is</span>
<span class="sd">    multiplied by a random weight (lambda) and then added to a randomly selected image from the batch</span>
<span class="sd">    multiplied by (1 - lambda). The same formula is also applied to the one-hot labels.</span>

<span class="sd">    The lambda is generated based on the specified alpha value. Two coefficients x1, x2 are randomly generated</span>
<span class="sd">    in the range [alpha, 1], and lambda = (x1 / (x1 + x2)).</span>

<span class="sd">    Note that you need to make labels into one-hot format and batched before calling this operator.</span>

<span class="sd">    Args:</span>
<span class="sd">        alpha (float, optional): Hyperparameter of beta distribution. The value must be positive (default = 1.0).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `alpha` is not of type float.</span>
<span class="sd">        ValueError: If `alpha` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;N, H, W, C&gt; or &lt;N, C, H, W&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; onehot_op = transforms.OneHot(num_classes=10)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset= image_folder_dataset.map(operations=onehot_op,</span>
<span class="sd">        ...                                                input_columns=[&quot;label&quot;])</span>
<span class="sd">        &gt;&gt;&gt; mixup_batch_op = vision.MixUpBatch(alpha=0.9)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.batch(5)</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=mixup_batch_op,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;, &quot;label&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_mix_up_batch_c</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">MixUpBatchOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span></div>


<div class="viewcode-block" id="Normalize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Normalize.html#mindspore.dataset.vision.Normalize">[docs]</a><span class="k">class</span> <span class="nc">Normalize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the input image with respect to mean and standard deviation. This operator will normalize</span>
<span class="sd">    the input image with: output[channel] = (input[channel] - mean[channel]) / std[channel], where channel &gt;= 1.</span>

<span class="sd">    Note:</span>
<span class="sd">        This operation supports running on Ascend or GPU platforms by Offload.</span>

<span class="sd">    Args:</span>
<span class="sd">        mean (sequence): List or tuple of mean values for each channel, with respect to channel order.</span>
<span class="sd">            The mean values must be in range [0.0, 255.0].</span>
<span class="sd">        std (sequence): List or tuple of standard deviations for each channel, with respect to channel order.</span>
<span class="sd">            The standard deviation values must be in range (0.0, 255.0].</span>
<span class="sd">        is_hwc (bool): Whether the input image is in HWC format. True - HWC format, False - CHW format. Default: True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `mean` is not of type sequence.</span>
<span class="sd">        TypeError: If `std` is not of type sequence.</span>
<span class="sd">        TypeError: If `is_hwc` is not of type bool.</span>
<span class="sd">        ValueError: If `mean` is not in range [0.0, 255.0].</span>
<span class="sd">        ValueError: If `mean` is not in range (0.0, 255.0].</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode() ## Decode output is expected to be HWC format</span>
<span class="sd">        &gt;&gt;&gt; normalize_op = vision.Normalize(mean=[121.0, 115.0, 100.0], std=[70.0, 68.0, 71.0], is_hwc=True)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, normalize_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_normalize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">is_hwc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span> <span class="o">=</span> <span class="n">is_hwc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">NormalizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span><span class="p">)</span></div>


<div class="viewcode-block" id="NormalizePad"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.NormalizePad.html#mindspore.dataset.vision.NormalizePad">[docs]</a><span class="k">class</span> <span class="nc">NormalizePad</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the input image with respect to mean and standard deviation then pad an extra channel with value zero.</span>

<span class="sd">    Args:</span>
<span class="sd">        mean (sequence): List or tuple of mean values for each channel, with respect to channel order.</span>
<span class="sd">            The mean values must be in range (0.0, 255.0].</span>
<span class="sd">        std (sequence): List or tuple of standard deviations for each channel, with respect to channel order.</span>
<span class="sd">            The standard deviation values must be in range (0.0, 255.0].</span>
<span class="sd">        dtype (str, optional): Set the output data type of normalized image (default is &quot;float32&quot;).</span>
<span class="sd">        is_hwc (bool): Whether the input image is in HWC format. True - HWC format, False - CHW format. Default: True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `mean` is not of type sequence.</span>
<span class="sd">        TypeError: If `std` is not of type sequence.</span>
<span class="sd">        TypeError: If `dtype` is not of type string.</span>
<span class="sd">        TypeError: If `is_hwc` is not of type bool.</span>
<span class="sd">        ValueError: If `mean` is not in range [0.0, 255.0].</span>
<span class="sd">        ValueError: If `mean` is not in range (0.0, 255.0].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt;, &lt;H, W, C&gt; or &lt;C, H, W&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; normalize_pad_op = vision.NormalizePad(mean=[121.0, 115.0, 100.0],</span>
<span class="sd">        ...                                        std=[70.0, 68.0, 71.0],</span>
<span class="sd">        ...                                        dtype=&quot;float32&quot;)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, normalize_pad_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_normalizepad</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">is_hwc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span> <span class="o">=</span> <span class="n">is_hwc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">NormalizePadOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pad"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Pad.html#mindspore.dataset.vision.Pad">[docs]</a><span class="k">class</span> <span class="nc">Pad</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad the image according to padding parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        padding (Union[int, Sequence[tuple]]): The number of pixels to pad each border of the image.</span>
<span class="sd">            If a single number is provided, it pads all borders with this value.</span>
<span class="sd">            If a tuple or lists of 2 values are provided, it pads the (left and top)</span>
<span class="sd">            with the first value and (right and bottom) with the second value.</span>
<span class="sd">            If 4 values are provided as a list or tuple, it pads the left, top, right and bottom respectively.</span>
<span class="sd">            The pad values must be non-negative.</span>
<span class="sd">        fill_value (Union[int, tuple[int]], optional): The pixel intensity of the borders, only valid for</span>
<span class="sd">            padding_mode Border.CONSTANT. If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>
<span class="sd">        padding_mode (Border, optional): The method of padding (default=Border.CONSTANT). Can be any of</span>
<span class="sd">            [Border.CONSTANT, Border.EDGE, Border.REFLECT, Border.SYMMETRIC].</span>

<span class="sd">            - Border.CONSTANT, means it fills the border with constant values.</span>

<span class="sd">            - Border.EDGE, means it pads with the last value on the edge.</span>

<span class="sd">            - Border.REFLECT, means it reflects the values on the edge omitting the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">            - Border.SYMMETRIC, means it reflects the values on the edge repeating the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">    Note:</span>
<span class="sd">        The behavior when `padding` is a sequence of length 2 will change from padding left/top with</span>
<span class="sd">        the first value and right/bottom with the second, to padding left/right with the first one</span>
<span class="sd">        and top/bottom with the second in the future. Or you can pass in a 4-element sequence to specify</span>
<span class="sd">        left, top, right and bottom respectively.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `padding` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `fill_value` is not of type int or tuple[int].</span>
<span class="sd">        TypeError: If `padding_mode` is not of type :class:`mindspore.dataset.vision.Border`.</span>
<span class="sd">        ValueError: If `padding` is negative.</span>
<span class="sd">        ValueError: If `fill_value` is not in range [0, 255].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.Pad([100, 100, 100, 100])]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_pad</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">Border</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">parse_padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_padding_mode</span> <span class="o">=</span> <span class="n">Border</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pil_padding_mode</span> <span class="o">=</span> <span class="n">Border</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">PadOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_padding_mode</span><span class="p">)</span>

<div class="viewcode-block" id="Pad.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Pad.html#mindspore.dataset.vision.Pad.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be padded.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, padded image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pil_padding_mode</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PadToSize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.PadToSize.html#mindspore.dataset.vision.PadToSize">[docs]</a><span class="k">class</span> <span class="nc">PadToSize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad the image to a fixed size.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int, int]]): The target size to pad.</span>
<span class="sd">            If int is provided, pad the image to [size, size].</span>
<span class="sd">            If Sequence[int, int] is provided, it should be in order of [height, width].</span>
<span class="sd">        offset (Union[int, Sequence[int, int]], optional): The lengths to pad on the top and left.</span>
<span class="sd">            If int is provided, pad both top and left borders with this value.</span>
<span class="sd">            If Sequence[int, int] is provided, is should be in order of [top, left].</span>
<span class="sd">            Default: None, means to pad symmetrically, keeping the original image in center.</span>
<span class="sd">        fill_value (Union[int, tuple[int, int, int]], optional): Pixel value used to pad the borders,</span>
<span class="sd">            only valid when `padding_mode` is Border.CONSTANT.</span>
<span class="sd">            If int is provided, it will be used for all RGB channels.</span>
<span class="sd">            If tuple[int, int, int] is provided, it will be used for R, G, B channels respectively. Default: 0.</span>
<span class="sd">        padding_mode (Border, optional): Method of padding. It can be Border.CONSTANT, Border.EDGE, Border.REFLECT</span>
<span class="sd">            or Border.SYMMETRIC. Default: Border.CONSTANT. Default: Border.CONSTANT.</span>

<span class="sd">            - Border.CONSTANT, pads with a constant value.</span>
<span class="sd">            - Border.EDGE, pads with the last value at the edge of the image.</span>
<span class="sd">            - Border.REFLECT, pads with reflection of the image omitting the last value on the edge.</span>
<span class="sd">            - Border.SYMMETRIC, pads with reflection of the image repeating the last value on the edge.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int, int].</span>
<span class="sd">        TypeError: If `offset` is not of type int or Sequence[int, int].</span>
<span class="sd">        TypeError: If `fill_value` is not of type int or tuple[int, int, int].</span>
<span class="sd">        TypeError: If `padding_mode` is not of type :class:`mindspore.dataset.vision.Border`.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        ValueError: If `offset` is negative.</span>
<span class="sd">        ValueError: If `fill_value` is not in range of [0, 255].</span>
<span class="sd">        RuntimeError: If shape of the input image is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.PadToSize([256, 256])]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_pad_to_size</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">Border</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">size</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">Border</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">PadToSizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomAdjustSharpness"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomAdjustSharpness.html#mindspore.dataset.vision.RandomAdjustSharpness">[docs]</a><span class="k">class</span> <span class="nc">RandomAdjustSharpness</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly adjust the sharpness of the input image with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        degree (float): Sharpness adjustment degree, which must be non negative.</span>
<span class="sd">            Degree of 0.0 gives a blurred image, degree of 1.0 gives the original image,</span>
<span class="sd">            and degree of 2.0 increases the sharpness by a factor of 2.</span>
<span class="sd">        prob (float, optional): Probability of the image being sharpness adjusted, which</span>
<span class="sd">            must be in range of [0, 1] (default=0.5).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `degree` is not of type float.</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `degree` is negative.</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomAdjustSharpness(2.0, 0.5)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_adjust_sharpness</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="n">degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomAdjustSharpnessOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomAffine"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomAffine.html#mindspore.dataset.vision.RandomAffine">[docs]</a><span class="k">class</span> <span class="nc">RandomAffine</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply Random affine transformation to the input image.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees (Union[int, float, sequence]): Range of the rotation degrees.</span>
<span class="sd">            If `degrees` is a number, the range will be (-degrees, degrees).</span>
<span class="sd">            If `degrees` is a sequence, it should be (min, max).</span>
<span class="sd">        translate (sequence, optional): Sequence (tx_min, tx_max, ty_min, ty_max) of minimum/maximum translation in</span>
<span class="sd">            x(horizontal) and y(vertical) directions, range [-1.0, 1.0] (default=None).</span>
<span class="sd">            The horizontal and vertical shift is selected randomly from the range:</span>
<span class="sd">            (tx_min*width, tx_max*width) and (ty_min*height, ty_max*height), respectively.</span>
<span class="sd">            If a tuple or list of size 2, then a translate parallel to the X axis in the range of</span>
<span class="sd">            (translate[0], translate[1]) is applied.</span>
<span class="sd">            If a tuple or list of size 4, then a translate parallel to the X axis in the range of</span>
<span class="sd">            (translate[0], translate[1]) and a translate parallel to the Y axis in the range of</span>
<span class="sd">            (translate[2], translate[3]) are applied.</span>
<span class="sd">            If None, no translation is applied.</span>
<span class="sd">        scale (sequence, optional): Scaling factor interval, which must be non negative</span>
<span class="sd">            (default=None, original scale is used).</span>
<span class="sd">        shear (Union[float, Sequence[float, float], Sequence[float, float, float, float]], optional):</span>
<span class="sd">            Range of shear factor to select from.</span>
<span class="sd">            If float is provided, a shearing parallel to X axis with a factor selected from</span>
<span class="sd">            (- `shear` , `shear` ) will be applied.</span>
<span class="sd">            If Sequence[float, float] is provided, a shearing parallel to X axis with a factor selected</span>
<span class="sd">            from ( `shear` [0], `shear` [1]) will be applied.</span>
<span class="sd">            If Sequence[float, float, float, float] is provided, a shearing parallel to X axis with a factor selected</span>
<span class="sd">            from ( `shear` [0], `shear` [1]) and a shearing parallel to Y axis with a factor selected from</span>
<span class="sd">            ( `shear` [2], `shear` [3]) will be applied. Default: None, means no shearing.</span>
<span class="sd">        resample (Inter, optional): An optional resampling filter (default=Inter.NEAREST).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC, Inter.AREA].</span>

<span class="sd">            - Inter.BILINEAR, means resample method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means resample method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means resample method is bicubic interpolation.</span>

<span class="sd">            - Inter.AREA, means resample method is pixel area interpolation.</span>

<span class="sd">        fill_value (Union[int, tuple[int]], optional): Optional fill_value to fill the area outside the transform</span>
<span class="sd">            in the output image. There must be three elements in tuple and the value of single element is [0, 255].</span>
<span class="sd">            (default=0, filling is performed).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `degrees` is not of type int, float or sequence.</span>
<span class="sd">        TypeError: If `translate` is not of type sequence.</span>
<span class="sd">        TypeError: If `scale` is not of type sequence.</span>
<span class="sd">        TypeError: If `shear` is not of type int, float or sequence.</span>
<span class="sd">        TypeError: If `resample` is not of type :class:`mindspore.dataset.vision.Inter`.</span>
<span class="sd">        TypeError: If `fill_value` is not of type int or tuple[int].</span>
<span class="sd">        ValueError: If `degrees` is negative.</span>
<span class="sd">        ValueError: If `translate` is not in range [-1.0, 1.0].</span>
<span class="sd">        ValueError: If `scale` is negative.</span>
<span class="sd">        ValueError: If `shear` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; random_affine_op = vision.RandomAffine(degrees=15,</span>
<span class="sd">        ...                                        translate=(-0.1, 0.1, 0, 0),</span>
<span class="sd">        ...                                        scale=(0.9, 1.1),</span>
<span class="sd">        ...                                        resample=Inter.NEAREST)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, random_affine_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_affine</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Parameter checking</span>
        <span class="k">if</span> <span class="n">shear</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
                <span class="n">shear</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">shear</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">shear</span> <span class="o">=</span> <span class="p">[</span><span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">shear</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shear</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">degrees</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

        <span class="c1"># translation</span>
        <span class="k">if</span> <span class="n">translate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">translate</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># scale</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># shear</span>
        <span class="k">if</span> <span class="n">shear</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">shear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">resample</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Inter</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span> <span class="n">Inter</span><span class="o">.</span><span class="n">PILCUBIC</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">resample</span> <span class="o">==</span> <span class="n">Inter</span><span class="o">.</span><span class="n">ANTIALIAS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Current Interpolation is not supported with NumPy input.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomAffineOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>

<div class="viewcode-block" id="RandomAffine.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomAffine.html#mindspore.dataset.vision.RandomAffine.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be randomly affine transformed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, randomly affine transformed image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Current Interpolation is not supported with PIL input.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_affine</span><span class="p">(</span><span class="n">img</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomAutoContrast"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomAutoContrast.html#mindspore.dataset.vision.RandomAutoContrast">[docs]</a><span class="k">class</span> <span class="nc">RandomAutoContrast</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Automatically adjust the contrast of the image with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        cutoff (float, optional): Percent of the lightest and darkest pixels to be cut off from</span>
<span class="sd">            the histogram of the input image. The value must be in range of [0.0, 50.0) (default=0.0).</span>
<span class="sd">        ignore (Union[int, sequence], optional): The background pixel values to be ignored, each of</span>
<span class="sd">            which must be in range of [0, 255] (default=None).</span>
<span class="sd">        prob (float, optional): Probability of the image being automatically contrasted, which</span>
<span class="sd">            must be in range of [0, 1] (default=0.5).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `cutoff` is not of type float.</span>
<span class="sd">        TypeError: If `ignore` is not of type integer or sequence of integer.</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `cutoff` is not in range [0.0, 50.0).</span>
<span class="sd">        ValueError: If `ignore` is not in range [0, 255].</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomAutoContrast(cutoff=0.0, ignore=None, prob=0.5)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_auto_contrast</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignore</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="n">ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomAutoContrastOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomColor"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomColor.html#mindspore.dataset.vision.RandomColor">[docs]</a><span class="k">class</span> <span class="nc">RandomColor</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust the color of the input image by a fixed or random degree.</span>
<span class="sd">    This operation works only with 3-channel color images.</span>

<span class="sd">    Args:</span>
<span class="sd">         degrees (Sequence[float], optional): Range of random color adjustment degrees, which must be non-negative.</span>
<span class="sd">            It should be in (min, max) format. If min=max, then it is a</span>
<span class="sd">            single fixed magnitude operation (default=(0.1, 1.9)).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `degrees` is not of type Sequence[float].</span>
<span class="sd">        ValueError: If `degrees` is negative.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomColor((0.5, 2.0))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_positive_degrees</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomColorOperation</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>

<div class="viewcode-block" id="RandomColor.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomColor.html#mindspore.dataset.vision.RandomColor.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be color adjusted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, color adjusted image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_color</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomColorAdjust"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomColorAdjust.html#mindspore.dataset.vision.RandomColorAdjust">[docs]</a><span class="k">class</span> <span class="nc">RandomColorAdjust</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly adjust the brightness, contrast, saturation, and hue of the input image.</span>

<span class="sd">    Note:</span>
<span class="sd">        This operation supports running on Ascend or GPU platforms by Offload.</span>

<span class="sd">    Args:</span>
<span class="sd">        brightness (Union[float, Sequence[float]], optional): Brightness adjustment factor (default=(1, 1)).</span>
<span class="sd">            Cannot be negative.</span>
<span class="sd">            If it is a float, the factor is uniformly chosen from the range [max(0, 1-brightness), 1+brightness].</span>
<span class="sd">            If it is a sequence, it should be [min, max] for the range.</span>
<span class="sd">        contrast (Union[float, Sequence[float]], optional): Contrast adjustment factor (default=(1, 1)).</span>
<span class="sd">            Cannot be negative.</span>
<span class="sd">            If it is a float, the factor is uniformly chosen from the range [max(0, 1-contrast), 1+contrast].</span>
<span class="sd">            If it is a sequence, it should be [min, max] for the range.</span>
<span class="sd">        saturation (Union[float, Sequence[float]], optional): Saturation adjustment factor (default=(1, 1)).</span>
<span class="sd">            Cannot be negative.</span>
<span class="sd">            If it is a float, the factor is uniformly chosen from the range [max(0, 1-saturation), 1+saturation].</span>
<span class="sd">            If it is a sequence, it should be [min, max] for the range.</span>
<span class="sd">        hue (Union[float, Sequence[float]], optional): Hue adjustment factor (default=(0, 0)).</span>
<span class="sd">            If it is a float, the range will be [-hue, hue]. Value should be 0 &lt;= hue &lt;= 0.5.</span>
<span class="sd">            If it is a sequence, it should be [min, max] where -0.5 &lt;= min &lt;= max &lt;= 0.5.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `brightness` is not of type float or Sequence[float].</span>
<span class="sd">        TypeError: If `contrast` is not of type float or Sequence[float].</span>
<span class="sd">        TypeError: If `saturation` is not of type float or Sequence[float].</span>
<span class="sd">        TypeError: If `hue` is not of type float or Sequence[float].</span>
<span class="sd">        ValueError: If `brightness` is negative.</span>
<span class="sd">        ValueError: If `contrast` is negative.</span>
<span class="sd">        ValueError: If `saturation` is negative.</span>
<span class="sd">        ValueError: If `hue` is not in range [-0.5, 0.5].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; transform_op = vision.RandomColorAdjust(brightness=(0.5, 1),</span>
<span class="sd">        ...                                         contrast=(0.4, 1),</span>
<span class="sd">        ...                                         saturation=(0.3, 1))</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, transform_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_color_adjust</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">brightness</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">contrast</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">saturation</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">hue</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">brightness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expand_values</span><span class="p">(</span><span class="n">brightness</span><span class="p">)</span>
        <span class="n">contrast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expand_values</span><span class="p">(</span><span class="n">contrast</span><span class="p">)</span>
        <span class="n">saturation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expand_values</span><span class="p">(</span><span class="n">saturation</span><span class="p">)</span>
        <span class="n">hue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expand_values</span><span class="p">(</span>
            <span class="n">hue</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">non_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">brightness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contrast</span> <span class="o">=</span> <span class="n">contrast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saturation</span> <span class="o">=</span> <span class="n">saturation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hue</span> <span class="o">=</span> <span class="n">hue</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomColorAdjustOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">brightness</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contrast</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">saturation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hue</span><span class="p">)</span>

<div class="viewcode-block" id="RandomColorAdjust.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomColorAdjust.html#mindspore.dataset.vision.RandomColorAdjust.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL image): Image to be randomly color adjusted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, randomly color adjusted image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_color_adjust</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">brightness</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contrast</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">saturation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hue</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__expand_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">FLOAT_MAX_INTEGER</span><span class="p">),</span> <span class="n">non_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expand input value for vision adjustment factor.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">center</span> <span class="o">-</span> <span class="n">value</span><span class="p">,</span> <span class="n">center</span> <span class="o">+</span> <span class="n">value</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">non_negative</span><span class="p">:</span>
                <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">check_range</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">bound</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="RandomCrop"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomCrop.html#mindspore.dataset.vision.RandomCrop">[docs]</a><span class="k">class</span> <span class="nc">RandomCrop</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image at a random location. If input image size is smaller than output size,</span>
<span class="sd">    input image will be padded before cropping.</span>

<span class="sd">    Note:</span>
<span class="sd">        If the input image is more than one, then make sure that the image size is the same.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The output size of the cropped image. The size value(s) must be positive.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, an image of size (height, width) will be cropped.</span>
<span class="sd">        padding (Union[int, Sequence[int]], optional): The number of pixels to pad each border of the image.</span>
<span class="sd">            The padding value(s) must be non-nagetive (default=None).</span>
<span class="sd">            If padding is not None, pad image first with padding values.</span>
<span class="sd">            If a single number is provided, pad all borders with this value.</span>
<span class="sd">            If a tuple or lists of 2 values are provided, pad the (left and top)</span>
<span class="sd">            with the first value and (right and bottom) with the second value.</span>
<span class="sd">            If 4 values are provided as a list or tuple,</span>
<span class="sd">            pad the left, top, right and bottom respectively.</span>
<span class="sd">        pad_if_needed (bool, optional): Pad the image if either side is smaller than</span>
<span class="sd">            the given output size (default=False).</span>
<span class="sd">        fill_value (Union[int, tuple[int]], optional): The pixel intensity of the borders, only valid for</span>
<span class="sd">            padding_mode Border.CONSTANT. If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>
<span class="sd">        padding_mode (Border, optional): The method of padding (default=Border.CONSTANT). It can be any of</span>
<span class="sd">            [Border.CONSTANT, Border.EDGE, Border.REFLECT, Border.SYMMETRIC].</span>

<span class="sd">            - Border.CONSTANT, means it fills the border with constant values.</span>

<span class="sd">            - Border.EDGE, means it pads with the last value on the edge.</span>

<span class="sd">            - Border.REFLECT, means it reflects the values on the edge omitting the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">            - Border.SYMMETRIC, means it reflects the values on the edge repeating the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">    Note:</span>
<span class="sd">        The behavior when `padding` is a sequence of length 2 will change from padding left/top with</span>
<span class="sd">        the first value and right/bottom with the second, to padding left/right with the first one</span>
<span class="sd">        and top/bottom with the second in the future. Or you can pass in a 4-element sequence to specify</span>
<span class="sd">        left, top, right and bottom respectively.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `padding` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `pad_if_needed` is not of type boolean.</span>
<span class="sd">        TypeError: If `fill_value` is not of type int or tuple[int].</span>
<span class="sd">        TypeError: If `padding_mode` is not of type :class:`mindspore.dataset.vision.Border`.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        ValueError: If `padding` is negative.</span>
<span class="sd">        ValueError: If `fill_value` is not in range [0, 255].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Border</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; random_crop_op = vision.RandomCrop(512, [200, 200, 200, 200], padding_mode=Border.EDGE)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, random_crop_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_if_needed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">Border</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">parse_padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span> <span class="o">=</span> <span class="n">pad_if_needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_padding_mode</span> <span class="o">=</span> <span class="n">Border</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pil_padding_mode</span> <span class="o">=</span> <span class="n">Border</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomCropOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">c_padding_mode</span><span class="p">)</span>

<div class="viewcode-block" id="RandomCrop.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomCrop.html#mindspore.dataset.vision.RandomCrop.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be randomly cropped.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, cropped image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pil_padding_mode</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomCropDecodeResize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomCropDecodeResize.html#mindspore.dataset.vision.RandomCropDecodeResize">[docs]</a><span class="k">class</span> <span class="nc">RandomCropDecodeResize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A combination of `Crop`, `Decode` and `Resize`. It will get better performance for JPEG images. This operator</span>
<span class="sd">    will crop the input image at a random location, decode the cropped image in RGB mode, and resize the decoded image.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The output size of the resized image. The size value(s) must be positive.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        scale (list, tuple, optional): Range [min, max) of respective size of the</span>
<span class="sd">            original size to be cropped, which must be non-negative (default=(0.08, 1.0)).</span>
<span class="sd">        ratio (list, tuple, optional): Range [min, max) of aspect ratio to be</span>
<span class="sd">            cropped, which must be non-negative (default=(3. / 4., 4. / 3.)).</span>
<span class="sd">        interpolation (Inter, optional): Image interpolation mode for resize operator(default=Inter.BILINEAR).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC, Inter.AREA, Inter.PILCUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">            - Inter.AREA, means interpolation method is pixel area interpolation.</span>

<span class="sd">            - Inter.PILCUBIC, means interpolation method is bicubic interpolation like implemented in pillow, input</span>
<span class="sd">              should be in 3 channels format.</span>

<span class="sd">        max_attempts (int, optional): The maximum number of attempts to propose a valid crop_area (default=10).</span>
<span class="sd">            If exceeded, fall back to use center_crop instead. The max_attempts value must be positive.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `scale` is not of type tuple.</span>
<span class="sd">        TypeError: If `ratio` is not of type tuple.</span>
<span class="sd">        TypeError: If `interpolation` is not of type :class:`mindspore.dataset.vision.Inter`.</span>
<span class="sd">        TypeError: If `max_attempts` is not of type integer.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        ValueError: If `scale` is negative.</span>
<span class="sd">        ValueError: If `ratio` is negative.</span>
<span class="sd">        ValueError: If `max_attempts` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor is not a 1D sequence.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; resize_crop_decode_op = vision.RandomCropDecodeResize(size=(50, 75),</span>
<span class="sd">        ...                                                       scale=(0.25, 0.5),</span>
<span class="sd">        ...                                                       interpolation=Inter.NEAREST,</span>
<span class="sd">        ...                                                       max_attempts=5)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [resize_crop_decode_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_resize_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">4.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">),</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span> <span class="o">=</span> <span class="n">max_attempts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Input should be an encoded image in 1-D NumPy format, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input should be an encoded image with uint8 type in 1-D NumPy format, &quot;</span> <span class="o">+</span>
                            <span class="s2">&quot;got format:</span><span class="si">{}</span><span class="s2">, dtype:</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomCropDecodeResizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span>
                                                   <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomCropWithBBox"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomCropWithBBox.html#mindspore.dataset.vision.RandomCropWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomCropWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image at a random location and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The output size of the cropped image. The size value(s) must be positive.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, an image of size (height, width) will be cropped.</span>
<span class="sd">        padding (Union[int, Sequence[int]], optional): The number of pixels to pad the image</span>
<span class="sd">            The padding value(s) must be non-nagetive (default=None).</span>
<span class="sd">            If padding is not None, first pad image with padding values.</span>
<span class="sd">            If a single number is provided, pad all borders with this value.</span>
<span class="sd">            If a tuple or lists of 2 values are provided, pad the (left and top)</span>
<span class="sd">            with the first value and (right and bottom) with the second value.</span>
<span class="sd">            If 4 values are provided as a list or tuple, pad the left, top, right and bottom respectively.</span>
<span class="sd">        pad_if_needed (bool, optional): Pad the image if either side is smaller than</span>
<span class="sd">            the given output size (default=False).</span>
<span class="sd">        fill_value (Union[int, tuple[int]], optional): The pixel intensity of the borders, only valid for</span>
<span class="sd">            padding_mode Border.CONSTANT. If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>
<span class="sd">        padding_mode (Border, optional): The method of padding (default=Border.CONSTANT). It can be any of</span>
<span class="sd">            [Border.CONSTANT, Border.EDGE, Border.REFLECT, Border.SYMMETRIC].</span>

<span class="sd">            - Border.CONSTANT, means it fills the border with constant values.</span>

<span class="sd">            - Border.EDGE, means it pads with the last value on the edge.</span>

<span class="sd">            - Border.REFLECT, means it reflects the values on the edge omitting the last</span>
<span class="sd">              value of edge.</span>

<span class="sd">            - Border.SYMMETRIC, means it reflects the values on the edge repeating the last</span>

<span class="sd">              value of edge.</span>

<span class="sd">    Note:</span>
<span class="sd">        The behavior when `padding` is a sequence of length 2 will change from padding left/top with</span>
<span class="sd">        the first value and right/bottom with the second, to padding left/right with the first one</span>
<span class="sd">        and top/bottom with the second in the future. Or you can pass in a 4-element sequence to specify</span>
<span class="sd">        left, top, right and bottom respectively.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `padding` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `pad_if_needed` is not of type boolean.</span>
<span class="sd">        TypeError: If `fill_value` is not of type int or tuple[int].</span>
<span class="sd">        TypeError: If `padding_mode` is not of type :class:`mindspore.dataset.vision.Border`.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        ValueError: If `padding` is negative.</span>
<span class="sd">        ValueError: If `fill_value` is not in range [0, 255].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; random_crop_with_bbox_op = vision.RandomCropWithBBox([512, 512], [200, 200, 200, 200])</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, random_crop_with_bbox_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_if_needed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">Border</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">parse_padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span> <span class="o">=</span> <span class="n">pad_if_needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">border_type</span> <span class="o">=</span> <span class="n">Border</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomCropWithBBoxOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_if_needed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
                                               <span class="n">border_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomEqualize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomEqualize.html#mindspore.dataset.vision.RandomEqualize">[docs]</a><span class="k">class</span> <span class="nc">RandomEqualize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply histogram equalization on the input image with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being equalized, which</span>
<span class="sd">            must be in range of [0, 1] (default=0.5).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomEqualize(0.5)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomEqualizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomErasing"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomErasing.html#mindspore.dataset.vision.RandomErasing">[docs]</a><span class="k">class</span> <span class="nc">RandomErasing</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly erase pixels within a random selected rectangle erea on the input numpy.ndarray image.</span>

<span class="sd">    See `Random Erasing Data Augmentation &lt;https://arxiv.org/pdf/1708.04896.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of performing erasing. Default: 0.5.</span>
<span class="sd">        scale (sequence, optional): Range of area scale of the erased area relative</span>
<span class="sd">            to the original image to select from, arranged in order of (min, max).</span>
<span class="sd">            Default: (0.02, 0.33).</span>
<span class="sd">        ratio (sequence, optional): Range of aspect ratio of the erased area to select</span>
<span class="sd">            from, arraged in order of (min, max). Default: (0.3, 3.3).</span>
<span class="sd">        value (Union[int, str, sequence]): Pixel value used to pad the erased area.</span>
<span class="sd">            If a single integer is provided, it will be used for all RGB channels.</span>
<span class="sd">            If a sequence of length 3 is provided, it will be used for R, G, B channels respectively.</span>
<span class="sd">            If a string of &#39;random&#39; is provided, each pixel will be erased with a random value obtained</span>
<span class="sd">            from a standard normal distribution. Default: 0.</span>
<span class="sd">        inplace (bool, optional): Whether to apply erasing inplace. Default: False.</span>
<span class="sd">        max_attempts (int, optional): The maximum number of attempts to propose a valid</span>
<span class="sd">            erased area, beyond which the original image will be returned. Default: 10.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        TypeError: If `scale` is not of type sequence.</span>
<span class="sd">        TypeError: If `ratio` is not of type sequence.</span>
<span class="sd">        TypeError: If `value` is not of type integer, string, or sequence.</span>
<span class="sd">        TypeError: If `inplace` is not of type boolean.</span>
<span class="sd">        TypeError: If `max_attempts` is not of type integer.</span>
<span class="sd">        ValueError: If `prob` is not in range of [0, 1].</span>
<span class="sd">        ValueError: If `scale` is negative.</span>
<span class="sd">        ValueError: If `ratio` is negative.</span>
<span class="sd">        ValueError: If `value` is not in range of [0, 255].</span>
<span class="sd">        ValueError: If `max_attempts` is not positive.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.ToTensor(),</span>
<span class="sd">        ...                            vision.RandomErasing(value=&#39;random&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_erasing</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inplace</span> <span class="o">=</span> <span class="n">inplace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span> <span class="o">=</span> <span class="n">max_attempts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="RandomErasing.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomErasing.html#mindspore.dataset.vision.RandomErasing.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np_img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            np_img (numpy.ndarray): image in shape of (C, H, W) to be randomly erased.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, erased image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">():</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">erase_h</span><span class="p">,</span> <span class="n">erase_w</span><span class="p">,</span> <span class="n">erase_value</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">get_erase_params</span><span class="p">(</span><span class="n">np_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span>
                                                                        <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">bounded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">np_img</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">erase_h</span><span class="p">,</span> <span class="n">erase_w</span><span class="p">,</span> <span class="n">erase_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np_img</span></div></div>


<div class="viewcode-block" id="RandomGrayscale"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomGrayscale.html#mindspore.dataset.vision.RandomGrayscale">[docs]</a><span class="k">class</span> <span class="nc">RandomGrayscale</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly convert the input PIL Image to grayscale.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of performing grayscale conversion. Default: 0.1.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `prob` is not in range of [0, 1].</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.RandomGrayscale(0.3),</span>
<span class="sd">        ...                            vision.ToTensor()])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="RandomGrayscale.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomGrayscale.html#mindspore.dataset.vision.RandomGrayscale.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be randomly converted to grayscale.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, randomly converted grayscale image, which has the same number of channels as the input image.</span>
<span class="sd">                If input image has 1 channel, the output grayscale image will have 1 channel.</span>
<span class="sd">                If input image has 3 channels, the output grayscale image will have 3 identical channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
            <span class="n">num_output_channels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_output_channels</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">grayscale</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">num_output_channels</span><span class="o">=</span><span class="n">num_output_channels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img</span></div></div>


<div class="viewcode-block" id="RandomHorizontalFlip"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomHorizontalFlip.html#mindspore.dataset.vision.RandomHorizontalFlip">[docs]</a><span class="k">class</span> <span class="nc">RandomHorizontalFlip</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly flip the input image horizontally with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being flipped, which must be in range of [0, 1] (default=0.5).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomHorizontalFlip(0.75)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomHorizontalFlipOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span>

<div class="viewcode-block" id="RandomHorizontalFlip.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomHorizontalFlip.html#mindspore.dataset.vision.RandomHorizontalFlip.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be horizontally flipped.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, randomly horizontally flipped image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_horizontal_flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomHorizontalFlipWithBBox"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomHorizontalFlipWithBBox.html#mindspore.dataset.vision.RandomHorizontalFlipWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomHorizontalFlipWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flip the input image horizontally randomly with a given probability and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being flipped, which must be in range of [0, 1] (default=0.5).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomHorizontalFlipWithBBox(0.70)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomHorizontalFlipWithBBoxOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomInvert"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomInvert.html#mindspore.dataset.vision.RandomInvert">[docs]</a><span class="k">class</span> <span class="nc">RandomInvert</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly invert the colors of image with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being inverted, which must be in range of [0, 1] (default=0.5).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomInvert(0.5)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomInvertOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomLighting"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomLighting.html#mindspore.dataset.vision.RandomLighting">[docs]</a><span class="k">class</span> <span class="nc">RandomLighting</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add AlexNet-style PCA-based noise to an image. The eigenvalue and eigenvectors for Alexnet&#39;s PCA noise is</span>
<span class="sd">    calculated from the imagenet dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        alpha (float, optional): Intensity of the image, which must be non-negative (default=0.05).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `alpha` is not of type float.</span>
<span class="sd">        ValueError: If `alpha` is negative.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomLighting(0.1)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_alpha</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomLightingOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

<div class="viewcode-block" id="RandomLighting.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomLighting.html#mindspore.dataset.vision.RandomLighting.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be added AlexNet-style PCA-based noise.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, image with noise added.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_lighting</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomPerspective"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomPerspective.html#mindspore.dataset.vision.RandomPerspective">[docs]</a><span class="k">class</span> <span class="nc">RandomPerspective</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly apply perspective transformation to the input PIL Image with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        distortion_scale (float, optional): Scale of distortion, in range of [0, 1]. Default: 0.5.</span>
<span class="sd">        prob (float, optional): Probability of performing perspective transformation. Default: 0.5.</span>
<span class="sd">        interpolation (Inter, optional): Method of interpolation. It can be Inter.BILINEAR,</span>
<span class="sd">            Inter.NEAREST or Inter.BICUBIC. Default: Inter.BICUBIC.</span>

<span class="sd">            - Inter.BILINEAR, bilinear interpolation.</span>
<span class="sd">            - Inter.NEAREST, nearest-neighbor interpolation.</span>
<span class="sd">            - Inter.BICUBIC, bicubic interpolation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `distortion_scale` is not of type float.</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        TypeError: If `interpolation` is not of type :class:`mindspore.dataset.vision.Inter`.</span>
<span class="sd">        ValueError: If `distortion_scale` is not in range of [0, 1].</span>
<span class="sd">        ValueError: If `prob` is not in range of [0, 1].</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.RandomPerspective(prob=0.1),</span>
<span class="sd">        ...                            vision.ToTensor()])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_perspective</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distortion_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">BICUBIC</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distortion_scale</span> <span class="o">=</span> <span class="n">distortion_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="RandomPerspective.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomPerspective.html#mindspore.dataset.vision.RandomPerspective.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be applied randomly perspective transformation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, image applied randomly perspective transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_pil</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input image should be a Pillow image.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">():</span>
            <span class="n">start_points</span><span class="p">,</span> <span class="n">end_points</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">get_perspective_params</span><span class="p">(</span>
                <span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distortion_scale</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">perspective</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">start_points</span><span class="p">,</span> <span class="n">end_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img</span></div></div>


<div class="viewcode-block" id="RandomPosterize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomPosterize.html#mindspore.dataset.vision.RandomPosterize">[docs]</a><span class="k">class</span> <span class="nc">RandomPosterize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduce the number of bits for each color channel to posterize the input image randomly with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        bits (sequence or int, optional): Range of random posterize to compress image.</span>
<span class="sd">            Bits values must be in range of [1,8], and include at</span>
<span class="sd">            least one integer value in the given range. It must be in</span>
<span class="sd">            (min, max) or integer format. If min=max, then it is a single fixed</span>
<span class="sd">            magnitude operation (default=(8, 8)).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `bits` is not of type integer or sequence of integer.</span>
<span class="sd">        ValueError: If `bits` is not in range [1, 8].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomPosterize((6, 8))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_posterize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bits</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomPosterizeOperation</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomResizedCrop"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomResizedCrop.html#mindspore.dataset.vision.RandomResizedCrop">[docs]</a><span class="k">class</span> <span class="nc">RandomResizedCrop</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This operator will crop the input image randomly, and resize the cropped image using a selected interpolation mode.</span>

<span class="sd">    Note:</span>
<span class="sd">        If the input image is more than one, then make sure that the image size is the same.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The output size of the resized image. The size value(s) must be positive.</span>
<span class="sd">            If size is an integer, a square of size (size, size) will be cropped with this value.</span>
<span class="sd">            If size is a sequence of length 2, an image of size (height, width) will be cropped.</span>
<span class="sd">        scale (Union[list, tuple], optional): Range [min, max) of respective size of the original</span>
<span class="sd">            size to be cropped, which must be non-negative (default=(0.08, 1.0)).</span>
<span class="sd">        ratio (Union[list, tuple], optional): Range [min, max) of aspect ratio to be</span>
<span class="sd">            cropped, which must be non-negative (default=(3. / 4., 4. / 3.)).</span>
<span class="sd">        interpolation (Inter, optional): Method of interpolation (default=Inter.BILINEAR).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC, Inter.AREA, Inter.PILCUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">            - Inter.AREA, means interpolation method is pixel area interpolation.</span>

<span class="sd">            - Inter.PILCUBIC, means interpolation method is bicubic interpolation like implemented in pillow, input</span>
<span class="sd">              should be in 3 channels format.</span>

<span class="sd">            - Inter.ANTIALIAS, means the interpolation method is antialias interpolation.</span>

<span class="sd">        max_attempts (int, optional): The maximum number of attempts to propose a valid</span>
<span class="sd">            crop_area (default=10). If exceeded, fall back to use center_crop instead.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `scale` is not of type tuple or list.</span>
<span class="sd">        TypeError: If `ratio` is not of type tuple or list.</span>
<span class="sd">        TypeError: If `interpolation` is not of type :class:`mindspore.dataset.vision.Inter`.</span>
<span class="sd">        TypeError: If `max_attempts` is not of type int.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        ValueError: If `scale` is negative.</span>
<span class="sd">        ValueError: If `ratio` is negative.</span>
<span class="sd">        ValueError: If `max_attempts` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; resize_crop_op = vision.RandomResizedCrop(size=(50, 75), scale=(0.25, 0.5),</span>
<span class="sd">        ...                                           interpolation=Inter.BILINEAR)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, resize_crop_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_resize_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">4.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">),</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Inter</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span> <span class="n">Inter</span><span class="o">.</span><span class="n">PILCUBIC</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="n">Inter</span><span class="o">.</span><span class="n">ANTIALIAS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span> <span class="o">=</span> <span class="n">max_attempts</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Current Interpolation is not supported with NumPy input.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomResizedCropOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span>

<div class="viewcode-block" id="RandomResizedCrop.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomResizedCrop.html#mindspore.dataset.vision.RandomResizedCrop.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be randomly cropped and resized.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, randomly cropped and resized image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Current Interpolation is not supported with PIL input.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_resize_crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomResizedCropWithBBox"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomResizedCropWithBBox.html#mindspore.dataset.vision.RandomResizedCropWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomResizedCropWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the input image to a random size and aspect ratio and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The size of the output image. The size value(s) must be positive.</span>
<span class="sd">            If size is an integer, a square crop of size (size, size) is returned.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        scale (list, tuple, optional): Range (min, max) of respective size of the original</span>
<span class="sd">            size to be cropped, which must be non-negative (default=(0.08, 1.0)).</span>
<span class="sd">        ratio (list, tuple, optional): Range (min, max) of aspect ratio to be</span>
<span class="sd">            cropped, which must be non-negative (default=(3. / 4., 4. / 3.)).</span>
<span class="sd">        interpolation (Inter mode, optional): Image interpolation mode (default=Inter.BILINEAR).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">        max_attempts (int, optional): The maximum number of attempts to propose a valid</span>
<span class="sd">            crop area (default=10). If exceeded, fall back to use center crop instead.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `scale` is not of type tuple.</span>
<span class="sd">        TypeError: If `ratio` is not of type tuple.</span>
<span class="sd">        TypeError: If `interpolation` is not of type Inter.</span>
<span class="sd">        TypeError: If `max_attempts` is not of type integer.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        ValueError: If `scale` is negative.</span>
<span class="sd">        ValueError: If `ratio` is negative.</span>
<span class="sd">        ValueError: If `max_attempts` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; bbox_op = vision.RandomResizedCropWithBBox(size=50, interpolation=Inter.NEAREST)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, bbox_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_resize_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">4.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">),</span>
                 <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span> <span class="o">=</span> <span class="n">max_attempts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomResizedCropWithBBoxOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span>
                                                      <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_attempts</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomResize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomResize.html#mindspore.dataset.vision.RandomResize">[docs]</a><span class="k">class</span> <span class="nc">RandomResize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the input image using a randomly selected interpolation mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The output size of the resized image. The size value(s) must be positive.</span>
<span class="sd">            If size is an integer, smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # randomly resize image, keeping aspect ratio</span>
<span class="sd">        &gt;&gt;&gt; transforms_list1 = [vision.Decode(), vision.RandomResize(50)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list1,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # randomly resize image to landscape style</span>
<span class="sd">        &gt;&gt;&gt; transforms_list2 = [vision.Decode(), vision.RandomResize((40, 60))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=transforms_list2,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomResizeOperation</span><span class="p">(</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomResizeWithBBox"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomResizeWithBBox.html#mindspore.dataset.vision.RandomResizeWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomResizeWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor operation to resize the input image using a randomly selected interpolation mode and adjust</span>
<span class="sd">    bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The output size of the resized image. The size value(s) must be positive.</span>
<span class="sd">            If size is an integer, smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # randomly resize image with bounding boxes, keeping aspect ratio</span>
<span class="sd">        &gt;&gt;&gt; transforms_list1 = [vision.Decode(), vision.RandomResizeWithBBox(60)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list1,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">        &gt;&gt;&gt; # randomly resize image with bounding boxes to portrait style</span>
<span class="sd">        &gt;&gt;&gt; transforms_list2 = [vision.Decode(), vision.RandomResizeWithBBox((80, 60))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset_1 = image_folder_dataset_1.map(operations=transforms_list2,</span>
<span class="sd">        ...                                                     input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomResizeWithBBoxOperation</span><span class="p">(</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomRotation"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomRotation.html#mindspore.dataset.vision.RandomRotation">[docs]</a><span class="k">class</span> <span class="nc">RandomRotation</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate the input image randomly within a specified range of degrees.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees (Union[int, float, sequence]): Range of random rotation degrees.</span>
<span class="sd">            If `degrees` is a number, the range will be converted to (-degrees, degrees).</span>
<span class="sd">            If `degrees` is a sequence, it should be (min, max).</span>
<span class="sd">        resample (Inter, optional): An optional resampling filter (default=Inter.NEAREST).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC, Inter.AREA].</span>

<span class="sd">            - Inter.BILINEAR, means resample method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means resample method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means resample method is bicubic interpolation.</span>

<span class="sd">            - Inter.AREA, means the interpolation method is area interpolation.</span>

<span class="sd">        expand (bool, optional):  Optional expansion flag (default=False). If set to True, expand the output</span>
<span class="sd">            image to make it large enough to hold the entire rotated image.</span>
<span class="sd">            If set to False or omitted, make the output image the same size as the input.</span>
<span class="sd">            Note that the expand flag assumes rotation around the center and no translation.</span>
<span class="sd">        center (tuple, optional): Optional center of rotation (a 2-tuple) (default=None).</span>
<span class="sd">            Origin is the top left corner. None sets to the center of the image.</span>
<span class="sd">        fill_value (Union[int, tuple[int]], optional): Optional fill color for the area outside the rotated image.</span>
<span class="sd">            If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `degrees` is not of type integer, float or sequence.</span>
<span class="sd">        TypeError: If `resample` is not of type Inter.</span>
<span class="sd">        TypeError: If `expand` is not of type boolean.</span>
<span class="sd">        TypeError: If `center` is not of type tuple.</span>
<span class="sd">        TypeError: If `fill_value` is not of type int or tuple[int].</span>
<span class="sd">        ValueError: If `fill_value` is not in range [0, 255].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(),</span>
<span class="sd">        ...                    vision.RandomRotation(degrees=5.0,</span>
<span class="sd">        ...                    resample=Inter.NEAREST,</span>
<span class="sd">        ...                    expand=True)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_rotation</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">%</span> <span class="mi">360</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">degrees</span><span class="p">,</span> <span class="n">degrees</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">360</span><span class="p">:</span>
                <span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="n">degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">360</span><span class="p">,</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">360</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">degrees</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">360</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">resample</span> <span class="o">==</span> <span class="n">Inter</span><span class="o">.</span><span class="n">AREA</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">resample</span> <span class="o">==</span> <span class="n">Inter</span><span class="o">.</span><span class="n">ANTIALIAS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">resample</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expand</span> <span class="o">=</span> <span class="n">expand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">py_center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_center</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Current Interpolation is not supported with NumPy input.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomRotationOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_resample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_center</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>

<div class="viewcode-block" id="RandomRotation.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomRotation.html#mindspore.dataset.vision.RandomRotation.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be randomly rotated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, randomly rotated image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Current Interpolation is not supported with PIL input.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_rotation</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_resample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomSelectSubpolicy"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomSelectSubpolicy.html#mindspore.dataset.vision.RandomSelectSubpolicy">[docs]</a><span class="k">class</span> <span class="nc">RandomSelectSubpolicy</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose a random sub-policy from a policy list to be applied on the input image.</span>

<span class="sd">    Args:</span>
<span class="sd">        policy (list[list[tuple[TensorOperation, float]]]): List of sub-policies to choose from.</span>
<span class="sd">            A sub-policy is a list of tuple[operation, prob], where operation is a data processing operation and prob</span>
<span class="sd">            is the probability that this operation will be applied, and the prob values must be in range [0, 1].</span>
<span class="sd">            Once a sub-policy is selected, each operation within the sub-policy with be applied in sequence according</span>
<span class="sd">            to its probability.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `policy` contains invalid data processing operations.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; policy = [[(vision.RandomRotation((45, 45)), 0.5),</span>
<span class="sd">        ...            (vision.RandomVerticalFlip(), 1),</span>
<span class="sd">        ...            (vision.RandomColorAdjust(), 0.8)],</span>
<span class="sd">        ...           [(vision.RandomRotation((90, 90)), 1),</span>
<span class="sd">        ...            (vision.RandomColorAdjust(), 0.2)]]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=vision.RandomSelectSubpolicy(policy),</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_select_subpolicy_op</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">policy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">list_one</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy</span><span class="p">:</span>
            <span class="n">policy_one</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">list_two</span> <span class="ow">in</span> <span class="n">list_one</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">list_two</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">list_two</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;parse&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">policy_one</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">list_two</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parse</span><span class="p">(),</span> <span class="n">list_two</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">policy_one</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">list_two</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">list_two</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">policy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">policy_one</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomSelectSubpolicyOperation</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomSharpness"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomSharpness.html#mindspore.dataset.vision.RandomSharpness">[docs]</a><span class="k">class</span> <span class="nc">RandomSharpness</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust the sharpness of the input image by a fixed or random degree. Degree of 0.0 gives a blurred image,</span>
<span class="sd">    degree of 1.0 gives the original image, and degree of 2.0 gives a sharpened image.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees (Union[list, tuple], optional): Range of random sharpness adjustment degrees,</span>
<span class="sd">            which must be non-negative. It should be in (min, max) format. If min=max, then</span>
<span class="sd">            it is a single fixed magnitude operation (default = (0.1, 1.9)).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError : If `degrees` is not a list or a tuple.</span>
<span class="sd">        ValueError: If `degrees` is negative.</span>
<span class="sd">        ValueError: If `degrees` is in (max, min) format instead of (min, max).</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomSharpness(degrees=(0.2, 1.9))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_positive_degrees</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomSharpnessOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>

<div class="viewcode-block" id="RandomSharpness.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomSharpness.html#mindspore.dataset.vision.RandomSharpness.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be sharpness adjusted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, sharpness adjusted image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_sharpness</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomSolarize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomSolarize.html#mindspore.dataset.vision.RandomSolarize">[docs]</a><span class="k">class</span> <span class="nc">RandomSolarize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly selects a subrange within the specified threshold range and sets the pixel value within</span>
<span class="sd">    the subrange to (255 - pixel).</span>

<span class="sd">    Args:</span>
<span class="sd">        threshold (tuple, optional): Range of random solarize threshold (default=(0, 255)).</span>
<span class="sd">            Threshold values should always be in (min, max) format,</span>
<span class="sd">            where min and max are integers in the range [0, 255], and min &lt;= max.</span>
<span class="sd">            If min=max, then invert all pixel values above min(max).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError : If `threshold` is not of type tuple.</span>
<span class="sd">        ValueError: If `threshold` is not in range of [0, 255].</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomSolarize(threshold=(10,100))]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_random_solarize</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomSolarizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span></div>


<div class="viewcode-block" id="RandomVerticalFlip"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomVerticalFlip.html#mindspore.dataset.vision.RandomVerticalFlip">[docs]</a><span class="k">class</span> <span class="nc">RandomVerticalFlip</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly flip the input image vertically with a given probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being flipped. Default=0.5.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomVerticalFlip(0.25)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomVerticalFlipOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span>

<div class="viewcode-block" id="RandomVerticalFlip.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomVerticalFlip.html#mindspore.dataset.vision.RandomVerticalFlip.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be vertically flipped.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, randomly vertically flipped image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">random_vertical_flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandomVerticalFlipWithBBox"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RandomVerticalFlipWithBBox.html#mindspore.dataset.vision.RandomVerticalFlipWithBBox">[docs]</a><span class="k">class</span> <span class="nc">RandomVerticalFlipWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flip the input image vertically, randomly with a given probability and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob (float, optional): Probability of the image being flipped (default=0.5).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `prob` is not of type float.</span>
<span class="sd">        ValueError: If `prob` is not in range [0, 1].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.RandomVerticalFlipWithBBox(0.20)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_prob</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RandomVerticalFlipWithBBoxOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rescale"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Rescale.html#mindspore.dataset.vision.Rescale">[docs]</a><span class="k">class</span> <span class="nc">Rescale</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescale the input image with the given rescale and shift. This operator will rescale the input image</span>
<span class="sd">    with: output = image * rescale + shift.</span>

<span class="sd">    Note:</span>
<span class="sd">        This operation supports running on Ascend or GPU platforms by Offload.</span>

<span class="sd">    Args:</span>
<span class="sd">        rescale (float): Rescale factor.</span>
<span class="sd">        shift (float): Shift factor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `rescale` is not of type float.</span>
<span class="sd">        TypeError: If `shift` is not of type float.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU`` ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.Rescale(1.0 / 255.0, -1.0)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_rescale</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rescale</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span> <span class="o">=</span> <span class="n">rescale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RescaleOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span></div>


<div class="viewcode-block" id="Resize"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Resize.html#mindspore.dataset.vision.Resize">[docs]</a><span class="k">class</span> <span class="nc">Resize</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">,</span> <span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the input image to the given size with a given interpolation mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The output size of the resized image. The size value(s) must be positive.</span>
<span class="sd">            If size is an integer, the smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        interpolation (Inter, optional): Image interpolation mode (default=Inter.BILINEAR).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.LINEAR, Inter.NEAREST, Inter.BICUBIC, Inter.AREA, Inter.PILCUBIC,</span>
<span class="sd">            Inter.ANTIALIAS].</span>

<span class="sd">            - Inter.BILINEAR, bilinear interpolation.</span>
<span class="sd">            - Inter.LINEAR, bilinear interpolation, here is the same as Inter.BILINEAR.</span>
<span class="sd">            - Inter.NEAREST, nearest-neighbor interpolation.</span>
<span class="sd">            - Inter.BICUBIC, bicubic interpolation.</span>
<span class="sd">            - Inter.AREA, pixel area interpolation.</span>
<span class="sd">            - Inter.PILCUBIC, bicubic interpolation like implemented in Pillow, only valid when the input is</span>
<span class="sd">              a 3-channel image in the numpy.ndarray format.</span>
<span class="sd">            - Inter.ANTIALIAS, antialias interpolation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `interpolation` is not of type Inter.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; resize_op = vision.Resize([100, 75], Inter.BICUBIC)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, resize_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize_interpolation</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">LINEAR</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">py_size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Inter</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span> <span class="n">Inter</span><span class="o">.</span><span class="n">PILCUBIC</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="n">Inter</span><span class="o">.</span><span class="n">ANTIALIAS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span> <span class="o">=</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_python_type</span><span class="p">(</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Current Interpolation is not supported with NumPy input.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">ResizeOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_interpolation</span><span class="p">)</span>

<div class="viewcode-block" id="Resize.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Resize.html#mindspore.dataset.vision.Resize.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be resized.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, resized image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Current Interpolation is not supported with PIL input.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">py_interpolation</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ResizeWithBBox"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.ResizeWithBBox.html#mindspore.dataset.vision.ResizeWithBBox">[docs]</a><span class="k">class</span> <span class="nc">ResizeWithBBox</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the input image to the given size and adjust bounding boxes accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, Sequence[int]]): The output size of the resized image.</span>
<span class="sd">            If size is an integer, smaller edge of the image will be resized to this value with</span>
<span class="sd">            the same image aspect ratio.</span>
<span class="sd">            If size is a sequence of length 2, it should be (height, width).</span>
<span class="sd">        interpolation (Inter mode, optional): Image interpolation mode (default=Inter.LINEAR).</span>
<span class="sd">            It can be any of [Inter.LINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.LINEAR, means interpolation method is bilinear interpolation.</span>

<span class="sd">            - Inter.NEAREST, means interpolation method is nearest-neighbor interpolation.</span>

<span class="sd">            - Inter.BICUBIC, means interpolation method is bicubic interpolation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type int or Sequence[int].</span>
<span class="sd">        TypeError: If `interpolation` is not of type Inter.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; bbox_op = vision.ResizeWithBBox(50, Inter.NEAREST)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, bbox_op]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_resize_interpolation</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">LINEAR</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">ResizeWithBBoxOperation</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">))</span></div>


<div class="viewcode-block" id="RgbToHsv"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RgbToHsv.html#mindspore.dataset.vision.RgbToHsv">[docs]</a><span class="k">class</span> <span class="nc">RgbToHsv</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input numpy.ndarray images from RGB to HSV.</span>

<span class="sd">    Args:</span>
<span class="sd">        is_hwc (bool): If True, means the input image is in shape of (H, W, C) or (N, H, W, C).</span>
<span class="sd">            Otherwise, it is in shape of (C, H, W) or (N, C, H, W). Default: False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `is_hwc` is not of type bool.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.CenterCrop(20),</span>
<span class="sd">        ...                            vision.ToTensor(),</span>
<span class="sd">        ...                            vision.RgbToHsv()])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_rgb_to_hsv</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_hwc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span> <span class="o">=</span> <span class="n">is_hwc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="RgbToHsv.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.RgbToHsv.html#mindspore.dataset.vision.RgbToHsv.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rgb_imgs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            rgb_imgs (numpy.ndarray): RGB images to be converted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, converted HSV images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">rgb_to_hsvs</span><span class="p">(</span><span class="n">rgb_imgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hwc</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Rotate"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.Rotate.html#mindspore.dataset.vision.Rotate">[docs]</a><span class="k">class</span> <span class="nc">Rotate</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate the input image by specified degrees.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees (Union[int, float]): Rotation degrees.</span>

<span class="sd">        resample (Inter mode, optional): An optional resampling filter (default=Inter.NEAREST).</span>
<span class="sd">            It can be any of [Inter.BILINEAR, Inter.NEAREST, Inter.BICUBIC].</span>

<span class="sd">            - Inter.BILINEAR, means resample method is bilinear interpolation.</span>
<span class="sd">            - Inter.NEAREST, means resample method is nearest-neighbor interpolation.</span>
<span class="sd">            - Inter.BICUBIC, means resample method is bicubic interpolation.</span>

<span class="sd">        expand (bool, optional):  Optional expansion flag (default=False). If set to True, expand the output</span>
<span class="sd">            image to make it large enough to hold the entire rotated image.</span>
<span class="sd">            If set to False or omitted, make the output image the same size as the input.</span>
<span class="sd">            Note that the expand flag assumes rotation around the center and no translation.</span>
<span class="sd">        center (tuple, optional): Optional center of rotation (a 2-tuple) (default=None).</span>
<span class="sd">            Origin is the top left corner. None sets to the center of the image.</span>
<span class="sd">        fill_value (Union[int, tuple[int]], optional): Optional fill color for the area outside the rotated image.</span>
<span class="sd">            If it is a 3-tuple, it is used to fill R, G, B channels respectively.</span>
<span class="sd">            If it is an integer, it is used for all RGB channels.</span>
<span class="sd">            The fill_value values must be in range [0, 255] (default=0).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `degrees` is not of type integer, float or sequence.</span>
<span class="sd">        TypeError: If `resample` is not of type Inter.</span>
<span class="sd">        TypeError: If `expand` is not of type bool.</span>
<span class="sd">        TypeError: If `center` is not of type tuple.</span>
<span class="sd">        TypeError: If `fill_value` is not of type int or tuple[int].</span>
<span class="sd">        ValueError: If `fill_value` is not in range [0, 255].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.vision import Inter</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(),</span>
<span class="sd">        ...                    vision.Rotate(degrees=30.0,</span>
<span class="sd">        ...                    resample=Inter.NEAREST,</span>
<span class="sd">        ...                    expand=True)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_rotate</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">Inter</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resample</span> <span class="o">=</span> <span class="n">resample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expand</span> <span class="o">=</span> <span class="n">expand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">RotateOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="n">Inter</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="SlicePatches"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.SlicePatches.html#mindspore.dataset.vision.SlicePatches">[docs]</a><span class="k">class</span> <span class="nc">SlicePatches</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Slice Tensor to multiple patches in horizontal and vertical directions.</span>

<span class="sd">    The usage scenario is suitable to large height and width Tensor. The Tensor</span>
<span class="sd">    will keep the same if set both num_height and num_width to 1. And the</span>
<span class="sd">    number of output tensors is equal to num_height*num_width.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_height (int, optional): The number of patches in vertical direction, which must be positive (default=1).</span>
<span class="sd">        num_width (int, optional): The number of patches in horizontal direction, which must be positive (default=1).</span>
<span class="sd">        slice_mode (Inter, optional): A mode represents pad or drop (default=SliceMode.PAD).</span>
<span class="sd">            It can be any of [SliceMode.PAD, SliceMode.DROP].</span>
<span class="sd">        fill_value (int, optional): The border width in number of pixels in</span>
<span class="sd">            right and bottom direction if slice_mode is set to be SliceMode.PAD.</span>
<span class="sd">            The fill_value must be in range [0, 255] (default=0).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `num_height` is not of type integer.</span>
<span class="sd">        TypeError: If `num_width` is not of type integer.</span>
<span class="sd">        TypeError: If `slice_mode` is not of type Inter.</span>
<span class="sd">        TypeError: If `fill_value` is not of type integer.</span>
<span class="sd">        ValueError: If `num_height` is not positive.</span>
<span class="sd">        ValueError: If `num_width` is not positive.</span>
<span class="sd">        ValueError: If `fill_value` is not in range [0, 255].</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # default padding mode</span>
<span class="sd">        &gt;&gt;&gt; decode_op = vision.Decode()</span>
<span class="sd">        &gt;&gt;&gt; num_h, num_w = (1, 4)</span>
<span class="sd">        &gt;&gt;&gt; slice_patches_op = vision.SlicePatches(num_h, num_w)</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [decode_op, slice_patches_op]</span>
<span class="sd">        &gt;&gt;&gt; cols = [&#39;img&#39; + str(x) for x in range(num_h*num_w)]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;],</span>
<span class="sd">        ...                                                 output_columns=cols, column_order=cols)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_slice_patches</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">slice_mode</span><span class="o">=</span><span class="n">SliceMode</span><span class="o">.</span><span class="n">PAD</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_height</span> <span class="o">=</span> <span class="n">num_height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_width</span> <span class="o">=</span> <span class="n">num_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_mode</span> <span class="o">=</span> <span class="n">slice_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">SlicePatchesOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_width</span><span class="p">,</span>
                                         <span class="n">SliceMode</span><span class="o">.</span><span class="n">to_c_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_mode</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="TenCrop"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.TenCrop.html#mindspore.dataset.vision.TenCrop">[docs]</a><span class="k">class</span> <span class="nc">TenCrop</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the given image into one central crop and four corners with the flipped version of these.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (Union[int, sequence]): The size of the cropped image.</span>
<span class="sd">            If a single integer is provided, a square of size (size, size) will be cropped with this value.</span>
<span class="sd">            If a sequence of length 2 is provided, an image of size (height, width) will be cropped.</span>
<span class="sd">        use_vertical_flip (bool, optional): If True, flip the images vertically. Otherwise, flip them</span>
<span class="sd">            horizontally. Default: False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `size` is not of type integer or sequence of integer.</span>
<span class="sd">        TypeError: If `use_vertical_flip` is not of type boolean.</span>
<span class="sd">        ValueError: If `size` is not positive.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.TenCrop(size=200),</span>
<span class="sd">        ...                            # 4D stack of 10 images</span>
<span class="sd">        ...                            lambda *images: numpy.stack([vision.ToTensor()(image) for image in images])])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_ten_crop</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">use_vertical_flip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_vertical_flip</span> <span class="o">=</span> <span class="n">use_vertical_flip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="TenCrop.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.TenCrop.html#mindspore.dataset.vision.TenCrop.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be cropped.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple, a tuple of 10 PIL Image, in order of top_left, top_right, bottom_left, bottom_right, center</span>
<span class="sd">                of the original image and top_left, top_right, bottom_left, bottom_right, center of the flipped image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">ten_crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_vertical_flip</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ToNumpy"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.ToNumpy.html#mindspore.dataset.vision.ToNumpy">[docs]</a><span class="k">class</span> <span class="nc">ToNumpy</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the PIL input image to numpy.ndarray image.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Use ToNumpy to explicitly select C++ implementation of subsequent op</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(True),</span>
<span class="sd">        ...                            vision.RandomHorizontalFlip(0.5),</span>
<span class="sd">        ...                            vision.ToNumpy(),</span>
<span class="sd">        ...                            vision.Resize(100, 120)])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Use &quot;Implementation.C&quot; to indicate to select C++ implementation for next op in transforms list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

<div class="viewcode-block" id="ToNumpy.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.ToNumpy.html#mindspore.dataset.vision.ToNumpy.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be converted to numpy.ndarray.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Image converted to numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ToPIL"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.ToPIL.html#mindspore.dataset.vision.ToPIL">[docs]</a><span class="k">class</span> <span class="nc">ToPIL</span><span class="p">(</span><span class="n">PyTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input decoded numpy.ndarray image to PIL Image.</span>

<span class="sd">    Note:</span>
<span class="sd">        The conversion mode will be determined by the data type using :class:`PIL.Image.fromarray`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input image is not of type :class:`numpy.ndarray` or :class:`PIL.Image.Image`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # data is already decoded, but not in PIL Image format</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.ToPIL(),</span>
<span class="sd">        ...                            vision.RandomHorizontalFlip(0.5),</span>
<span class="sd">        ...                            vision.ToTensor()])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PY</span>

<div class="viewcode-block" id="ToPIL.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.ToPIL.html#mindspore.dataset.vision.ToPIL.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (numpy.ndarray): Decoded numpy.ndarray image to be converted to PIL Image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, converted PIL Image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">to_pil</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ToTensor"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.ToTensor.html#mindspore.dataset.vision.ToTensor">[docs]</a><span class="k">class</span> <span class="nc">ToTensor</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input PIL Image or numpy.ndarray to numpy.ndarray of the desired dtype, rescale the pixel value</span>
<span class="sd">    range from [0, 255] to [0.0, 1.0] and change the shape from (H, W, C) to (C, H, W).</span>

<span class="sd">    Args:</span>
<span class="sd">        output_type (Union[mindspore.dtype, numpy.dtype], optional): The desired dtype of the output image.</span>
<span class="sd">            Default: :class:`numpy.float32`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input image is not of type :class:`PIL.Image.Image` or :class:`numpy.ndarray`.</span>
<span class="sd">        TypeError: If dimension of the input image is not 2 or 3.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # create a list of transformations to be applied to the &quot;image&quot; column of each data row</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.RandomHorizontalFlip(0.5),</span>
<span class="sd">        ...                            vision.ToTensor()])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_to_tensor</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_type</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">):</span>
            <span class="n">output_type</span> <span class="o">=</span> <span class="n">mstype_to_detype</span><span class="p">(</span><span class="n">output_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_type</span> <span class="o">=</span> <span class="n">nptype_to_detype</span><span class="p">(</span><span class="n">output_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">ToTensorOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="ToType"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.ToType.html#mindspore.dataset.vision.ToType">[docs]</a><span class="k">class</span> <span class="nc">ToType</span><span class="p">(</span><span class="n">TypeCast</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cast the input to a given MindSpore data type or NumPy data type.</span>

<span class="sd">    It is the same as that of :class:`mindspore.dataset.transforms.TypeCast`.</span>

<span class="sd">    Note:</span>
<span class="sd">        This operation supports running on Ascend or GPU platforms by Offload.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_type (Union[mindspore.dtype, numpy.dtype]): The desired data type of the output image,</span>
<span class="sd">            such as :class:`numpy.float32`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `data_type` is not of type :class:`mindspore.dtype` or :class:`numpy.dtype`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU`` ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.RandomHorizontalFlip(0.5),</span>
<span class="sd">        ...                            vision.ToTensor(),</span>
<span class="sd">        ...                            vision.ToType(np.float32)])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="UniformAugment"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.UniformAugment.html#mindspore.dataset.vision.UniformAugment">[docs]</a><span class="k">class</span> <span class="nc">UniformAugment</span><span class="p">(</span><span class="n">CompoundOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uniformly select a number of transformations from a sequence and apply them</span>
<span class="sd">    sequentially and randomly, which means that there is a chance that a chosen</span>
<span class="sd">    transformation will not be applied.</span>

<span class="sd">    All transformations in the sequence require the output type to be the same as</span>
<span class="sd">    the input. Thus, the latter one can deal with the output of the previous one.</span>

<span class="sd">    Args:</span>
<span class="sd">         transforms (sequence): Sequence of transformations to select from.</span>
<span class="sd">         num_ops (int, optional): Number of transformations to be sequentially and randomly applied. Default: 2.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `transforms` is not a sequence of data processing operations.</span>
<span class="sd">        TypeError: If `num_ops` is not of type integer.</span>
<span class="sd">        ValueError: If `num_ops` is not positive.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset.transforms import Compose</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; transforms = [vision.CenterCrop(64),</span>
<span class="sd">        ...               vision.RandomColor(),</span>
<span class="sd">        ...               vision.RandomSharpness(),</span>
<span class="sd">        ...               vision.RandomRotation(30)]</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = Compose([vision.Decode(to_pil=True)),</span>
<span class="sd">        ...                            vision.UniformAugment(transforms),</span>
<span class="sd">        ...                            vision.ToTensor()])</span>
<span class="sd">        &gt;&gt;&gt; # apply the transform to dataset through map function</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=&quot;image&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_uniform_augment</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="n">num_ops</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ops</span> <span class="o">=</span> <span class="n">num_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">operations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_transforms</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">UniformAugOperation</span><span class="p">(</span><span class="n">operations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ops</span><span class="p">)</span>

<div class="viewcode-block" id="UniformAugment.execute_py"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.UniformAugment.html#mindspore.dataset.vision.UniformAugment.execute_py">[docs]</a>    <span class="k">def</span> <span class="nf">execute_py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute method.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (PIL Image): Image to be transformed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL Image, transformed image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">uniform_augment</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ops</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="VerticalFlip"><a class="viewcode-back" href="../../../../api_python/dataset_vision/mindspore.dataset.vision.VerticalFlip.html#mindspore.dataset.vision.VerticalFlip">[docs]</a><span class="k">class</span> <span class="nc">VerticalFlip</span><span class="p">(</span><span class="n">ImageTensorOperation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flip the input image vertically.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If given tensor shape is not &lt;H, W&gt; or &lt;H, W, C&gt;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; transforms_list = [vision.Decode(), vision.VerticalFlip()]</span>
<span class="sd">        &gt;&gt;&gt; image_folder_dataset = image_folder_dataset.map(operations=transforms_list,</span>
<span class="sd">        ...                                                 input_columns=[&quot;image&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implementation</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">C</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cde</span><span class="o">.</span><span class="n">VerticalFlipOperation</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">not_random</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specify the function as &quot;not random&quot;, i.e., it produces deterministic result.</span>
<span class="sd">    A Python function can only be cached after it is specified as &quot;not random&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">func</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>