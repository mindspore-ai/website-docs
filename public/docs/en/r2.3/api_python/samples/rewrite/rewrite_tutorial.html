<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modifying Network With ReWrite &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script><script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/js/theme.js"></script><script src="../../../_static/underscore.js"></script><script src="../../../_static/doctools.js"></script><script src="../../../_static/js/mermaid-9.3.0.js"></script><script crossorigin="anonymous" integrity="sha256-1fEPhSsRKlFKGfK3eO710tEweHh1fwokU5wFGDHO+vg=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../design/overview.html">MindSpore Design Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/programming_paradigm.html">Functional and Object-Oriented Fusion Programming Paradigm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/dynamic_graph_and_static_graph.html">Combination of Dynamic and Static Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/distributed_training_design.html">Distributed Parallel Native</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/data_engine.html">High Performance Data Processing Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/all_scenarios.html">Full-scenarios Unified Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/graph_fusion_engine.html">Graph-Kernel Fusion Acceleration Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/pluggable_device.html">Third-Party Hardware Interconnection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../note/official_models.html">Official Models</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.ops.primitive.html">mindspore.ops.primitive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.amp.html">mindspore.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.hal.html">mindspore.hal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.rewrite.html">mindspore.rewrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.multiprocessing.html">mindspore.multiprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.boost.html">mindspore.boost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.scipy.html">mindspore.scipy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mindspore.experimental.html">mindspore.experimental</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Mapping</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../note/api_mapping/pytorch_api_mapping.html">PyTorch and MindSpore API Mapping Table</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Migration Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../migration_guide/overview.html">Overview of Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../migration_guide/enveriment_preparation.html">Environment Preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../migration_guide/analysis_and_preparation.html">Model Analysis and Preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../migration_guide/model_development/model_development.html">Network Constructing Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../migration_guide/debug_and_tune.html">Debugging and Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../migration_guide/sample_code.html">Network Migration Debugging Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../migration_guide/faq.html">FAQs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Syntax Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../note/static_graph_syntax_support.html">Static Graph Syntax Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../note/static_graph_syntax/operators.html">Static Graph Syntax - Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../note/static_graph_syntax/statements.html">Static Graph Syntax - Python Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../note/static_graph_syntax/python_builtin_functions.html">Static Graph Syntax - Python Built-in Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../note/index_support.html">Tensor Index Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Environment Variables</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../note/env_var_list.html">Environment Variables</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/data_processing.html">Data Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/implement_problem.html">Implement Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/network_compilation.html">Network Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/operators_compile.html">Operators Compile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/usage_migrate_3rd.html">Migration from a Third-party Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/performance_tuning.html">Performance Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/precision_tuning.html">Precision Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/distributed_parallel.html">Distributed Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/feature_advice.html">Feature Advice</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Modifying Network With ReWrite</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/api_python/samples/rewrite/rewrite_tutorial.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section class="tex2jax_ignore mathjax_ignore" id="modifying-network-with-rewrite">
<h1>Modifying Network With ReWrite<a class="headerlink" href="#modifying-network-with-rewrite" title="Permalink to this headline"></a></h1>
<p><a class="reference external" href="https://gitee.com/mindspore/mindspore/blob/r2.3/docs/api/api_python_en/samples/rewrite/rewrite_tutorial.md"><img alt="View Source On Gitee" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.3/resource/_static/logo_source_en.svg" /></a></p>
<p>This example illustrates the various usages of APIs available in the <a class="reference external" href="https://www.mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html">mindspore.rewrite</a> module.</p>
<p>For a complete ReWrite example, refer to
<a class="reference external" href="https://gitee.com/mindspore/mindspore/blob/r2.3/docs/api/api_python_en/rewrite_example.py">rewrite_example.py</a> .
The main functions of the sample code include: how to create a SymbolTree through the network, and how to insert, delete,
and replace the nodes in the SymbolTree. It also includes the modification of the subnet and node replacement through pattern
matching.</p>
<section id="function-introduction">
<h2>Function Introduction<a class="headerlink" href="#function-introduction" title="Permalink to this headline"></a></h2>
<p>ReWrite module uses SymbolTree to record the forward computation of a network, where each code statement of the
forward computation process is expanded and stored in the SymbolTree as nodes.</p>
<p>The ReWrite module provides a new set of interfaces that users can use to create a SymbolTree for a network and then
modify the nodes in the SymbolTree to achieve the network forward computation process modification. Finally, a modified
network code, or a new network instance can be obtained.</p>
</section>
<section id="creating-a-symboltree">
<h2>Creating A SymbolTree<a class="headerlink" href="#creating-a-symboltree" title="Permalink to this headline"></a></h2>
<p>When we need to modify a network using the ReWrite module, we first need to create a SymbolTree based on the instance
of the network, using the interface <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.create">mindspore.rewrite.SymbolTree.create</a> .</p>
<p>Through the use of the interface <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.get_code">mindspore.rewrite.SymbolTree.get_code</a>, we can view the network code currently
stored in SymbolTree.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">mindspore.rewrite</span> <span class="kn">import</span> <span class="n">SymbolTree</span>

<span class="k">class</span> <span class="nc">MyNet</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">has_bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weight_init</span><span class="o">=</span><span class="s2">&quot;ones&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="n">net</span> <span class="o">=</span> <span class="n">MyNet</span><span class="p">()</span>
<span class="n">stree</span> <span class="o">=</span> <span class="n">SymbolTree</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stree</span><span class="o">.</span><span class="n">get_code</span><span class="p">())</span>
</pre></div>
</div>
<p>The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>import sys
sys.path.append(&#39;...&#39;) # Current working directory
import mindspore
from mindspore import nn
import mindspore.nn as nn

class MyNetOpt(nn.Cell):

    def __init__(self, obj):
        super().__init__()
        for (key, value) in obj.__dict__.items():
            setattr(self, key, value)

    def construct(self, x):
        x = self.dense(x)
        x = self.relu(x)
        return x
</pre></div>
</div>
<p>It can be seen that by parsing the network <code class="docutils literal notranslate"><span class="pre">MyNet</span></code> , the class name of the new network stored in SymbolTree is <code class="docutils literal notranslate"><span class="pre">MyNetOpt</span></code> ,
which adds the suffix <code class="docutils literal notranslate"><span class="pre">Opt</span></code> to the original network.</p>
<p>At the same time, the parameters and content of the init function have been changed. The new parameter <code class="docutils literal notranslate"><span class="pre">obj</span></code> is passed into
the instance of the original network, and the attribute information of the original network is copied to the new network in
the function.</p>
<p>The new network also saves the current working directory to <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> , ensuring that modules that the original network
depends on can be searched for when running on the new network.</p>
<p>By using the interface <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.print_node_tabulate">mindspore.rewrite.SymbolTree.print_node_tabulate</a> , we can see the node information and node
topology relationships stored in the SymbolTree.
This interface depends on the tabulate module, and the installation command is: <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">tabulate</span></code> .</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stree</span><span class="o">.</span><span class="n">print_node_tabulate</span><span class="p">()</span>
</pre></div>
</div>
<p>The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>================================================================================
node type          name     codes              arg providers          target users
-----------------  -------  -----------------  ---------------------  ----------------------
NodeType.Input     input_x  x                  []                     [[0, [(&#39;dense&#39;, 0)]]]
NodeType.CallCell  dense    x = self.dense(x)  [[0, (&#39;input_x&#39;, 0)]]  [[0, [(&#39;relu&#39;, 0)]]]
NodeType.CallCell  relu     x = self.relu(x)   [[0, (&#39;dense&#39;, 0)]]    [[0, [(&#39;return&#39;, 0)]]]
NodeType.Output    return   return x           [[0, (&#39;relu&#39;, 0)]]     []
==================================================================================
</pre></div>
</div>
<p>It can be seen that each statement in the network’s forward computation process is converted to a node, where the name
of each node is unique.
The SymbolTree records the topological relationship between each node, that is, the output of which node an input comes
from, and the output of a node is used by which input of which node.</p>
<p>When there are complex statements in the forward computation process, the statements are expanded during the creation
of SymbolTree, and then each expanded statement is converted to a node.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">mindspore.rewrite</span> <span class="kn">import</span> <span class="n">SymbolTree</span>

<span class="k">class</span> <span class="nc">MyNet_2</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">has_bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weight_init</span><span class="o">=</span><span class="s2">&quot;ones&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="n">net</span> <span class="o">=</span> <span class="n">MyNet_2</span><span class="p">()</span>
<span class="n">stree</span> <span class="o">=</span> <span class="n">SymbolTree</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="n">stree</span><span class="o">.</span><span class="n">print_node_tabulate</span><span class="p">()</span>
</pre></div>
</div>
<p>The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>================================================================================
node type          name        codes                     arg providers             target users
-----------------  ----------  ------------------------  ------------------------  --------------------------
NodeType.Input     input_x     x                         []                        [[0, [(&#39;dense&#39;, 0)]]]
NodeType.CallCell  dense       dense = self.dense(x)     [[0, (&#39;input_x&#39;, 0)]]     [[0, [(&#39;binop_mult&#39;, 1)]]]
NodeType.MathOps   binop_mult  mult_var = (0.5 * dense)  [[1, (&#39;dense&#39;, 0)]]       [[0, [(&#39;relu&#39;, 0)]]]
NodeType.CallCell  relu        x = self.relu(mult_var)   [[0, (&#39;binop_mult&#39;, 0)]]  [[0, [(&#39;return&#39;, 0)]]]
NodeType.Output    return      return x                  [[0, (&#39;relu&#39;, 0)]]        []
==================================================================================
</pre></div>
</div>
<p>It can be seen that the dense, multiplication, and relu operations written on the same line during forward computing are
expanded into three lines of code and then converted into three corresponding nodes.</p>
</section>
<section id="inserting-nodes">
<h2>Inserting Nodes<a class="headerlink" href="#inserting-nodes" title="Permalink to this headline"></a></h2>
<p>When we need to insert a new line of code during the forward computation of the network, we can first create a new node
using interface <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.Node.create_call_cell">mindspore.rewrite.Node.create_call_cell</a> , and then insert the created node into SymbolTree
using interface <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.insert">mindspore.rewrite.SymbolTree.insert</a> .</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore.rewrite</span> <span class="kn">import</span> <span class="n">SymbolTree</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ScopedValue</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">MyNet</span><span class="p">()</span>
<span class="n">stree</span> <span class="o">=</span> <span class="n">SymbolTree</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="n">new_relu_cell</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
<span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">create_call_cell</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="n">new_relu_cell</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">ScopedValue</span><span class="o">.</span><span class="n">create_naming_value</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;new_relu&quot;</span><span class="p">)</span>
<span class="n">dense_node</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">&quot;dense&quot;</span><span class="p">)</span>
<span class="n">stree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stree</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="n">dense_node</span><span class="p">),</span> <span class="n">new_node</span><span class="p">)</span>
<span class="n">stree</span><span class="o">.</span><span class="n">print_node_tabulate</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, the process for inserting a node is as follows:</p>
<ol class="arabic simple">
<li><p>Firstly, a new node is created. The Cell used is <code class="docutils literal notranslate"><span class="pre">nn.ReLU()</span></code> , the input and output are <code class="docutils literal notranslate"><span class="pre">&quot;x&quot;</span></code> , and the node name is <code class="docutils literal notranslate"><span class="pre">&quot;new_relu&quot;</span></code> .</p></li>
<li><p>Then the dense node is fetched by using <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.get_node">mindspore.rewrite.SymbolTree.get_node</a> .</p></li>
<li><p>Finally, the newly created node is inserted after the dense node through <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.insert">mindspore.rewrite.SymbolTree.insert</a> .</p></li>
</ol>
<p>The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>================================================================================
node type          name      codes                 arg providers           target users
-----------------  --------  --------------------  ----------------------  ------------------------
NodeType.Input     input_x   x                     []                      [[0, [(&#39;dense&#39;, 0)]]]
NodeType.CallCell  dense     x = self.dense(x)     [[0, (&#39;input_x&#39;, 0)]]   [[0, [(&#39;new_relu&#39;, 0)]]]
NodeType.CallCell  new_relu  x = self.new_relu(x)  [[0, (&#39;dense&#39;, 0)]]     [[0, [(&#39;relu&#39;, 0)]]]
NodeType.CallCell  relu      x = self.relu(x)      [[0, (&#39;new_relu&#39;, 0)]]  [[0, [(&#39;return&#39;, 0)]]]
NodeType.Output    return    return x              [[0, (&#39;relu&#39;, 0)]]      []
==================================================================================
</pre></div>
</div>
<p>It can be seen that the new new_relu node is inserted between the dense node and the relu node, and the topology of
node is automatically updated with the node insertion.
The definition of <code class="docutils literal notranslate"><span class="pre">self.new_relu</span></code> in the code of new node is saved in the init function of the new network, using
parameter <code class="docutils literal notranslate"><span class="pre">new_relu_cell</span></code> as the instance.</p>
<p>In addition to getting nodes using <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.get_node">mindspore.rewrite.SymbolTree.get_node</a> to specify the insertion location, we can
also iterate through nodes by <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.nodes">mindspore.rewrite.SymbolTree.nodes</a> and use <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.Node.get_instance_type">mindspore.rewrite.Node.get_instance_type</a>
to get the node and determine the insertion position based on the type of corresponding instance of node.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">stree</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get_instance_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">:</span>
        <span class="n">stree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stree</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">new_node</span><span class="p">)</span>
</pre></div>
</div>
<p>If we want the output of new code to be inserted does not reuse variables from the original network, we can
use <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.unique_name">mindspore.rewrite.SymbolTree.unique_name</a> to get an variable name that are not duplicated in the SymbolTree
as the output of node when creating nodes.</p>
<p>Then, before inserting the node, we can modify the node input variable name by using <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.Node.set_arg">mindspore.rewrite.Node.set_arg</a>
to set which nodes use the new node output as input.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore.rewrite</span> <span class="kn">import</span> <span class="n">SymbolTree</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ScopedValue</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">MyNet</span><span class="p">()</span>
<span class="n">stree</span> <span class="o">=</span> <span class="n">SymbolTree</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="n">new_relu_cell</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
<span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">create_call_cell</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="n">new_relu_cell</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="n">stree</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)],</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">ScopedValue</span><span class="o">.</span><span class="n">create_naming_value</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;new_relu&quot;</span><span class="p">)</span>
<span class="n">dense_node</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">&quot;dense&quot;</span><span class="p">)</span>
<span class="n">stree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stree</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="n">dense_node</span><span class="p">),</span> <span class="n">new_node</span><span class="p">)</span>
<span class="n">old_relu_node</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">&quot;relu&quot;</span><span class="p">)</span>
<span class="n">old_relu_node</span><span class="o">.</span><span class="n">set_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_node</span><span class="o">.</span><span class="n">get_targets</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">stree</span><span class="o">.</span><span class="n">print_node_tabulate</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, when creating a new node, the value of the <code class="docutils literal notranslate"><span class="pre">targets</span></code> parameter is treated without duplication,
and the input of old relu node is changed to the output of new node.</p>
<p>The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>================================================================================
node type          name      codes                   arg providers           target users
-----------------  --------  ----------------------  ----------------------  ------------------------
NodeType.Input     input_x   x                       []                      [[0, [(&#39;dense&#39;, 0)]]]
NodeType.CallCell  dense     x = self.dense(x)       [[0, (&#39;input_x&#39;, 0)]]   [[0, [(&#39;new_relu&#39;, 0)]]]
NodeType.CallCell  new_relu  x_1 = self.new_relu(x)  [[0, (&#39;dense&#39;, 0)]]     [[0, [(&#39;relu&#39;, 0)]]]
NodeType.CallCell  relu      x = self.relu(x_1)      [[0, (&#39;new_relu&#39;, 0)]]  [[0, [(&#39;return&#39;, 0)]]]
NodeType.Output    return    return x                [[0, (&#39;relu&#39;, 0)]]      []
==================================================================================
</pre></div>
</div>
<p>It can be seen that the output variable name of new node is an unnamed name <code class="docutils literal notranslate"><span class="pre">x_1</span></code> , and the old relu node uses <code class="docutils literal notranslate"><span class="pre">x_1</span></code> as input.</p>
</section>
<section id="deleting-nodes">
<h2>Deleting Nodes<a class="headerlink" href="#deleting-nodes" title="Permalink to this headline"></a></h2>
<p>When we need to delete a line of code during the forward computation of the network, we can use the interface
<a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.erase">mindspore.rewrite.SymbolTree.erase</a> to delete the node.</p>
<p>After the node is deleted, the topological relationship of the remaining nodes in the symbol tree will be automatically
updated according to the code of network after deletion.
Therefore, when the output of node to be deleted is used by other nodes, we need to pay attention to whether the topological
relationship of the remaining nodes meets the design expectations after the node is deleted.</p>
<p>If a node exists in front of the node to be deleted that has the same output name as the node to be deleted, after the node
is deleted, the output of the previous node is automatically used as input for the node that uses the output name as the input.
The topology relationship is updated according to this policy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore.rewrite</span> <span class="kn">import</span> <span class="n">SymbolTree</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ScopedValue</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">MyNet</span><span class="p">()</span>
<span class="n">stree</span> <span class="o">=</span> <span class="n">SymbolTree</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="n">relu_node</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">&quot;relu&quot;</span><span class="p">)</span>
<span class="n">stree</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">relu_node</span><span class="p">)</span>
<span class="n">stree</span><span class="o">.</span><span class="n">print_node_tabulate</span><span class="p">()</span>
</pre></div>
</div>
<p>The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>================================================================================
node type          name     codes              arg providers          target users
-----------------  -------  -----------------  ---------------------  ----------------------
NodeType.Input     input_x  x                  []                     [[0, [(&#39;dense&#39;, 0)]]]
NodeType.CallCell  dense    x = self.dense(x)  [[0, (&#39;input_x&#39;, 0)]]  [[0, [(&#39;return&#39;, 0)]]]
NodeType.Output    return   return x           [[0, (&#39;dense&#39;, 0)]]    []
==================================================================================
</pre></div>
</div>
<p>It can be seen that because the output of dense node and the output of relu node have the same name, after deleting
the relu node, the return value uses the output of the dense node.</p>
<p>If there is no node that has the same output name as the node to be deleted in front of the node to be deleted, we need
to modify subsequent nodes that uses this output as input by updating the input names, and then delete the node, in order
to avoid errors using undefined variables after deleting the node.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">mindspore.rewrite</span> <span class="kn">import</span> <span class="n">SymbolTree</span>

<span class="k">class</span> <span class="nc">MyNet_3</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">has_bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weight_init</span><span class="o">=</span><span class="s2">&quot;ones&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span>

<span class="n">net</span> <span class="o">=</span> <span class="n">MyNet_3</span><span class="p">()</span>
<span class="n">stree</span> <span class="o">=</span> <span class="n">SymbolTree</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="n">relu_node</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">&quot;relu&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">relu_node</span><span class="o">.</span><span class="n">get_users</span><span class="p">():</span>
    <span class="n">node</span><span class="o">.</span><span class="n">set_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">relu_node</span><span class="o">.</span><span class="n">get_args</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">stree</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">relu_node</span><span class="p">)</span>
<span class="n">stree</span><span class="o">.</span><span class="n">print_node_tabulate</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, after getting the relu node, first we use the interface <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.Node.get_users">mindspore.rewrite.Node.get_users</a> to
iterate through the nodes that use the output of relu node as input, change the input of these nodes to the input of relu
node, and then delete the relu node. In this case, the subsequent use of the relu node output <code class="docutils literal notranslate"><span class="pre">z</span></code> will be changed to
the relu node input <code class="docutils literal notranslate"><span class="pre">y</span></code> .</p>
<p>The specific parameter name modification strategy depends on the actual scenario requirements.</p>
<p>The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>================================================================================
node type          name     codes              arg providers          target users
-----------------  -------  -----------------  ---------------------  ----------------------
NodeType.Input     input_x  x                  []                     [[0, [(&#39;dense&#39;, 0)]]]
NodeType.CallCell  dense    y = self.dense(x)  [[0, (&#39;input_x&#39;, 0)]]  [[0, [(&#39;return&#39;, 0)]]]
NodeType.Output    return   return y           [[0, (&#39;dense&#39;, 0)]]    []
==================================================================================
</pre></div>
</div>
<p>It can be seen that after deleting the relu node, the value of the last return node is updated from <code class="docutils literal notranslate"><span class="pre">z</span></code> to <code class="docutils literal notranslate"><span class="pre">y</span></code> .</p>
</section>
<section id="replacing-nodes">
<h2>Replacing Nodes<a class="headerlink" href="#replacing-nodes" title="Permalink to this headline"></a></h2>
<p>When we need to replace code during the forward computation of network, we can replace the node with the
interface <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.replace">mindspore.rewrite.SymbolTree.replace</a> .</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore.rewrite</span> <span class="kn">import</span> <span class="n">SymbolTree</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ScopedValue</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">MyNet</span><span class="p">()</span>
<span class="n">stree</span> <span class="o">=</span> <span class="n">SymbolTree</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="n">new_relu_cell</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
<span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">create_call_cell</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="n">new_relu_cell</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">ScopedValue</span><span class="o">.</span><span class="n">create_naming_value</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;new_relu&quot;</span><span class="p">)</span>
<span class="n">relu_node</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">&quot;relu&quot;</span><span class="p">)</span>
<span class="n">stree</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">relu_node</span><span class="p">,</span> <span class="p">[</span><span class="n">new_node</span><span class="p">])</span>
<span class="n">stree</span><span class="o">.</span><span class="n">print_node_tabulate</span><span class="p">()</span>
</pre></div>
</div>
<p>This example replaces relu node in the original network with new_relu node. The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>================================================================================
node type          name      codes                 arg providers           target users
-----------------  --------  --------------------  ----------------------  ------------------------
NodeType.Input     input_x   x                     []                      [[0, [(&#39;dense&#39;, 0)]]]
NodeType.CallCell  dense     x = self.dense(x)     [[0, (&#39;input_x&#39;, 0)]]   [[0, [(&#39;new_relu&#39;, 0)]]]
NodeType.CallCell  new_relu  x = self.new_relu(x)  [[0, (&#39;dense&#39;, 0)]]     [[0, [(&#39;return&#39;, 0)]]]
NodeType.Output    return    return x              [[0, (&#39;new_relu&#39;, 0)]]  []
==================================================================================
</pre></div>
</div>
<p>If the output name of the new node and the replaced node are inconsistent, we need to pay attention
to maintaining the topological relationship between nodes after replacement, that is, first modify the subsequent nodes that
uses the output of the replaced node, update the parameter names of these nodes, and then perform the node replacement operation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore.rewrite</span> <span class="kn">import</span> <span class="n">SymbolTree</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ScopedValue</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">MyNet</span><span class="p">()</span>
<span class="n">stree</span> <span class="o">=</span> <span class="n">SymbolTree</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="c1"># Update the parameter names of subsequent nodes</span>
<span class="n">relu_node</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">&quot;relu&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">relu_node</span><span class="o">.</span><span class="n">get_users</span><span class="p">():</span>
    <span class="n">node</span><span class="o">.</span><span class="n">set_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;y1&quot;</span><span class="p">)</span>
<span class="c1"># Create two new nodes</span>
<span class="n">new_relu_cell</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
<span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">create_call_cell</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="n">new_relu_cell</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y1&quot;</span><span class="p">],</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">ScopedValue</span><span class="o">.</span><span class="n">create_naming_value</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;new_relu_1&quot;</span><span class="p">)</span>
<span class="n">new_relu_cell_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
<span class="n">new_node_2</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">create_call_cell</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="n">new_relu_cell_2</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y2&quot;</span><span class="p">],</span>
                                   <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">ScopedValue</span><span class="o">.</span><span class="n">create_naming_value</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;new_relu_2&quot;</span><span class="p">)</span>
<span class="c1"># Replace relu node with two new nodes</span>
<span class="n">stree</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">relu_node</span><span class="p">,</span> <span class="p">[</span><span class="n">new_node</span><span class="p">,</span> <span class="n">new_node_2</span><span class="p">])</span>
<span class="n">stree</span><span class="o">.</span><span class="n">print_node_tabulate</span><span class="p">()</span>
</pre></div>
</div>
<p>The example replaces relu node with two new nodes, where the output of first node <code class="docutils literal notranslate"><span class="pre">y1</span></code> is used as the return value in the
return node. The results are as follows:</p>
<div class="highlight-log notranslate"><div class="highlight"><pre><span></span>================================================================================
node type          name        codes                    arg providers           target users
-----------------  ----------  -----------------------  ----------------------  -------------------------------------------
NodeType.Input     input_x     x                        []                      [[0, [(&#39;dense&#39;, 0)]]]
NodeType.CallCell  dense       x = self.dense(x)        [[0, (&#39;input_x&#39;, 0)]]   [[0, [(&#39;new_relu&#39;, 0), (&#39;new_relu_1&#39;, 0)]]]
NodeType.CallCell  new_relu    y1 = self.new_relu(x)    [[0, (&#39;dense&#39;, 0)]]     [[0, [(&#39;return&#39;, 0)]]]
NodeType.CallCell  new_relu_1  y2 = self.new_relu_1(x)  [[0, (&#39;dense&#39;, 0)]]     []
NodeType.Output    return      return y1                [[0, (&#39;new_relu&#39;, 0)]]  []
==================================================================================
</pre></div>
</div>
<p>It can be seen that the relu node was successfully replaced with two new nodes, and the return value was also
updated to the output of the first new node.</p>
</section>
<section id="returning-a-new-network">
<h2>Returning A New Network<a class="headerlink" href="#returning-a-new-network" title="Permalink to this headline"></a></h2>
<p>When the network is modified, we can use the interface <a class="reference external" href="https://mindspore.cn/docs/en/r2.3/api_python/mindspore.rewrite.html#mindspore.rewrite.SymbolTree.get_network">mindspore.rewrite.SymbolTree.get_network</a> to get the
modified network instance.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">mindspore.common</span> <span class="kn">import</span> <span class="n">dtype</span> <span class="k">as</span> <span class="n">mstype</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">new_net</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">get_network</span><span class="p">()</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">]),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">new_net</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
</pre></div>
</div>
<p>After calling this interface, rewrite module will first generate a script file corresponding to the modified network in the
rewritten_network folder of the current working directory, and then use the script file to create a new network instance,
and use the original network instance as a parameter. New network instances can be used directly for compute and training.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>