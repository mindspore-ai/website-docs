

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mindspore.nn.layer.basic &mdash; MindSpore master 文档</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/training.css" type="text/css" />
   
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script src="../../../../_static/js/training.js"></script>
        <script src="../../../../_static/translations.js"></script>
        
        
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">设计</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/overview.html">MindSpore设计概览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/programming_paradigm.html">编程范式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/auto_gradient.html">函数式微分编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/mindir.html">中间表示MindIR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/all_scenarios.html">全场景统一</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/dynamic_graph_and_static_graph.html">动静态图结合</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/pluggable_device.html">三方硬件对接</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/distributed_training_design.html">分布式并行</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/graph_fusion_engine.html">图算融合加速引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/data_engine.html">高性能数据处理引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/glossary.html">术语</a></li>
</ul>
<p class="caption"><span class="caption-text">规格</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/benchmark.html">基准性能</a></li>
<li class="toctree-l1"><a class="reference external" href="https://gitee.com/mindspore/models/blob/master/README_CN.md#目录">网络支持↗</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/operator_list.html">API支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/syntax_list.html">语法支持</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.primitive.html">mindspore.ops.primitive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.amp.html">mindspore.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.rewrite.html">mindspore.rewrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.boost.html">mindspore.boost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.scipy.html">mindspore.scipy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.mindspore.cn/lite/api/zh-CN/master/api_cpp/mindspore.html">C++ API↗</a></li>
</ul>
<p class="caption"><span class="caption-text">API映射</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/api_mapping/pytorch_api_mapping.html">PyTorch与MindSpore API映射表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/api_mapping/tensorflow_api_mapping.html">TensorFlow与MindSpore API映射表</a></li>
</ul>
<p class="caption"><span class="caption-text">迁移指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/overview.html">迁移指南概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/enveriment_preparation.html">环境准备与资料获取</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/analysis_and_preparation.html">模型分析与准备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/model_development/model_development.html">MindSpore网络搭建</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/debug_and_tune.html">调试调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/sample_code.html">网络迁移调试实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/faq.html">常见问题</a></li>
</ul>
<p class="caption"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/installation.html">安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/data_processing.html">数据处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/implement_problem.html">执行问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/network_compilation.html">网络编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/operators_compile.html">算子编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/usage_migrate_3rd.html">第三方框架迁移使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/performance_tuning.html">性能调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/precision_tuning.html">精度调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/distributed_parallel.html">分布式并行</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/inference.html">推理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/feature_advice.html">特性咨询</a></li>
</ul>
<p class="caption"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../RELEASE.html">Release Notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">模块代码</a> &raquo;</li>
        
      <li>mindspore.nn.layer.basic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>mindspore.nn.layer.basic 源代码</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020-2021 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>

<span class="sd">&quot;&quot;&quot;basic&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">mindspore.common.dtype</span> <span class="k">as</span> <span class="nn">mstype</span>
<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">context</span><span class="p">,</span> <span class="n">log</span> <span class="k">as</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.composite.multitype_ops</span> <span class="kn">import</span> <span class="n">_constexpr_utils</span> <span class="k">as</span> <span class="n">const_utils</span>
<span class="kn">from</span> <span class="nn">mindspore.common.seed</span> <span class="kn">import</span> <span class="n">_get_graph_seed</span>
<span class="kn">from</span> <span class="nn">mindspore.common.tensor</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">mindspore.common.initializer</span> <span class="kn">import</span> <span class="n">initializer</span>
<span class="kn">from</span> <span class="nn">mindspore.ops</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">P</span>
<span class="kn">from</span> <span class="nn">mindspore.ops</span> <span class="kn">import</span> <span class="n">functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.operations</span> <span class="kn">import</span> <span class="n">_inner_ops</span> <span class="k">as</span> <span class="n">inner</span>
<span class="kn">from</span> <span class="nn">mindspore.ops.primitive</span> <span class="kn">import</span> <span class="n">constexpr</span><span class="p">,</span> <span class="n">Primitive</span><span class="p">,</span> <span class="n">_primexpr</span>
<span class="kn">from</span> <span class="nn">mindspore.common.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">mindspore._extends</span> <span class="kn">import</span> <span class="n">cell_attr_register</span>
<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">_checkparam</span> <span class="k">as</span> <span class="n">Validator</span>
<span class="kn">from</span> <span class="nn">mindspore.nn.cell</span> <span class="kn">import</span> <span class="n">Cell</span>
<span class="kn">from</span> <span class="nn">mindspore.nn.layer.activation</span> <span class="kn">import</span> <span class="n">get_activation</span>
<span class="kn">from</span> <span class="nn">mindspore.common._decorator</span> <span class="kn">import</span> <span class="n">deprecated</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dropout&#39;</span><span class="p">,</span> <span class="s1">&#39;Flatten&#39;</span><span class="p">,</span> <span class="s1">&#39;Dense&#39;</span><span class="p">,</span> <span class="s1">&#39;ClipByNorm&#39;</span><span class="p">,</span> <span class="s1">&#39;Norm&#39;</span><span class="p">,</span> <span class="s1">&#39;OneHot&#39;</span><span class="p">,</span> <span class="s1">&#39;Pad&#39;</span><span class="p">,</span> <span class="s1">&#39;Unfold&#39;</span><span class="p">,</span> <span class="s1">&#39;Tril&#39;</span><span class="p">,</span> <span class="s1">&#39;Triu&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ResizeBilinear&#39;</span><span class="p">,</span> <span class="s1">&#39;MatrixDiag&#39;</span><span class="p">,</span> <span class="s1">&#39;MatrixDiagPart&#39;</span><span class="p">,</span> <span class="s1">&#39;MatrixSetDiag&#39;</span><span class="p">,</span> <span class="s1">&#39;L1Regularizer&#39;</span><span class="p">,</span> <span class="s1">&#39;Dropout1d&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Dropout2d&#39;</span><span class="p">,</span> <span class="s1">&#39;Dropout3d&#39;</span><span class="p">,</span> <span class="s1">&#39;Upsample&#39;</span><span class="p">,</span> <span class="s1">&#39;Roll&#39;</span><span class="p">,</span> <span class="s1">&#39;Identity&#39;</span><span class="p">,</span> <span class="s1">&#39;Unflatten&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">L1Regularizer</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies l1 regularization to weights.</span>

<span class="sd">    l1 regularization makes weights sparsity.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{loss}=\lambda * \text{reduce_sum}(\text{abs}(\omega))</span>

<span class="sd">    where :math:`\lambda` is `scale` .</span>

<span class="sd">    Note:</span>
<span class="sd">        scale(regularization factor) should be a number which greater than 0.</span>

<span class="sd">    Args:</span>
<span class="sd">        scale (int, float): l1 regularization factor which greater than 0.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **weights** (Tensor) - The input of L1Regularizer with data type of float16 or float32.</span>
<span class="sd">          The shape is :math:`(N,*)` where :math:`*` means, any number of additional dimensions.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, which dtype is higher precision data type between mindspore.float32 and weights dtype,</span>
<span class="sd">        and Tensor shape is ()</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `scale` is neither an int nor float.</span>
<span class="sd">        ValueError: If `scale` is not greater than 0.</span>
<span class="sd">        ValueError: If `scale` is math.inf or math.nan.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; scale = 0.5</span>
<span class="sd">        &gt;&gt;&gt; net = nn.L1Regularizer(scale)</span>
<span class="sd">        &gt;&gt;&gt; weights = Tensor(np.array([[1.0, -2.0], [-3.0, 4.0]]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; output = net(weights)</span>
<span class="sd">        &gt;&gt;&gt; print(output.asnumpy())</span>
<span class="sd">        5.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize L1Regularizer.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1Regularizer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;scale&#39; must be greater than 0, but got </span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;scale&#39; can not be INF or NAN, but got </span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abs</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Abs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ReduceSum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">const_utils</span><span class="o">.</span><span class="n">check_type_valid</span><span class="p">(</span>
            <span class="n">F</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">number_type</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">)</span>
        <span class="n">l1_regularization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">l1_regularization</span>


<div class="viewcode-block" id="Dropout"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Dropout.html#mindspore.nn.Dropout">[文档]</a><span class="k">class</span> <span class="nc">Dropout</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dropout layer for the input.</span>

<span class="sd">    Dropout is a regularization method. The operator randomly sets some neurons output to 0</span>
<span class="sd">    according to the probability of discarding the probability of discarding.</span>
<span class="sd">    During the reasoning, this layer returns the same Tensor as the `x`.</span>

<span class="sd">    This technique is proposed in paper `Dropout: A Simple Way to Prevent Neural Networks from Overfitting</span>
<span class="sd">    &lt;http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf&gt;`_ and proved to be effective to reduce</span>
<span class="sd">    over-fitting and prevents neurons from co-adaptation. See more details in `Improving neural networks by</span>
<span class="sd">    preventing co-adaptation of feature detectors</span>
<span class="sd">    &lt;https://arxiv.org/pdf/1207.0580.pdf&gt;`_.</span>

<span class="sd">    Note:</span>
<span class="sd">        - Each channel will be zeroed out independently on every construct call.</span>
<span class="sd">        - Parameter `keep_prob` will be removed in a future version, please use parameter `p` instead.</span>
<span class="sd">          Parameter `p` means the probability of the element of the input tensor to be zeroed.</span>
<span class="sd">        - Parameter `dtype` will be removed in a future version. It is not recommended to define this parameter.</span>

<span class="sd">    Args:</span>
<span class="sd">        keep_prob (float): Deprecated. The keep rate, greater than 0 and less equal than 1.</span>
<span class="sd">            E.g. rate=0.9, dropping out 10% of input neurons. Default: 0.5.</span>
<span class="sd">        p (Union[float, int, None]): The dropout rate, greater than or equal to 0 and less than 1.</span>
<span class="sd">            E.g. rate=0.9, dropping out 90% of input neurons. Default: None.</span>
<span class="sd">        dtype (:class:`mindspore.dtype`): Data type of `input`. Default: mindspore.float32.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The input of Dropout with data type of float16 or float32.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, output tensor with the same shape as the `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `keep_prob` is not a float.</span>
<span class="sd">        TypeError: If the dtype of `p` is not float or int.</span>
<span class="sd">        TypeError: If dtype of `x` is not neither float16 nor float32.</span>
<span class="sd">        ValueError: If `keep_prob` is not in range (0, 1].</span>
<span class="sd">        ValueError: If `p` is not in range [0, 1).</span>
<span class="sd">        ValueError: If length of shape of `x` is less than 1.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.ones([2, 2, 3]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Dropout(p=0.2)</span>
<span class="sd">        &gt;&gt;&gt; net.set_train()</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 2, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dropout.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dropout</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;This parameter `dtype` will be deleted or invisible in the future. Please don&#39;t use it.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;For Dropout, this parameter `keep_prob` will be deprecated, please use `p` instead.&quot;</span><span class="p">)</span>
            <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;keep_prob&#39;</span><span class="p">,</span> <span class="n">keep_prob</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keep_prob</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">keep_prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;keep_prob&#39; must be a number in range (0, 1], &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">keep_prob</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">seed0</span><span class="p">,</span> <span class="n">seed1</span> <span class="o">=</span> <span class="n">_get_graph_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;dropout&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">keep_prob</span><span class="p">,</span> <span class="n">seed0</span><span class="p">,</span> <span class="n">seed1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;p&#39; must be a number in range [0, 1), &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">seed0</span><span class="p">,</span> <span class="n">seed1</span> <span class="o">=</span> <span class="n">_get_graph_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;dropout&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span> <span class="n">seed0</span><span class="p">,</span> <span class="n">seed1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span> <span class="o">=</span> <span class="n">keep_prob</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">extend_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;For Dropout, this parameter `keep_prob` will be deprecated, please use `p` instead.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;keep_prob=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;p=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span></div>


<div class="viewcode-block" id="Dropout1d"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Dropout1d.html#mindspore.nn.Dropout1d">[文档]</a><span class="k">class</span> <span class="nc">Dropout1d</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    During training, randomly zeroes entire channels of the input tensor with probability `p`</span>
<span class="sd">    from a Bernoulli distribution (For a 3-dimensional tensor with a shape of :math:`(N, C, L)`,</span>
<span class="sd">    the channel feature map refers to a 1-dimensional feature map with the shape of :math:`L`).</span>

<span class="sd">    For example, the :math:`j\_th` channel of the :math:`i\_th` sample in the batched input is a to-be-processed</span>
<span class="sd">    `1D` tensor input[i,j].</span>
<span class="sd">    Each channel will be zeroed out independently on every forward call with probability `p` using samples</span>
<span class="sd">    from a Bernoulli distribution.</span>

<span class="sd">    The paper `Dropout: A Simple Way to Prevent Neural Networks from Overfitting</span>
<span class="sd">    &lt;http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf&gt;`_ mentioned this technology, And it is proved that</span>
<span class="sd">    it can effectively reduce over fitting and prevent neuronal coadaptation.</span>
<span class="sd">    For more details, refer to `Improving neural networks by preventing co-adaptation of feature detectors</span>
<span class="sd">    &lt;https://arxiv.org/pdf/1207.0580.pdf&gt;`_ .</span>

<span class="sd">    `Dropout1d` can improve the independence between channel feature maps.</span>

<span class="sd">    Args:</span>
<span class="sd">        p (float, optional): The dropping probability of a channel, between 0 and 1, e.g. `p` = 0.8,</span>
<span class="sd">            which means an 80% chance of being set to 0. Default: 0.5.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - A tensor with shape :math:`(N, C, L)` or :math:`(C, L)`, where `N` is the batch size,</span>
<span class="sd">          `C` is the number of channels, `L` is the feature length. The data type must be int8, int16, int32,</span>
<span class="sd">          int64, float16, float32 or float64.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, output, with the same shape and data type as `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `x` is not a Tensor.</span>
<span class="sd">        TypeError: If the data type of `p` is not float.</span>
<span class="sd">        ValueError: If `p` is out of the range `[0.0, 1.0]`.</span>
<span class="sd">        ValueError: If `x` shape is not `2D` or `3D`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import nn, Tensor</span>
<span class="sd">        &gt;&gt;&gt; op = nn.Dropout1d(p=0.6)</span>
<span class="sd">        &gt;&gt;&gt; op.training = True</span>
<span class="sd">        &gt;&gt;&gt; a = Tensor(np.ones((3, 3)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; output = op(a)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dropout1d.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dropout1d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;p&#39; must be a number in range [0, 1], &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Dropout2d"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Dropout2d.html#mindspore.nn.Dropout2d">[文档]</a><span class="k">class</span> <span class="nc">Dropout2d</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    During training, randomly zeroes some channels of the input tensor with probability `p`</span>
<span class="sd">    from a Bernoulli distribution (For a 4-dimensional tensor with a shape of :math:`NCHW`,</span>
<span class="sd">    the channel feature map refers to a 2-dimensional feature map with the shape of :math:`HW`).</span>

<span class="sd">    For example, the :math:`j\_th` channel of the :math:`i\_th` sample in the batched input is a to-be-processed</span>
<span class="sd">    `2D` tensor input[i,j].</span>
<span class="sd">    Each channel will be zeroed out independently on every forward call with probability `p` using samples</span>
<span class="sd">    from a Bernoulli distribution.</span>

<span class="sd">    `Dropout2d` can improve the independence between channel feature maps.</span>

<span class="sd">    Refer to :func:`mindspore.ops.dropout2d` for more details.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; dropout = nn.Dropout2d(p=0.5)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.ones([2, 1, 2, 3]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; output = dropout(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 1, 2, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dropout2d.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dropout2d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;p&#39; must be a number in range [0, 1], &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout2d</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Dropout2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">extend_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;p=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dropout3d"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Dropout3d.html#mindspore.nn.Dropout3d">[文档]</a><span class="k">class</span> <span class="nc">Dropout3d</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    During training, randomly zeroes some channels of the input tensor</span>
<span class="sd">    with probability `p` from a Bernoulli distribution (For a 5-dimensional tensor with</span>
<span class="sd">    a shape of :math:`NCDHW`, the channel feature map refers to a 3-dimensional feature</span>
<span class="sd">    map with a shape of :math:`DHW`).</span>

<span class="sd">    For example, the :math:`j\_th` channel of the :math:`i\_th` sample in the batched input is a to-be-processed</span>
<span class="sd">    `3D` tensor input[i,j].</span>
<span class="sd">    Each channel will be zeroed out independently on every forward call which based on Bernoulli distribution</span>
<span class="sd">    probability `p`.</span>

<span class="sd">    `Dropout3d` can improve the independence between channel feature maps.</span>

<span class="sd">    Refer to :func:`mindspore.ops.dropout3d` for more details.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; dropout = nn.Dropout3d(p=0.5)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.ones([2, 1, 2, 1, 2]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; output = dropout(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 1, 2, 1, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dropout3d.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dropout3d</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;p&#39; must be a number in range [0, 1], &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout3d</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Dropout3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">extend_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;p=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="Upsample"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Upsample.html#mindspore.nn.Upsample">[文档]</a><span class="k">class</span> <span class="nc">Upsample</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For details, please refer to :func:`mindspore.ops.interpolate`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([[[[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0]]]])</span>
<span class="sd">        &gt;&gt;&gt; upsample = nn.Upsample(size=(5, 5))</span>
<span class="sd">        &gt;&gt;&gt; out = upsample(x)</span>
<span class="sd">        &gt;&gt;&gt; print(x.asnumpy())</span>
<span class="sd">        [[[[1. 2. 3. 4.]</span>
<span class="sd">           [5. 6. 7. 8.]]]]</span>
<span class="sd">        &gt;&gt;&gt; print(out.asnumpy())</span>
<span class="sd">        [[[[1. 1. 2. 3. 4.]</span>
<span class="sd">           [1. 1. 2. 3. 4.]</span>
<span class="sd">           [1. 1. 2. 3. 4.]</span>
<span class="sd">           [5. 5. 6. 7. 8.]</span>
<span class="sd">           [5. 5. 6. 7. 8.]]]]</span>
<span class="sd">        &gt;&gt;&gt; print(out.shape)</span>
<span class="sd">        (1, 1, 5, 5)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recompute_scale_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Upsample.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Upsample</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span> <span class="o">=</span> <span class="n">scale_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">align_corners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_scale_factor</span> <span class="o">=</span> <span class="n">recompute_scale_factor</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">recompute_scale_factor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Flatten"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Flatten.html#mindspore.nn.Flatten">[文档]</a><span class="k">class</span> <span class="nc">Flatten</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flatten the input Tensor along dimensions from `start_dim` to `end_dim`.</span>

<span class="sd">    Args:</span>
<span class="sd">        start_dim (int, optional): The first dimension to flatten. Default: 1.</span>
<span class="sd">        end_dim (int, optional): The last dimension to flatten. Default: -1.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The input Tensor to be flattened.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor. If no dimensions are flattened, returns the original `x`, otherwise return the flattened Tensor.</span>
<span class="sd">        If `x` is a 0-dimensional Tensor, a 1-dimensional Tensor will be returned.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `x` is not a Tensor.</span>
<span class="sd">        TypeError: If `start_dim` or `end_dim` is not int.</span>
<span class="sd">        ValueError: If `start_dim` is greater than `end_dim` after canonicalized.</span>
<span class="sd">        ValueError: If `start_dim` or `end_dim` is not in range of [-x.dim, x.dim-1].</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[[1.2, 1.2], [2.1, 2.1]], [[2.2, 2.2], [3.2, 3.2]]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Flatten()</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[1.2 1.2 2.1 2.1]</span>
<span class="sd">         [2.2 2.2 3.2 3.2]]</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;before flatten the x shape is {x.shape}&quot;)</span>
<span class="sd">        before flatten the x shape is  (2, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;after flatten the output shape is {output.shape}&quot;)</span>
<span class="sd">        after flatten the output shape is (2, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Flatten.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Flatten</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_dim</span> <span class="o">=</span> <span class="n">start_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_dim</span> <span class="o">=</span> <span class="n">end_dim</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x_rank</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">x_rank</span> <span class="k">if</span> <span class="n">x_rank</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_dim</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">ndim</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_dim</span> <span class="o">&gt;=</span> <span class="n">ndim</span><span class="p">:</span>
            <span class="n">const_utils</span><span class="o">.</span><span class="n">raise_value_error</span><span class="p">(</span><span class="s2">&quot;&#39;start_dim&#39; out of range.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_dim</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">ndim</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_dim</span> <span class="o">&gt;=</span> <span class="n">ndim</span><span class="p">:</span>
            <span class="n">const_utils</span><span class="o">.</span><span class="n">raise_value_error</span><span class="p">(</span><span class="s2">&quot;&#39;end_dim&#39; out of range.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start_dim</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">end_dim</span><span class="p">)</span></div>


<span class="nd">@_primexpr</span>
<span class="k">def</span> <span class="nf">check_dense_input_shape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prim_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; check the shape of inputs&quot;&quot;&quot;</span>
    <span class="n">msg_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39;, the&quot;</span> <span class="k">if</span> <span class="n">prim_name</span> <span class="k">else</span> <span class="s2">&quot;The&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> dimension of &#39;x&#39; should not be less than 2, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Identity"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Identity.html#mindspore.nn.Identity">[文档]</a><span class="k">class</span> <span class="nc">Identity</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a Tensor with the same shape and contents as input.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The shape of tensor is :math:`(x_1, x_2, ..., x_R)`. The data type is Number.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, the shape of tensor and the data type are the same as `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `x` is not a Tensor.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([1, 2, 3, 4]), mindspore.int64)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Identity()</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [1 2 3 4]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Identity.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Identity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identity</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Dense"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Dense.html#mindspore.nn.Dense">[文档]</a><span class="k">class</span> <span class="nc">Dense</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The dense connected layer.</span>

<span class="sd">    Applies dense connected layer for the input. This layer implements the operation as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{outputs} = \text{activation}(\text{X} * \text{kernel} + \text{bias}),</span>

<span class="sd">    where :math:`X` is the input tensors, :math:`\text{activation}` is the activation function passed as the activation</span>
<span class="sd">    argument (if passed in), :math:`\text{kernel}` is a weight matrix with the same</span>
<span class="sd">    data type as the :math:`X` created by the layer, and :math:`\text{bias}` is a bias vector</span>
<span class="sd">    with the same data type as the :math:`X` created by the layer (only if has_bias is True).</span>

<span class="sd">    Args:</span>
<span class="sd">        in_channels (int): The number of channels in the input space.</span>
<span class="sd">        out_channels (int): The number of channels in the output space.</span>
<span class="sd">        weight_init (Union[Tensor, str, Initializer, numbers.Number]): The trainable weight_init parameter. The dtype</span>
<span class="sd">            is same as `x`. The values of str refer to the function `initializer`. Default: &#39;normal&#39;.</span>
<span class="sd">        bias_init (Union[Tensor, str, Initializer, numbers.Number]): The trainable bias_init parameter. The dtype is</span>
<span class="sd">            same as `x`. The values of str refer to the function `initializer`. Default: &#39;zeros&#39;.</span>
<span class="sd">        has_bias (bool): Specifies whether the layer uses a bias vector :math:`\text{bias}`. Default: True.</span>
<span class="sd">        activation (Union[str, Cell, Primitive, None]): activate function applied to the output of the fully connected</span>
<span class="sd">            layer. Both activation name, e.g. &#39;relu&#39;, and mindspore activation function, e.g. mindspore.ops.ReLU(),</span>
<span class="sd">            are supported. Default: None.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - Tensor of shape :math:`(*, in\_channels)`. The `in_channels` in `Args` should be equal</span>
<span class="sd">          to :math:`in\_channels` in `Inputs`.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor of shape :math:`(*, out\_channels)`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `in_channels` or `out_channels` is not an int.</span>
<span class="sd">        TypeError: If `has_bias` is not a bool.</span>
<span class="sd">        TypeError: If `activation` is not one of str, Cell, Primitive, None.</span>
<span class="sd">        ValueError: If length of shape of `weight_init` is not equal to 2 or shape[0] of `weight_init`</span>
<span class="sd">                    is not equal to `out_channels` or shape[1] of `weight_init` is not equal to `in_channels`.</span>
<span class="sd">        ValueError: If length of shape of `bias_init` is not equal to 1</span>
<span class="sd">                    or shape[0] of `bias_init` is not equal to `out_channels`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[180, 234, 154], [244, 48, 247]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Dense(3, 4)</span>
<span class="sd">        &gt;&gt;&gt; output = net(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@cell_attr_register</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;has_bias&#39;</span><span class="p">,</span> <span class="s1">&#39;activation&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_channels</span><span class="p">,</span>
                 <span class="n">out_channels</span><span class="p">,</span>
                 <span class="n">weight_init</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span>
                 <span class="n">bias_init</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">,</span>
                 <span class="n">has_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">activation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Dense.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dense</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_channels</span> <span class="o">=</span> <span class="n">Validator</span><span class="o">.</span><span class="n">check_positive_int</span><span class="p">(</span>
            <span class="n">in_channels</span><span class="p">,</span> <span class="s2">&quot;in_channels&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_channels</span> <span class="o">=</span> <span class="n">Validator</span><span class="o">.</span><span class="n">check_positive_int</span><span class="p">(</span>
            <span class="n">out_channels</span><span class="p">,</span> <span class="s2">&quot;out_channels&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span> <span class="o">=</span> <span class="n">Validator</span><span class="o">.</span><span class="n">check_bool</span><span class="p">(</span>
            <span class="n">has_bias</span><span class="p">,</span> <span class="s2">&quot;has_bias&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight_init</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">weight_init</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">weight_init</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out_channels</span> <span class="ow">or</span> \
                    <span class="n">weight_init</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">in_channels</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, weight init shape error. The ndim of &#39;weight_init&#39; must &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;be equal to 2, and the first dim must be equal to &#39;out_channels&#39;, and the &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;second dim must be equal to &#39;in_channels&#39;. But got &#39;weight_init&#39;: </span><span class="si">{</span><span class="n">weight_init</span><span class="si">}</span><span class="s2">, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;&#39;out_channels&#39;: </span><span class="si">{</span><span class="n">out_channels</span><span class="si">}</span><span class="s2">, &#39;in_channels&#39;: </span><span class="si">{</span><span class="n">in_channels</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">initializer</span><span class="p">(</span>
            <span class="n">weight_init</span><span class="p">,</span> <span class="p">[</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bias_init</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bias_init</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">bias_init</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out_channels</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, bias init shape error. The ndim of &#39;bias_init&#39; must &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;be equal to 1, and the first dim must be equal to &#39;out_channels&#39;. But got &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;&#39;bias_init&#39;: </span><span class="si">{</span><span class="n">bias_init</span><span class="si">}</span><span class="s2">, &#39;out_channels&#39;: </span><span class="si">{</span><span class="n">out_channels</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">initializer</span><span class="p">(</span>
                <span class="n">bias_init</span><span class="p">,</span> <span class="p">[</span><span class="n">out_channels</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;bias&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias_add</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">BiasAdd</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matmul</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">MatMul</span><span class="p">(</span><span class="n">transpose_b</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">get_activation</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">activation</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">activation</span>
        <span class="k">if</span> <span class="n">activation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span> <span class="p">(</span><span class="n">Cell</span><span class="p">,</span> <span class="n">Primitive</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the &#39;activation&#39; must be str or Cell or Primitive, but got &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_op</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">check_dense_input_shape</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_flag</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">extend_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;input_channels=</span><span class="si">{}</span><span class="s1">, output_channels=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_channels</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, has_bias=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_bias</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_flag</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, activation=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_is_equal_one</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_dtype_check</span><span class="p">(</span><span class="n">x_dtype</span><span class="p">,</span> <span class="n">prim_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">msg_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39;, the&quot;</span> <span class="k">if</span> <span class="n">prim_name</span> <span class="k">else</span> <span class="s2">&quot;The&quot;</span>
    <span class="k">if</span> <span class="n">x_dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> x_dtype must be float32 or float16, but got </span><span class="si">{</span><span class="n">x_dtype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_is_float_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_need_reduce_all</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="p">():</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">ClipByNorm</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clips tensor values to a maximum :math:`L_2`-norm.</span>

<span class="sd">    The output of this layer remains the same if the :math:`L_2`-norm of the input tensor</span>
<span class="sd">    is not greater than the argument clip_norm. Otherwise the tensor will be normalized as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{output}(X) = \frac{\text{clip_norm} * X}{L_2(X)},</span>

<span class="sd">    where :math:`L_2(X)` is the :math:`L_2`-norm of :math:`X`.</span>

<span class="sd">    Args:</span>
<span class="sd">        axis (Union[None, int, tuple(int)]): Compute the L2-norm along the Specific dimension.</span>
<span class="sd">                                            Default: None, all dimensions to calculate.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - Tensor of shape N-D. The type must be float32 or float16.</span>
<span class="sd">        - **clip_norm** (Tensor) - A scalar Tensor of shape :math:`()` or :math:`(1)`.</span>
<span class="sd">          Or a tensor shape can be broadcast to input `x` shape.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, clipped tensor with the same shape as the `x`, whose type is float32.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `axis` is not one of None, int, tuple.</span>
<span class="sd">        TypeError: If dtype of `x` is neither float32 nor float16.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; net = nn.ClipByNorm()</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.random.randint(0, 10, [4, 16]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; clip_norm = Tensor(np.array([100]).astype(np.float32))</span>
<span class="sd">        &gt;&gt;&gt; output = net(x, clip_norm)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (4, 16)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize ClipByNorm.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ClipByNorm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_by_norm</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">ClipByNorm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">clip_norm</span><span class="p">):</span>
        <span class="n">values_clip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip_by_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">clip_norm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values_clip</span>


<span class="k">class</span> <span class="nc">Norm</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Norm class will be deprecated in the future,</span>
<span class="sd">    this function can be replaced by :func:`ops.norm`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="s2">&quot;ops.norm&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(),</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Norm.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Norm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span>
            <span class="s2">&quot;keep_dims&quot;</span><span class="p">,</span> <span class="n">keep_dims</span><span class="p">,</span> <span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_dims</span> <span class="o">=</span> <span class="n">keep_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ReduceSum</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_dims</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">extend_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;axis=</span><span class="si">{}</span><span class="s1">, keep_dims=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_dims</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OneHot</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The OneHot class will be deprecated in the future,</span>
<span class="sd">    this function can be replaced by :func:`ops.one_hot`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="s2">&quot;ops.one_hot&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">off_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize OneHot.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OneHot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onehot</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">OneHot</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_value</span> <span class="o">=</span> <span class="n">on_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">off_value</span> <span class="o">=</span> <span class="n">off_value</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onehot</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">off_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>


<div class="viewcode-block" id="Pad"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Pad.html#mindspore.nn.Pad">[文档]</a><span class="k">class</span> <span class="nc">Pad</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pads the input tensor according to the paddings and mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        paddings (tuple): The shape of parameter `paddings` is :math:`(N, 2)` . N is the rank of input data. All</span>
<span class="sd">            elements of paddings are int type. For `D` th dimension of the `x`, paddings[D, 0] indicates how many</span>
<span class="sd">            sizes to be extended ahead of the `D` th dimension of the input tensor, and paddings[D, 1] indicates how</span>
<span class="sd">            many sizes to be extended behind of the `D` th dimension of the input tensor. The padded size of each</span>
<span class="sd">            dimension D of the output is: :math:`paddings[D, 0] + input\_x.dim\_size(D) + paddings[D, 1]`,</span>
<span class="sd">            e.g.:</span>

<span class="sd">            .. code-block::</span>

<span class="sd">                mode = &quot;CONSTANT&quot;.</span>
<span class="sd">                paddings = [[1,1], [2,2]].</span>
<span class="sd">                x = [[1,2,3], [4,5,6], [7,8,9]].</span>
<span class="sd">                # The above can be seen: 1st dimension of `x` is 3, 2nd dimension of `x` is 3.</span>
<span class="sd">                # Substitute into the formula to get:</span>
<span class="sd">                # 1st dimension of output is paddings[0][0] + 3 + paddings[0][1] = 1 + 3 + 1 = 5.</span>
<span class="sd">                # 2nd dimension of output is paddings[1][0] + 3 + paddings[1][1] = 2 + 3 + 2 = 7.</span>
<span class="sd">                # So the shape of output is (5, 7).</span>

<span class="sd">        mode (str): Specifies padding mode. The optional values are &quot;CONSTANT&quot;, &quot;REFLECT&quot;, &quot;SYMMETRIC&quot;.</span>
<span class="sd">            Default: &quot;CONSTANT&quot;.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The input tensor.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, the tensor after padding.</span>

<span class="sd">        - If `mode` is &quot;CONSTANT&quot;, it fills the edge with 0, regardless of the values of the `x`.</span>
<span class="sd">          If the `x` is [[1,2,3], [4,5,6], [7,8,9]] and `paddings` is [[1,1], [2,2]], then the</span>
<span class="sd">          Outputs is [[0,0,0,0,0,0,0], [0,0,1,2,3,0,0], [0,0,4,5,6,0,0], [0,0,7,8,9,0,0], [0,0,0,0,0,0,0]].</span>
<span class="sd">        - If `mode` is &quot;REFLECT&quot;, it uses a way of symmetrical copying through the axis of symmetry to fill in.</span>
<span class="sd">          If the `x` is [[1,2,3], [4,5,6], [7,8,9]] and `paddings` is [[1,1], [2,2]], then the</span>
<span class="sd">          Outputs is [[6,5,4,5,6,5,4], [3,2,1,2,3,2,1], [6,5,4,5,6,5,4], [9,8,7,8,9,8,7], [6,5,4,5,6,5,4]].</span>
<span class="sd">        - If `mode` is &quot;SYMMETRIC&quot;, the filling method is similar to the &quot;REFLECT&quot;. It is also copied</span>
<span class="sd">          according to the symmetry axis, except that it includes the symmetry axis. If the `x`</span>
<span class="sd">          is [[1,2,3], [4,5,6], [7,8,9]] and `paddings` is [[1,1], [2,2]], then the Outputs is</span>
<span class="sd">          [[2,1,1,2,3,3,2], [2,1,1,2,3,3,2], [5,4,4,5,6,6,5], [8,7,7,8,9,9,8], [8,7,7,8,9,9,8]].</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `paddings` is not a tuple.</span>
<span class="sd">        ValueError: If length of `paddings` is more than 4 or its shape is not :math:`(N, 2)` .</span>
<span class="sd">        ValueError: If `mode` is not one of &#39;CONSTANT&#39;, &#39;REFLECT&#39;, &#39;SYMMETRIC&#39;.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; # If `mode` is &quot;CONSTANT&quot;</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.pad = nn.Pad(paddings=((1, 1), (2, 2)), mode=&quot;CONSTANT&quot;)</span>
<span class="sd">        ...     def construct(self, x):</span>
<span class="sd">        ...         return self.pad(x)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2, 3], [4, 5, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; pad = Net()</span>
<span class="sd">        &gt;&gt;&gt; output = pad(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[0. 0. 0. 0. 0. 0. 0.]</span>
<span class="sd">         [0. 0. 1. 2. 3. 0. 0.]</span>
<span class="sd">         [0. 0. 4. 5. 6. 0. 0.]</span>
<span class="sd">         [0. 0. 0. 0. 0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; # Another way to call</span>
<span class="sd">        &gt;&gt;&gt; pad = ops.Pad(paddings=((1, 1), (2, 2)))</span>
<span class="sd">        &gt;&gt;&gt; # From the above code, we can see following:</span>
<span class="sd">        &gt;&gt;&gt; # &quot;paddings=((1, 1), (2, 2))&quot;,</span>
<span class="sd">        &gt;&gt;&gt; # paddings[0][0] = 1, indicates a row of values is filled top of the input data in the 1st dimension.</span>
<span class="sd">        &gt;&gt;&gt; # Shown as follows:</span>
<span class="sd">        &gt;&gt;&gt; # [[0. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [1. 2. 3.]</span>
<span class="sd">        &gt;&gt;&gt; #  [4. 5. 6.]]</span>
<span class="sd">        &gt;&gt;&gt; # paddings[0][1] = 1 indicates a row of values is filled below input data in the 1st dimension.</span>
<span class="sd">        &gt;&gt;&gt; # Shown as follows:</span>
<span class="sd">        &gt;&gt;&gt; # [[0. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [1. 2. 3.]</span>
<span class="sd">        &gt;&gt;&gt; #  [4. 5. 6.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; # paddings[1][0] = 2, indicates 2 rows of values is filled in front of input data in the 2nd dimension.</span>
<span class="sd">        &gt;&gt;&gt; # Shown as follows:</span>
<span class="sd">        &gt;&gt;&gt; # [[0. 0. 0. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 1. 2. 3.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 4. 5. 6.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; # paddings[1][1] = 2, indicates 2 rows of values is filled in front of input data in the 2nd dimension.</span>
<span class="sd">        &gt;&gt;&gt; # Shown as follows:</span>
<span class="sd">        &gt;&gt;&gt; # [[0. 0. 0. 0. 0. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 1. 2. 3. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 4. 5. 6. 0. 0.]</span>
<span class="sd">        &gt;&gt;&gt; #  [0. 0. 0. 0. 0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; output = pad(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[0. 0. 0. 0. 0. 0. 0.]</span>
<span class="sd">         [0. 0. 1. 2. 3. 0. 0.]</span>
<span class="sd">         [0. 0. 4. 5. 6. 0. 0.]</span>
<span class="sd">         [0. 0. 0. 0. 0. 0. 0.]]</span>
<span class="sd">        &gt;&gt;&gt; # if mode is &quot;REFLECT&quot;</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.pad = nn.Pad(paddings=((1, 1), (2, 2)), mode=&quot;REFLECT&quot;)</span>
<span class="sd">        ...     def construct(self, x):</span>
<span class="sd">        ...         return self.pad(x)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2, 3], [4, 5, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; pad = Net()</span>
<span class="sd">        &gt;&gt;&gt; output = pad(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[6. 5. 4. 5. 6. 5. 4.]</span>
<span class="sd">         [3. 2. 1. 2. 3. 2. 1.]</span>
<span class="sd">         [6. 5. 4. 5. 6. 5. 4.]</span>
<span class="sd">         [3. 2. 1. 2. 3. 2. 1.]]</span>
<span class="sd">        &gt;&gt;&gt; # if mode is &quot;SYMMETRIC&quot;</span>
<span class="sd">        &gt;&gt;&gt; class Net(nn.Cell):</span>
<span class="sd">        ...     def __init__(self):</span>
<span class="sd">        ...         super(Net, self).__init__()</span>
<span class="sd">        ...         self.pad = nn.Pad(paddings=((1, 1), (2, 2)), mode=&quot;SYMMETRIC&quot;)</span>
<span class="sd">        ...     def construct(self, x):</span>
<span class="sd">        ...         return self.pad(x)</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.array([[1, 2, 3], [4, 5, 6]]), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; pad = Net()</span>
<span class="sd">        &gt;&gt;&gt; output = pad(x)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[2. 1. 1. 2. 3. 3. 2.]</span>
<span class="sd">         [2. 1. 1. 2. 3. 3. 2.]</span>
<span class="sd">         [5. 4. 4. 5. 6. 6. 5.]</span>
<span class="sd">         [5. 4. 4. 5. 6. 6. 5.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paddings</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;CONSTANT&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Pad.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Pad</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paddings</span> <span class="o">=</span> <span class="n">paddings</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_string</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;CONSTANT&quot;</span><span class="p">,</span> <span class="s2">&quot;REFLECT&quot;</span><span class="p">,</span> <span class="s2">&quot;SYMMETRIC&quot;</span><span class="p">],</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paddings</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the type of &#39;paddings&#39; must be tuple, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">paddings</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">paddings</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the dimension of &#39;paddings&#39; must be (n, 2), &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">paddings</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paddings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, only &#39;paddings&#39; up to 4 dims is supported, but got &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">paddings</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;CONSTANT&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paddings</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">paddings</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paddings</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mstype</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">MirrorPad</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;CONSTANT&quot;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paddings</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">bilinear</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">,</span> <span class="n">prim_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check input and calculate shape&quot;&quot;&quot;</span>
    <span class="n">msg_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39;, the&quot;</span> <span class="k">if</span> <span class="n">prim_name</span> <span class="k">else</span> <span class="s2">&quot;The&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">align_corners</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> type of &#39;align_corners&#39; must be bool, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">align_corners</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> &#39;size&#39; and &#39;scale&#39; both none.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> &#39;size&#39; and &#39;scale&#39; both not none.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg_prefix</span><span class="si">}</span><span class="s2"> &#39;size&#39; must be tuple or list or None, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;size[0]&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;size[1]&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;scale factor&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span>


<div class="viewcode-block" id="ResizeBilinear"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.ResizeBilinear.html#mindspore.nn.ResizeBilinear">[文档]</a><span class="k">class</span> <span class="nc">ResizeBilinear</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &#39;nn.ResizeBilinear&#39; is deprecated from version 2.0 and will be removed in a future version,</span>
<span class="sd">    use :class:`mindspore.ops.ResizeBilinearV2` or :func:`mindspore.ops.interpolate` instead.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        Deprecated</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([[[[1, 2, 3, 4], [5, 6, 7, 8]]]], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; resize_bilinear = nn.ResizeBilinear()</span>
<span class="sd">        &gt;&gt;&gt; result = resize_bilinear(x, size=(5,5))</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[[[1. 2. 3. 4.]</span>
<span class="sd">           [5. 6. 7. 8.]]]]</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[[[1.        1.8       2.6       3.4       4.       ]</span>
<span class="sd">           [2.6       3.4       4.2000003 5.        5.6000004]</span>
<span class="sd">           [4.2       5.0000005 5.8       6.6       7.2      ]</span>
<span class="sd">           [5.        5.8       6.6       7.4       8.       ]</span>
<span class="sd">           [5.        5.8       6.6       7.4000006 8.       ]]]]</span>
<span class="sd">        &gt;&gt;&gt; print(result.shape)</span>
<span class="sd">        (1, 1, 5, 5)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">half_pixel_centers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize ResizeBilinear.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResizeBilinear</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;&#39;nn.ResizeBilinear&#39; is deprecated from version 2.0 and will be removed in a &quot;</span>
                       <span class="s2">&quot;future version, use &#39;ops.ResizeBilinearV2&#39; or &#39;ops.interpolate&#39; instead.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">half_pixel_centers</span> <span class="o">=</span> <span class="n">half_pixel_centers</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">,</span>
                         <span class="n">align_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">resize_bilinear</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ResizeBilinear</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_pixel_centers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resize_bilinear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="Unfold"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Unfold.html#mindspore.nn.Unfold">[文档]</a><span class="k">class</span> <span class="nc">Unfold</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts patches from images.</span>
<span class="sd">    The input tensor must be a 4-D tensor and the data format is NCHW.</span>

<span class="sd">    Args:</span>
<span class="sd">        ksizes (Union[tuple[int], list[int]]): The size of sliding window, must be a tuple or a list of integers,</span>
<span class="sd">            and the format is [1, ksize_row, ksize_col, 1].</span>
<span class="sd">        strides (Union[tuple[int], list[int]]): Distance between the centers of the two consecutive patches,</span>
<span class="sd">            must be a tuple or list of int, and the format is [1, stride_row, stride_col, 1].</span>
<span class="sd">        rates (Union[tuple[int], list[int]]): In each extracted patch, the gap between the corresponding dimension</span>
<span class="sd">            pixel positions, must be a tuple or a list of integers, and the format is [1, rate_row, rate_col, 1].</span>
<span class="sd">        padding (str): The type of padding algorithm, is a string whose value is &quot;same&quot; or &quot;valid&quot;, not case sensitive.</span>
<span class="sd">            Default: &quot;valid&quot;.</span>

<span class="sd">            - same: Means that the patch can take the part beyond the original image, and this part is filled with 0.</span>

<span class="sd">            - valid: Means that the taken patch area must be completely covered in the original image.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - A 4-D tensor whose shape is [in_batch, in_depth, in_row, in_col] and</span>
<span class="sd">          data type is number.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, a 4-D tensor whose data type is same as `x`,</span>
<span class="sd">        and the shape is [out_batch, out_depth, out_row, out_col] where `out_batch` is the same as the `in_batch`.</span>

<span class="sd">        - :math:`out\_depth = ksize\_row * ksize\_col * in\_depth`</span>
<span class="sd">        - :math:`out\_row = (in\_row - (ksize\_row + (ksize\_row - 1) * (rate\_row - 1))) // stride\_row + 1`</span>
<span class="sd">        - :math:`out\_col = (in\_col - (ksize\_col + (ksize\_col - 1) * (rate\_col - 1))) // stride\_col + 1`</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `ksizes`, `strides` or `rates` is neither a tuple nor list.</span>
<span class="sd">        ValueError: If shape of `ksizes`, `strides` or `rates` is not (1, x_row, x_col, 1).</span>
<span class="sd">        ValueError: If the second and third element of `ksizes`, `strides` or `rates` is less than 1.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; net = Unfold(ksizes=[1, 2, 2, 1], strides=[1, 2, 2, 1], rates=[1, 2, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; # As stated in the above code:</span>
<span class="sd">        &gt;&gt;&gt; # ksize_row = 2, ksize_col = 2, rate_row = 2, rate_col = 2, stride_row = 2, stride_col = 2.</span>
<span class="sd">        &gt;&gt;&gt; image = Tensor(np.ones([2, 3, 6, 6]), dtype=mstype.float16)</span>
<span class="sd">        &gt;&gt;&gt; # in_batch = 2, in_depth = 3, in_row = 6, in_col = 6.</span>
<span class="sd">        &gt;&gt;&gt; # Substituting the formula to get:</span>
<span class="sd">        &gt;&gt;&gt; # out_batch = in_batch = 2</span>
<span class="sd">        &gt;&gt;&gt; # out_depth = 2 * 2 * 3 = 12</span>
<span class="sd">        &gt;&gt;&gt; # out_row = (6 - (2 + (2 - 1) * (2 - 1))) // 2 + 1 = 2</span>
<span class="sd">        &gt;&gt;&gt; # out_col = (6 - (2 + (2 - 1) * (2 - 1))) // 2 + 1 = 2</span>
<span class="sd">        &gt;&gt;&gt; output = net(image)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (2, 12, 2, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ksizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Unfold.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Unfold</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_check_tuple_or_list</span><span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="n">arg_val</span><span class="p">,</span> <span class="n">prim_name</span><span class="p">):</span>
            <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">,</span> <span class="n">ksizes</span><span class="p">,</span> <span class="p">[</span>
                <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">arg_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">arg_val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39; the format of &#39;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">s&#39; must be [1, </span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_row, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_col, 1], but got </span><span class="si">{</span><span class="n">arg_val</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_val</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_val</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arg_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">arg_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="n">prim_name</span><span class="si">}</span><span class="s2">&#39; the </span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_row and </span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_col in &#39;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">s&#39; must be &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;an positive integer number, but got </span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_row is </span><span class="si">{</span><span class="n">arg_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">_col is </span><span class="si">{</span><span class="n">arg_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">_check_tuple_or_list</span><span class="p">(</span><span class="s2">&quot;ksize&quot;</span><span class="p">,</span> <span class="n">ksizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">_check_tuple_or_list</span><span class="p">(</span><span class="s2">&quot;stride&quot;</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">_check_tuple_or_list</span><span class="p">(</span><span class="s2">&quot;rate&quot;</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">ksizes</span> <span class="o">=</span> <span class="n">ksizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ksizes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">ksizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ksizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strides</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">strides</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">strides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rates</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">rates</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rates</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extract_image_patches</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">ExtractImagePatches</span><span class="p">(</span>
            <span class="n">ksizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_image_patches</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<span class="nd">@_primexpr</span>
<span class="k">def</span> <span class="nf">tril</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;x rank&quot;</span><span class="p">,</span> <span class="s2">&quot;tril&quot;</span><span class="p">)</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_is_int</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k value&quot;</span><span class="p">,</span> <span class="s2">&quot;tril&quot;</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">Tril</span><span class="p">(</span><span class="n">diagonal</span><span class="o">=</span><span class="n">k</span><span class="p">)(</span><span class="n">F</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)),</span> <span class="n">x_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">Tril</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Tril class will be deprecated in the future,</span>
<span class="sd">    this function can be replaced by :func:`ops.tril`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="s2">&quot;ops.tril&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Tril.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Tril</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">tril</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">assist</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="nd">@_primexpr</span>
<span class="k">def</span> <span class="nf">triu</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;x rank&quot;</span><span class="p">,</span> <span class="s2">&quot;triu&quot;</span><span class="p">)</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_is_int</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k value&quot;</span><span class="p">,</span> <span class="s2">&quot;triu&quot;</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">Triu</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span><span class="n">F</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)),</span> <span class="n">x_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">Triu</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Triu class will be deprecated in the future,</span>
<span class="sd">    this function can be replaced by :func:`ops.triu`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="s2">&quot;ops.triu&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Triu.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Triu</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">triu</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">assist</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="nd">@_primexpr</span>
<span class="k">def</span> <span class="nf">_get_matrix_diag_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get matrix diag assist&quot;&quot;&quot;</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;x rank&quot;</span><span class="p">,</span> <span class="s2">&quot;_get_matrix_diag_assist&quot;</span><span class="p">)</span>
    <span class="n">base_eye</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">F</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_dtype</span><span class="p">),</span> <span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">base_eye</span><span class="p">,</span> <span class="n">x_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">F</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">base_eye</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">x_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],))</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">assist</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_get_matrix_diag_part_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get matrix diag part assist&quot;&quot;&quot;</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;x rank&quot;</span><span class="p">,</span> <span class="s2">&quot;_get_matrix_diag_part_assist&quot;</span><span class="p">)</span>
    <span class="n">base_eye</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">F</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_dtype</span><span class="p">),</span> <span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">base_eye</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">base_eye</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">x_shape</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">assist</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">MatrixDiag</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The MatrixDiag class will be deprecated in the future,</span>
<span class="sd">    this function can be replaced by :func:`ops.diag`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="s2">&quot;ops.diag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize MatrixDiag.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatrixDiag</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_diag</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">MatrixDiag</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">x_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">_get_matrix_diag_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>
        <span class="n">out_matrix_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_diag</span><span class="p">(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">assist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_matrix_diag</span>


<span class="k">class</span> <span class="nc">MatrixDiagPart</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The MatrixDiagPart class will be deprecated in the future,</span>
<span class="sd">    this function can be replaced by :func:`ops.diagonal`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="s2">&quot;ops.diagonal&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize MatrixDiagPart.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatrixDiagPart</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_diag_part</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">MatrixDiagPart</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">x_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">_get_matrix_diag_part_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>
        <span class="n">out_matrix_diag_part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_diag_part</span><span class="p">(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">assist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_matrix_diag_part</span>


<span class="k">class</span> <span class="nc">MatrixSetDiag</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modifies the batched diagonal part of a batched tensor.</span>

<span class="sd">    Assume `x` has :math:`k+1` dimensions :math:`[I, J, K, ..., M, N]` and `diagonal` has :math:`k`</span>
<span class="sd">    dimensions :math:`[I, J, K, ..., min(M, N)]`, the output is a tensor of rank :math:`k+1` with dimensions</span>
<span class="sd">    :math:`[I, J, K, ..., M, N]`, where:</span>

<span class="sd">    .. math::</span>
<span class="sd">        output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]\ for\ m == n</span>

<span class="sd">    .. math::</span>
<span class="sd">        output[i, j, k, ..., m, n] = x[i, j, k, ..., m, n]\ for\ m != n</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **x** (Tensor) - The batched tensor. Rank k+1, where k &gt;= 1. It can be one of the following data types:</span>
<span class="sd">          float32, float16, int32, int8, and uint8.</span>
<span class="sd">        - **diagonal** (Tensor) - The diagonal values. Must have the same type as input `x`. Rank k, where k &gt;= 1.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor, has the same type and shape as input `x`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If dtype of `x` or `diagonal` is not one of float32, float16, int32, int8 or uint8.</span>
<span class="sd">        ValueError: If length of shape of `x` is less than 2.</span>
<span class="sd">        ValueError: If x_shape[-2] &lt; x_shape[-1] and x_shape[:-1] != diagonal_shape.</span>
<span class="sd">        ValueError: If x_shape[-2] &gt;= x_shape[-1] and x_shape[:-2] + x_shape[-1:] != diagonal_shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor([[[-1, 0], [0, 1]], [[-1, 0], [0, 1]], [[-1, 0], [0, 1]]], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; diagonal = Tensor([[-1., 2.], [-1., 1.], [-1., 1.]], mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; matrix_set_diag = nn.MatrixSetDiag()</span>
<span class="sd">        &gt;&gt;&gt; output = matrix_set_diag(x, diagonal)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        [[[-1.  0.]</span>
<span class="sd">          [ 0.  2.]]</span>
<span class="sd">         [[-1.  0.]</span>
<span class="sd">          [ 0.  1.]]</span>
<span class="sd">         [[-1.  0.]</span>
<span class="sd">          [ 0.  1.]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize MatrixSetDiag.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatrixSetDiag</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_set_diag</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">MatrixSetDiag</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">DType</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">):</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">x_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">assist</span> <span class="o">=</span> <span class="n">_get_matrix_diag_part_assist</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">x_dtype</span><span class="p">)</span>
        <span class="n">out_matrix_set_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_set_diag</span><span class="p">(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">,</span> <span class="n">assist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_matrix_set_diag</span>


<span class="nd">@constexpr</span>
<span class="k">def</span> <span class="nf">_check_input_dim</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">):</span>
    <span class="n">Validator</span><span class="o">.</span><span class="n">check_int_range</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">INC_LEFT</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Roll</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Roll class will be deprecated in the future,</span>
<span class="sd">    this function can be replaced by :func:`ops.roll`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="s2">&quot;ops.roll&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Roll&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Roll</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span>
            <span class="s2">&quot;shift&quot;</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span>
            <span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_op</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpu</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;device_target&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;GPU&quot;</span><span class="p">:</span>
            <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;shift&quot;</span><span class="p">,</span> <span class="s2">&quot;Roll&quot;</span><span class="p">)</span>
            <span class="n">Validator</span><span class="o">.</span><span class="n">check_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Validator</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span> <span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="s2">&quot;Roll&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s_axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">:</span>
                <span class="n">Validator</span><span class="o">.</span><span class="n">check_is_int</span><span class="p">(</span><span class="n">s_axis</span><span class="p">,</span> <span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="s2">&quot;Roll&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s_shift</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">:</span>
                <span class="n">Validator</span><span class="o">.</span><span class="n">check_is_int</span><span class="p">(</span><span class="n">s_shift</span><span class="p">,</span> <span class="s2">&quot;shift&quot;</span><span class="p">,</span> <span class="s2">&quot;Roll&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roll</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gpu</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the shape of &#39;shift&#39; and the shape of &#39;axis&#39; must be &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;the same, but got the length of &#39;shift&#39; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;and the length of &#39;axis&#39; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">Roll</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="si">}</span><span class="s2">&#39;, the shape of &#39;shift&#39; and the shape of &#39;axis&#39; must be &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;the same, but got the length of &#39;shift&#39; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;and the length of &#39;axis&#39; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">Roll</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_op</span><span class="p">(</span><span class="n">input_x</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpu</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">single_op_roll</span><span class="p">,</span> <span class="n">single_axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">op_list</span><span class="p">:</span>
                <span class="n">_check_input_dim</span><span class="p">(</span><span class="n">single_axis</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">single_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">single_axis</span> <span class="o">+=</span> <span class="n">dim</span>
                <span class="n">transpose_perm</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                    <span class="n">transpose_perm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">transpose_perm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">transpose_perm</span><span class="p">[</span><span class="n">single_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_axis</span><span class="p">,</span> <span class="mi">0</span>

                <span class="n">input_x</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">transpose_perm</span><span class="p">)</span>
                <span class="n">input_x</span> <span class="o">=</span> <span class="n">single_op_roll</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
                <span class="n">input_x</span> <span class="o">=</span> <span class="n">input_x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">transpose_perm</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">input_x</span>
        <span class="k">return</span> <span class="n">output</span>


<div class="viewcode-block" id="Unflatten"><a class="viewcode-back" href="../../../../api_python/nn/mindspore.nn.Unflatten.html#mindspore.nn.Unflatten">[文档]</a><span class="k">class</span> <span class="nc">Unflatten</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary:</span>
<span class="sd">        Unflattens a Tensor dim according to `axis` and `unflattened_size`.</span>

<span class="sd">    Args:</span>
<span class="sd">        axis (int): specifies the dimension of the input Tensor to be unflattened.</span>
<span class="sd">        unflattened_size (Union(tuple[int], list[int])): the new shape of the unflattened dimension of</span>
<span class="sd">            the Tensor and it can be a tuple of ints or a list of ints. The product of `unflattened_size`</span>
<span class="sd">            must equal to input_shape[axis].</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **input** (Tensor) - The input Tensor to be unflattened.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        Tensor that has been unflattend.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `axis` is not int.</span>
<span class="sd">        TypeError: If `unflattened_size` is neither tuple of ints nor list of ints.</span>
<span class="sd">        TypeError: The product of `unflattened_size` does not equal to input_shape[axis].</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; input = Tensor(np.arange(0, 100).reshape(2, 10, 5), mindspore.float32)</span>
<span class="sd">        &gt;&gt;&gt; net = nn.Unflatten(1, (2, 5))</span>
<span class="sd">        &gt;&gt;&gt; output = net(input)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;before unflatten the input shape is {input.shape}&quot;)</span>
<span class="sd">        before unflatten the input shape is  (2, 10, 5)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;after unflatten the output shape is {output.shape}&quot;)</span>
<span class="sd">        after unflatten the output shape is (2, 2, 5, 5)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">unflattened_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Unflatten.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Unflatten</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_is_int</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;Unflatten&#39;</span><span class="p">)</span>
        <span class="n">Validator</span><span class="o">.</span><span class="n">check_value_type</span><span class="p">(</span>
            <span class="s1">&#39;unflattended_size&#39;</span><span class="p">,</span> <span class="n">unflattened_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="s1">&#39;Unflatten&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unflattened_size</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">unflattened_size</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unflattened_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unflattened_size</span> <span class="o">=</span> <span class="n">unflattened_size</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_x</span><span class="p">):</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="n">new_shape</span> <span class="o">+=</span> <span class="n">input_shape</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">new_shape</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unflattened_size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">+=</span> <span class="n">input_shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">input_x</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2022, MindSpore.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>