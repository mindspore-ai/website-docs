<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.dataset.GeneratorDataset &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script>
      <link rel="stylesheet" href="../../_static/css/bootstrap.min.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/training.css" type="text/css" /><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script><script src="../../_static/jquery.js"></script>
        <script src="../../_static/js/theme.js"></script><script src="../../_static/underscore.js"></script><script src="../../_static/doctools.js"></script><script src="../../_static/js/training.js"></script><script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="mindspore.dataset.NumpySlicesDataset" href="mindspore.dataset.NumpySlicesDataset.html" />
    <link rel="prev" title="mindspore.dataset.TFRecordDataset" href="mindspore.dataset.TFRecordDataset.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">设计</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../design/overview.html">MindSpore设计概览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/auto_gradient.html">函数式微分编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/mindir.html">中间表示MindIR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/all_scenarios.html">全场景统一</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/dynamic_graph_and_static_graph.html">动静态图结合</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/distributed_training_design.html">分布式并行</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/graph_fusion_engine.html">图算融合加速引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/data_engine.html">高性能数据处理引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/glossary.html">术语</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">规格</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../note/benchmark.html">基准性能</a></li>
<li class="toctree-l1"><a class="reference external" href="https://gitee.com/mindspore/models/blob/r1.9/README_CN.md#目录">网络支持↗</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../note/operator_list.html">API支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../note/syntax_list.html">语法支持</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.amp.html">mindspore.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../mindspore.dataset.html">mindspore.dataset</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../mindspore.dataset.html#数据处理pipeline介绍">数据处理Pipeline介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mindspore.dataset.html#视觉">视觉</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mindspore.dataset.html#文本">文本</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mindspore.dataset.html#音频">音频</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mindspore.dataset.html#标准格式">标准格式</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../mindspore.dataset.html#用户自定义">用户自定义</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">mindspore.dataset.GeneratorDataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="mindspore.dataset.NumpySlicesDataset.html">mindspore.dataset.NumpySlicesDataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="mindspore.dataset.PaddedDataset.html">mindspore.dataset.PaddedDataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="mindspore.dataset.RandomDataset.html">mindspore.dataset.RandomDataset</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mindspore.dataset.html#图">图</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mindspore.dataset.html#采样器">采样器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mindspore.dataset.html#其他">其他</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.dataset.audio.html">mindspore.dataset.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.dataset.config.html">mindspore.dataset.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.dataset.text.html">mindspore.dataset.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.dataset.vision.html">mindspore.dataset.vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.nn.transformer.html">mindspore.nn.transformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.ops.function.html">mindspore.ops.function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.rewrite.html">mindspore.rewrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.scipy.html">mindspore.scipy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindspore.boost.html">mindspore.boost</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.mindspore.cn/lite/api/zh-CN/r1.9/api_cpp/mindspore.html">C++ API↗</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API映射</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../note/api_mapping/pytorch_api_mapping.html">PyTorch与MindSpore API映射表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../note/api_mapping/tensorflow_api_mapping.html">TensorFlow与MindSpore API映射表</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">迁移指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/overview.html">概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/enveriment_preparation.html">环境准备与资料获取</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/analysis_and_preparation.html">模型分析与准备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/model_development/model_development.html">MindSpore网络搭建</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/debug_and_tune.html">调试调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/sample_code.html">网络迁移调试实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/faq.html">常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/typical_api_comparision.html">与PyTorch典型区别</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration_guide/use_third_party_op.html">基于自定义算子接口调用第三方算子库</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../faq/installation.html">安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/data_processing.html">数据处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/implement_problem.html">执行问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/network_compilation.html">网络编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/operators_compile.html">算子编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/usage_migrate_3rd.html">第三方框架迁移使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/performance_tuning.html">性能调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/precision_tuning.html">精度调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/distributed_configure.html">分布式配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/inference.html">推理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/feature_advice.html">特性咨询</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../mindspore.dataset.html">mindspore.dataset</a> &raquo;</li>
      <li>mindspore.dataset.GeneratorDataset</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/api_python/dataset/mindspore.dataset.GeneratorDataset.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="mindspore-dataset-generatordataset">
<h1>mindspore.dataset.GeneratorDataset<a class="headerlink" href="#mindspore-dataset-generatordataset" title="Permalink to this headline"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindspore.dataset.</span></span><span class="sig-name descname"><span class="pre">GeneratorDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schema</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_parallel_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_shards</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shard_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">python_multiprocessing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_rowsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/mindspore/dataset/engine/datasets_user_defined.html#GeneratorDataset"><span class="viewcode-link"><span class="pre">[源代码]</span></span></a><a class="headerlink" href="#mindspore.dataset.GeneratorDataset" title="Permalink to this definition"></a></dt>
<dd><p>自定义Python数据源，通过迭代该数据源构造数据集。生成的数据集的列名和列类型取决于用户定义的Python数据源。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>source</strong> (Union[Callable, Iterable, Random Accessible]) - 一个Python的可调用对象，可以是可迭代的Python对象，或支持随机访问的Python对象。</p>
<ul>
<li><p>如果 <cite>source</cite> 是可调用对象，要求 <cite>source</cite> 对象可以通过 <cite>source().next()</cite> 的方式返回一个由NumPy数组构成的元组。</p></li>
<li><p>如果 <cite>source</cite> 是可迭代对象，要求 <cite>source</cite> 对象通过 <cite>iter(source).next()</cite> 的方式返回一个由NumPy数组构成的元组。</p></li>
<li><p>如果 <cite>source</cite> 是支持随机访问的对象，要求 <cite>source</cite> 对象通过 <cite>source[idx]</cite> 的方式返回一个由NumPy数组构成的元组。</p></li>
</ul>
</li>
<li><p><strong>column_names</strong> (Union[str, list[str]]，可选) - 指定数据集生成的列名，默认值：None，不指定。用户可以通过此参数或 <cite>schema</cite> 参数指定列名。</p></li>
<li><p><strong>column_types</strong> (list[mindspore.dtype]，可选) - 指定生成数据集各个数据列的数据类型，默认值：None，不指定。
如果未指定该参数，则自动推断类型；如果指定了该参数，将在数据输出时做类型匹配检查。</p></li>
<li><p><strong>schema</strong> (Union[Schema, str]，可选) - 读取模式策略，用于指定读取数据列的数据类型、数据维度等信息。
支持传入JSON文件路径或 mindspore.dataset.Schema 构造的对象。默认值：None，不指定。
用户可以通过提供 <cite>column_names</cite> 或 <cite>schema</cite> 指定数据集的列名，但如果同时指定两者，则将优先从 <cite>schema</cite> 中获取列名信息。</p></li>
<li><p><strong>num_samples</strong> (int, 可选) - 指定从数据集中读取的样本数，默认值：None，读取全部样本。</p></li>
<li><p><strong>num_parallel_workers</strong> (int, 可选) - 指定读取数据的工作进程数/线程数（由参数 <cite>python_multiprocessing</cite> 决定当前为多进程模式或多线程模式），默认值：1。</p></li>
<li><p><strong>shuffle</strong> (bool，可选) - 是否混洗数据集。只有输入的 <cite>source</cite> 参数带有可随机访问属性（<cite>__getitem__</cite>）时，才可以指定该参数。默认值：None，下表中会展示不同配置的预期行为。</p></li>
<li><p><strong>sampler</strong> (Union[Sampler, Iterable]，可选) - 指定从数据集中选取样本的采样器。只有输入的 <cite>source</cite> 参数带有可随机访问属性（<cite>__getitem__</cite>）时，才可以指定该参数。默认值：None，下表中会展示不同配置的预期行为。</p></li>
<li><p><strong>num_shards</strong> (int, 可选) - 指定分布式训练时将数据集进行划分的分片数，默认值：None。指定此参数后， <cite>num_samples</cite> 表示每个分片的最大样本数。</p></li>
<li><p><strong>shard_id</strong> (int, 可选) - 指定分布式训练时使用的分片ID号，默认值：None。只有当指定了 <cite>num_shards</cite> 时才能指定此参数。</p></li>
<li><p><strong>python_multiprocessing</strong> (bool，可选) - 启用Python多进程模式加速运算，默认值：True。当传入 <cite>source</cite> 的Python对象的计算量很大时，开启此选项可能会有较好效果。</p></li>
<li><p><strong>max_rowsize</strong> (int, 可选) - 指定在多进程之间复制数据时，共享内存分配的最大空间，默认值：6，单位为MB。仅当参数 <cite>python_multiprocessing</cite> 设为True时，此参数才会生效。</p></li>
</ul>
</dd>
<dt>异常：</dt><dd><ul class="simple">
<li><p><strong>RuntimeError</strong> - Python对象 <cite>source</cite> 在执行期间引发异常。</p></li>
<li><p><strong>RuntimeError</strong> - <cite>column_names</cite> 参数指定的列名数量与 <cite>source</cite> 参数输出的数据数量不匹配。</p></li>
<li><p><strong>ValueError</strong> - <cite>num_parallel_workers</cite> 参数超过最大线程数。</p></li>
<li><p><strong>ValueError</strong> - 同时指定了 <cite>sampler</cite> 和 <cite>shuffle</cite> 参数。</p></li>
<li><p><strong>ValueError</strong> - 同时指定了 <cite>sampler</cite> 和 <cite>num_shards</cite> 参数或同时指定了 <cite>sampler</cite> 和 <cite>shard_id</cite> 参数。</p></li>
<li><p><strong>ValueError</strong> - 指定了 <cite>num_shards</cite> 参数，但是未指定 <cite>shard_id</cite> 参数。</p></li>
<li><p><strong>ValueError</strong> - 指定了 <cite>shard_id</cite> 参数，但是未指定 <cite>num_shards</cite> 参数。</p></li>
<li><p><strong>ValueError</strong> - <cite>shard_id</cite> 参数值错误（小于0或者大于等于 <cite>num_shards</cite> ）。</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p><cite>source</cite> 参数接收用户自定义的Python函数（PyFuncs），不要将 <cite>mindspore.nn</cite> 和 <cite>mindspore.ops</cite> 目录下或其他的网络计算算子添加
到 <cite>source</cite> 中。</p></li>
<li><p>此数据集可以指定参数 <cite>sampler</cite> ，但参数 <cite>sampler</cite> 和参数 <cite>shuffle</cite> 的行为是互斥的。下表展示了几种合法的输入参数组合及预期的行为。</p></li>
</ul>
</div>
<table class="colwidths-given docutils align-default" id="id3">
<caption><span class="caption-text">配置 <cite>sampler</cite> 和 <cite>shuffle</cite> 的不同组合得到的预期排序结果</span><a class="headerlink" href="#id3" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>参数 <cite>sampler</cite></p></th>
<th class="head"><p>参数 <cite>shuffle</cite></p></th>
<th class="head"><p>预期数据顺序</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>None</p></td>
<td><p>None</p></td>
<td><p>随机排列</p></td>
</tr>
<tr class="row-odd"><td><p>None</p></td>
<td><p>True</p></td>
<td><p>随机排列</p></td>
</tr>
<tr class="row-even"><td><p>None</p></td>
<td><p>False</p></td>
<td><p>顺序排列</p></td>
</tr>
<tr class="row-odd"><td><p><cite>sampler</cite> 实例</p></td>
<td><p>None</p></td>
<td><p>由 <cite>sampler</cite> 行为定义的顺序</p></td>
</tr>
<tr class="row-even"><td><p><cite>sampler</cite> 实例</p></td>
<td><p>True</p></td>
<td><p>不允许</p></td>
</tr>
<tr class="row-odd"><td><p><cite>sampler</cite> 实例</p></td>
<td><p>False</p></td>
<td><p>不允许</p></td>
</tr>
</tbody>
</table>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 1) Multidimensional generator function as callable input.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator_multidimensional</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]]),)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">generator_multidimensional</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;multi_dimensional_data&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 2) Multi-column generator function as callable input.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator_multi_column</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">generator_multi_column</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;col1&quot;</span><span class="p">,</span> <span class="s2">&quot;col2&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 3) Iterable dataset as iterable input.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyIterable</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">StopIteration</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">])</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="n">item</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">MyIterable</span><span class="p">(),</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 4) Random accessible dataset as random accessible input.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyAccessible</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">MyAccessible</span><span class="p">(),</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># list, dict, tuple of Python is also random accessible</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">),),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">),),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="p">),)],</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.add_sampler">
<span class="sig-name descname"><span class="pre">add_sampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_sampler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.add_sampler" title="Permalink to this definition"></a></dt>
<dd><p>为当前数据集添加子采样器。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>new_sampler</strong> (Sampler) - 待添加的子采样器。</p></li>
</ul>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_sampler</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span><span class="o">.</span><span class="n">add_sampler</span><span class="p">(</span><span class="n">new_sampler</span><span class="p">)</span>  <span class="c1"># dataset is an instance of Dataset</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">apply_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.apply" title="Permalink to this definition"></a></dt>
<dd><p>对数据集对象执行给定操作函数。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>apply_func</strong> (function) - 数据集处理函数，要求该函数的输入是一个 <cite>Dataset</cite> 对象，返回的是处理后的 <cite>Dataset</cite> 对象。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>执行了给定操作函数的数据集对象。</p>
</dd>
<dt>异常：</dt><dd><ul class="simple">
<li><p><strong>TypeError</strong> - <cite>apply_func</cite> 的类型不是函数。</p></li>
<li><p><strong>TypeError</strong> - <cite>apply_func</cite> 未返回 <cite>Dataset</cite> 对象。</p></li>
</ul>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Declare an apply_func function which returns a Dataset object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">apply_func</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use apply to call apply_func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">apply_func</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.batch">
<span class="sig-name descname"><span class="pre">batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop_remainder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_parallel_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">per_batch_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">python_multiprocessing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_rowsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.batch" title="Permalink to this definition"></a></dt>
<dd><p>将数据集中连续 <cite>batch_size</cite> 条数据合并为一个批处理数据。</p>
<p><cite>batch</cite> 操作要求每列中的数据具有相同的shape。如果指定了参数 <cite>per_batch_map</cite> ，该参数将作用于批处理后的数据。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>执行 <cite>repeat</cite> 和 <cite>batch</cite> 操作的先后顺序，会影响批处理数据的数量及 <cite>per_batch_map</cite> 的结果。建议在 <cite>batch</cite> 操作完成后执行 <cite>repeat</cite> 操作。</p>
</div>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>batch_size</strong> (Union[int, Callable]) - 指定每个批处理数据包含的数据条目。
如果 <cite>batch_size</cite> 为整型，则直接表示每个批处理数据大小；
如果为可调用对象，则可以通过自定义行为动态指定每个批处理数据大小，要求该可调用对象接收一个参数BatchInfo，返回一个整形代表批处理大小，用法请参考样例（3）。</p></li>
<li><p><strong>drop_remainder</strong> (bool, 可选) - 当最后一个批处理数据包含的数据条目小于 <cite>batch_size</cite> 时，是否将该批处理丢弃，不传递给下一个操作。默认值：False，不丢弃。</p></li>
<li><p><strong>num_parallel_workers</strong> (int, 可选) - 指定 <cite>batch</cite> 操作的并发进程数/线程数（由参数 <cite>python_multiprocessing</cite> 决定当前为多进程模式或多线程模式）。
默认值：None，使用mindspore.dataset.config中配置的线程数。</p></li>
<li><p><strong>per_batch_map</strong> (Callable[[List[numpy.ndarray], …, List[numpy.ndarray], BatchInfo], (List[numpy.ndarray], …, List[numpy.ndarray])], 可选) - 可调用对象，
以(list[numpy.ndarray], …, list[numpy.ndarray], BatchInfo)作为输入参数，
处理后返回(list[numpy.ndarray], list[numpy.ndarray],…)作为新的数据列。输入参数中每个list[numpy.ndarray]代表给定数据列中的一批numpy.ndarray，
list[numpy.ndarray]的个数应与 <cite>input_columns</cite> 中传入列名的数量相匹配，在返回的(list[numpy.ndarray], list[numpy.ndarray], …)中，
list[numpy.ndarray]的个数应与输入相同，如果输出列数与输入列数不一致，则需要指定 <cite>output_columns</cite>。该可调用对象的最后一个输入参数始终是BatchInfo，
用于获取数据集的信息，用法参考样例（2）。</p></li>
<li><p><strong>input_columns</strong> (Union[str, list[str]], 可选) - 指定 <cite>batch</cite> 操作的输入数据列。
如果 <cite>per_batch_map</cite> 不为None，列表中列名的个数应与 <cite>per_batch_map</cite> 中包含的列数匹配。默认值：None，不指定。</p></li>
<li><p><strong>output_columns</strong> (Union[str, list[str]], 可选) - 指定 <cite>batch</cite> 操作的输出数据列。如果输入数据列与输入数据列的长度不相等，则必须指定此参数。
此列表中列名的数量必须与 <cite>per_batch_map</cite> 方法的返回值数量相匹配。默认值：None，输出列将与输入列具有相同的名称。</p></li>
<li><p><strong>column_order</strong> (Union[str, list[str]], 可选) - 指定传递到下一个数据集操作的数据列顺序。
如果 <cite>input_column</cite> 长度不等于 <cite>output_column</cite> 长度，则此参数必须指定。
注意：列名不限定在 <cite>input_columns</cite> 和 <cite>output_columns</cite> 中指定的列，也可以是上一个操作输出的未被处理的数据列，详细可参阅使用样例（4）。默认值：None，按照原输入顺序排列。</p></li>
<li><p><strong>pad_info</strong> (dict, 可选) - 对给定数据列进行填充。通过传入dict来指定列信息与填充信息，例如 <cite>pad_info={“col1”:([224,224],0)}</cite> ，
则将列名为”col1”的数据列扩充到shape为(224, 224)的Tensor，缺失的值使用0填充。默认值：None，不填充。</p></li>
<li><p><strong>python_multiprocessing</strong> (bool, 可选) - 启动Python多进程模式并行执行 <cite>per_batch_map</cite> 。如果 <cite>per_batch_map</cite> 的计算量很大，此选项可能会很有用。默认值：False，不启用多进程。</p></li>
<li><p><strong>max_rowsize</strong> (int, 可选) - 指定在多进程之间复制数据时，共享内存分配的最大空间，仅当 <cite>python_multiprocessing</cite> 为True时，该选项有效。默认值：16，单位为MB。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>Dataset， <cite>batch</cite> 操作后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 1) Create a dataset where every 100 rows are combined into a batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and drops the last incomplete batch if there is one.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 2）resize image according to its batch number, if it&#39;s 5-th batch, resize to (5^2, 5^2) = (25, 25)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">np_resize</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">BatchInfo</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">output</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">BatchInfo</span><span class="o">.</span><span class="n">get_batch_num</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="gp">... </span>    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
<span class="gp">... </span>        <span class="n">output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">output</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span> <span class="n">per_batch_map</span><span class="o">=</span><span class="n">np_resize</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 3）Create a dataset where its batch size is dynamic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define a callable batch size function and let batch size increase 1 each time.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">BatchInfo</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">BatchInfo</span><span class="o">.</span><span class="n">get_batch_num</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">add_one</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 4）Create a dataset with batch, then specify the column order.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Assume that the original coulmn order is [&quot;image&quot;, &quot;label&quot;] and change to [&quot;label&quot;, &quot;image&quot;].</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">column_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.bucket_batch_by_length">
<span class="sig-name descname"><span class="pre">bucket_batch_by_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bucket_boundaries</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bucket_batch_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_length_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_to_bucket_boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop_remainder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.bucket_batch_by_length" title="Permalink to this definition"></a></dt>
<dd><p>根据数据的长度进行分桶。每个桶将在数据填满的时候进行填充和批处理操作。</p>
<p>对数据集中的每一条数据进行长度计算。根据该条数据的长度计算结果和每个分桶的范围将该数据归类到特定的桶里面。
当某个分桶中数据条数达到指定的大小 <cite>bucket_batch_sizes</cite> 时，将根据 <cite>pad_info</cite> 的信息对分桶进行填充，再进行批处理。</p>
<p>执行流程参考下图：</p>
<img alt="../../_images/bucket_batch_by_length_cn.png" src="../../_images/bucket_batch_by_length_cn.png" />
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>column_names</strong> (list[str]) - 传递给参数 <cite>element_length_function</cite> 的数据列，用于计算数据的长度。</p></li>
<li><p><strong>bucket_boundaries</strong> (list[int]) - 指定各个分桶的上边界值，列表的数值必须严格递增。
如果有n个边界，则会创建n+1个桶，分配后桶的边界如下：[0, bucket_boundaries[0])，[bucket_boundaries[i], bucket_boundaries[i+1])，[bucket_boundaries[n-1], inf)，其中，0&lt;i&lt;n-1。</p></li>
<li><p><strong>bucket_batch_sizes</strong> (list[int]) - 指定每个分桶的批数据大小，必须包含 <cite>len(bucket_boundaries)+1</cite> 个元素。</p></li>
<li><p><strong>element_length_function</strong> (Callable, 可选) - 长度计算函数。要求接收 <cite>len(column_names)</cite> 个输入参数，并返回一个整数代表该条数据的长度。
如果未指定该参数，则参数 <cite>column_names</cite> 的长度必须为1，此时该列数据的shape[0]值将被当做数据长度。默认值：None，不指定。</p></li>
<li><p><strong>pad_info</strong> (dict, 可选) - 对指定数据列进行填充。通过传入dict来指定列信息与填充信息，要求dict的键是要填充的数据列名，dict的值是包含2个元素的元组。
元组中第1个元素表示要扩展至的目标shape，第2个元素表示要填充的值。
如果某一个数据列未指定将要填充后的shape和填充值，则该列中的每条数据都将填充至该批次中最长数据的长度，且填充值为0。
注意，<cite>pad_info</cite> 中任何填充shape为None的列，其每条数据长度都将被填充为当前批处理中最长数据的长度，除非指定 <cite>pad_to_bucket_boundary</cite> 为True。默认值：None，不填充。</p></li>
<li><p><strong>pad_to_bucket_boundary</strong> (bool, 可选) - 如果为True，则 <cite>pad_info</cite> 中填充shape为None的列，会被填充至由参数 <cite>bucket_batch_sizes</cite> 指定的对应分桶长度-1的长度。
如果有任何数据落入最后一个分桶中，则将报错。默认值：False。</p></li>
<li><p><strong>drop_remainder</strong> (bool, 可选) - 当每个分桶中的最后一个批处理数据数据条目小于 <cite>bucket_batch_sizes</cite> 时，是否丢弃该批处理数据。默认值：False，不丢弃。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>Dataset，按长度进行分桶和批处理操作后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset where certain counts rows are combined into a batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and drops the last incomplete batch if there is one.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generate_2_columns</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;col1&quot;</span><span class="p">,</span> <span class="s2">&quot;col2&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">generate_2_columns</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">column_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bucket_boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bucket_batch_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element_length_function</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">col2</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Will pad col2 to shape [bucket_boundaries[i]] where i is the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># index of the bucket that is currently being batched.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pad_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;col2&quot;</span><span class="p">:</span> <span class="p">([</span><span class="kc">None</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pad_to_bucket_boundary</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">bucket_batch_by_length</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">bucket_boundaries</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">bucket_batch_sizes</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">element_length_function</span><span class="p">,</span> <span class="n">pad_info</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">pad_to_bucket_boundary</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.build_sentencepiece_vocab">
<span class="sig-name descname"><span class="pre">build_sentencepiece_vocab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">columns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vocab_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">character_coverage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.build_sentencepiece_vocab" title="Permalink to this definition"></a></dt>
<dd><p>迭代源数据集对象获取数据并构建SentencePiece词汇表。
源数据集要求的是文本类数据集。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>columns</strong> (list[str]) - 指定 <cite>build_sentencepiece_vocab</cite> 操作的输入列，会从该列获取数据构造词汇表。</p></li>
<li><p><strong>vocab_size</strong> (int) - 词汇表的容量。</p></li>
<li><p><strong>character_coverage</strong> (float) - 模型涵盖的字符百分比，必须介于0.98和1.0之间。
对于具有丰富字符集的语言，如日语或中文字符集，推荐使用0.9995；对于其他字符集较小的语言，比如英语或拉丁文，推荐使用1.0。</p></li>
<li><p><strong>model_type</strong> (SentencePieceModel) - 训练的SentencePiece模型类型，可取值为’SentencePieceModel.UNIGRAM’、’SentencePieceModel.BPE’、’SentencePieceModel.CHAR’或’SentencePieceModel.WORD’。
当取值为’SentencePieceModel.WORD’时，输入的数据必须进行预分词（pretokenize）。默认值：SentencePieceModel.UNIGRAM。</p></li>
<li><p><strong>params</strong> (dict) - 如果希望使用SentencePiece的其他参数，可以构造一个dict进行传入，键为SentencePiece库接口的输入参数名，值为参数值。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>构建好的SentencePiece词汇表。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindspore.dataset.text</span> <span class="kn">import</span> <span class="n">SentencePieceModel</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># You can construct any text dataset as source, take TextFileDataset as example.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">TextFileDataset</span><span class="p">(</span><span class="s2">&quot;/path/to/sentence/piece/vocab/file&quot;</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">build_sentencepiece_vocab</span><span class="p">([</span><span class="s2">&quot;text&quot;</span><span class="p">],</span> <span class="mi">5000</span><span class="p">,</span> <span class="mf">0.9995</span><span class="p">,</span> <span class="n">SentencePieceModel</span><span class="o">.</span><span class="n">UNIGRAM</span><span class="p">,</span> <span class="p">{})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.build_vocab">
<span class="sig-name descname"><span class="pre">build_vocab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">columns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">special_tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">special_first</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.build_vocab" title="Permalink to this definition"></a></dt>
<dd><p>迭代源数据集对象获取数据并构建词汇表。
源数据集要求的是文本类数据集。</p>
<p>收集数据集中所有的不重复单词。返回 <cite>top_k</cite> 个最常见的单词组成的词汇表（如果指定了 <cite>top_k</cite> ）。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>columns</strong> (Union[str, list[str]]) - 指定 <cite>build_vocab</cite> 操作的输入列，会从该列获取数据构造词汇表。</p></li>
<li><p><strong>freq_range</strong> (tuple[int]) - 由(min_frequency, max_frequency)组成的整数元组，代表词汇出现的频率范围，在这个频率范围的词汇会被保存下来。
取值范围需满足：0 &lt;= min_frequency &lt;= max_frequency &lt;= 单词总数，其中min_frequency、max_frequency的默认值分别设置为0、单词总数。</p></li>
<li><p><strong>top_k</strong> (int) - 使用 <cite>top_k</cite> 个最常见的单词构建词汇表。假如指定了参数 <cite>freq_range</cite> ，则优先统计给定频率范围内的词汇，再根据参数 <cite>top_k</cite> 选取最常见的单词构建词汇表。
如果 <cite>top_k</cite> 的值大于单词总数，则取所有单词构建词汇表。</p></li>
<li><p><strong>special_tokens</strong> (list[str]) - 指定词汇表的特殊标记（special token），如’[UNK]’、’[SEP]’。</p></li>
<li><p><strong>special_first</strong> (bool) - 是否将参数 <cite>special_tokens</cite> 指定的特殊标记添加到词汇表的开头。如果为True则放到开头，否则放到词汇表的结尾。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>构建好的词汇表。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_corpus</span><span class="p">():</span>
<span class="gp">... </span>    <span class="c1"># key: word, value: number of occurrences, reason for using letters is so their order is apparent</span>
<span class="gp">... </span>    <span class="n">corpus</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">corpus</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">),)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;column1&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">gen_corpus</span><span class="p">,</span> <span class="n">column_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">build_vocab</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;column1&quot;</span><span class="p">],</span>
<span class="gp">... </span>                              <span class="n">freq_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">top_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                              <span class="n">special_tokens</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&lt;pad&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;unk&gt;&quot;</span><span class="p">],</span>
<span class="gp">... </span>                              <span class="n">special_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.close_pool">
<span class="sig-name descname"><span class="pre">close_pool</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.close_pool" title="Permalink to this definition"></a></dt>
<dd><p>关闭数据集对象中的多进程池。如果您熟悉多进程库，可以将此视为进程池对象的析构函数。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>该接口在将来会被删除或不可见，不建议用户调用该接口。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.concat">
<span class="sig-name descname"><span class="pre">concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datasets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.concat" title="Permalink to this definition"></a></dt>
<dd><p>对传入的多个数据集对象进行拼接操作。可以使用”+”运算符来进行数据集进行拼接。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>用于拼接的多个数据集对象，每个数据集对象的列名、每列数据的维度（rank）和数据类型必须相同。</p>
</div>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>datasets</strong> (Union[list, Dataset]) - 与当前数据集对象拼接的数据集对象列表或单个数据集对象。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>Dataset，拼接后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset by concatenating dataset_1 and dataset_2 with &quot;+&quot; operator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset_1</span> <span class="o">+</span> <span class="n">dataset_2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset by concatenating dataset_1 and dataset_2 with concat operation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset_1</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dataset_2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.create_dict_iterator">
<span class="sig-name descname"><span class="pre">create_dict_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_numpy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.create_dict_iterator" title="Permalink to this definition"></a></dt>
<dd><p>基于数据集对象创建迭代器。输出的数据为字典类型。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>num_epochs</strong> (int, 可选) - 迭代器可以迭代的最大次数。默认值：-1，迭代器可以迭代无限次。</p></li>
<li><p><strong>output_numpy</strong> (bool, 可选) - 输出的数据是否转为NumPy类型。如果为False，迭代器输出的每列数据类型为MindSpore.Tensor，否则为NumPy。默认值：False。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>DictIterator，基于数据集对象创建的字典迭代器。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">create_dict_iterator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># item is a dict</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">break</span>
<span class="go">&lt;class &#39;dict&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.create_tuple_iterator">
<span class="sig-name descname"><span class="pre">create_tuple_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_numpy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.create_tuple_iterator" title="Permalink to this definition"></a></dt>
<dd><p>基于数据集对象创建迭代器。输出数据为 <cite>numpy.ndarray</cite> 组成的列表。</p>
<p>可以通过参数 <cite>columns</cite> 指定输出的所有列名及列的顺序。如果columns未指定，列的顺序将保持不变。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>columns</strong> (list[str], 可选) - 用于指定输出的数据列和列的顺序。默认值：None，输出所有数据列。</p></li>
<li><p><strong>num_epochs</strong> (int, 可选) - 迭代器可以迭代的最大次数。默认值：-1，迭代器可以迭代无限次。</p></li>
<li><p><strong>output_numpy</strong> (bool, 可选) - 输出的数据是否转为NumPy类型。如果为False，迭代器输出的每列数据类型为MindSpore.Tensor，否则为NumPy。默认值：False。</p></li>
<li><p><strong>do_copy</strong> (bool, 可选) - 当参数 <cite>output_numpy</cite> 为False，即输出数据类型为mindspore.Tensor时，可以将此参数指定为False以减少拷贝，获得更好的性能。默认值：True。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>TupleIterator，基于数据集对象创建的元组迭代器。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">create_tuple_iterator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># item is a list</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">break</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.device_que">
<span class="sig-name descname"><span class="pre">device_que</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">send_epoch_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create_data_info_queue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.device_que" title="Permalink to this definition"></a></dt>
<dd><p>将数据异步传输到Ascend/GPU设备上。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>send_epoch_end</strong> (bool, 可选) - 数据发送完成后是否发送结束标识到设备上，默认值：True。</p></li>
<li><p><strong>create_data_info_queue</strong> (bool, 可选) - 是否创建一个队列，用于存储每条数据的数据类型和shape。默认值：False，不创建。</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果设备类型为Ascend，数据的特征将被逐一传输。每次传输的数据大小限制为256MB。</p>
</div>
<dl class="simple">
<dt>返回：</dt><dd><p>Dataset，用于帮助发送数据到设备上的数据集对象。</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.dynamic_min_max_shapes">
<span class="sig-name descname"><span class="pre">dynamic_min_max_shapes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.dynamic_min_max_shapes" title="Permalink to this definition"></a></dt>
<dd><p>当数据集对象中的数据shape不唯一（动态shape）时，获取数据的最小shape和最大shape。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>两个列表代表最小shape和最大shape，每个列表中的shape按照数据列的顺序排列。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator1</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">83</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">generator1</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;data1&quot;</span><span class="p">,</span> <span class="s2">&quot;data2&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span><span class="o">.</span><span class="n">set_dynamic_columns</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">83</span><span class="p">],</span> <span class="s2">&quot;data2&quot;</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_shapes</span><span class="p">,</span> <span class="n">max_shapes</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">dynamic_min_max_shapes</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_parallel_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.filter" title="Permalink to this definition"></a></dt>
<dd><p>通过自定义判断条件对数据集对象中的数据进行过滤。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>predicate</strong> (callable) - Python可调用对象。要求该对象接收n个入参，用于指代每个数据列的数据，最后返回值一个bool值。
如果返回值为False，则表示过滤掉该条数据。注意n的值与参数 <cite>input_columns</cite> 表示的输入列数量一致。</p></li>
<li><p><strong>input_columns</strong> (Union[str, list[str]], 可选) - <cite>filter</cite> 操作的输入数据列。默认值：None，<cite>predicate</cite> 将应用于数据集中的所有列。</p></li>
<li><p><strong>num_parallel_workers</strong> (int, 可选) - 指定 <cite>filter</cite> 操作的并发线程数。默认值：None，使用mindspore.dataset.config中配置的线程数。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>Dataset，执行给定筛选过滤操作的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># generator data(0 ~ 63)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># filter the data that greater than or equal to 11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">predicate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> <span class="n">data</span> <span class="o">&lt;</span> <span class="mi">11</span><span class="p">,</span> <span class="n">input_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.flat_map">
<span class="sig-name descname"><span class="pre">flat_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.flat_map" title="Permalink to this definition"></a></dt>
<dd><p>对数据集对象中每一条数据执行给定的数据处理，并将结果展平。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>func</strong> (function) - 数据处理函数，要求输入必须为一个 <cite>numpy.ndarray</cite> ，返回值是一个 <cite>Dataset</cite> 对象。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>执行给定操作后的数据集对象。</p>
</dd>
<dt>异常：</dt><dd><ul class="simple">
<li><p><strong>TypeError</strong> - <cite>func</cite> 不是函数。</p></li>
<li><p><strong>TypeError</strong> - <cite>func</cite> 的返回值不是 <cite>Dataset</cite> 对象。</p></li>
</ul>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 1) flat_map on one column dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># create a NumpySlicesDataset with the array</span>
<span class="gp">... </span>    <span class="n">data</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">... </span>    <span class="c1"># repeat the dataset twice</span>
<span class="gp">... </span>    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">flat_map</span><span class="p">(</span><span class="n">repeat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># [0, 1, 0, 1, 2, 3, 2, 3]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 2) flat_map on multi column dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">(([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]]),</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">plus_and_minus</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># apply different methods on columns</span>
<span class="gp">... </span>    <span class="n">data</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">((</span><span class="n">col1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">flat_map</span><span class="p">(</span><span class="n">plus_and_minus</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ([1, 2, 3, 4], [-1, -2, -3, -4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.get_batch_size">
<span class="sig-name descname"><span class="pre">get_batch_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.get_batch_size" title="Permalink to this definition"></a></dt>
<dd><p>获得数据集对象定义的批处理大小，即一个批处理数据中包含的数据条数。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>int，一个批处理数据中包含的数据条数。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_batch_size</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.get_class_indexing">
<span class="sig-name descname"><span class="pre">get_class_indexing</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.get_class_indexing" title="Permalink to this definition"></a></dt>
<dd><p>返回类别索引。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>dict，描述类别名称到索引的键值对映射关系，通常为str-to-int格式。针对COCO数据集，类别名称到索引映射关系描述形式为str-to-list&lt;int&gt;格式，列表中的第二个数字表示超类别。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">class_indexing</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_class_indexing</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.get_col_names">
<span class="sig-name descname"><span class="pre">get_col_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.get_col_names" title="Permalink to this definition"></a></dt>
<dd><p>返回数据集对象中包含的列名。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>list，数据集中所有列名组成列表。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">col_names</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_col_names</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.get_dataset_size">
<span class="sig-name descname"><span class="pre">get_dataset_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.get_dataset_size" title="Permalink to this definition"></a></dt>
<dd><p>返回一个epoch中的batch数。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>int，batch的数目。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset_size</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.get_repeat_count">
<span class="sig-name descname"><span class="pre">get_repeat_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.get_repeat_count" title="Permalink to this definition"></a></dt>
<dd><p>获取 <cite>RepeatDataset</cite> 中定义的repeat操作的次数，默认值：1。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>int，repeat操作的次数。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repeat_count</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_repeat_count</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.input_indexs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">input_indexs</span></span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.input_indexs" title="Permalink to this definition"></a></dt>
<dd><p>获取/设置数据列索引，它表示使用下沉模式时数据列映射至网络中的对应关系。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>int，数据集的input index信息。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set input_indexs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span><span class="o">.</span><span class="n">input_indexs</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">input_indexs</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_parallel_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">python_multiprocessing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_rowsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offload</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.map" title="Permalink to this definition"></a></dt>
<dd><p>给定一组数据增强列表，按顺序将数据增强作用在数据集对象上。</p>
<p>每个数据增强操作将数据集对象中的一个或多个数据列作为输入，将数据增强的结果输出为一个或多个数据列。
第一个数据增强操作将 <cite>input_columns</cite> 中指定的列作为输入。
如果数据增强列表中存在多个数据增强操作，则上一个数据增强的输出列将作为下一个数据增强的输入列。</p>
<p>最后一个数据增强的输出列的列名由 <cite>output_columns</cite> 指定，如果没有指定 <cite>output_columns</cite> ，输出列名与 <cite>input_columns</cite> 一致。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>operations</strong> (Union[list[TensorOperation], list[functions]]) - 一组数据增强操作，支持数据集增强算子或者用户自定义的Python Callable对象。map操作将按顺序将一组数据增强作用在数据集对象上。</p></li>
<li><p><strong>input_columns</strong> (Union[str, list[str]], 可选) - 第一个数据增强操作的输入数据列。此列表的长度必须与 <cite>operations</cite> 列表中第一个数据增强的预期输入列数相匹配。默认值：None。表示所有数据列都将传递给第一个数据增强操作。</p></li>
<li><p><strong>output_columns</strong> (Union[str, list[str]], 可选) - 最后一个数据增强操作的输出数据列。如果 <cite>input_columns</cite> 长度不等于 <cite>output_columns</cite> 长度，则必须指定此参数。列表的长度必须必须与最后一个数据增强的输出列数相匹配。默认值：None，输出列将与输入列具有相同的名称。</p></li>
<li><p><strong>column_order</strong> (Union[str, list[str]], 可选) - 指定传递到下一个数据集操作的数据列的顺序。如果 <cite>input_columns</cite> 长度不等于 <cite>output_columns</cite> 长度，则必须指定此参数。注意：参数的列名不限定在 <cite>input_columns</cite> 和 <cite>output_columns</cite> 中指定的列，也可以是上一个操作输出的未被处理的数据列。默认值：None，按照原输入顺序排列。</p></li>
<li><p><strong>num_parallel_workers</strong> (int, 可选) - 指定map操作的多进程/多线程并发数，加快处理速度。默认值：None，将使用 <cite>set_num_parallel_workers</cite> 设置的并发数。</p></li>
<li><p><strong>python_multiprocessing</strong> (bool, 可选) - 启用Python多进程模式加速map操作。当传入的 <cite>operations</cite> 计算量很大时，开启此选项可能会有较好效果。默认值：False。</p></li>
<li><p><strong>cache</strong> (DatasetCache, 可选) - 单节点数据缓存服务，用于加快数据集处理，详情请阅读 <a class="reference external" href="https://www.mindspore.cn/tutorials/experts/zh-CN/r1.9/dataset/cache.html">单节点数据缓存</a> 。默认值：None，不使用缓存。</p></li>
<li><p><strong>callbacks</strong> (DSCallback, list[DSCallback], 可选) - 要调用的Dataset回调函数列表。默认值：None。</p></li>
<li><p><strong>max_rowsize</strong> (int, 可选) - 指定在多进程之间复制数据时，共享内存分配的最大空间，仅当 <cite>python_multiprocessing</cite> 为True时，该选项有效。默认值：16，单位为MB。</p></li>
<li><p><strong>offload</strong> (bool, 可选) - 是否进行异构硬件加速，详情请阅读 <a class="reference external" href="https://www.mindspore.cn/tutorials/experts/zh-CN/r1.9/dataset/dataset_offload.html">数据准备异构加速</a> 。默认值：None。</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p><cite>operations</cite> 参数接收 <cite>TensorOperation</cite> 类型的数据处理操作，以及用户定义的Python函数(PyFuncs)。</p></li>
<li><p>不要将 <cite>mindspore.nn</cite> 和 <cite>mindspore.ops</cite> 或其他的网络计算算子添加到 <cite>operations</cite> 中。</p></li>
</ul>
</div>
<dl class="simple">
<dt>返回：</dt><dd><p>MapDataset，map操作后的数据集。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance of Dataset which has 2 columns, &quot;image&quot; and &quot;label&quot;.</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define two operations, where each operation accepts 1 input column and outputs 1 column.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decode_op</span> <span class="o">=</span> <span class="n">c_vision</span><span class="o">.</span><span class="n">Decode</span><span class="p">(</span><span class="n">rgb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_jitter_op</span> <span class="o">=</span> <span class="n">c_vision</span><span class="o">.</span><span class="n">RandomColorAdjust</span><span class="p">(</span><span class="n">brightness</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="n">contrast</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                                              <span class="n">saturation</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">hue</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 1) Simple map example.</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Apply decode_op on column &quot;image&quot;. This column will be replaced by the outputted</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># column of decode_op. Since column_order is not provided, both columns &quot;image&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and &quot;label&quot; will be propagated to the child node in their original order.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">decode_op</span><span class="p">],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Decode and rename column &quot;image&quot; to &quot;decoded_image&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">decode_op</span><span class="p">],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span> <span class="n">output_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decoded_image&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify the order of the output columns.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">decode_op</span><span class="p">],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">output_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">column_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Rename column &quot;image&quot; to &quot;decoded_image&quot; and also specify the order of the output columns.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">decode_op</span><span class="p">],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">output_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decoded_image&quot;</span><span class="p">],</span> <span class="n">column_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;decoded_image&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Rename column &quot;image&quot; to &quot;decoded_image&quot; and keep only this column.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">decode_op</span><span class="p">],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">output_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decoded_image&quot;</span><span class="p">],</span> <span class="n">column_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decoded_image&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A simple example for mapping pyfunc. Renaming columns and specifying column order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># work in the same way as the previous examples.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 2) Map example with more than one operation.</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset where the images are decoded, then randomly color jittered.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># decode_op takes column &quot;image&quot; as input and outputs one column. The column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># outputted by decode_op is passed as input to random_jitter_op.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># random_jitter_op will output one column. Column &quot;image&quot; will be replaced by</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the column outputted by random_jitter_op (the very last operation). All other</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># columns are unchanged. Since column_order is not specified, the order of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># columns will remain the same.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">decode_op</span><span class="p">,</span> <span class="n">random_jitter_op</span><span class="p">],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Rename the column outputted by random_jitter_op to &quot;image_mapped&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specifying column order works in the same way as examples in 1).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">decode_op</span><span class="p">,</span> <span class="n">random_jitter_op</span><span class="p">],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">output_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image_mapped&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Map with multiple operations using pyfunc. Renaming columns and specifying column order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># work in the same way as examples in 1).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span>
<span class="gp">... </span>                                  <span class="n">output_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data_mapped&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 3) Example where number of input columns is not equal to number of output columns.</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># operations[0] is a lambda that takes 2 columns as input and outputs 3 columns.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># operations[1] is a lambda that takes 3 columns as input and outputs 1 column.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># operations[2] is a lambda that takes 1 column as input and outputs 4 columns.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: The number of output columns of operation[i] must equal the number of</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input columns of operation[i+1]. Otherwise, this map call will also result</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># in an error.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operations</span> <span class="o">=</span> <span class="p">[(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
<span class="gp">... </span>              <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span><span class="p">),</span>
<span class="gp">... </span>              <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">5</span><span class="p">,</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">7</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: Since the number of input columns is not the same as the number of</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># output columns, the output_columns and column_order parameters must be</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># specified. Otherwise, this map call will also result in an error.</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]),</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Propagate all columns to the child node in this order:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">output_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mod2&quot;</span><span class="p">,</span> <span class="s2">&quot;mod3&quot;</span><span class="p">,</span> <span class="s2">&quot;mod5&quot;</span><span class="p">,</span> <span class="s2">&quot;mod7&quot;</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">column_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mod2&quot;</span><span class="p">,</span> <span class="s2">&quot;mod3&quot;</span><span class="p">,</span> <span class="s2">&quot;mod5&quot;</span><span class="p">,</span> <span class="s2">&quot;mod7&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Propagate some columns to the child node in this order:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">output_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mod2&quot;</span><span class="p">,</span> <span class="s2">&quot;mod3&quot;</span><span class="p">,</span> <span class="s2">&quot;mod5&quot;</span><span class="p">,</span> <span class="s2">&quot;mod7&quot;</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">column_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mod7&quot;</span><span class="p">,</span> <span class="s2">&quot;mod3&quot;</span><span class="p">,</span> <span class="s2">&quot;col2&quot;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.num_classes">
<span class="sig-name descname"><span class="pre">num_classes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.num_classes" title="Permalink to this definition"></a></dt>
<dd><p>获取数据集对象中所有样本的类别数目。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>int，类别的数目。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">num_classes</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.output_shapes">
<span class="sig-name descname"><span class="pre">output_shapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.output_shapes" title="Permalink to this definition"></a></dt>
<dd><p>获取数据集对象中每列数据的shape。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>estimate</strong> (bool) - 如果 <cite>estimate</cite> 为 False，将返回数据集第一条数据的shape。
否则将遍历整个数据集以获取数据集的真实shape信息，其中动态变化的维度将被标记为None（可用于动态shape数据集场景），默认值：False。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>list，每列数据的shape列表。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator1</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">83</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">generator1</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;data1&quot;</span><span class="p">,</span> <span class="s2">&quot;data2&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_shapes</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">output_shapes</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.output_types">
<span class="sig-name descname"><span class="pre">output_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.output_types" title="Permalink to this definition"></a></dt>
<dd><p>获取数据集对象中每列数据的数据类型。</p>
<dl class="simple">
<dt>返回：</dt><dd><p>list，每列数据的数据类型列表。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_types</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">output_types</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">columns</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.project" title="Permalink to this definition"></a></dt>
<dd><p>从数据集对象中选择需要的列，并按给定的列名的顺序进行排序。
未指定的数据列将被丢弃。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>columns</strong> (Union[str, list[str]]) - 要选择的数据列的列名列表。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>Dataset，project操作后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns_to_project</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;column3&quot;</span><span class="p">,</span> <span class="s2">&quot;column1&quot;</span><span class="p">,</span> <span class="s2">&quot;column2&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset that consists of column3, column1, column2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># in that order, regardless of the original order of columns.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns_to_project</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.rename">
<span class="sig-name descname"><span class="pre">rename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_columns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_columns</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.rename" title="Permalink to this definition"></a></dt>
<dd><p>对数据集对象按指定的列名进行重命名。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>input_columns</strong> (Union[str, list[str]]) - 待重命名的列名列表。</p></li>
<li><p><strong>output_columns</strong> (Union[str, list[str]]) - 重命名后的列名列表。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>RenameDataset，rename操作后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">input_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;input_col1&quot;</span><span class="p">,</span> <span class="s2">&quot;input_col2&quot;</span><span class="p">,</span> <span class="s2">&quot;input_col3&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;output_col1&quot;</span><span class="p">,</span> <span class="s2">&quot;output_col2&quot;</span><span class="p">,</span> <span class="s2">&quot;output_col3&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset where input_col1 is renamed to output_col1, and</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input_col2 is renamed to output_col2, and input_col3 is renamed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># to output_col3.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">input_columns</span><span class="o">=</span><span class="n">input_columns</span><span class="p">,</span> <span class="n">output_columns</span><span class="o">=</span><span class="n">output_columns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.repeat">
<span class="sig-name descname"><span class="pre">repeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.repeat" title="Permalink to this definition"></a></dt>
<dd><p>重复此数据集 <cite>count</cite> 次。如果 <cite>count</cite> 为None或-1，则无限重复迭代。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>repeat和batch的顺序反映了batch的数量。建议：repeat操作在batch操作之后使用。</p>
</div>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>count</strong> (int) - 数据集重复的次数。默认值：None。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>RepeatDataset，repeat操作后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset where the dataset is repeated for 50 epochs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset where each epoch is shuffled individually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset where the dataset is first repeated for</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 50 epochs before shuffling. The shuffle operator will treat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the entire 50 epochs as one big dataset.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.reset" title="Permalink to this definition"></a></dt>
<dd><p>重置下一个epoch的数据集对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_files</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mindrecord'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.save" title="Permalink to this definition"></a></dt>
<dd><p>将数据处理管道中正处理的数据保存为通用的数据集格式。数据集格式仅支持：’mindrecord’。可以使用’MindDataset’类来读取保存的’mindrecord’文件。</p>
<p>将数据保存为’mindrecord’格式时存在隐式类型转换。转换表展示如何执行类型转换。</p>
<table class="colwidths-given docutils align-default" id="id4">
<caption><span class="caption-text">保存为’mindrecord’格式时的隐式类型转换</span><a class="headerlink" href="#id4" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>‘dataset’类型</p></th>
<th class="head"><p>‘mindrecord’类型</p></th>
<th class="head"><p>说明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool</p></td>
<td><p>None</p></td>
<td><p>不支持</p></td>
</tr>
<tr class="row-odd"><td><p>int8</p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>uint8</p></td>
<td><p>bytes</p></td>
<td><p>丢失维度信息</p></td>
</tr>
<tr class="row-odd"><td><p>int16</p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>uint16</p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>int32</p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>uint32</p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>int64</p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>uint64</p></td>
<td><p>None</p></td>
<td><p>不支持</p></td>
</tr>
<tr class="row-odd"><td><p>float16</p></td>
<td><p>float32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>float32</p></td>
<td><p>float32</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>float64</p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>string</p></td>
<td><p>string</p></td>
<td><p>不支持多维字符串</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>如需按顺序保存数据，将数据集的 <cite>shuffle</cite> 设置为False，将 <cite>num_files</cite> 设置为1。</p></li>
<li><p>在执行保存操作之前，不要使用batch操作、repeat操作或具有随机属性的数据增强的map操作。</p></li>
<li><p>当数据的维度可变时，只支持1维数组或者在第0维变化的多维数组。</p></li>
<li><p>不支持UINT64类型、多维的UINT8类型、多维STRING类型。</p></li>
</ol>
</div>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>file_name</strong> (str) - 数据集文件的路径。</p></li>
<li><p><strong>num_files</strong> (int, 可选) - 数据集文件的数量，默认值：1。</p></li>
<li><p><strong>file_type</strong> (str, 可选) - 数据集格式，默认值：’mindrecord’。</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.set_dynamic_columns">
<span class="sig-name descname"><span class="pre">set_dynamic_columns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.set_dynamic_columns" title="Permalink to this definition"></a></dt>
<dd><p>设置数据集的动态shape信息，需要在定义好完整的数据处理管道后进行设置。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>columns</strong> (dict) - 包含数据集中每列shape信息的字典。shape[i]为 <cite>None</cite> 表示shape[i]的数据长度是动态的。</p></li>
</ul>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator1</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">83</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">generator1</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;data1&quot;</span><span class="p">,</span> <span class="s2">&quot;data2&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span><span class="o">.</span><span class="n">set_dynamic_columns</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">83</span><span class="p">],</span> <span class="s2">&quot;data2&quot;</span><span class="p">:</span> <span class="p">[]})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.shuffle">
<span class="sig-name descname"><span class="pre">shuffle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.shuffle" title="Permalink to this definition"></a></dt>
<dd><p>使用以下策略混洗此数据集的行：</p>
<ol class="arabic simple">
<li><p>生成一个混洗缓冲区包含 <cite>buffer_size</cite> 条数据行。</p></li>
<li><p>从混洗缓冲区中随机选择一个数据行，传递给下一个操作。</p></li>
<li><p>从上一个操作获取下一个数据行（如果有的话），并将其放入混洗缓冲区中。</p></li>
<li><p>重复步骤2和3，直到混洗缓冲区中没有数据行为止。</p></li>
</ol>
<p>在第一个epoch中可以通过 <cite>dataset.config.set_seed</cite> 来设置随机种子。在随后的每个epoch，种子都会被设置成一个新产生的随机值。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>buffer_size</strong> (int) - 用于混洗的缓冲区大小（必须大于1）。将 <cite>buffer_size</cite> 设置为数据集大小将进行全局混洗。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>ShuffleDataset，混洗后的数据集对象。</p>
</dd>
<dt>异常：</dt><dd><ul class="simple">
<li><p><strong>RuntimeError</strong> - 混洗前存在通过 <cite>dataset.sync_wait</cite> 进行同步操作。</p></li>
</ul>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Optionally set the seed for the first epoch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">58</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a shuffled dataset using a shuffle buffer of size 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.skip">
<span class="sig-name descname"><span class="pre">skip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.skip" title="Permalink to this definition"></a></dt>
<dd><p>跳过此数据集对象的前 <cite>count</cite> 条数据。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>count</strong> (int) - 要跳过数据的条数。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>SkipDataset，跳过指定条数据后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset which skips first 3 elements from data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">randomize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.split" title="Permalink to this definition"></a></dt>
<dd><p>将数据集拆分为多个不重叠的子数据集。</p>
<dl>
<dt>参数：</dt><dd><ul>
<li><p><strong>sizes</strong> (Union[list[int], list[float]]) - 如果指定了一列整数[s1, s2, …, sn]，数据集将被拆分为n个大小为s1、s2、…、sn的数据集。如果所有输入大小的总和不等于原始数据集大小，则报错。如果指定了一列浮点数[f1, f2, …, fn]，则所有浮点数必须介于0和1之间，并且总和必须为1，否则报错。数据集将被拆分为n个大小为round(f1*K)、round(f2*K)、…、round(fn*K)的数据集，其中K是原始数据集的大小。</p>
<p>如果round四舍五入计算后：</p>
<ul class="simple">
<li><p>任何子数据集的的大小等于0，都将发生错误。</p></li>
<li><p>如果子数据集大小的总和小于K，K - sigma(round(fi * k))的值将添加到第一个子数据集，sigma为求和操作。</p></li>
<li><p>如果子数据集大小的总和大于K，sigma(round(fi * K)) - K的值将从第一个足够大的子数据集中删除，且删除后的子数据集大小至少大于1。</p></li>
</ul>
</li>
<li><p><strong>randomize</strong> (bool, 可选) - 确定是否随机拆分数据，默认值：True，数据集将被随机拆分。否则将按顺序拆分为多个不重叠的子数据集。</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>如果进行拆分操作的数据集对象为MappableDataset类型，则将自动调用一个优化后的split操作。</p></li>
<li><p>如果进行split操作，则不应对数据集对象进行分片操作（如指定num_shards或使用DistributerSampler）。相反，如果创建一个DistributerSampler，并在split操作拆分后的子数据集对象上进行分片操作，强烈建议在每个子数据集上设置相同的种子，否则每个分片可能不是同一个子数据集的一部分（请参见示例）。</p></li>
<li><p>强烈建议不要对数据集进行混洗，而是使用随机化（randomize=True）。对数据集进行混洗的结果具有不确定性，每个拆分后的子数据集中的数据在每个epoch可能都不同。</p></li>
</ol>
</div>
<dl class="simple">
<dt>异常：</dt><dd><ul class="simple">
<li><p><strong>RuntimeError</strong> - 数据集对象不支持 <cite>get_dataset_size</cite> 或者 <cite>get_dataset_size</cite> 返回None。</p></li>
<li><p><strong>RuntimeError</strong> - <cite>sizes</cite> 是list[int]，并且 <cite>sizes</cite> 中所有元素的总和不等于数据集大小。</p></li>
<li><p><strong>RuntimeError</strong> - <cite>sizes</cite> 是list[float]，并且计算后存在大小为0的拆分子数据集。</p></li>
<li><p><strong>RuntimeError</strong> - 数据集对象在调用拆分之前已进行分片。</p></li>
<li><p><strong>ValueError</strong> - <cite>sizes</cite> 是list[float]，且并非所有float数值都在0和1之间，或者float数值的总和不等于1。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>tuple(Dataset)，split操作后子数据集对象的元组。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Since many datasets have shuffle on by default, set shuffle to False if split will be called!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">ImageFolderDataset</span><span class="p">(</span><span class="n">image_folder_dataset_dir</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Set the seed, and tell split to use this seed when randomizing.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># This is needed because sharding will be done later</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">58</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">test_dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">split</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># To shard the train dataset, use a DistributedSampler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_sampler</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_dataset</span><span class="o">.</span><span class="n">use_sampler</span><span class="p">(</span><span class="n">train_sampler</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.sync_update">
<span class="sig-name descname"><span class="pre">sync_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.sync_update" title="Permalink to this definition"></a></dt>
<dd><p>释放阻塞条件并使用给定数据触发回调函数。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>condition_name</strong> (str) - 用于触发发送下一个数据行的条件名称。</p></li>
<li><p><strong>num_batch</strong> (Union[int, None]) - 释放的batch（row）数。当 <cite>num_batch</cite> 为None时，将默认为 <cite>sync_wait</cite>  操作指定的值，默认值：None。</p></li>
<li><p><strong>data</strong> (Any) - 用户自定义传递给回调函数的数据，默认值：None。</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.sync_wait">
<span class="sig-name descname"><span class="pre">sync_wait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.sync_wait" title="Permalink to this definition"></a></dt>
<dd><p>为同步操作在数据集对象上添加阻塞条件。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>condition_name</strong> (str) - 用于触发发送下一行数据的条件名称。</p></li>
<li><p><strong>num_batch</strong> (int) - 每个epoch开始时无阻塞的batch数。默认值：1。</p></li>
<li><p><strong>callback</strong> (function) - <cite>sync_update</cite> 操作中将调用的回调函数。默认值：None。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>SyncWaitDataset，添加了阻塞条件的数据集对象。</p>
</dd>
<dt>异常：</dt><dd><ul class="simple">
<li><p><strong>RuntimeError</strong> - 条件名称已存在。</p></li>
</ul>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">),)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Augment</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loss</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">input_</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GeneratorDataset</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">Augment</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">sync_wait</span><span class="p">(</span><span class="n">condition_name</span><span class="o">=</span><span class="s2">&quot;policy&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">aug</span><span class="o">.</span><span class="n">update</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="n">aug</span><span class="o">.</span><span class="n">preprocess</span><span class="p">],</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">create_dict_iterator</span><span class="p">(</span><span class="n">num_epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">count</span>
<span class="gp">... </span>    <span class="n">count</span> <span class="o">+=</span> <span class="n">batch_size</span>
<span class="gp">... </span>    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;loss&quot;</span><span class="p">:</span> <span class="n">count</span><span class="p">}</span>
<span class="gp">... </span>    <span class="n">dataset</span><span class="o">.</span><span class="n">sync_update</span><span class="p">(</span><span class="n">condition_name</span><span class="o">=</span><span class="s2">&quot;policy&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.take">
<span class="sig-name descname"><span class="pre">take</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.take" title="Permalink to this definition"></a></dt>
<dd><p>从数据集中获取最多 <cite>count</cite> 的元素。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>如果 <cite>count</cite> 大于数据集中的数据条数或等于-1，则取数据集中的所有数据。</p></li>
<li><p>take和batch操作顺序很重要，如果take在batch操作之前，则取给定条数，否则取给定batch数。</p></li>
</ol>
</div>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>count</strong> (int, 可选) - 要从数据集对象中获取的数据条数，默认值：-1，获取所有数据。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>TakeDataset，take操作后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset where the dataset includes 50 elements.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.to_device">
<span class="sig-name descname"><span class="pre">to_device</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">send_epoch_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create_data_info_queue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.to_device" title="Permalink to this definition"></a></dt>
<dd><p>将数据从CPU传输到GPU、Ascend或其他设备。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>send_epoch_end</strong> (bool, 可选) - 是否将epoch结束符 <cite>end_of_sequence</cite> 发送到设备，默认值：True。</p></li>
<li><p><strong>create_data_info_queue</strong> (bool, 可选) - 是否创建存储数据类型和shape的队列，默认值：False。</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>该接口在将来会被删除或不可见。建议使用 <cite>device_queue</cite> 接口。
如果设备为Ascend，则逐个传输数据。每次数据传输的限制为256M。</p>
</div>
<dl class="simple">
<dt>返回：</dt><dd><p>TransferDataset，用于传输的数据集对象。</p>
</dd>
<dt>异常：</dt><dd><ul class="simple">
<li><p><strong>RuntimeError</strong> - 如果提供了分布式训练的文件路径但读取失败。</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.to_json" title="Permalink to this definition"></a></dt>
<dd><p>将数据处理管道序列化为JSON字符串，如果提供了文件名，则转储到文件中。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>filename</strong> (str) - 保存JSON文件的路径（包含文件名）。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>str，数据处理管道序列化后的JSON字符串。</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.use_sampler">
<span class="sig-name descname"><span class="pre">use_sampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_sampler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.use_sampler" title="Permalink to this definition"></a></dt>
<dd><p>替换当前数据集的最末子采样器，保持父采样器不变。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>new_sampler</strong> (Sampler) - 用于替换的新采样器。</p></li>
</ul>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dataset is an instance object of Dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># use a DistributedSampler instead</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_sampler</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">DistributedSampler</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span><span class="o">.</span><span class="n">use_sampler</span><span class="p">(</span><span class="n">new_sampler</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindspore.dataset.GeneratorDataset.zip">
<span class="sig-name descname"><span class="pre">zip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datasets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mindspore.dataset.GeneratorDataset.zip" title="Permalink to this definition"></a></dt>
<dd><p>将数据集对象和输入的数据集对象或者数据集对象元组按列进行合并压缩。输入数据集对象中不能有重名的列。</p>
<dl class="simple">
<dt>参数：</dt><dd><ul class="simple">
<li><p><strong>datasets</strong> (Union[tuple, class Dataset]) - 数据集对象的元组或单个数据集对象与当前数据集对象一起合并压缩。</p></li>
</ul>
</dd>
<dt>返回：</dt><dd><p>ZipDataset，合并压缩后的数据集对象。</p>
</dd>
</dl>
<p><strong>样例：</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dataset which is the combination of dataset and dataset_1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">dataset_1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mindspore.dataset.TFRecordDataset.html" class="btn btn-neutral float-left" title="mindspore.dataset.TFRecordDataset" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mindspore.dataset.NumpySlicesDataset.html" class="btn btn-neutral float-right" title="mindspore.dataset.NumpySlicesDataset" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>