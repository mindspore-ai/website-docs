

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mindspore.dataset.engine.graphdata &mdash; MindSpore master 文档</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/training.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/nbsphinx-code-cells.css" type="text/css" />
   
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script src="../../../../_static/js/training.js"></script>
        <script src="../../../../_static/translations.js"></script>
        
        
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">设计</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/overview.html">MindSpore设计概览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/programming_paradigm.html">编程范式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/auto_gradient.html">函数式微分编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/mindir.html">中间表示MindIR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/all_scenarios.html">全场景统一</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/dynamic_graph_and_static_graph.html">动静态图结合</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/pluggable_device.html">三方硬件对接</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/distributed_training_design.html">分布式并行</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/graph_fusion_engine.html">图算融合加速引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/data_engine.html">高性能数据处理引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/glossary.html">术语</a></li>
</ul>
<p class="caption"><span class="caption-text">规格</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/benchmark.html">基准性能</a></li>
<li class="toctree-l1"><a class="reference external" href="https://gitee.com/mindspore/models/blob/r2.0/README_CN.md#目录">网络支持↗</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/operator_list.html">API支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/syntax_list.html">语法支持</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.primitive.html">mindspore.ops.primitive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.amp.html">mindspore.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.rewrite.html">mindspore.rewrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.boost.html">mindspore.boost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.scipy.html">mindspore.scipy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.mindspore.cn/lite/api/zh-CN/r2.0/api_cpp/mindspore.html">C++ API↗</a></li>
</ul>
<p class="caption"><span class="caption-text">API映射</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/api_mapping/pytorch_api_mapping.html">PyTorch与MindSpore API映射表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/api_mapping/tensorflow_api_mapping.html">TensorFlow与MindSpore API映射表</a></li>
</ul>
<p class="caption"><span class="caption-text">迁移指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/overview.html">迁移指南概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/enveriment_preparation.html">环境准备与资料获取</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/analysis_and_preparation.html">模型分析与准备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/model_development/model_development.html">MindSpore网络搭建</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/debug_and_tune.html">调试调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/sample_code.html">网络迁移调试实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/faq.html">常见问题</a></li>
</ul>
<p class="caption"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/installation.html">安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/data_processing.html">数据处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/implement_problem.html">执行问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/network_compilation.html">网络编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/operators_compile.html">算子编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/usage_migrate_3rd.html">第三方框架迁移使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/performance_tuning.html">性能调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/precision_tuning.html">精度调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/distributed_parallel.html">分布式并行</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/inference.html">推理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/feature_advice.html">特性咨询</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">模块代码</a> &raquo;</li>
        
      <li>mindspore.dataset.engine.graphdata</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>mindspore.dataset.engine.graphdata 源代码</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020-2022 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0(the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http:  // www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">graphdata.py supports loading graph dataset for GNN network training,</span>
<span class="sd">and provides operations related to graph data.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">atexit</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">IntEnum</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mindspore._c_dataengine</span> <span class="kn">import</span> <span class="n">GraphDataClient</span>
<span class="kn">from</span> <span class="nn">mindspore._c_dataengine</span> <span class="kn">import</span> <span class="n">GraphDataServer</span>
<span class="kn">from</span> <span class="nn">mindspore._c_dataengine</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">mindspore._c_dataengine</span> <span class="kn">import</span> <span class="n">SamplingStrategy</span> <span class="k">as</span> <span class="n">Sampling</span>
<span class="kn">from</span> <span class="nn">mindspore._c_dataengine</span> <span class="kn">import</span> <span class="n">OutputFormat</span> <span class="k">as</span> <span class="n">Format</span>

<span class="kn">from</span> <span class="nn">.validators</span> <span class="kn">import</span> <span class="n">check_gnn_graphdata</span><span class="p">,</span> <span class="n">check_gnn_get_all_nodes</span><span class="p">,</span> <span class="n">check_gnn_get_all_edges</span><span class="p">,</span> \
    <span class="n">check_gnn_get_nodes_from_edges</span><span class="p">,</span> <span class="n">check_gnn_get_edges_from_nodes</span><span class="p">,</span> <span class="n">check_gnn_get_all_neighbors</span><span class="p">,</span> \
    <span class="n">check_gnn_get_sampled_neighbors</span><span class="p">,</span> <span class="n">check_gnn_get_neg_sampled_neighbors</span><span class="p">,</span> <span class="n">check_gnn_get_node_feature</span><span class="p">,</span> \
    <span class="n">check_gnn_get_edge_feature</span><span class="p">,</span> <span class="n">check_gnn_random_walk</span><span class="p">,</span> <span class="n">check_gnn_graph</span><span class="p">,</span> <span class="n">check_gnn_get_graph_feature</span>
<span class="kn">from</span> <span class="nn">..core.validator_helpers</span> <span class="kn">import</span> <span class="n">replace_none</span>
<span class="kn">from</span> <span class="nn">.datasets_user_defined</span> <span class="kn">import</span> <span class="n">GeneratorDataset</span>


<div class="viewcode-block" id="SamplingStrategy"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.SamplingStrategy.html#mindspore.dataset.SamplingStrategy">[文档]</a><span class="k">class</span> <span class="nc">SamplingStrategy</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specifies the sampling strategy when execute `get_sampled_neighbors` .</span>

<span class="sd">    - RANDOM: Random sampling with replacement.</span>
<span class="sd">    - EDGE_WEIGHT: Sampling with edge weight as probability.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">RANDOM</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">EDGE_WEIGHT</span> <span class="o">=</span> <span class="mi">1</span></div>


<span class="n">DE_C_INTER_SAMPLING_STRATEGY</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">SamplingStrategy</span><span class="o">.</span><span class="n">RANDOM</span><span class="p">:</span> <span class="n">Sampling</span><span class="o">.</span><span class="n">DE_SAMPLING_RANDOM</span><span class="p">,</span>
    <span class="n">SamplingStrategy</span><span class="o">.</span><span class="n">EDGE_WEIGHT</span><span class="p">:</span> <span class="n">Sampling</span><span class="o">.</span><span class="n">DE_SAMPLING_EDGE_WEIGHT</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="OutputFormat"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.OutputFormat.html#mindspore.dataset.OutputFormat">[文档]</a><span class="k">class</span> <span class="nc">OutputFormat</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specifies the output storage format when execute `get_all_neighbors` .</span>

<span class="sd">    - NORMAL: Normal format.</span>
<span class="sd">    - COO: COO format.</span>
<span class="sd">    - CSR: CSR format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NORMAL</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">COO</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">CSR</span> <span class="o">=</span> <span class="mi">2</span></div>


<span class="n">DE_C_INTER_OUTPUT_FORMAT</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">OutputFormat</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">:</span> <span class="n">Format</span><span class="o">.</span><span class="n">DE_FORMAT_NORMAL</span><span class="p">,</span>
    <span class="n">OutputFormat</span><span class="o">.</span><span class="n">COO</span><span class="p">:</span> <span class="n">Format</span><span class="o">.</span><span class="n">DE_FORMAT_COO</span><span class="p">,</span>
    <span class="n">OutputFormat</span><span class="o">.</span><span class="n">CSR</span><span class="p">:</span> <span class="n">Format</span><span class="o">.</span><span class="n">DE_FORMAT_CSR</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="GraphData"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData">[文档]</a><span class="k">class</span> <span class="nc">GraphData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads the graph dataset used for GNN training from the shared file and database.</span>
<span class="sd">    Support reading graph datasets like Cora, Citeseer and PubMed.</span>

<span class="sd">    About how to load raw graph dataset into MindSpore please</span>
<span class="sd">    refer to `Loading Graph Dataset &lt;https://www.mindspore.cn/tutorials/en/</span>
<span class="sd">    r2.0/advanced/dataset/augment_graph_data.html&gt;`_ .</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_file (str): One of file names in the dataset.</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to process the dataset in parallel.</span>
<span class="sd">            Default: None.</span>
<span class="sd">        working_mode (str, optional): Set working mode, now supports &#39;local&#39;/&#39;client&#39;/&#39;server&#39;. Default: &#39;local&#39;.</span>

<span class="sd">            - &#39;local&#39;, used in non-distributed training scenarios.</span>

<span class="sd">            - &#39;client&#39;, used in distributed training scenarios. The client does not load data,</span>
<span class="sd">              but obtains data from the server.</span>

<span class="sd">            - &#39;server&#39;, used in distributed training scenarios. The server loads the data</span>
<span class="sd">              and is available to the client.</span>

<span class="sd">        hostname (str, optional): Hostname of the graph data server. This parameter is only valid when</span>
<span class="sd">            `working_mode` is set to &#39;client&#39; or &#39;server&#39;. Default: &#39;127.0.0.1&#39;.</span>
<span class="sd">        port (int, optional): Port of the graph data server. The range is 1024-65535. This parameter is</span>
<span class="sd">            only valid when `working_mode` is set to &#39;client&#39; or &#39;server&#39;. Default: 50051.</span>
<span class="sd">        num_client (int, optional): Maximum number of clients expected to connect to the server. The server will</span>
<span class="sd">            allocate resources according to this parameter. This parameter is only valid when `working_mode`</span>
<span class="sd">            is set to &#39;server&#39;. Default: 1.</span>
<span class="sd">        auto_shutdown (bool, optional): Valid when `working_mode` is set to &#39;server&#39;,</span>
<span class="sd">            when the number of connected clients reaches `num_client` and no client is being connected,</span>
<span class="sd">            the server automatically exits. Default: True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `dataset_file` does not exist or permission denied.</span>
<span class="sd">        ValueError: If `num_parallel_workers` exceeds the max thread numbers.</span>
<span class="sd">        ValueError: If `working_mode` is not &#39;local&#39;, &#39;client&#39; or &#39;server&#39;.</span>
<span class="sd">        TypeError: If `hostname` is illegal.</span>
<span class="sd">        ValueError: If `port` is not in range [1024, 65535].</span>
<span class="sd">        ValueError: If `num_client` is not in range [1, 255].</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; graph_dataset_dir = &quot;/path/to/graph_dataset_file&quot;</span>
<span class="sd">        &gt;&gt;&gt; graph_data = ds.GraphData(dataset_file=graph_dataset_dir, num_parallel_workers=2)</span>
<span class="sd">        &gt;&gt;&gt; nodes = graph_data.get_all_nodes(node_type=1)</span>
<span class="sd">        &gt;&gt;&gt; features = graph_data.get_node_feature(node_list=nodes, feature_types=[1])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_gnn_graphdata</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_file</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">working_mode</span><span class="o">=</span><span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="n">hostname</span><span class="o">=</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">50051</span><span class="p">,</span>
                 <span class="n">num_client</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">auto_shutdown</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_file</span> <span class="o">=</span> <span class="n">dataset_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">=</span> <span class="n">working_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_format</span> <span class="o">=</span> <span class="s2">&quot;mindrecord&quot;</span>
        <span class="k">if</span> <span class="n">num_parallel_workers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">working_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="s1">&#39;client&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span> <span class="o">=</span> <span class="n">GraphDataClient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_format</span><span class="p">,</span> <span class="n">dataset_file</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">working_mode</span><span class="p">,</span>
                                               <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
            <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span> <span class="o">=</span> <span class="n">GraphDataServer</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_format</span><span class="p">,</span> <span class="n">dataset_file</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">num_client</span><span class="p">,</span> <span class="n">auto_shutdown</span><span class="p">)</span>
            <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">is_stopped</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Graph data server receives KeyboardInterrupt.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GraphData.get_all_nodes"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_all_nodes">[文档]</a>    <span class="nd">@check_gnn_get_all_nodes</span>
    <span class="k">def</span> <span class="nf">get_all_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all nodes in the graph.</span>

<span class="sd">        Args:</span>
<span class="sd">            node_type (int): Specify the type of node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of nodes.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph_data.get_all_nodes(node_type=1)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_type` is not integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_all_nodes</span><span class="p">(</span><span class="n">node_type</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="GraphData.get_all_edges"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_all_edges">[文档]</a>    <span class="nd">@check_gnn_get_all_edges</span>
    <span class="k">def</span> <span class="nf">get_all_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all edges in the graph.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_type (int): Specify the type of edge.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of edges.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; edges = graph_data.get_all_edges(edge_type=0)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `edge_type` is not integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_all_edges</span><span class="p">(</span><span class="n">edge_type</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="GraphData.get_nodes_from_edges"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_nodes_from_edges">[文档]</a>    <span class="nd">@check_gnn_get_nodes_from_edges</span>
    <span class="k">def</span> <span class="nf">get_nodes_from_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get nodes from the edges.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_list (Union[list, numpy.ndarray]): The given list of edges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of nodes.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore.dataset import GraphData</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; g = ds.GraphData(&quot;/path/to/testdata&quot;, 1)</span>
<span class="sd">            &gt;&gt;&gt; edges = g.get_all_edges(0)</span>
<span class="sd">            &gt;&gt;&gt; nodes = g.get_nodes_from_edges(edges)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `edge_list` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_nodes_from_edges</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="GraphData.get_edges_from_nodes"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_edges_from_nodes">[文档]</a>    <span class="nd">@check_gnn_get_edges_from_nodes</span>
    <span class="k">def</span> <span class="nf">get_edges_from_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get edges from the nodes.</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list[tuple], numpy.ndarray]): The given list of pair nodes ID.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of edges ID.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; edges = graph_data.get_edges_from_nodes(node_list=[(101, 201), (103, 207)])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `edge_list` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_edges_from_nodes</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="GraphData.get_all_neighbors"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_all_neighbors">[文档]</a>    <span class="nd">@check_gnn_get_all_neighbors</span>
    <span class="k">def</span> <span class="nf">get_all_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">neighbor_type</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="n">OutputFormat</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `neighbor_type` neighbors of the nodes in `node_list` .</span>
<span class="sd">        We try to use the following example to illustrate the definition of these formats. 1 represents connected</span>
<span class="sd">        between two nodes, and 0 represents not connected.</span>

<span class="sd">        .. list-table:: Adjacent Matrix</span>
<span class="sd">           :widths: 20 20 20 20 20</span>
<span class="sd">           :header-rows: 1</span>

<span class="sd">           * -</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 3</span>
<span class="sd">           * - 0</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>
<span class="sd">           * - 1</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 0</span>
<span class="sd">           * - 2</span>
<span class="sd">             - 1</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">           * - 3</span>
<span class="sd">             - 1</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>

<span class="sd">        .. list-table:: Normal Format</span>
<span class="sd">           :widths: 20 20 20 20 20</span>
<span class="sd">           :header-rows: 1</span>

<span class="sd">           * - src</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 3</span>
<span class="sd">           * - dst_0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">           * - dst_1</span>
<span class="sd">             - -1</span>
<span class="sd">             - -1</span>
<span class="sd">             - 3</span>
<span class="sd">             - -1</span>

<span class="sd">        .. list-table:: COO Format</span>
<span class="sd">           :widths: 20 20 20 20 20 20</span>
<span class="sd">           :header-rows: 1</span>

<span class="sd">           * - src</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 2</span>
<span class="sd">             - 3</span>
<span class="sd">           * - dst</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 0</span>
<span class="sd">             - 3</span>
<span class="sd">             - 1</span>

<span class="sd">        .. list-table:: CSR Format</span>
<span class="sd">           :widths: 40 20 20 20 20 20</span>
<span class="sd">           :header-rows: 1</span>

<span class="sd">           * - offsetTable</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 4</span>
<span class="sd">             -</span>
<span class="sd">           * - dstTable</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 0</span>
<span class="sd">             - 3</span>
<span class="sd">             - 1</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list, numpy.ndarray]): The given list of nodes.</span>
<span class="sd">            neighbor_type (int): Specify the type of neighbor node.</span>
<span class="sd">            output_format (OutputFormat, optional): Output storage format. Default: OutputFormat.NORMAL.</span>
<span class="sd">                It can be any of [OutputFormat.NORMAL, OutputFormat.COO, OutputFormat.CSR].</span>

<span class="sd">        Returns:</span>
<span class="sd">            For NORMAL format or COO format</span>
<span class="sd">            numpy.ndarray which represents the array of neighbors will return.</span>
<span class="sd">            As if CSR format is specified, two numpy.ndarrays will return.</span>
<span class="sd">            The first one is offset table, the second one is neighbors</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore.dataset.engine import OutputFormat</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph_data.get_all_nodes(node_type=1)</span>
<span class="sd">            &gt;&gt;&gt; neighbors = graph_data.get_all_neighbors(node_list=nodes, neighbor_type=2)</span>
<span class="sd">            &gt;&gt;&gt; neighbors_coo = graph_data.get_all_neighbors(node_list=nodes, neighbor_type=2,</span>
<span class="sd">            ...                                              output_format=OutputFormat.COO)</span>
<span class="sd">            &gt;&gt;&gt; offset_table, neighbors_csr = graph_data.get_all_neighbors(node_list=nodes, neighbor_type=2,</span>
<span class="sd">            ...                                                            output_format=OutputFormat.CSR)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `neighbor_type` is not integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="n">result_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_all_neighbors</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">neighbor_type</span><span class="p">,</span>
                                                         <span class="n">DE_C_INTER_OUTPUT_FORMAT</span><span class="p">[</span><span class="n">output_format</span><span class="p">])</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">output_format</span> <span class="o">==</span> <span class="n">OutputFormat</span><span class="o">.</span><span class="n">CSR</span><span class="p">:</span>
            <span class="n">offset_table</span> <span class="o">=</span> <span class="n">result_list</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)]</span>
            <span class="n">neighbor_table</span> <span class="o">=</span> <span class="n">result_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">):]</span>
            <span class="k">return</span> <span class="n">offset_table</span><span class="p">,</span> <span class="n">neighbor_table</span>
        <span class="k">return</span> <span class="n">result_list</span></div>

<div class="viewcode-block" id="GraphData.get_sampled_neighbors"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_sampled_neighbors">[文档]</a>    <span class="nd">@check_gnn_get_sampled_neighbors</span>
    <span class="k">def</span> <span class="nf">get_sampled_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">neighbor_nums</span><span class="p">,</span> <span class="n">neighbor_types</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">SamplingStrategy</span><span class="o">.</span><span class="n">RANDOM</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get sampled neighbor information.</span>

<span class="sd">        The api supports multi-hop neighbor sampling. That is, the previous sampling result is used as the input of</span>
<span class="sd">        next-hop sampling. A maximum of 6-hop are allowed.</span>

<span class="sd">        The sampling result is tiled into a list in the format of [input node, 1-hop sampling result,</span>
<span class="sd">        2-hop sampling result ...].</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list, numpy.ndarray]): The given list of nodes.</span>
<span class="sd">            neighbor_nums (Union[list, numpy.ndarray]): Number of neighbors sampled per hop.</span>
<span class="sd">            neighbor_types (Union[list, numpy.ndarray]): Neighbor type sampled per hop, type of each element in</span>
<span class="sd">                neighbor_types should be int.</span>
<span class="sd">            strategy (SamplingStrategy, optional): Sampling strategy. Default: SamplingStrategy.RANDOM.</span>
<span class="sd">                It can be any of [SamplingStrategy.RANDOM, SamplingStrategy.EDGE_WEIGHT].</span>

<span class="sd">                - SamplingStrategy.RANDOM, random sampling with replacement.</span>
<span class="sd">                - SamplingStrategy.EDGE_WEIGHT, sampling with edge weight as probability.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of neighbors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph_data.get_all_nodes(node_type=1)</span>
<span class="sd">            &gt;&gt;&gt; neighbors = graph_data.get_sampled_neighbors(node_list=nodes, neighbor_nums=[2, 2],</span>
<span class="sd">            ...                                              neighbor_types=[2, 1])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `neighbor_nums` is not list or ndarray.</span>
<span class="sd">            TypeError: If `neighbor_types` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">SamplingStrategy</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong input type for strategy, should be enum of &#39;SamplingStrategy&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_sampled_neighbors</span><span class="p">(</span>
            <span class="n">node_list</span><span class="p">,</span> <span class="n">neighbor_nums</span><span class="p">,</span> <span class="n">neighbor_types</span><span class="p">,</span> <span class="n">DE_C_INTER_SAMPLING_STRATEGY</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">strategy</span><span class="p">))</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="GraphData.get_neg_sampled_neighbors"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_neg_sampled_neighbors">[文档]</a>    <span class="nd">@check_gnn_get_neg_sampled_neighbors</span>
    <span class="k">def</span> <span class="nf">get_neg_sampled_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">neg_neighbor_num</span><span class="p">,</span> <span class="n">neg_neighbor_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `neg_neighbor_type` negative sampled neighbors of the nodes in `node_list` .</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list, numpy.ndarray]): The given list of nodes.</span>
<span class="sd">            neg_neighbor_num (int): Number of neighbors sampled.</span>
<span class="sd">            neg_neighbor_type (int): Specify the type of negative neighbor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of neighbors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph_data.get_all_nodes(node_type=1)</span>
<span class="sd">            &gt;&gt;&gt; neg_neighbors = graph_data.get_neg_sampled_neighbors(node_list=nodes, neg_neighbor_num=5,</span>
<span class="sd">            ...                                                      neg_neighbor_type=2)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `neg_neighbor_num` is not integer.</span>
<span class="sd">            TypeError: If `neg_neighbor_type` is not integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_neg_sampled_neighbors</span><span class="p">(</span>
            <span class="n">node_list</span><span class="p">,</span> <span class="n">neg_neighbor_num</span><span class="p">,</span> <span class="n">neg_neighbor_type</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="GraphData.get_node_feature"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_node_feature">[文档]</a>    <span class="nd">@check_gnn_get_node_feature</span>
    <span class="k">def</span> <span class="nf">get_node_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">feature_types</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `feature_types` feature of the nodes in `node_list` .</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list, numpy.ndarray]): The given list of nodes.</span>
<span class="sd">            feature_types (Union[list, numpy.ndarray]): The given list of feature types.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of features.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph_data.get_all_nodes(node_type=1)</span>
<span class="sd">            &gt;&gt;&gt; features = graph_data.get_node_feature(node_list=nodes, feature_types=[2, 3])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `feature_types` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">node_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">t</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_node_feature</span><span class="p">(</span>
                <span class="n">Tensor</span><span class="p">(</span><span class="n">node_list</span><span class="p">),</span>
                <span class="n">feature_types</span><span class="p">)]</span></div>

<div class="viewcode-block" id="GraphData.get_edge_feature"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.get_edge_feature">[文档]</a>    <span class="nd">@check_gnn_get_edge_feature</span>
    <span class="k">def</span> <span class="nf">get_edge_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">,</span> <span class="n">feature_types</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `feature_types` feature of the edges in `edge_list` .</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_list (Union[list, numpy.ndarray]): The given list of edges.</span>
<span class="sd">            feature_types (Union[list, numpy.ndarray]): The given list of feature types.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of features.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; edges = graph_data.get_all_edges(edge_type=0)</span>
<span class="sd">            &gt;&gt;&gt; features = graph_data.get_edge_feature(edge_list=edges, feature_types=[1])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `edge_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `feature_types` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">t</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_edge_feature</span><span class="p">(</span>
                <span class="n">Tensor</span><span class="p">(</span><span class="n">edge_list</span><span class="p">),</span>
                <span class="n">feature_types</span><span class="p">)]</span></div>

<div class="viewcode-block" id="GraphData.graph_info"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.graph_info">[文档]</a>    <span class="k">def</span> <span class="nf">graph_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the meta information of the graph, including the number of nodes, the type of nodes,</span>
<span class="sd">        the feature information of nodes, the number of edges, the type of edges, and the feature information of edges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict, meta information of the graph. The key is node_type, edge_type, node_num, edge_num,</span>
<span class="sd">            node_feature_type and edge_feature_type.</span>

<span class="sd">        Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset import GraphData</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; g = ds.GraphData(&quot;/path/to/testdata&quot;, 2)</span>
<span class="sd">        &gt;&gt;&gt; graph_info = g.graph_info()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">graph_info</span><span class="p">()</span></div>

<div class="viewcode-block" id="GraphData.random_walk"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.GraphData.html#mindspore.dataset.GraphData.random_walk">[文档]</a>    <span class="nd">@check_gnn_random_walk</span>
    <span class="k">def</span> <span class="nf">random_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">,</span> <span class="n">meta_path</span><span class="p">,</span> <span class="n">step_home_param</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">step_away_param</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">default_node</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Random walk in nodes.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_nodes (list[int]): Start node list in random walk</span>
<span class="sd">            meta_path (list[int]): node type for each walk step</span>
<span class="sd">            step_home_param (float, optional): return hyper parameter in node2vec algorithm. Default: 1.0.</span>
<span class="sd">            step_away_param (float, optional): in out hyper parameter in node2vec algorithm. Default: 1.0.</span>
<span class="sd">            default_node (int, optional): default node if no more neighbors found. Default: -1.</span>
<span class="sd">                A default value of -1 indicates that no node is given.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of nodes.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph_data.get_all_nodes(node_type=1)</span>
<span class="sd">            &gt;&gt;&gt; walks = graph_data.random_walk(target_nodes=nodes, meta_path=[2, 1, 2])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `target_nodes` is not list or ndarray.</span>
<span class="sd">            TypeError: If `meta_path` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">random_walk</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">,</span> <span class="n">meta_path</span><span class="p">,</span> <span class="n">step_home_param</span><span class="p">,</span> <span class="n">step_away_param</span><span class="p">,</span>
                                            <span class="n">default_node</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stop GraphDataClient or GraphDataServer.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span></div>


<div class="viewcode-block" id="Graph"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph">[文档]</a><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">GraphData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A graph object for storing Graph structure and feature data, and provide capabilities such as graph sampling.</span>

<span class="sd">    This class supports init graph With input numpy array data, which represent node, edge and its features.</span>
<span class="sd">    If working mode is `local` , there is no need to specify input arguments like `working_mode` , `hostname` , `port` ,</span>
<span class="sd">    `num_client` , `auto_shutdown` .</span>

<span class="sd">    Args:</span>
<span class="sd">        edges(Union[list, numpy.ndarray]): edges of graph in COO format with shape [2, num_edges].</span>
<span class="sd">        node_feat(dict, optional): feature of nodes, input data format should be dict, key is feature type, which is</span>
<span class="sd">            represented with string like &#39;weight&#39; etc, value should be numpy.array with shape</span>
<span class="sd">            [num_nodes, num_node_features].</span>
<span class="sd">        edge_feat(dict, optional): feature of edges, input data format should be dict, key is feature type, which is</span>
<span class="sd">            represented with string like &#39;weight&#39; etc, value should be numpy.array with shape</span>
<span class="sd">            [num_edges, num_edge_features].</span>
<span class="sd">        graph_feat(dict, optional): additional feature, which can not be assigned to node_feat or edge_feat, input data</span>
<span class="sd">            format should be dict, key is feature type, which is represented with string, value should be numpy.array,</span>
<span class="sd">            its shape is not restricted.</span>
<span class="sd">        node_type(Union[list, numpy.ndarray], optional): type of nodes, each element should be string which represent</span>
<span class="sd">            type of corresponding node. If not provided, default type for each node is &quot;0&quot;.</span>
<span class="sd">        edge_type(Union[list, numpy.ndarray], optional): type of edges, each element should be string which represent</span>
<span class="sd">            type of corresponding edge. If not provided, default type for each edge is &quot;0&quot;.</span>
<span class="sd">        num_parallel_workers (int, optional): Number of workers to process the dataset in parallel. Default: None.</span>
<span class="sd">        working_mode (str, optional): Set working mode, now supports &#39;local&#39;/&#39;client&#39;/&#39;server&#39;. Default: &#39;local&#39;.</span>

<span class="sd">            - &#39;local&#39;, used in non-distributed training scenarios.</span>

<span class="sd">            - &#39;client&#39;, used in distributed training scenarios. The client does not load data,</span>
<span class="sd">              but obtains data from the server.</span>

<span class="sd">            - &#39;server&#39;, used in distributed training scenarios. The server loads the data</span>
<span class="sd">              and is available to the client.</span>

<span class="sd">        hostname (str, optional): Hostname of the graph data server. This parameter is only valid when</span>
<span class="sd">            `working_mode` is set to &#39;client&#39; or &#39;server&#39;. Default: &#39;127.0.0.1&#39;.</span>
<span class="sd">        port (int, optional): Port of the graph data server. The range is 1024-65535. This parameter is</span>
<span class="sd">            only valid when `working_mode` is set to &#39;client&#39; or &#39;server&#39;. Default: 50051.</span>
<span class="sd">        num_client (int, optional): Maximum number of clients expected to connect to the server. The server will</span>
<span class="sd">            allocate resources according to this parameter. This parameter is only valid when `working_mode`</span>
<span class="sd">            is set to &#39;server&#39;. Default: 1.</span>
<span class="sd">        auto_shutdown (bool, optional): Valid when `working_mode` is set to &#39;server&#39;,</span>
<span class="sd">            when the number of connected clients reaches `num_client` and no client is being connected,</span>
<span class="sd">            the server automatically exits. Default: True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `edges` not list or NumPy array.</span>
<span class="sd">        TypeError: If `node_feat` provided but not dict, or key in dict is not string type, or value in dict not NumPy</span>
<span class="sd">            array.</span>
<span class="sd">        TypeError: If `edge_feat` provided but not dict, or key in dict is not string type, or value in dict not NumPy</span>
<span class="sd">            array.</span>
<span class="sd">        TypeError: If `graph_feat` provided but not dict, or key in dict is not string type, or value in dict not NumPy</span>
<span class="sd">            array.</span>
<span class="sd">        TypeError: If `node_type` provided but its type not list or NumPy array.</span>
<span class="sd">        TypeError: If `edge_type` provided but its type not list or NumPy array.</span>
<span class="sd">        ValueError: If `num_parallel_workers` exceeds the max thread numbers.</span>
<span class="sd">        ValueError: If `working_mode` is not &#39;local&#39;, &#39;client&#39; or &#39;server&#39;.</span>
<span class="sd">        TypeError: If `hostname` is illegal.</span>
<span class="sd">        ValueError: If `port` is not in range [1024, 65535].</span>
<span class="sd">        ValueError: If `num_client` is not in range [1, 255].</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset import Graph</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # 1) Only provide edges for creating graph, as this is the only required input parameter</span>
<span class="sd">        &gt;&gt;&gt; edges = np.array([[1, 2], [0, 1]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; graph = Graph(edges)</span>
<span class="sd">        &gt;&gt;&gt; graph_info = graph.graph_info()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # 2) Setting node_feat and edge_feat for corresponding node and edge</span>
<span class="sd">        &gt;&gt;&gt; #    first dimension of feature shape should be corresponding node num or edge num.</span>
<span class="sd">        &gt;&gt;&gt; edges = np.array([[1, 2], [0, 1]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; node_feat = {&quot;node_feature_1&quot;: np.array([[0], [1], [2]], dtype=np.int32)}</span>
<span class="sd">        &gt;&gt;&gt; edge_feat = {&quot;edge_feature_1&quot;: np.array([[1, 2], [3, 4]], dtype=np.int32)}</span>
<span class="sd">        &gt;&gt;&gt; graph = Graph(edges, node_feat, edge_feat)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # 3) Setting graph feature for graph, there is no shape limit for graph feature</span>
<span class="sd">        &gt;&gt;&gt; edges = np.array([[1, 2], [0, 1]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; graph_feature = {&quot;graph_feature_1&quot;: np.array([1, 2, 3, 4, 5, 6], dtype=np.int32)}</span>
<span class="sd">        &gt;&gt;&gt; graph = Graph(edges, graph_feat=graph_feature)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@check_gnn_graph</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">node_feat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_feat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">graph_feat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_parallel_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">working_mode</span><span class="o">=</span><span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="n">hostname</span><span class="o">=</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">50051</span><span class="p">,</span> <span class="n">num_client</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">auto_shutdown</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">node_feat</span> <span class="o">=</span> <span class="n">replace_none</span><span class="p">(</span><span class="n">node_feat</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">edge_feat</span> <span class="o">=</span> <span class="n">replace_none</span><span class="p">(</span><span class="n">edge_feat</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">graph_feat</span> <span class="o">=</span> <span class="n">replace_none</span><span class="p">(</span><span class="n">graph_feat</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># infer num_nodes</span>
        <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">node_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">node_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">node_type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">num_nodes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Input &#39;node_type&#39; should be of 1 dimension, and its length should be </span><span class="si">{}</span><span class="s2">, but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">num_nodes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_type</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;0&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span><span class="p">)</span>

        <span class="n">edge_type</span> <span class="o">=</span> <span class="n">replace_none</span><span class="p">(</span><span class="n">edge_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;0&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">edge_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edge_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">=</span> <span class="n">working_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_format</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_type_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_feature_type_mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_feature_type_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_feature_type_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_node_type_mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_edge_type_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_node_feature_type_mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_edge_feature_type_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_graph_feature_type_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">node_feat</span><span class="p">,</span> <span class="n">edge_feat</span><span class="p">,</span> <span class="n">graph_feat</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">edge_type</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_replace_string</span><span class="p">(</span><span class="n">node_feat</span><span class="p">,</span> <span class="n">edge_feat</span><span class="p">,</span> <span class="n">graph_feat</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_parallel_workers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_parallel_workers</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">working_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="s1">&#39;client&#39;</span><span class="p">]:</span>
            <span class="c1"># GraphDataClient should support different init way, as data might be different</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span> <span class="o">=</span> <span class="n">GraphDataClient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_format</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">node_feat</span><span class="p">,</span> <span class="n">edge_feat</span><span class="p">,</span> <span class="n">graph_feat</span><span class="p">,</span>
                                               <span class="n">node_type</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">working_mode</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span>
                                               <span class="n">port</span><span class="p">)</span>
            <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span> <span class="o">=</span> <span class="n">GraphDataServer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_format</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">node_feat</span><span class="p">,</span> <span class="n">edge_feat</span><span class="p">,</span> <span class="n">graph_feat</span><span class="p">,</span>
                                               <span class="n">node_type</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">num_client</span><span class="p">,</span>
                                               <span class="n">auto_shutdown</span><span class="p">)</span>
            <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">is_stopped</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Graph data server receives KeyboardInterrupt.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.get_all_nodes"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.get_all_nodes">[文档]</a>    <span class="nd">@check_gnn_get_all_nodes</span>
    <span class="k">def</span> <span class="nf">get_all_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all nodes in the graph.</span>

<span class="sd">        Args:</span>
<span class="sd">            node_type (str): Specify the type of node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of nodes.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph.get_all_nodes(node_type=&quot;0&quot;)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_type` is not string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given node type </span><span class="si">{}</span><span class="s2"> is not exist in graph, existed is: </span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="n">node_int_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">[</span><span class="n">node_type</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_all_nodes</span><span class="p">(</span><span class="n">node_int_type</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.get_all_edges"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.get_all_edges">[文档]</a>    <span class="nd">@check_gnn_get_all_edges</span>
    <span class="k">def</span> <span class="nf">get_all_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all edges in the graph.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_type (str): Specify the type of edge, default edge_type is &quot;0&quot; when init graph without specify</span>
<span class="sd">                edge_type.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of edges.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; edges = graph.get_all_edges(edge_type=&quot;0&quot;)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `edge_type` is not string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edge_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_type_mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given node type </span><span class="si">{}</span><span class="s2"> is not exist in graph, existed is: </span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="n">edge_int_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">[</span><span class="n">edge_type</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_all_edges</span><span class="p">(</span><span class="n">edge_int_type</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.get_all_neighbors"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.get_all_neighbors">[文档]</a>    <span class="nd">@check_gnn_get_all_neighbors</span>
    <span class="k">def</span> <span class="nf">get_all_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">neighbor_type</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="n">OutputFormat</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `neighbor_type` neighbors of the nodes in `node_list` .</span>
<span class="sd">        We try to use the following example to illustrate the definition of these formats. 1 represents connected</span>
<span class="sd">        between two nodes, and 0 represents not connected.</span>

<span class="sd">        .. list-table:: Adjacent Matrix</span>
<span class="sd">           :widths: 20 20 20 20 20</span>
<span class="sd">           :header-rows: 1</span>

<span class="sd">           * -</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 3</span>
<span class="sd">           * - 0</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>
<span class="sd">           * - 1</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 0</span>
<span class="sd">           * - 2</span>
<span class="sd">             - 1</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">           * - 3</span>
<span class="sd">             - 1</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>
<span class="sd">             - 0</span>

<span class="sd">        .. list-table:: Normal Format</span>
<span class="sd">           :widths: 20 20 20 20 20</span>
<span class="sd">           :header-rows: 1</span>

<span class="sd">           * - src</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 3</span>
<span class="sd">           * - dst_0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">           * - dst_1</span>
<span class="sd">             - -1</span>
<span class="sd">             - -1</span>
<span class="sd">             - 3</span>
<span class="sd">             - -1</span>

<span class="sd">        .. list-table:: COO Format</span>
<span class="sd">           :widths: 20 20 20 20 20 20</span>
<span class="sd">           :header-rows: 1</span>

<span class="sd">           * - src</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 2</span>
<span class="sd">             - 3</span>
<span class="sd">           * - dst</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 0</span>
<span class="sd">             - 3</span>
<span class="sd">             - 1</span>

<span class="sd">        .. list-table:: CSR Format</span>
<span class="sd">           :widths: 40 20 20 20 20 20</span>
<span class="sd">           :header-rows: 1</span>

<span class="sd">           * - offsetTable</span>
<span class="sd">             - 0</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 4</span>
<span class="sd">             -</span>
<span class="sd">           * - dstTable</span>
<span class="sd">             - 1</span>
<span class="sd">             - 2</span>
<span class="sd">             - 0</span>
<span class="sd">             - 3</span>
<span class="sd">             - 1</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list, numpy.ndarray]): The given list of nodes.</span>
<span class="sd">            neighbor_type (str): Specify the type of neighbor node.</span>
<span class="sd">            output_format (OutputFormat, optional): Output storage format. Default: OutputFormat.NORMAL.</span>
<span class="sd">                It can be any of [OutputFormat.NORMAL, OutputFormat.COO, OutputFormat.CSR].</span>

<span class="sd">        Returns:</span>
<span class="sd">            For NORMAL format or COO format</span>
<span class="sd">            numpy.ndarray which represents the array of neighbors will return.</span>
<span class="sd">            As if CSR format is specified, two numpy.ndarrays will return.</span>
<span class="sd">            The first one is offset table, the second one is neighbors</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindspore.dataset.engine import OutputFormat</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph.get_all_nodes(node_type=&quot;0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; neighbors = graph.get_all_neighbors(node_list=nodes, neighbor_type=&quot;0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; neighbors_coo = graph.get_all_neighbors(node_list=nodes, neighbor_type=&quot;0&quot;,</span>
<span class="sd">            ...                                         output_format=OutputFormat.COO)</span>
<span class="sd">            &gt;&gt;&gt; offset_table, neighbors_csr = graph.get_all_neighbors(node_list=nodes, neighbor_type=&quot;0&quot;,</span>
<span class="sd">            ...                                                       output_format=OutputFormat.CSR)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `neighbor_type` is not string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">neighbor_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given neighbor node type </span><span class="si">{}</span><span class="s2"> is not exist in graph, existed is: </span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">neighbor_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="n">neighbor_int_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">[</span><span class="n">neighbor_type</span><span class="p">]</span>
        <span class="n">result_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_all_neighbors</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">neighbor_int_type</span><span class="p">,</span>
                                                         <span class="n">DE_C_INTER_OUTPUT_FORMAT</span><span class="p">[</span><span class="n">output_format</span><span class="p">])</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">output_format</span> <span class="o">==</span> <span class="n">OutputFormat</span><span class="o">.</span><span class="n">CSR</span><span class="p">:</span>
            <span class="n">offset_table</span> <span class="o">=</span> <span class="n">result_list</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)]</span>
            <span class="n">neighbor_table</span> <span class="o">=</span> <span class="n">result_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">):]</span>
            <span class="k">return</span> <span class="n">offset_table</span><span class="p">,</span> <span class="n">neighbor_table</span>
        <span class="k">return</span> <span class="n">result_list</span></div>

<div class="viewcode-block" id="Graph.get_sampled_neighbors"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.get_sampled_neighbors">[文档]</a>    <span class="nd">@check_gnn_get_sampled_neighbors</span>
    <span class="k">def</span> <span class="nf">get_sampled_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">neighbor_nums</span><span class="p">,</span> <span class="n">neighbor_types</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">SamplingStrategy</span><span class="o">.</span><span class="n">RANDOM</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get sampled neighbor information.</span>

<span class="sd">        The api supports multi-hop neighbor sampling. That is, the previous sampling result is used as the input of</span>
<span class="sd">        next-hop sampling. A maximum of 6-hop are allowed.</span>

<span class="sd">        The sampling result is tiled into a list in the format of [input node, 1-hop sampling result,</span>
<span class="sd">        2-hop sampling result ...].</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list, numpy.ndarray]): The given list of nodes.</span>
<span class="sd">            neighbor_nums (Union[list, numpy.ndarray]): Number of neighbors sampled per hop.</span>
<span class="sd">            neighbor_types (Union[list, numpy.ndarray]): Neighbor type sampled per hop, type of each element in</span>
<span class="sd">                neighbor_types should be str.</span>
<span class="sd">            strategy (SamplingStrategy, optional): Sampling strategy. Default: SamplingStrategy.RANDOM.</span>
<span class="sd">                It can be any of [SamplingStrategy.RANDOM, SamplingStrategy.EDGE_WEIGHT].</span>

<span class="sd">                - SamplingStrategy.RANDOM, random sampling with replacement.</span>
<span class="sd">                - SamplingStrategy.EDGE_WEIGHT, sampling with edge weight as probability.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of neighbors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph.get_all_nodes(node_type=&quot;0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; neighbors = graph.get_sampled_neighbors(node_list=nodes, neighbor_nums=[2, 2],</span>
<span class="sd">            ...                                         neighbor_types=[&quot;0&quot;, &quot;0&quot;])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `neighbor_nums` is not list or ndarray.</span>
<span class="sd">            TypeError: If `neighbor_types` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">SamplingStrategy</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong input type for strategy, should be enum of &#39;SamplingStrategy&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>

        <span class="n">neighbor_int_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">neighbor_type</span> <span class="ow">in</span> <span class="n">neighbor_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neighbor_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given neighbor node type </span><span class="si">{}</span><span class="s2"> is not exist in graph, existed is: </span><span class="si">{}</span><span class="s2">.&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">neighbor_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="n">neighbor_int_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">[</span><span class="n">neighbor_type</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_sampled_neighbors</span><span class="p">(</span>
            <span class="n">node_list</span><span class="p">,</span> <span class="n">neighbor_nums</span><span class="p">,</span> <span class="n">neighbor_int_types</span><span class="p">,</span> <span class="n">DE_C_INTER_SAMPLING_STRATEGY</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">strategy</span><span class="p">))</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.get_neg_sampled_neighbors"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.get_neg_sampled_neighbors">[文档]</a>    <span class="nd">@check_gnn_get_neg_sampled_neighbors</span>
    <span class="k">def</span> <span class="nf">get_neg_sampled_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">neg_neighbor_num</span><span class="p">,</span> <span class="n">neg_neighbor_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `neg_neighbor_type` negative sampled neighbors of the nodes in `node_list` .</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list, numpy.ndarray]): The given list of nodes.</span>
<span class="sd">            neg_neighbor_num (int): Number of neighbors sampled.</span>
<span class="sd">            neg_neighbor_type (str): Specify the type of negative neighbor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of neighbors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph.get_all_nodes(node_type=&quot;0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; neg_neighbors = graph.get_neg_sampled_neighbors(node_list=nodes, neg_neighbor_num=3,</span>
<span class="sd">            ...                                                 neg_neighbor_type=&quot;0&quot;)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `neg_neighbor_num` is not integer.</span>
<span class="sd">            TypeError: If `neg_neighbor_type` is not string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">neg_neighbor_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given neighbor node type </span><span class="si">{}</span><span class="s2"> is not exist in graph, existed is: </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">neg_neighbor_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="n">neg_neighbor_int_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">[</span><span class="n">neg_neighbor_type</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_neg_sampled_neighbors</span><span class="p">(</span>
            <span class="n">node_list</span><span class="p">,</span> <span class="n">neg_neighbor_num</span><span class="p">,</span> <span class="n">neg_neighbor_int_type</span><span class="p">)</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.get_node_feature"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.get_node_feature">[文档]</a>    <span class="nd">@check_gnn_get_node_feature</span>
    <span class="k">def</span> <span class="nf">get_node_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">feature_types</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `feature_types` feature of the nodes in `node_list` .</span>

<span class="sd">        Args:</span>
<span class="sd">            node_list (Union[list, numpy.ndarray]): The given list of nodes.</span>
<span class="sd">            feature_types (Union[list, numpy.ndarray]): The given list of feature types, each element should be string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of features.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nodes = graph.get_all_nodes(node_type=&quot;0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; features = graph.get_node_feature(node_list=nodes, feature_types=[&quot;node_feature_1&quot;])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `node_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `feature_types` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>

        <span class="n">feature_int_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">feature_type</span> <span class="ow">in</span> <span class="n">feature_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">feature_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_feature_type_mapping</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given node feature type </span><span class="si">{}</span><span class="s2"> is not exist in graph, existed is: </span><span class="si">{}</span><span class="s2">.&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">feature_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_feature_type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="n">feature_int_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_feature_type_mapping</span><span class="p">[</span><span class="n">feature_type</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">node_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">t</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_node_feature</span><span class="p">(</span>
                <span class="n">Tensor</span><span class="p">(</span><span class="n">node_list</span><span class="p">),</span>
                <span class="n">feature_int_types</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Graph.get_edge_feature"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.get_edge_feature">[文档]</a>    <span class="nd">@check_gnn_get_edge_feature</span>
    <span class="k">def</span> <span class="nf">get_edge_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">,</span> <span class="n">feature_types</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `feature_types` feature of the edges in `edge_list` .</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_list (Union[list, numpy.ndarray]): The given list of edges.</span>
<span class="sd">            feature_types (Union[list, numpy.ndarray]): The given list of feature types, each element should be string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of features.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; edges = graph.get_all_edges(edge_type=&quot;0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; features = graph.get_edge_feature(edge_list=edges, feature_types=[&quot;edge_feature_1&quot;])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `edge_list` is not list or ndarray.</span>
<span class="sd">            TypeError: If `feature_types` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="n">feature_int_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">feature_type</span> <span class="ow">in</span> <span class="n">feature_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">feature_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_feature_type_mapping</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given edge feature type </span><span class="si">{}</span><span class="s2"> is not exist in graph, existed is: </span><span class="si">{}</span><span class="s2">.&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">feature_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_feature_type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="n">feature_int_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_feature_type_mapping</span><span class="p">[</span><span class="n">feature_type</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">t</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_edge_feature</span><span class="p">(</span>
                <span class="n">Tensor</span><span class="p">(</span><span class="n">edge_list</span><span class="p">),</span>
                <span class="n">feature_int_types</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Graph.get_graph_feature"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.get_graph_feature">[文档]</a>    <span class="nd">@check_gnn_get_graph_feature</span>
    <span class="k">def</span> <span class="nf">get_graph_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_types</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get `feature_types` feature that stored in Graph feature level.</span>

<span class="sd">        Args:</span>
<span class="sd">            feature_types (Union[list, numpy.ndarray]): The given list of feature types, each element should be string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, array of features.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; features = graph.get_graph_feature(feature_types=[&#39;graph_feature_1&#39;])</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `feature_types` is not list or ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;server&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>

        <span class="n">feature_int_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">feature_type</span> <span class="ow">in</span> <span class="n">feature_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">feature_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_feature_type_mapping</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given graph feature type </span><span class="si">{}</span><span class="s2"> is not exist in graph, existed is: </span><span class="si">{}</span><span class="s2">.&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">feature_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_feature_type_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="n">feature_int_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_feature_type_mapping</span><span class="p">[</span><span class="n">feature_type</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">get_graph_feature</span><span class="p">(</span><span class="n">feature_int_types</span><span class="p">)]</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_list</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert list data according to given mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_data</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert dict data according to given mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">new_data</span>

<div class="viewcode-block" id="Graph.graph_info"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.Graph.html#mindspore.dataset.Graph.graph_info">[文档]</a>    <span class="k">def</span> <span class="nf">graph_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the meta information of the graph, including the number of nodes, the type of nodes,</span>
<span class="sd">        the feature information of nodes, the number of edges, the type of edges, and the feature information of edges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict, meta information of the graph. The key is node_type, edge_type, node_num, edge_num,</span>
<span class="sd">            node_feature_type, edge_feature_type and graph_feature_type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_mode</span> <span class="o">==</span> <span class="s1">&#39;server&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This method is not supported when working mode is server.&quot;</span><span class="p">)</span>
        <span class="c1"># do type convert for node_type, edge_type, and other feature_type</span>
        <span class="n">raw_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_data</span><span class="o">.</span><span class="n">graph_info</span><span class="p">()</span>
        <span class="n">graph_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;node_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_list</span><span class="p">(</span><span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;node_type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_node_type_mapping</span><span class="p">)</span>
        <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;edge_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_list</span><span class="p">(</span><span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;edge_type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_edge_type_mapping</span><span class="p">)</span>
        <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;node_feature_type&quot;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_convert_list</span><span class="p">(</span><span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;node_feature_type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_node_feature_type_mapping</span><span class="p">)</span>
        <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;edge_feature_type&quot;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_convert_list</span><span class="p">(</span><span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;edge_feature_type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_edge_feature_type_mapping</span><span class="p">)</span>
        <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;graph_feature_type&quot;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_convert_list</span><span class="p">(</span><span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;graph_feature_type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_graph_feature_type_mapping</span><span class="p">)</span>
        <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;node_num&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dict</span><span class="p">(</span><span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;node_num&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_node_type_mapping</span><span class="p">)</span>
        <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;edge_num&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dict</span><span class="p">(</span><span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;edge_num&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_edge_type_mapping</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph_info</span></div>

    <span class="k">def</span> <span class="nf">_replace_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_feat</span><span class="p">,</span> <span class="n">edge_feat</span><span class="p">,</span> <span class="n">graph_feat</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        replace key in node_feat, edge_feat and graph_feat from string into int, and replace value in node_type and</span>
<span class="sd">        edge_type from string to int.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">replace_dict_key</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">new_feature</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">feature_type_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">feature</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_feature</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">feature_type_mapping</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">index</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">new_feature</span><span class="p">,</span> <span class="n">feature_type_mapping</span>

        <span class="k">def</span> <span class="nf">replace_value</span><span class="p">(</span><span class="n">data_type</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">feature_type_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">node_type_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node_type_set</span><span class="p">:</span>
                <span class="n">data_type</span><span class="p">[</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                <span class="n">feature_type_mapping</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="n">data_type</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">feature_type_mapping</span>

        <span class="k">def</span> <span class="nf">invert_dict</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
            <span class="n">new_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_mapping</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">return</span> <span class="n">new_mapping</span>

        <span class="n">new_node_feat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_feature_type_mapping</span> <span class="o">=</span> <span class="n">replace_dict_key</span><span class="p">(</span><span class="n">node_feat</span><span class="p">)</span>
        <span class="n">new_edge_feat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_feature_type_mapping</span> <span class="o">=</span> <span class="n">replace_dict_key</span><span class="p">(</span><span class="n">edge_feat</span><span class="p">)</span>
        <span class="n">new_graph_feat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_feature_type_mapping</span> <span class="o">=</span> <span class="n">replace_dict_key</span><span class="p">(</span><span class="n">graph_feat</span><span class="p">)</span>
        <span class="n">new_node_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span> <span class="o">=</span> <span class="n">replace_value</span><span class="p">(</span><span class="n">node_type</span><span class="p">)</span>
        <span class="n">new_edge_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_type_mapping</span> <span class="o">=</span> <span class="n">replace_value</span><span class="p">(</span><span class="n">edge_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invert_node_type_mapping</span> <span class="o">=</span> <span class="n">invert_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type_mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_edge_type_mapping</span> <span class="o">=</span> <span class="n">invert_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_type_mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_node_feature_type_mapping</span> <span class="o">=</span> <span class="n">invert_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_feature_type_mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_edge_feature_type_mapping</span> <span class="o">=</span> <span class="n">invert_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_feature_type_mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_graph_feature_type_mapping</span> <span class="o">=</span> <span class="n">invert_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_feature_type_mapping</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">new_node_feat</span><span class="p">,</span> <span class="n">new_edge_feat</span><span class="p">,</span> <span class="n">new_graph_feat</span><span class="p">,</span> <span class="n">new_node_type</span><span class="p">,</span> <span class="n">new_edge_type</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">save_graphs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">graph_list</span><span class="p">,</span> <span class="n">num_graphs_per_file</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_format</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When init a graph, input parameter including: edges, node_feat, edge_feat, graph_feat, node_type, edge_type</span>
<span class="sd">    if do collate function, data of graph will be load into python layer</span>
<span class="sd">    but we consider to implement save graph in c++ layer, thus save to single graph_idx.npz firstly</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">merge_into_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_array</span><span class="p">,</span> <span class="n">feature_type</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">feature_type</span><span class="p">,</span> <span class="n">data_array</span><span class="p">):</span>
            <span class="c1"># shape each item should be [num_xxx, num_feature]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">prefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">graph_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">pre_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">graph_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">graph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph_list</span><span class="p">):</span>
        <span class="n">graph_info</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_info</span><span class="p">()</span>
        <span class="c1"># currently input args of get_all_edges can only be int not list.</span>
        <span class="n">edge_ids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_all_edges</span><span class="p">(</span><span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;edge_type&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get_nodes_from_edges</span><span class="p">(</span><span class="n">edge_ids</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">graph_data</span><span class="p">[</span><span class="s2">&quot;graph_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span>

        <span class="c1"># currently input args of get_all_nodes can only be int not list.</span>
        <span class="n">node_ids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_all_nodes</span><span class="p">(</span><span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;node_type&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;node_feature_type&quot;</span><span class="p">]:</span>
            <span class="n">node_feat</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_node_feature</span><span class="p">(</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;node_feature_type&quot;</span><span class="p">])</span>
            <span class="n">merge_into_dict</span><span class="p">(</span><span class="n">graph_data</span><span class="p">,</span> <span class="n">node_feat</span><span class="p">,</span> <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;node_feature_type&quot;</span><span class="p">],</span> <span class="s2">&quot;graph_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_node_feat_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;edge_feature_type&quot;</span><span class="p">]:</span>
            <span class="n">edge_feat</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_edge_feature</span><span class="p">(</span><span class="n">edge_ids</span><span class="p">,</span> <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;edge_feature_type&quot;</span><span class="p">])</span>
            <span class="n">merge_into_dict</span><span class="p">(</span><span class="n">graph_data</span><span class="p">,</span> <span class="n">edge_feat</span><span class="p">,</span> <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;edge_feature_type&quot;</span><span class="p">],</span> <span class="s2">&quot;graph_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_edge_feat_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;graph_feature_type&quot;</span><span class="p">]:</span>
            <span class="n">graph_feat</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_graph_feature</span><span class="p">(</span><span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;graph_feature_type&quot;</span><span class="p">])</span>
            <span class="n">merge_into_dict</span><span class="p">(</span><span class="n">graph_data</span><span class="p">,</span> <span class="n">graph_feat</span><span class="p">,</span> <span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;graph_feature_type&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;graph_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_graph_feat_&quot;</span><span class="p">)</span>

        <span class="c1"># node_type and edge_type need to provide access interface, current unable to get</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_graphs_per_file</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">==</span> <span class="p">(</span><span class="n">graph_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="s2">&quot;graph_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pre_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npz&quot;</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="o">**</span><span class="n">graph_data</span><span class="p">)</span>
            <span class="n">graph_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">pre_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">load_graphs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">data_format</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To be implemented in c++ layer, logic may similar as current implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># consider add param like in graph param: working_mode, num_client ...</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span>
    <span class="nb">sorted</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_feature_data</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">graph_data</span><span class="p">):</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">param_name</span> <span class="o">=</span> <span class="n">param_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
                <span class="n">feature_type</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">param_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># reshape data with 2 dimension</span>
                <span class="n">temp_data</span> <span class="o">=</span> <span class="n">graph_data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;graph_feat_&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param_name</span><span class="p">:</span>
                    <span class="n">temp_data</span> <span class="o">=</span> <span class="n">temp_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">temp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">data_dict</span><span class="p">[</span><span class="n">feature_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_data</span>
        <span class="k">return</span> <span class="n">data_dict</span>

    <span class="n">graphs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;npz&quot;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">id_list</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;.npz&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">id_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">id_list</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">total_files</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">files</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="n">node_feat</span><span class="p">,</span> <span class="n">edge_feat</span><span class="p">,</span> <span class="n">graph_feat</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">edge_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;graph_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">total_files</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
                    <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="n">edges</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;edges&quot;</span><span class="p">]</span>
            <span class="n">node_feat</span> <span class="o">=</span> <span class="n">get_feature_data</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;node_feat&quot;</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">edge_feat</span> <span class="o">=</span> <span class="n">get_feature_data</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;edge_feat&quot;</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">graph_feat</span> <span class="o">=</span> <span class="n">get_feature_data</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;graph_feat&quot;</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;node_type&quot;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">node_type</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;node_type&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;edge_type&quot;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">edge_type</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;edge_type&quot;</span><span class="p">]</span>

            <span class="c1"># consider graph been created in graph mode firstly</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">node_feat</span><span class="p">,</span> <span class="n">edge_feat</span><span class="p">,</span> <span class="n">graph_feat</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">,</span>
                          <span class="n">num_parallel_workers</span><span class="o">=</span><span class="n">num_parallel_workers</span><span class="p">)</span>
            <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graphs</span>


<span class="k">class</span> <span class="nc">_UsersDatasetTemplate</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Template for guiding user to create corresponding dataset(should inherit InMemoryGraphDataset when implemented).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_ReInitTemplate</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal class _ReInitTemplate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># Before we overwrite &#39;__init__&#39; to user-defined &#39;__init__&#39;,</span>
        <span class="c1"># we need make sure the &#39;__init__&#39; should be the basic version(_ReInitTemplate.__init__).</span>
        <span class="n">basic_init_class</span> <span class="o">=</span> <span class="n">_UsersDatasetTemplate</span><span class="o">.</span><span class="n">_ReInitTemplate</span><span class="p">()</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>  <span class="c1"># pylint: disable=W0642</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__init__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">basic_init_class</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__init__&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<div class="viewcode-block" id="InMemoryGraphDataset"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.InMemoryGraphDataset.html#mindspore.dataset.InMemoryGraphDataset">[文档]</a><span class="k">class</span> <span class="nc">InMemoryGraphDataset</span><span class="p">(</span><span class="n">GeneratorDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic Dataset for loading graph into memory.</span>

<span class="sd">    Recommended to Implement your own dataset with inheriting this class, and implement your own method like `process` ,</span>
<span class="sd">    `save` and `load` , refer source code of `ArgoverseDataset` for how to implement your own dataset. When init your</span>
<span class="sd">    own dataset like ArgoverseDataset, The executed process like follows. Check if there are already processed data</span>
<span class="sd">    under given `data_dir` , if so will call `load` method to load it directly, otherwise it will call `process` method</span>
<span class="sd">    to create graphs and call `save` method to save the graphs into `save_dir` .</span>

<span class="sd">    You can access graph in created dataset using `graphs = my_dataset.graphs` and also you can iterate dataset</span>
<span class="sd">    and get data using `my_dataset.create_tuple_iterator()` (in this way you need to implement methods like</span>
<span class="sd">    `__getitem__` and `__len__`), referring to the following example for detail. Note: we have overwritten the</span>
<span class="sd">    `__new__` method to reinitialize `__init__` internally, which means the user-defined `__new__` method won&#39;t work.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_dir (str): directory for loading dataset, here contains origin format data and will be loaded in</span>
<span class="sd">            `process` method.</span>
<span class="sd">        save_dir (str): relative directory for saving processed dataset, this directory is under `data_dir` .</span>
<span class="sd">            Default: &#39;./processed&#39;.</span>
<span class="sd">        column_names (Union[str, list[str]], optional): single column name or list of column names of the dataset,</span>
<span class="sd">            num of column name should be equal to num of item in return data when implement method like `__getitem__` .</span>
<span class="sd">            Default: &#39;graph&#39;.</span>
<span class="sd">        num_samples (int, optional): The number of samples to be included in the dataset. Default: None, all samples.</span>
<span class="sd">        num_parallel_workers (int, optional): Number of subprocesses used to fetch the dataset in parallel. Default: 1.</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset. This parameter can only be</span>
<span class="sd">            specified when the implemented dataset has a random access attribute ( `__getitem__` ). Default: None.</span>
<span class="sd">        num_shards (int, optional): Number of shards that the dataset will be divided into. Default: None.</span>
<span class="sd">            When this argument is specified, `num_samples` reflects the max</span>
<span class="sd">            sample number of per shard.</span>
<span class="sd">        shard_id (int, optional): The shard ID within `num_shards` . Default: None. This argument must be specified only</span>
<span class="sd">            when `num_shards` is also specified.</span>
<span class="sd">        python_multiprocessing (bool, optional): Parallelize Python operations with multiple worker process. This</span>
<span class="sd">            option could be beneficial if the Python operation is computational heavy. Default: True.</span>
<span class="sd">        max_rowsize(int, optional): Maximum size of row in MB that is used for shared memory allocation to copy</span>
<span class="sd">            data between processes. This is only used if python_multiprocessing is set to True. Default: 6 MB.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `data_dir` is not of type str.</span>
<span class="sd">        TypeError: If `save_dir` is not of type str.</span>
<span class="sd">        TypeError: If `num_parallel_workers` is not of type int.</span>
<span class="sd">        TypeError: If `shuffle` is not of type bool.</span>
<span class="sd">        TypeError: If `python_multiprocessing` is not of type bool.</span>
<span class="sd">        TypeError: If `perf_mode` is not of type bool.</span>
<span class="sd">        RuntimeError: If `data_dir` is not valid or does not exit.</span>
<span class="sd">        RuntimeError: If `num_shards` is specified but `shard_id` is None.</span>
<span class="sd">        RuntimeError: If `shard_id` is specified but `num_shards` is None.</span>
<span class="sd">        ValueError: If `num_parallel_workers` exceeds the max thread numbers.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset import InMemoryGraphDataset, Graph</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; class MyDataset(InMemoryGraphDataset):</span>
<span class="sd">        ...     def __init__(self, data_dir):</span>
<span class="sd">        ...         super().__init__(data_dir)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def process(self):</span>
<span class="sd">        ...         # create graph with loading data in given data_dir</span>
<span class="sd">        ...         # here create graph with numpy array directly instead</span>
<span class="sd">        ...         edges = np.array([[0, 1], [1, 2]])</span>
<span class="sd">        ...         graph = Graph(edges=edges)</span>
<span class="sd">        ...         self.graphs.append(graph)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def __getitem__(self, index):</span>
<span class="sd">        ...         # this method and &#39;__len__&#39; method are required when iterating created dataset</span>
<span class="sd">        ...         graph = self.graphs[index]</span>
<span class="sd">        ...         return graph.get_all_edges(&#39;0&#39;)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def __len__(self):</span>
<span class="sd">        ...         return len(self.graphs)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s2">&quot;./processed&quot;</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">python_multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_rowsize</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">data_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_dir</span> <span class="o">=</span> <span class="n">save_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_dir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s1">&#39;process&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

        <span class="n">source</span> <span class="o">=</span> <span class="n">_UsersDatasetTemplate</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;__new__&quot;</span><span class="p">:</span>
                <span class="c1"># The user-defined &#39;__new__&#39; is skipped.</span>
                <span class="k">continue</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="n">column_names</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
                         <span class="n">num_parallel_workers</span><span class="o">=</span><span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="n">num_shards</span><span class="p">,</span>
                         <span class="n">shard_id</span><span class="o">=</span><span class="n">shard_id</span><span class="p">,</span> <span class="n">python_multiprocessing</span><span class="o">=</span><span class="n">python_multiprocessing</span><span class="p">,</span> <span class="n">max_rowsize</span><span class="o">=</span><span class="n">max_rowsize</span><span class="p">)</span>

<div class="viewcode-block" id="InMemoryGraphDataset.process"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.InMemoryGraphDataset.html#mindspore.dataset.InMemoryGraphDataset.process">[文档]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process method based on origin dataset, override this method in your our dataset class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;process&#39; method should be implemented in your own logic.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="InMemoryGraphDataset.save"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.InMemoryGraphDataset.html#mindspore.dataset.InMemoryGraphDataset.save">[文档]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save processed data into disk in numpy.npz format, you can also override this method in your dataset class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_graphs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graphs</span><span class="p">)</span></div>

<div class="viewcode-block" id="InMemoryGraphDataset.load"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.InMemoryGraphDataset.html#mindspore.dataset.InMemoryGraphDataset.load">[文档]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load data from given(processed) path, you can also override this method in your dataset class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graphs</span> <span class="o">=</span> <span class="n">load_graphs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_path</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># file has been processed and saved into processed_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_path</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span></div>


<div class="viewcode-block" id="ArgoverseDataset"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.ArgoverseDataset.html#mindspore.dataset.ArgoverseDataset">[文档]</a><span class="k">class</span> <span class="nc">ArgoverseDataset</span><span class="p">(</span><span class="n">InMemoryGraphDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load argoverse dataset and create graph.</span>

<span class="sd">    Here argoverse dataset is public dataset for autonomous driving, current implement `ArgoverseDataset` is mainly for</span>
<span class="sd">    loading Motion Forecasting Dataset in argoverse dataset, recommend to visit official website for more detail:</span>
<span class="sd">    https://www.argoverse.org/av1.html#download-link.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_dir (str): directory for loading dataset, here contains origin format data and will be loaded in</span>
<span class="sd">            `process` method.</span>
<span class="sd">        column_names (Union[str, list[str]], optional): single column name or list of column names of the dataset.</span>
<span class="sd">            Default: &quot;graph&quot;. Num of column name should be equal to num of item in return data when implement method</span>
<span class="sd">            like `__getitem__`, recommend to specify it with</span>
<span class="sd">            `column_names=[&quot;edge_index&quot;, &quot;x&quot;, &quot;y&quot;, &quot;cluster&quot;, &quot;valid_len&quot;, &quot;time_step_len&quot;]` like the following example.</span>
<span class="sd">        num_parallel_workers (int, optional): Number of subprocesses used to fetch the dataset in parallel. Default: 1.</span>
<span class="sd">        shuffle (bool, optional): Whether or not to perform shuffle on the dataset. This parameter can only be</span>
<span class="sd">            specified when the implemented dataset has a random access attribute ( `__getitem__` ). Default: None.</span>
<span class="sd">        python_multiprocessing (bool, optional): Parallelize Python operations with multiple worker process. This</span>
<span class="sd">            option could be beneficial if the Python operation is computational heavy. Default: True.</span>
<span class="sd">        perf_mode(bool, optional): mode for obtaining higher performance when iterate created dataset(will call</span>
<span class="sd">            `__getitem__` method in this process). Default True, will save all the data in graph</span>
<span class="sd">            (like edge index, node feature and graph feature) into graph feature.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `data_dir` is not of type str.</span>
<span class="sd">        TypeError: If `num_parallel_workers` is not of type int.</span>
<span class="sd">        TypeError: If `shuffle` is not of type bool.</span>
<span class="sd">        TypeError: If `python_multiprocessing` is not of type bool.</span>
<span class="sd">        TypeError: If `perf_mode` is not of type bool.</span>
<span class="sd">        RuntimeError: If `data_dir` is not valid or does not exit.</span>
<span class="sd">        ValueError: If `num_parallel_workers` exceeds the max thread numbers.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.dataset import ArgoverseDataset</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; argoverse_dataset_dir = &quot;/path/to/argoverse_dataset_directory&quot;</span>
<span class="sd">        &gt;&gt;&gt; graph_dataset = ArgoverseDataset(data_dir=argoverse_dataset_dir,</span>
<span class="sd">        ...                                  column_names=[&quot;edge_index&quot;, &quot;x&quot;, &quot;y&quot;, &quot;cluster&quot;, &quot;valid_len&quot;,</span>
<span class="sd">        ...                                                &quot;time_step_len&quot;])</span>
<span class="sd">        &gt;&gt;&gt; for item in graph_dataset.create_dict_iterator(output_numpy=True, num_epochs=1):</span>
<span class="sd">        ...     pass</span>

<span class="sd">    About Argoverse Dataset:</span>

<span class="sd">    Argverse is the first dataset containing high-precision maps, which contains 290KM high-precision map data with</span>
<span class="sd">    geometric shape and semantic information.</span>

<span class="sd">    You can unzip the dataset files into the following structure and read by MindSpore&#39;s API:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        .</span>
<span class="sd">        └── argoverse_dataset_dir</span>
<span class="sd">            ├── train</span>
<span class="sd">            │    ├──...</span>
<span class="sd">            ├── val</span>
<span class="sd">            │    └──...</span>
<span class="sd">            ├── test</span>
<span class="sd">            │    └──...</span>

<span class="sd">    Citation:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        @inproceedings{Argoverse,</span>
<span class="sd">        author     = {Ming-Fang Chang and John W Lambert and Patsorn Sangkloy and Jagjeet Singh</span>
<span class="sd">                   and Slawomir Bak and Andrew Hartnett and De Wang and Peter Carr</span>
<span class="sd">                   and Simon Lucey and Deva Ramanan and James Hays},</span>
<span class="sd">        title      = {Argoverse: 3D Tracking and Forecasting with Rich Maps},</span>
<span class="sd">        booktitle  = {Conference on Computer Vision and Pattern Recognition (CVPR)},</span>
<span class="sd">        year       = {2019}</span>
<span class="sd">        }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">python_multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">perf_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># For high performance, here we store edge_index into graph_feature directly</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">perf_mode</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Type of &#39;perf_mode&#39; should be bool, but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">perf_mode</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perf_mode</span> <span class="o">=</span> <span class="n">perf_mode</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data_dir</span><span class="o">=</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="n">column_names</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
                         <span class="n">num_parallel_workers</span><span class="o">=</span><span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">python_multiprocessing</span><span class="o">=</span><span class="n">python_multiprocessing</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graphs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_mode</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get_graph_feature</span><span class="p">(</span>
                <span class="n">feature_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;edge_index&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="s2">&quot;valid_len&quot;</span><span class="p">,</span> <span class="s2">&quot;time_step_len&quot;</span><span class="p">]))</span>

        <span class="n">graph_info</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph_info</span><span class="p">()</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_all_nodes</span><span class="p">(</span><span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;node_type&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">edge_ids</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_all_edges</span><span class="p">(</span><span class="n">graph_info</span><span class="p">[</span><span class="s2">&quot;edge_type&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">edge_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get_nodes_from_edges</span><span class="p">(</span><span class="n">edge_ids</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_node_feature</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">,</span> <span class="n">feature_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">graph_feature</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_graph_feature</span><span class="p">(</span><span class="n">feature_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="s2">&quot;valid_len&quot;</span><span class="p">,</span> <span class="s2">&quot;time_step_len&quot;</span><span class="p">])</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">valid_len</span><span class="p">,</span> <span class="n">time_step_len</span> <span class="o">=</span> <span class="n">graph_feature</span>

        <span class="k">return</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">valid_len</span><span class="p">,</span> <span class="n">time_step_len</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graphs</span><span class="p">)</span>

<div class="viewcode-block" id="ArgoverseDataset.process"><a class="viewcode-back" href="../../../../api_python/dataset/mindspore.dataset.ArgoverseDataset.html#mindspore.dataset.ArgoverseDataset.process">[文档]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process method for argoverse dataset, here we load original dataset and create a lot of graphs based on it.</span>
<span class="sd">        Pre-processed method mainly refers to: https://github.com/xk-huang/yet-another-vectornet/blob/master/dataset.py.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Import pandas failed, recommend to install pandas with pip.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_edge_full_connection</span><span class="p">(</span><span class="n">node_num</span><span class="p">,</span> <span class="n">start_index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Obtain edge_index with shape (2, edge_num)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_num</span><span class="p">):</span>
                <span class="n">begin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span> <span class="n">idx</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">edges</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">begin</span><span class="p">[:</span><span class="n">idx</span><span class="p">],</span> <span class="n">begin</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">end</span><span class="p">[:</span><span class="n">idx</span><span class="p">],</span> <span class="n">end</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]])))))</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span> <span class="o">+</span> <span class="n">start_index</span>

            <span class="k">return</span> <span class="n">edges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="n">node_num</span> <span class="o">+</span> <span class="n">start_index</span>

        <span class="n">file_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">)]</span>
        <span class="nb">sorted</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>

        <span class="n">valid_len_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">data_p</span> <span class="ow">in</span> <span class="n">file_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data_p</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;pkl&#39;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">x_list</span><span class="p">,</span> <span class="n">edge_index_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">data_p</span><span class="p">)</span>
            <span class="n">input_features</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;POLYLINE_FEATURES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">basic_len</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;TARJ_LEN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="n">input_features</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">valid_len_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;GT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="n">traj_id_mask</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TRAJ_ID_TO_MASK&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lane_id_mask</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LANE_ID_TO_MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">traj_id_mask</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">feature</span> <span class="o">=</span> <span class="n">input_features</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">temp_edge</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="n">get_edge_full_connection</span><span class="p">(</span>
                    <span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start_idx</span><span class="p">)</span>
                <span class="n">x_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
                <span class="n">edge_index_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_edge</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">lane_id_mask</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">feature</span> <span class="o">=</span> <span class="n">input_features</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">basic_len</span><span class="p">:</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">basic_len</span><span class="p">]</span>
                <span class="n">temp_edge</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="n">get_edge_full_connection</span><span class="p">(</span>
                    <span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start_idx</span><span class="p">)</span>
                <span class="n">x_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
                <span class="n">edge_index_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_edge</span><span class="p">)</span>
            <span class="n">edge_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">edge_index_list</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">x_list</span><span class="p">)</span>
            <span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">])</span>

        <span class="n">graphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pad_to_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">valid_len_list</span><span class="p">)</span>
        <span class="n">feature_len</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_list</span><span class="p">):</span>
            <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pad_to_index</span> <span class="o">-</span> <span class="n">item</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">feature_len</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)])</span>
            <span class="n">item</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pad_to_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_mode</span><span class="p">:</span>
                <span class="n">graph_feature</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;edge_index&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                 <span class="s2">&quot;valid_len&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">valid_len_list</span><span class="p">[</span><span class="n">index</span><span class="p">]]),</span>
                                 <span class="s2">&quot;time_step_len&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pad_to_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])}</span>
                <span class="n">g_data</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">graph_feat</span><span class="o">=</span><span class="n">graph_feature</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_feature</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
                <span class="n">graph_feature</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;valid_len&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">valid_len_list</span><span class="p">[</span><span class="n">index</span><span class="p">]]),</span>
                                 <span class="s2">&quot;time_step_len&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pad_to_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])}</span>
                <span class="n">g_data</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">node_feat</span><span class="o">=</span><span class="n">node_feature</span><span class="p">,</span> <span class="n">graph_feat</span><span class="o">=</span><span class="n">graph_feature</span><span class="p">)</span>
            <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graphs</span> <span class="o">=</span> <span class="n">graphs</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2022, MindSpore.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>