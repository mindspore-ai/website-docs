<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindspore.train.callback._landscape &mdash; MindSpore master 文档</title>
      <link rel="stylesheet" href="../../../../_static/css/bootstrap.min.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/training.css" type="text/css" /><link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/js/training.js"></script>
        <script src="../../../../_static/translations.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">设计</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/overview.html">MindSpore设计概览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/programming_paradigm.html">编程范式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/auto_gradient.html">函数式微分编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/mindir.html">中间表示MindIR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/all_scenarios.html">全场景统一</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/dynamic_graph_and_static_graph.html">动静态图结合</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/pluggable_device.html">三方硬件对接</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/distributed_training_design.html">分布式并行</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/graph_fusion_engine.html">图算融合加速引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/data_engine.html">高性能数据处理引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design/glossary.html">术语</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">模型库</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/official_models.html">官方模型库</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.html">mindspore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.html">mindspore.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.html">mindspore.ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.ops.primitive.html">mindspore.ops.primitive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.amp.html">mindspore.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.train.html">mindspore.train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.communication.html">mindspore.communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.common.initializer.html">mindspore.common.initializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.html">mindspore.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.dataset.transforms.html">mindspore.dataset.transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.mindrecord.html">mindspore.mindrecord</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.nn.probability.html">mindspore.nn.probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.rewrite.html">mindspore.rewrite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.boost.html">mindspore.boost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.numpy.html">mindspore.numpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_python/mindspore.scipy.html">mindspore.scipy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API映射</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/api_mapping/pytorch_api_mapping.html">PyTorch与MindSpore API映射表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/api_mapping/tensorflow_api_mapping.html">TensorFlow与MindSpore API映射表</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">迁移指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/overview.html">迁移指南概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/enveriment_preparation.html">环境准备与资料获取</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/analysis_and_preparation.html">模型分析与准备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/model_development/model_development.html">MindSpore网络搭建</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/debug_and_tune.html">调试调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/sample_code.html">网络迁移调试实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration_guide/faq.html">常见问题</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">语法支持</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/static_graph_syntax_support.html">静态图语法支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../note/index_support.html">Tensor索引支持</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/installation.html">安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/data_processing.html">数据处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/implement_problem.html">执行问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/network_compilation.html">网络编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/operators_compile.html">算子编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/usage_migrate_3rd.html">第三方框架迁移使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/performance_tuning.html">性能调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/precision_tuning.html">精度调优</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/distributed_parallel.html">分布式并行</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/inference.html">推理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/feature_advice.html">特性咨询</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">模块代码</a> &raquo;</li>
      <li>mindspore.train.callback._landscape</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>mindspore.train.callback._landscape 源代码</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021-2022 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>
<span class="sd">&quot;&quot;&quot;Process data and Calc loss landscape.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">stat</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">wait</span><span class="p">,</span> <span class="n">ALL_COMPLETED</span><span class="p">,</span> <span class="n">ProcessPoolExecutor</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span><span class="p">,</span> <span class="n">sparse</span>

<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">mindspore.common.tensor</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">mindspore.common.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">mindspore.train.serialization</span> <span class="kn">import</span> <span class="n">load_checkpoint</span><span class="p">,</span> <span class="n">load_param_into_net</span>
<span class="kn">from</span> <span class="nn">mindspore.train.summary_pb2</span> <span class="kn">import</span> <span class="n">LossLandscape</span>
<span class="kn">from</span> <span class="nn">mindspore.train.summary</span> <span class="kn">import</span> <span class="n">SummaryRecord</span>
<span class="kn">from</span> <span class="nn">mindspore.train.summary.enums</span> <span class="kn">import</span> <span class="n">PluginEnum</span>
<span class="kn">from</span> <span class="nn">mindspore.train.anf_ir_pb2</span> <span class="kn">import</span> <span class="n">DataType</span>
<span class="kn">from</span> <span class="nn">mindspore.train._utils</span> <span class="kn">import</span> <span class="n">check_value_type</span><span class="p">,</span> <span class="n">_make_directory</span>
<span class="kn">from</span> <span class="nn">mindspore.train.dataset_helper</span> <span class="kn">import</span> <span class="n">DatasetHelper</span>
<span class="kn">from</span> <span class="nn">mindspore.train.metrics</span> <span class="kn">import</span> <span class="n">get_metrics</span>
<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">context</span>

<span class="c1"># if there is no path, you need to set to empty list</span>
<span class="n">Points</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Points&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">nptype_to_prototype</span><span class="p">(</span><span class="n">np_value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform the np type to proto type.</span>

<span class="sd">    Args:</span>
<span class="sd">        np_value (Type): Numpy data type.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Type, proto data type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np2pt_tbl</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span> <span class="s1">&#39;DT_BOOL&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">:</span> <span class="s1">&#39;DT_INT8&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">:</span> <span class="s1">&#39;DT_INT16&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span> <span class="s1">&#39;DT_INT32&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span> <span class="s1">&#39;DT_INT64&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span> <span class="s1">&#39;DT_UINT8&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">:</span> <span class="s1">&#39;DT_UINT16&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">:</span> <span class="s1">&#39;DT_UINT32&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">:</span> <span class="s1">&#39;DT_UINT64&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">:</span> <span class="s1">&#39;DT_FLOAT16&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">:</span> <span class="s1">&#39;DT_FLOAT64&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span> <span class="s1">&#39;DT_FLOAT32&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span> <span class="s1">&#39;DT_FLOAT64&#39;</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">:</span> <span class="s1">&#39;DT_UNDEFINED&#39;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">np_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">np_type</span> <span class="o">=</span> <span class="n">np_value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
    <span class="n">proto</span> <span class="o">=</span> <span class="n">np2pt_tbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">np_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">proto</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;No match for proto data type.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">proto</span>


<span class="k">def</span> <span class="nf">fill_array_to_tensor</span><span class="p">(</span><span class="n">np_value</span><span class="p">,</span> <span class="n">summary_tensor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Package the tensor summary.</span>

<span class="sd">    Args:</span>
<span class="sd">        np_value (Type): Summary data type.</span>
<span class="sd">        summary_tensor (Tensor): The tensor of summary.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Summary, return tensor summary content.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get tensor dtype</span>
    <span class="n">tensor_dtype</span> <span class="o">=</span> <span class="n">nptype_to_prototype</span><span class="p">(</span><span class="n">np_value</span><span class="p">)</span>
    <span class="n">summary_tensor</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">DataType</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">tensor_dtype</span><span class="p">)</span>

    <span class="c1"># get the value list</span>
    <span class="n">tensor_value_list</span> <span class="o">=</span> <span class="n">np_value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">summary_tensor</span><span class="o">.</span><span class="n">float_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tensor_value_list</span><span class="p">)</span>

    <span class="c1"># get the tensor dim</span>
    <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">np_value</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">summary_tensor</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summary_tensor</span>


<span class="k">def</span> <span class="nf">transfer_tensor_to_tuple</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If the input is a tensor, convert it to a tuple. If not, the output is unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">inputs</span><span class="p">,)</span>

    <span class="k">return</span> <span class="n">inputs</span>


<span class="k">class</span> <span class="nc">Landscape</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return loss landscape.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">intervals</span><span class="p">,</span>
                 <span class="n">decomposition</span><span class="p">,</span>
                 <span class="n">landscape_points</span><span class="p">:</span> <span class="n">Points</span><span class="p">,</span>
                 <span class="n">convergence_point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">path_points</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">landscape_points</span> <span class="o">=</span> <span class="n">landscape_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span> <span class="o">=</span> <span class="n">decomposition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">intervals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="mi">2048</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_point</span> <span class="o">=</span> <span class="n">convergence_point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_points</span> <span class="o">=</span> <span class="n">path_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;step&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_per_epoch</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">set_convergence_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convergence_point</span><span class="p">:</span> <span class="n">Points</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the convergence point.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_point</span> <span class="o">=</span> <span class="n">convergence_point</span>

    <span class="k">def</span> <span class="nf">transform_to_loss_landscape_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">landscape_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform to loss landscape_msg.&quot;&quot;&quot;</span>
        <span class="n">landscape_msg</span> <span class="o">=</span> <span class="n">LossLandscape</span><span class="p">()</span>
        <span class="c1"># only save one dim in x and y</span>
        <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">landscape_points</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">landscape</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">landscape_points</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">landscape</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">landscape_points</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">landscape</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">landscape_data</span><span class="o">.</span><span class="n">path_points</span><span class="p">:</span>
            <span class="n">landscape_msg</span><span class="o">.</span><span class="n">loss_path</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">intervals</span><span class="p">)</span>
            <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">path_points</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">loss_path</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">path_points</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">loss_path</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">path_points</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">loss_path</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">landscape_data</span><span class="o">.</span><span class="n">convergence_point</span><span class="p">:</span>
            <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">convergence_point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">convergence_point</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">convergence_point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">convergence_point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">fill_array_to_tensor</span><span class="p">(</span><span class="n">landscape_data</span><span class="o">.</span><span class="n">convergence_point</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">landscape_msg</span><span class="o">.</span><span class="n">convergence_point</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="n">landscape_msg</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">decomposition</span> <span class="o">=</span> <span class="n">landscape_data</span><span class="o">.</span><span class="n">decomposition</span>
        <span class="n">landscape_msg</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
        <span class="n">landscape_msg</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">step_per_epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_per_epoch</span>

        <span class="k">return</span> <span class="n">landscape_msg</span>


<div class="viewcode-block" id="SummaryLandscape"><a class="viewcode-back" href="../../../../api_python/mindspore/mindspore.SummaryLandscape.html#mindspore.SummaryLandscape">[文档]</a><span class="k">class</span> <span class="nc">SummaryLandscape</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SummaryLandscape can help you to collect loss landscape information.</span>
<span class="sd">    It can create landscape in PCA direction or random direction by calculating loss.</span>

<span class="sd">    Note:</span>
<span class="sd">        1. When using SummaryLandscape, you need to run the code in `if __name__ == &quot;__main__&quot;` .</span>
<span class="sd">        2. SummaryLandscape only supports Linux systems.</span>

<span class="sd">    Args:</span>
<span class="sd">        summary_dir (str): The path of summary is used to save the model weight,</span>
<span class="sd">            metadata and other data required to create landscape.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; import mindspore.nn as nn</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.nn import Loss, Accuracy</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.train import Model, SummaryCollector, SummaryLandscape</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; if __name__ == &#39;__main__&#39;:</span>
<span class="sd">        ...     # If the device_target is Ascend, set the device_target to &quot;Ascend&quot;</span>
<span class="sd">        ...     ms.set_context(mode=ms.GRAPH_MODE, device_target=&quot;GPU&quot;)</span>
<span class="sd">        ...     # Create the dataset taking MNIST as an example. Refer to</span>
<span class="sd">        ...     # https://gitee.com/mindspore/docs/blob/r2.0/docs/mindspore/code/mnist.py</span>
<span class="sd">        ...     ds_train = create_dataset()</span>
<span class="sd">        ...     # Define the network structure of LeNet5. Refer to</span>
<span class="sd">        ...     # https://gitee.com/mindspore/docs/blob/r2.0/docs/mindspore/code/lenet.py</span>
<span class="sd">        ...     network = LeNet5()</span>
<span class="sd">        ...     net_loss = nn.SoftmaxCrossEntropyWithLogits(sparse=True, reduction=&quot;mean&quot;)</span>
<span class="sd">        ...     net_opt = nn.Momentum(network.trainable_params(), 0.01, 0.9)</span>
<span class="sd">        ...     model = Model(network, net_loss, net_opt, metrics={&quot;Accuracy&quot;: Accuracy()})</span>
<span class="sd">        ...     # Simple usage for collect landscape information:</span>
<span class="sd">        ...     interval_1 = [1, 2, 3, 4, 5]</span>
<span class="sd">        ...     summary_collector = SummaryCollector(summary_dir=&#39;./summary/lenet_interval_1&#39;,</span>
<span class="sd">        ...                                          collect_specified_data={&#39;collect_landscape&#39;:{&quot;landscape_size&quot;: 4,</span>
<span class="sd">        ...                                                                                        &quot;unit&quot;: &quot;step&quot;,</span>
<span class="sd">        ...                                                                          &quot;create_landscape&quot;:{&quot;train&quot;:True,</span>
<span class="sd">        ...                                                                                             &quot;result&quot;:False},</span>
<span class="sd">        ...                                                                          &quot;num_samples&quot;: 2048,</span>
<span class="sd">        ...                                                                          &quot;intervals&quot;: [interval_1]}</span>
<span class="sd">        ...                                                                    })</span>
<span class="sd">        ...     model.train(1, ds_train, callbacks=[summary_collector], dataset_sink_mode=False)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     # Simple usage for visualization landscape:</span>
<span class="sd">        ...     def callback_fn():</span>
<span class="sd">        ...         # Define the network structure of LeNet5. Refer to</span>
<span class="sd">        ...         # https://gitee.com/mindspore/docs/blob/r2.0/docs/mindspore/code/lenet.py</span>
<span class="sd">        ...         network = LeNet5()</span>
<span class="sd">        ...         net_loss = nn.SoftmaxCrossEntropyWithLogits(sparse=True, reduction=&quot;mean&quot;)</span>
<span class="sd">        ...         metrics = {&quot;Loss&quot;: Loss()}</span>
<span class="sd">        ...         model = Model(network, net_loss, metrics=metrics)</span>
<span class="sd">        ...         # Create the dataset taking MNIST as an example. Refer to</span>
<span class="sd">        ...         # https://gitee.com/mindspore/docs/blob/r2.0/docs/mindspore/code/mnist.py</span>
<span class="sd">        ...         ds_eval = create_dataset()</span>
<span class="sd">        ...         return model, network, ds_eval, metrics</span>
<span class="sd">        ...</span>
<span class="sd">        ...     summary_landscape = SummaryLandscape(&#39;./summary/lenet_interval_1&#39;)</span>
<span class="sd">        ...     # parameters of collect_landscape can be modified or unchanged</span>
<span class="sd">        ...     summary_landscape.gen_landscapes_with_multi_process(callback_fn,</span>
<span class="sd">        ...                                                        collect_landscape={&quot;landscape_size&quot;: 4,</span>
<span class="sd">        ...                                                                         &quot;create_landscape&quot;:{&quot;train&quot;:False,</span>
<span class="sd">        ...                                                                                            &quot;result&quot;:False},</span>
<span class="sd">        ...                                                                          &quot;num_samples&quot;: 2048,</span>
<span class="sd">        ...                                                                          &quot;intervals&quot;: [interval_1]},</span>
<span class="sd">        ...                                                         device_ids=[1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">summary_dir</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_summary_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">summary_dir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ckpt_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_summary_dir</span><span class="p">,</span> <span class="s1">&#39;ckpt_dir&#39;</span><span class="p">)</span>
        <span class="n">_make_directory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ckpt_dir</span><span class="p">)</span>

        <span class="c1"># save the model params file, key is epoch, value is the ckpt file path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_params_file_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metric_fns</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_model_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the model params.&quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">epochs</span><span class="p">:</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_params_file_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">epoch</span><span class="p">))</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">load_checkpoint</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">parameters</span>

    <span class="k">def</span> <span class="nf">_create_epoch_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intervals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">interval</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

<div class="viewcode-block" id="SummaryLandscape.clean_ckpt"><a class="viewcode-back" href="../../../../api_python/mindspore/mindspore.SummaryLandscape.html#mindspore.SummaryLandscape.clean_ckpt">[文档]</a>    <span class="k">def</span> <span class="nf">clean_ckpt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean the checkpoint.&quot;&quot;&quot;</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ckpt_dir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SummaryLandscape.gen_landscapes_with_multi_process"><a class="viewcode-back" href="../../../../api_python/mindspore/mindspore.SummaryLandscape.html#mindspore.SummaryLandscape.gen_landscapes_with_multi_process">[文档]</a>    <span class="k">def</span> <span class="nf">gen_landscapes_with_multi_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_fn</span><span class="p">,</span> <span class="n">collect_landscape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">device_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the multi process to generate landscape.</span>

<span class="sd">        Args:</span>
<span class="sd">            callback_fn (python function): A python function object. User needs to write a function,</span>
<span class="sd">                it has no input, and the return requirements are as follows.</span>

<span class="sd">                - mindspore.train.Model: User&#39;s model object.</span>
<span class="sd">                - mindspore.nn.Cell: User&#39;s network object.</span>
<span class="sd">                - mindspore.dataset: User&#39;s dataset object for create loss landscape.</span>
<span class="sd">                - mindspore.train.Metrics: User&#39;s metrics object.</span>
<span class="sd">            collect_landscape (Union[dict, None]): The meaning of the parameters</span>
<span class="sd">                when creating loss landscape is consistent with the fields</span>
<span class="sd">                with the same name in SummaryCollector. The purpose of setting here</span>
<span class="sd">                is to allow users to freely modify creating parameters. Default: None.</span>

<span class="sd">                - landscape_size (int): Specify the image resolution of the generated loss landscape.</span>
<span class="sd">                  For example, if it is set to 128, the resolution of the landscape is 128 * 128.</span>
<span class="sd">                  The calculation time increases with the increase of resolution.</span>
<span class="sd">                  Default: 40. Optional values: between 3 and 256.</span>
<span class="sd">                - create_landscape (dict): Select how to create loss landscape.</span>
<span class="sd">                  Training process loss landscape(train) and training result loss landscape(result).</span>
<span class="sd">                  Default: {&quot;train&quot;: True, &quot;result&quot;: True}. Optional: True/False.</span>
<span class="sd">                - num_samples (int): The size of the dataset used to create the loss landscape.</span>
<span class="sd">                  For example, in image dataset, You can set num_samples is 2048,</span>
<span class="sd">                  which means that 2048 images are used to create loss landscape.</span>
<span class="sd">                  Default: 2048.</span>
<span class="sd">                - intervals (List[List[int]]): Specifies the interval</span>
<span class="sd">                  in which the loss landscape. For example: If the user wants to</span>
<span class="sd">                  create loss landscape of two training processes, they are 1-5 epoch</span>
<span class="sd">                  and 6-10 epoch respectively. They can set [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]].</span>
<span class="sd">                  Note: Each interval have at least three epochs.</span>
<span class="sd">            device_ids (List(int)): Specifies which devices are used to create loss landscape.</span>
<span class="sd">                For example: [0, 1] refers to creating loss landscape with device 0 and device 1.</span>
<span class="sd">                Default: None.</span>
<span class="sd">            output (str): Specifies the path to save the loss landscape.</span>
<span class="sd">                Default: None. The default save path is the same as the summary file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">executor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">executor</span> <span class="o">=</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">))</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_context</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">device_ids</span><span class="p">]</span>
            <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">ALL_COMPLETED</span><span class="p">)</span>

        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary_dir</span>
        <span class="n">summary_record</span> <span class="o">=</span> <span class="n">SummaryRecord</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_device_ids</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">collect_landscape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_collect_landscape_data</span><span class="p">(</span><span class="n">collect_landscape</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">summary_record</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">raise</span> <span class="n">err</span>
            <span class="n">json_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ckpt_dir</span><span class="p">,</span> <span class="s1">&#39;train_metadata.json&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">json_path</span><span class="p">):</span>
                <span class="n">summary_record</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;train_metadata.json file path of </span><span class="si">{</span><span class="n">json_path</span><span class="si">}</span><span class="s1"> not exists.&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">collect_landscape</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">if</span> <span class="s2">&quot;intervals&quot;</span> <span class="ow">in</span> <span class="n">collect_landscape</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_epoch_group</span><span class="p">(</span><span class="n">collect_landscape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;intervals&quot;</span><span class="p">))</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;epoch_group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">json_path</span><span class="p">,</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRUSR</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">interval</span><span class="p">,</span> <span class="n">landscape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_landscapes</span><span class="p">(</span><span class="n">callback_fn</span><span class="o">=</span><span class="n">callback_fn</span><span class="p">,</span> <span class="n">executor</span><span class="o">=</span><span class="n">executor</span><span class="p">,</span>
                                                         <span class="n">device_ids</span><span class="o">=</span><span class="n">device_ids</span><span class="p">):</span>
            <span class="n">summary_record</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="n">PluginEnum</span><span class="o">.</span><span class="n">LANDSCAPE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;landscape_</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">landscape</span><span class="p">)</span>
            <span class="n">summary_record</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">summary_record</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">summary_record</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_list_landscapes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_fn</span><span class="p">,</span> <span class="n">executor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create landscape with single device and list all landscape.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ckpt_dir</span><span class="p">,</span> <span class="s1">&#39;train_metadata.json&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, train_metadata.json file does not exist &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;under the path, please use summary_collector to collect information to &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;create the json file&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ckpt_dir</span><span class="p">,</span> <span class="s1">&#39;train_metadata.json&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_json_file_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;epoch_group&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_params_file_map</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;model_params_file_map&#39;</span><span class="p">]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">proz</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">landscape_size</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;landscape_size&#39;</span><span class="p">],</span> <span class="n">device_ids</span><span class="o">=</span><span class="n">device_ids</span><span class="p">,</span> <span class="n">callback_fn</span><span class="o">=</span><span class="n">callback_fn</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;executor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">executor</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;create_landscape&#39;</span><span class="p">][</span><span class="s1">&#39;train&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log_message</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;create_landscape&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">epochs</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;epochs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">epochs</span>
                <span class="n">mid_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">landscape_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_landscape_by_pca</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Create landscape end, use time: </span><span class="si">%s</span><span class="s2"> s.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">mid_time</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
                <span class="n">landscape_data</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span>
                <span class="n">landscape_data</span><span class="o">.</span><span class="n">step_per_epoch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;step_per_epoch&#39;</span><span class="p">]</span>
                <span class="n">landscape_data</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;num_samples&#39;</span><span class="p">]</span>
                <span class="k">yield</span> <span class="p">[</span><span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">landscape_data</span><span class="o">.</span><span class="n">transform_to_loss_landscape_msg</span><span class="p">(</span><span class="n">landscape_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;create_landscape&#39;</span><span class="p">][</span><span class="s1">&#39;result&#39;</span><span class="p">]:</span>
            <span class="n">final_epochs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log_message</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;create_landscape&#39;</span><span class="p">],</span> <span class="n">final_epochs</span><span class="o">=</span><span class="n">final_epochs</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;epochs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_epochs</span>
            <span class="n">mid_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">landscape_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_landscape_by_random</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Create landscape end, use time: </span><span class="si">%s</span><span class="s2"> s.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">mid_time</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
            <span class="n">landscape_data</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span>
            <span class="n">landscape_data</span><span class="o">.</span><span class="n">step_per_epoch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;step_per_epoch&#39;</span><span class="p">]</span>
            <span class="n">landscape_data</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;num_samples&#39;</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">final_epochs</span><span class="p">,</span> <span class="n">landscape_data</span><span class="o">.</span><span class="n">transform_to_loss_landscape_msg</span><span class="p">(</span><span class="n">landscape_data</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Total use time: </span><span class="si">%s</span><span class="s2"> s.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_log_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">create_landscape</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">final_epochs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate drawing information using log.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">final_epochs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">create_landscape</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Start to create the </span><span class="si">{</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> landscapes, &quot;</span> \
                      <span class="sa">f</span><span class="s2">&quot;checkpoint is </span><span class="si">{</span><span class="n">interval</span><span class="si">}</span><span class="s2">, decomposition is PCA.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Start to create the </span><span class="si">{</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span><span class="p">)</span><span class="si">}</span><span class="s2"> landscapes, &quot;</span> \
                      <span class="sa">f</span><span class="s2">&quot;checkpoint is </span><span class="si">{</span><span class="n">interval</span><span class="si">}</span><span class="s2">, decomposition is PCA.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">create_landscape</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Start to create the </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epoch_group</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> landscapes, &quot;</span> \
                      <span class="sa">f</span><span class="s2">&quot;checkpoint is </span><span class="si">{</span><span class="n">final_epochs</span><span class="si">}</span><span class="s2">, decomposition is Random. &quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Start to create the </span><span class="si">{</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span><span class="s2"> landscapes, &quot;</span> \
                      <span class="sa">f</span><span class="s2">&quot;checkpoint is </span><span class="si">{</span><span class="n">final_epochs</span><span class="si">}</span><span class="s2">, decomposition is Random.&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_set_context</span><span class="p">(</span><span class="n">device_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set context.&quot;&quot;&quot;</span>
        <span class="n">context</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">device_id</span><span class="o">=</span><span class="n">device_id</span><span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">GRAPH_MODE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_landscape_by_pca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">proz</span><span class="p">,</span> <span class="n">landscape_size</span><span class="p">,</span> <span class="n">device_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">executor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create landscape by PCA.&quot;&quot;&quot;</span>
        <span class="n">multi_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_model_params</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>
        <span class="n">param_matrixs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">multi_parameters</span><span class="p">:</span>
            <span class="n">parlis</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;bias&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;moment&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
                    <span class="n">parlis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">parlis</span><span class="p">,</span> <span class="n">data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">param_matrixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parlis</span><span class="p">)</span>
        <span class="n">param_matrixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">param_matrixs</span><span class="p">)</span>
        <span class="n">param_matrixs</span> <span class="o">=</span> <span class="n">param_matrixs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">param_matrixs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Only 2 are needed, as we have to reduce high dimensions into 2D.And we reserve one for loss value.</span>
        <span class="n">pca</span> <span class="o">=</span> <span class="n">_PCA</span><span class="p">(</span><span class="n">n_comps</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">principal_components</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">param_matrixs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">v_ori</span><span class="p">,</span> <span class="n">w_ori</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">principal_components</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">principal_components</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">final_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">multi_parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Reshape PCA directions(include dimensions of all parameters) into original shape of Model parameters</span>
        <span class="n">v_ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_vector</span><span class="p">(</span><span class="n">v_ori</span><span class="p">,</span> <span class="n">final_params</span><span class="p">)</span>
        <span class="n">w_ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_vector</span><span class="p">(</span><span class="n">w_ori</span><span class="p">,</span> <span class="n">final_params</span><span class="p">)</span>

        <span class="c1"># Reshape PCA directions(include dimensions of only weights) into original shape of Model parameters</span>
        <span class="n">final_params_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_weight_and_bias</span><span class="p">(</span><span class="n">final_params</span><span class="p">)</span>
        <span class="n">v_ndarray_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_vector</span><span class="p">(</span><span class="n">v_ori</span><span class="p">,</span> <span class="n">final_params_filtered</span><span class="p">)</span>
        <span class="n">w_ndarray_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_vector</span><span class="p">(</span><span class="n">w_ori</span><span class="p">,</span> <span class="n">final_params_filtered</span><span class="p">)</span>

        <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_vector</span><span class="p">(</span><span class="n">final_params</span><span class="p">,</span> <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">)</span>
        <span class="n">v_ndarray_filtered</span><span class="p">,</span> <span class="n">w_ndarray_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_vector</span><span class="p">(</span><span class="n">final_params_filtered</span><span class="p">,</span> <span class="n">v_ndarray_filtered</span><span class="p">,</span>
                                                                        <span class="n">w_ndarray_filtered</span><span class="p">)</span>
        <span class="c1"># Flat to a single vector and calc alpha, beta</span>
        <span class="n">v_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flat_ndarray</span><span class="p">(</span><span class="n">v_ndarray_filtered</span><span class="p">)</span>
        <span class="n">w_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flat_ndarray</span><span class="p">(</span><span class="n">w_ndarray_filtered</span><span class="p">)</span>
        <span class="n">final_params_numpy</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">final_params</span><span class="p">]</span>
        <span class="n">final_params_filtered_numpy</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">final_params_filtered</span><span class="p">]</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_coefs</span><span class="p">(</span><span class="n">multi_parameters</span><span class="p">,</span> <span class="n">final_params_filtered_numpy</span><span class="p">,</span> <span class="n">v_param</span><span class="p">,</span> <span class="n">w_param</span><span class="p">)</span>

        <span class="c1"># generate coordinates of loss landscape</span>
        <span class="n">coefs_x</span> <span class="o">=</span> <span class="n">coefs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">coefs_y</span> <span class="o">=</span> <span class="n">coefs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">x_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">coefs_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">proz</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">coefs_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">coefs_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                             <span class="nb">max</span><span class="p">(</span><span class="n">coefs_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">proz</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">coefs_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">coefs_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">landscape_size</span><span class="p">)</span>
        <span class="n">y_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">coefs_y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">proz</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">coefs_y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">coefs_y</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                             <span class="nb">max</span><span class="p">(</span><span class="n">coefs_y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">proz</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">coefs_y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">coefs_y</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">landscape_size</span><span class="p">)</span>
        <span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">y_axis</span><span class="p">)</span>

        <span class="n">test_final_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">final_params</span><span class="p">:</span>
            <span class="n">test_final_params</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coefs_parts</span><span class="p">,</span> <span class="n">y_points_parts</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">count_per_parts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">coefs_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">count_per_parts</span><span class="p">])</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">count_per_parts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coefs_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="n">start</span><span class="p">:])</span>
            <span class="n">count_per_parts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_points</span><span class="p">)</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Use multi process, device_id: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">device_ids</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">y_points_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_points</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">count_per_parts</span><span class="p">])</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">count_per_parts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_points_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_points</span><span class="p">[</span><span class="n">start</span><span class="p">:])</span>

            <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">device_ids</span><span class="p">):</span>
                <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cont_loss_wrapper</span><span class="p">,</span> <span class="n">callback_fn</span><span class="p">,</span> <span class="n">test_final_params</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">,</span>
                                         <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">,</span> <span class="n">x_points</span><span class="p">,</span> <span class="n">y_points_parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">coefs</span><span class="o">=</span><span class="n">coefs_parts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
            <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">ALL_COMPLETED</span><span class="p">)</span>

            <span class="n">z_points</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
                <span class="n">paths</span> <span class="o">+=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">z_points</span> <span class="o">+=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">paths</span><span class="p">,</span> <span class="n">z_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cont_loss_wrapper</span><span class="p">(</span><span class="n">callback_fn</span><span class="p">,</span> <span class="n">test_final_params</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">,</span>
                                                      <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">,</span> <span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">,</span> <span class="n">coefs</span><span class="o">=</span><span class="n">coefs</span><span class="p">)</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="n">landscape_points</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">z_points</span><span class="p">))</span>
        <span class="n">path_points</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span><span class="n">coefs_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coefs_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">paths</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">zero_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">path_points</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">convergence_point</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">path_points</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">zero_index</span><span class="p">]]))</span>
        <span class="n">landscape</span> <span class="o">=</span> <span class="n">Landscape</span><span class="p">(</span><span class="n">intervals</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">decomposition</span><span class="o">=</span><span class="s1">&#39;PCA&#39;</span><span class="p">,</span> <span class="n">landscape_points</span><span class="o">=</span><span class="n">landscape_points</span><span class="p">,</span>
                              <span class="n">path_points</span><span class="o">=</span><span class="n">path_points</span><span class="p">,</span> <span class="n">convergence_point</span><span class="o">=</span><span class="n">convergence_point</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">landscape</span>

    <span class="k">def</span> <span class="nf">_cont_loss_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_fn</span><span class="p">,</span> <span class="n">test_final_params</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">,</span>
                           <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">,</span> <span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">,</span> <span class="n">coefs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute loss wrapper.&quot;&quot;&quot;</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">valid_dataset</span><span class="p">,</span> <span class="n">metrics</span> <span class="o">=</span> <span class="n">callback_fn</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ckpt_dir</span><span class="p">,</span> <span class="s1">&#39;train_metadata.json&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_json_file_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;num_samples&#39;</span><span class="p">]</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">valid_dataset</span><span class="o">.</span><span class="n">get_batch_size</span><span class="p">()</span>
        <span class="n">num_batches</span> <span class="o">=</span> <span class="n">num_samples</span> <span class="o">//</span> <span class="n">batch_size</span>
        <span class="n">valid_dataset</span> <span class="o">=</span> <span class="n">valid_dataset</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">num_batches</span><span class="p">)</span>

        <span class="n">paths</span><span class="p">,</span> <span class="n">final_params</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">test_final_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">final_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coefs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coef</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coefs</span><span class="p">):</span>
                <span class="n">loss_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cont_loss</span><span class="p">(</span><span class="n">valid_dataset</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">metrics</span><span class="p">,</span> <span class="n">final_params</span><span class="p">,</span>
                                            <span class="n">final_params_numpy</span><span class="p">,</span> <span class="p">[</span><span class="n">coef</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">coef</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_data</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Drawing landscape path total progress is </span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">, landscape path loss is </span><span class="si">%s</span><span class="s2">.&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">),</span> <span class="n">loss_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># Start to calc loss landscape</span>
        <span class="n">z_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Compute loss landscape</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y_points</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Drawing landscape total progress: </span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_points</span><span class="p">)))</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cont_loss</span><span class="p">(</span><span class="n">valid_dataset</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">metrics</span><span class="p">,</span> <span class="n">final_params</span><span class="p">,</span>
                                   <span class="n">final_params_numpy</span><span class="p">,</span> <span class="n">x_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">)</span>
            <span class="n">z_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">paths</span><span class="p">,</span> <span class="n">z_points</span>

    <span class="k">def</span> <span class="nf">_create_landscape_by_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">proz</span><span class="p">,</span> <span class="n">landscape_size</span><span class="p">,</span> <span class="n">device_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">callback_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">executor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create landscape by Random.&quot;&quot;&quot;</span>
        <span class="n">multi_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_model_params</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>
        <span class="n">final_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">multi_parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">final_params_numpy</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">final_params</span><span class="p">]</span>
        <span class="n">total_params</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">final_params_numpy</span><span class="p">)</span>
        <span class="n">v_rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">total_params</span><span class="p">)</span>
        <span class="n">w_rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">total_params</span><span class="p">)</span>

        <span class="c1"># Reshape Random directions(include dimensions of all parameters) into original shape of Model parameters</span>
        <span class="n">v_ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_random_vector</span><span class="p">(</span><span class="n">v_rand</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">)</span>
        <span class="n">w_ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_random_vector</span><span class="p">(</span><span class="n">w_rand</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">)</span>
        <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_vector</span><span class="p">(</span><span class="n">final_params</span><span class="p">,</span> <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">)</span>

        <span class="n">boundaries_x</span><span class="p">,</span> <span class="n">boundaries_y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
        <span class="n">x_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">proz</span> <span class="o">*</span> <span class="n">boundaries_x</span><span class="p">,</span> <span class="n">proz</span> <span class="o">*</span> <span class="n">boundaries_x</span><span class="p">,</span> <span class="n">landscape_size</span><span class="p">)</span>
        <span class="n">y_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">proz</span> <span class="o">*</span> <span class="n">boundaries_y</span><span class="p">,</span> <span class="n">proz</span> <span class="o">*</span> <span class="n">boundaries_y</span><span class="p">,</span> <span class="n">landscape_size</span><span class="p">)</span>
        <span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">y_axis</span><span class="p">)</span>
        <span class="n">test_final_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">final_params</span><span class="p">:</span>
            <span class="n">test_final_params</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Use multi process, device_id: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">device_ids</span><span class="p">))</span>
            <span class="n">y_points_parts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">count_per_parts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_points</span><span class="p">)</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">y_points_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_points</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">count_per_parts</span><span class="p">])</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">count_per_parts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_points_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_points</span><span class="p">[</span><span class="n">start</span><span class="p">:])</span>

            <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">device_ids</span><span class="p">)):</span>
                <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cont_loss_wrapper</span><span class="p">,</span> <span class="n">callback_fn</span><span class="p">,</span> <span class="n">test_final_params</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">,</span>
                                         <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">,</span> <span class="n">x_points</span><span class="p">,</span> <span class="n">y_points_parts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
            <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">ALL_COMPLETED</span><span class="p">)</span>
            <span class="n">z_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
                <span class="n">z_points</span> <span class="o">+=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">z_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cont_loss_wrapper</span><span class="p">(</span><span class="n">callback_fn</span><span class="p">,</span> <span class="n">test_final_params</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">,</span>
                                                  <span class="n">v_ndarray</span><span class="p">,</span> <span class="n">w_ndarray</span><span class="p">,</span> <span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">)</span>

        <span class="n">landscape_points</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">z_points</span><span class="p">))</span>
        <span class="n">convergence_point</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_axis</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y_axis</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">y_axis</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]]),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z_points</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">y_axis</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]]))</span>
        <span class="n">landscape</span> <span class="o">=</span> <span class="n">Landscape</span><span class="p">(</span><span class="n">intervals</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">decomposition</span><span class="o">=</span><span class="s1">&#39;Random&#39;</span><span class="p">,</span> <span class="n">landscape_points</span><span class="o">=</span><span class="n">landscape_points</span><span class="p">,</span>
                              <span class="n">convergence_point</span><span class="o">=</span><span class="n">convergence_point</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">landscape</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_filter_weight_and_bias</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter the weight and bias of parameters.&quot;&quot;&quot;</span>

        <span class="n">filter_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;weight&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="s1">&#39;bias&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;moment&#39;</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">filter_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filter_params</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reshape vector into model shape.&quot;&quot;&quot;</span>
        <span class="n">ndarray</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;weight&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="s2">&quot;bias&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;moment&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="n">ndarray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="n">vec_it</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">index</span><span class="p">:(</span><span class="n">index</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">ndarray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec_it</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">ndarray</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reshape_random_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">params_numpy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reshape random vector into model shape.&quot;&quot;&quot;</span>
        <span class="n">ndarray</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params_numpy</span><span class="p">:</span>
            <span class="n">len_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="n">p_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="n">vec_it</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">index</span><span class="p">:(</span><span class="n">index</span> <span class="o">+</span> <span class="n">len_p</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p_size</span><span class="p">)</span>
            <span class="n">ndarray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec_it</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">len_p</span>
        <span class="k">return</span> <span class="n">ndarray</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_normalize_vector</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">get_v</span><span class="p">,</span> <span class="n">get_w</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalizes the vectors spanning the 2D space, to make trajectories comparable between each other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
            <span class="c1"># Here as MindSpore ckpt has hyperparameters, we should skip them to make sure</span>
            <span class="c1"># PCA calculation is correct.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;bias&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;moment&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="n">factor_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">get_v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">factor_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">get_w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">get_v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">factor_v</span>
                <span class="n">get_w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">factor_w</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">get_v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span>
                <span class="n">get_w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">get_v</span><span class="p">,</span> <span class="n">get_w</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_flat_ndarray</span><span class="p">(</span><span class="n">ndarray_vector</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concatenates a python array of numpy arrays into a single, flat numpy array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">item</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ndarray_vector</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_coefs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_group</span><span class="p">,</span> <span class="n">final_param_ndarray</span><span class="p">,</span> <span class="n">v_vector</span><span class="p">,</span> <span class="n">w_vector</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the scale factors for plotting points</span>
<span class="sd">        in the 2D space spanned by the vectors v and w.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">matris</span> <span class="o">=</span> <span class="p">[</span><span class="n">v_vector</span><span class="p">,</span> <span class="n">w_vector</span><span class="p">]</span>
        <span class="n">matris</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">matris</span><span class="p">)</span>
        <span class="n">matris</span> <span class="o">=</span> <span class="n">matris</span><span class="o">.</span><span class="n">T</span>

        <span class="n">pas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flat_ndarray</span><span class="p">(</span><span class="n">final_param_ndarray</span><span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">parameter_group</span><span class="p">:</span>
            <span class="n">testi</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                <span class="c1"># Here as MindSpore ckpt has hyperparameters,</span>
                <span class="c1"># we should skip them to make sure PCA calculation is correct</span>
                <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;weight&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="s1">&#39;bias&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;moment&#39;</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">testi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>

            <span class="n">st_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flat_ndarray</span><span class="p">(</span><span class="n">testi</span><span class="p">)</span>
            <span class="n">b_vec</span> <span class="o">=</span> <span class="n">st_vec</span> <span class="o">-</span> <span class="n">pas</span>
            <span class="c1"># Here using least square method to get solutions of a equation system to generate alpha and beta.</span>
            <span class="n">coefs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">matris</span><span class="p">,</span> <span class="n">b_vec</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cont_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds_eval</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">metrics</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
                   <span class="n">final_params_numpy</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">get_v</span><span class="p">,</span> <span class="n">get_w</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the loss landscape based on vectors v and w (which can be principal components).</span>
<span class="sd">        Changes the internal state of model. Executes model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;start to cont loss&quot;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">al_item</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alph</span><span class="p">):</span>
            <span class="c1"># calculate new parameters for model</span>

            <span class="n">parameters_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
                <span class="n">parameters_dict</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_parameter</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">,</span>
                                                                     <span class="n">alph</span><span class="p">[</span><span class="n">al_item</span><span class="p">],</span> <span class="n">beta</span><span class="p">,</span>
                                                                     <span class="n">get_v</span><span class="p">,</span> <span class="n">get_w</span><span class="p">)</span>

            <span class="n">al_item</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># load parameters into model and calculate loss</span>

            <span class="n">load_param_into_net</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">parameters_dict</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">parameters_dict</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loss_compute</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">ds_eval</span><span class="p">,</span> <span class="n">metrics</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current local landscape progress is </span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">, landscape loss is </span><span class="si">%s</span><span class="s2">.&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">alph</span><span class="p">),</span> <span class="n">loss</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span><span class="p">)))</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">loss</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">vals</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_change_parameter</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">final_params_numpy</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">get_v</span><span class="p">,</span> <span class="n">get_w</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function for changing parameter value with map and lambda.&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">final_params_numpy</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">data_target</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">get_v</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">get_w</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">data_target</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">data_target</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">parameter</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">data_target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">parameter</span>

    <span class="k">def</span> <span class="nf">_loss_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">metrics</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute loss.&quot;&quot;&quot;</span>
        <span class="n">dataset_sink_mode</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metric_fns</span> <span class="o">=</span> <span class="n">get_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metric_fns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">metric</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="n">network</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">train_network</span>
        <span class="n">dataset_helper</span> <span class="o">=</span> <span class="n">DatasetHelper</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dataset_sink_mode</span><span class="p">)</span>

        <span class="n">network</span><span class="o">.</span><span class="n">set_train</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">network</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="s1">&#39;train&#39;</span>

        <span class="k">for</span> <span class="n">inputs</span> <span class="ow">in</span> <span class="n">dataset_helper</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">transfer_tensor_to_tuple</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">network</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_metrics</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

        <span class="n">metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_metrics</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">metrics</span>

    <span class="k">def</span> <span class="nf">_update_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update metrics local values.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The argument &#39;outputs&#39; should be tuple, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Modify &#39;output&#39; to Tensor or tuple. &quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metric_fns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">metric</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_get_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get metrics local values.&quot;&quot;&quot;</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metric_fns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">metrics</span>

    <span class="k">def</span> <span class="nf">_check_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check unit type and value.&quot;&quot;&quot;</span>
        <span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">,</span> <span class="s2">&quot;epoch&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, the &quot;unit&quot; in train_metadata.json should be &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;step or epoch, but got the: </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_landscape_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">landscape_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check landscape size type and value.&quot;&quot;&quot;</span>
        <span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;landscape_size&#39;</span><span class="p">,</span> <span class="n">landscape_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="c1"># landscape size should be between 3 and 256.</span>
        <span class="k">if</span> <span class="n">landscape_size</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">landscape_size</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, &quot;landscape_size&quot; in train_metadata.json should be &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;between 3 and 256, but got the: </span><span class="si">{</span><span class="n">landscape_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_create_landscape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">create_landscape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check create landscape type and value.&quot;&quot;&quot;</span>
        <span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;create_landscape&#39;</span><span class="p">,</span> <span class="n">create_landscape</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">create_landscape</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="s2">&quot;result&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, the key of &quot;create_landscape&quot; should be in &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;[&quot;train&quot;, &quot;result&quot;], but got the: </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">create_landscape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, the key of &quot;create_landscape&quot; should be train &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;and result, but only got the: </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">check_value_type</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check intervals type and value.&quot;&quot;&quot;</span>
        <span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;intervals&#39;</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intervals</span><span class="p">):</span>
            <span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;each interval in intervals&#39;</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="c1">#Each interval have at least three epochs.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, the length of each list in &quot;intervals&quot; &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;should not be less than three, but got the: </span><span class="si">{</span><span class="n">interval</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">interval</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, the type of each value in &quot;intervals&quot; &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;should be int, but got the: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_device_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device_ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check device_ids type and value.&quot;&quot;&quot;</span>
        <span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;device_ids&#39;</span><span class="p">,</span> <span class="n">device_ids</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">device_ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.gen_landscapes_with_multi_process&quot;, the parameter &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;&quot;device_ids&quot; type should be int, but got the: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="c1">#device_id should be between 0 and 7.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.gen_landscapes_with_multi_process&quot;, the parameter &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;&quot;device_ids&quot; should be between 0 and 7,but got </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_collect_landscape_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collect_landscape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check collect landscape data type and value.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">collect_landscape</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;landscape_size&quot;</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="s2">&quot;num_samples&quot;</span><span class="p">,</span> <span class="s2">&quot;create_landscape&quot;</span><span class="p">,</span> <span class="s2">&quot;intervals&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, the key of collect landscape should be &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;landscape_size, unit, num_samples create_landscape or intervals, &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;but got the: </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">. &#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;landscape_size&quot;</span> <span class="ow">in</span> <span class="n">collect_landscape</span><span class="p">:</span>
            <span class="n">landscape_size</span> <span class="o">=</span> <span class="n">collect_landscape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;landscape_size&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_landscape_size</span><span class="p">(</span><span class="n">landscape_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;unit&quot;</span> <span class="ow">in</span> <span class="n">collect_landscape</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">collect_landscape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;unit&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;num_samples&quot;</span> <span class="ow">in</span> <span class="n">collect_landscape</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="n">collect_landscape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_samples&quot;</span><span class="p">)</span>
            <span class="n">check_value_type</span><span class="p">(</span><span class="s2">&quot;num_samples&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;create_landscape&quot;</span> <span class="ow">in</span> <span class="n">collect_landscape</span><span class="p">:</span>
            <span class="n">create_landscape</span> <span class="o">=</span> <span class="n">collect_landscape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;create_landscape&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_create_landscape</span><span class="p">(</span><span class="n">create_landscape</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;intervals&quot;</span> <span class="ow">in</span> <span class="n">collect_landscape</span><span class="p">:</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="n">collect_landscape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;intervals&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_json_file_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_file_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check json file data.&quot;&quot;&quot;</span>
        <span class="n">file_key</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;epoch_group&quot;</span><span class="p">,</span> <span class="s2">&quot;model_params_file_map&quot;</span><span class="p">,</span> <span class="s2">&quot;step_per_epoch&quot;</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;num_samples&quot;</span><span class="p">,</span> <span class="s2">&quot;landscape_size&quot;</span><span class="p">,</span> <span class="s2">&quot;create_landscape&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">json_file_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file_key</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;train_metadata&quot; json file should be </span><span class="si">{</span><span class="n">file_key</span><span class="si">}</span><span class="s1">, but got the: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">epoch_group</span> <span class="o">=</span> <span class="n">json_file_data</span><span class="p">[</span><span class="s2">&quot;epoch_group&quot;</span><span class="p">]</span>
        <span class="n">model_params_file_map</span> <span class="o">=</span> <span class="n">json_file_data</span><span class="p">[</span><span class="s2">&quot;model_params_file_map&quot;</span><span class="p">]</span>
        <span class="n">step_per_epoch</span> <span class="o">=</span> <span class="n">json_file_data</span><span class="p">[</span><span class="s2">&quot;step_per_epoch&quot;</span><span class="p">]</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">json_file_data</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="n">json_file_data</span><span class="p">[</span><span class="s2">&quot;num_samples&quot;</span><span class="p">]</span>
        <span class="n">landscape_size</span> <span class="o">=</span> <span class="n">json_file_data</span><span class="p">[</span><span class="s2">&quot;landscape_size&quot;</span><span class="p">]</span>
        <span class="n">create_landscape</span> <span class="o">=</span> <span class="n">json_file_data</span><span class="p">[</span><span class="s2">&quot;create_landscape&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epoch_group</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="c1"># Each epoch_group have at least three epochs.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, the &quot;epoch_group&quot; in train_metadata.json, &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;length of each list in &quot;epoch_group&quot; should not be less than 3, &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;but got: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span><span class="si">}</span><span class="s1">. &#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">epochs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_params_file_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, the &quot;model_params_file_map&quot; in &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;train_metadata.json does not exist </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s1">th checkpoint in intervals.&#39;</span><span class="p">)</span>

        <span class="n">check_value_type</span><span class="p">(</span><span class="s1">&#39;step_per_epoch&#39;</span><span class="p">,</span> <span class="n">step_per_epoch</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_landscape_size</span><span class="p">(</span><span class="n">landscape_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">check_value_type</span><span class="p">(</span><span class="s2">&quot;num_samples&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_create_landscape</span><span class="p">(</span><span class="n">create_landscape</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_PCA</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The internal class for computing PCA vectors.</span>

<span class="sd">    .. math::</span>

<span class="sd">        u, s, vt = svd(x - mean(x)),</span>
<span class="sd">        u_i = u_i * s_i,</span>

<span class="sd">    where :math:`mean` is the mean operator, :math:`svd` is the singular value decomposition operator.</span>
<span class="sd">    :math:`u_i` is line :math:`i` of the :math:`u`, :math:`s_i` is column :math:`i` of the :math:`s`,</span>
<span class="sd">    :math:`i` ranges from :math:`0` to :math:`n\_comps`.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_comps (int): Number of principal components needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_comps</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_comps</span> <span class="o">=</span> <span class="n">n_comps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_status</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iterated_power</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_oversamples</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_safe_dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dot product that handle the matrix case correctly.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="c1"># Sparse is always 2 dimensional. Implies a is above 3 dimensional.</span>
                <span class="c1"># [n, ..., o, p] @ [l, m] -&gt; [n, ..., o, m]</span>
                <span class="n">a_2d</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">a_2d</span> <span class="o">@</span> <span class="n">b</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="c1"># Sparse is always 2 dimensional. Implies b is above 3 dimensional.</span>
                <span class="c1"># [l, m] @ [n, ..., o, p, q] -&gt; [l, n, ..., o, q]</span>
                <span class="n">b_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">b_2d</span> <span class="o">=</span> <span class="n">b_</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b_2d</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">b_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_svd_turn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u_decision</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Confirm correction to ensure deterministic output from SVD.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">u_decision</span><span class="p">:</span>
            <span class="c1"># rows of v, columns of u</span>
            <span class="n">max_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">max_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))])</span>
            <span class="n">v</span> <span class="o">*=</span> <span class="n">signs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">u</span> <span class="o">*=</span> <span class="n">signs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># rows of u, columns of v</span>
            <span class="n">max_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">max_rows</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">*=</span> <span class="n">signs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">u</span> <span class="o">*=</span> <span class="n">signs</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_random_status</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform seed into a np.random.RandomState instance.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">seed</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">seed</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> cannot be used to seed a numpy.random.RandomState instance&quot;</span> <span class="o">%</span> <span class="n">seed</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Main method for computing principal components.&quot;&quot;&quot;</span>
        <span class="n">n_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_comps</span>
        <span class="c1"># small dimension (the shape is less than 500), and the full amount is calculated.</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">500</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_few</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># When dimension of x is much, truncated SVD is used for calculation.</span>
        <span class="k">elif</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">n_components</span> <span class="o">&lt;</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_much</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_components</span><span class="p">)</span>
        <span class="c1">#  A case of n_components in (0, 1)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_few</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="c1"># To prevent s from being equal to 0, a small fixed noise is added.</span>
            <span class="c1"># Adjust 1e-19 was found a good compromise for s.</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-19</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_comps</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">*=</span> <span class="n">s</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_comps</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">u</span>

    <span class="k">def</span> <span class="nf">_fit_few</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute principal components with full SVD on x, when dimension of x is few.&quot;&quot;&quot;</span>
        <span class="n">mean_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">mean_</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_svd_turn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">vt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span>

    <span class="k">def</span> <span class="nf">_fit_much</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n_components</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute principal components with truncated SVD on x, when dimension of x is much.&quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_random_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_status</span><span class="p">)</span>
        <span class="n">mean_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">mean_</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_svd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">n_oversamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_oversamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span>

    <span class="k">def</span> <span class="nf">_random_svd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">n_oversamples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="s2">&quot;warn&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute a truncated randomized SVD.&quot;&quot;&quot;</span>
        <span class="n">n_random</span> <span class="o">=</span> <span class="n">n_components</span> <span class="o">+</span> <span class="n">n_oversamples</span>
        <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Adjust 7 or 4 was found a good compromise for randomized SVD.</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">7</span> <span class="k">if</span> <span class="n">n_components</span> <span class="o">&lt;</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">else</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="n">n_features</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span>

        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_range_finder</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_random</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># Project m to the low dimensional space using the basis vectors (q vector).</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_dot</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="c1"># Compute the svd on this matrix (b matrix)</span>
        <span class="n">uhat</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">b</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">uhat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="n">n_features</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_svd_turn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">vt</span><span class="p">,</span> <span class="n">u_decision</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_svd_turn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">vt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="n">n_features</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vt</span><span class="p">[:</span><span class="n">n_components</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">s</span><span class="p">[:</span><span class="n">n_components</span><span class="p">],</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_components</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_components</span><span class="p">],</span> <span class="n">s</span><span class="p">[:</span><span class="n">n_components</span><span class="p">],</span> <span class="n">vt</span><span class="p">[:</span><span class="n">n_components</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">_random_range_finder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes an orthonormal matrix whose range approximates the range of A.&quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_random_status</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># Generate normal random vectors.</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
            <span class="c1"># Ensure f32 is retained as f32</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">power_iteration_normalizer</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">power_iteration_normalizer</span> <span class="o">=</span> <span class="s2">&quot;LU&quot;</span>
        <span class="c1"># use power iterations with q to further compute the top singular vectors of a in q</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">power_iteration_normalizer</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">power_iteration_normalizer</span> <span class="o">==</span> <span class="s2">&quot;LU&quot;</span><span class="p">:</span>
                <span class="n">q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_safe_dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">permute_l</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_safe_dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">permute_l</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># The orthogonal basis is extracted by the linear projection of Q, and the range of a is sampled.</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_safe_dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;economic&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">q</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, MindSpore.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>