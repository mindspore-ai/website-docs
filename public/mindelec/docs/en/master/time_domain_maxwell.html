<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Method for Solving Point Source Maxwell’s Equations &mdash; MindSpore master documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Incremental Training for Solving a Family of Maxwell’s Equation" href="incremental_learning.html" />
    <link rel="prev" title="Physics Informed Deep Learning Method for Electromagnetic Simulation" href="physics_driven.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro_and_install.html">MindSpore Elec Introduction and Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="physics_driven.html">Physics Informed Deep Learning Method for Electromagnetic Simulation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">AI Method for Solving Point Source Maxwell’s Equations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maxwell's-equations">Maxwell’s Equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#description">Description</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dependency">Dependency</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-dataset">Creating a Dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-the-control-equation-and-initial-boundary-value-condition">Defining the Control Equation and Initial Boundary Value Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#building-a-neural-network">Building a Neural Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adaptive-weighted-loss-function-for-accelerating-convergence">Adaptive Weighted Loss Function for Accelerating Convergence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-testing">Model Testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-training">Model Training</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="incremental_learning.html">Incremental Training for Solving a Family of Maxwell’s Equation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_driven.html">Data Driven Deep Learning Method for Electromagnetic Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="AD_FDTD.html">Device-to-device differentiable FDTD method</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualizing Electromagnetic Simulation Results</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindelec.architecture.html">mindelec.architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.common.html">mindelec.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.data.html">mindelec.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.geometry.html">mindelec.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.loss.html">mindelec.loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.operators.html">mindelec.operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.solver.html">mindelec.solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.vision.html">mindelec.vision</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="physics_driven.html">Physics Informed Deep Learning Method for Electromagnetic Simulation</a> &raquo;</li>
      <li>AI Method for Solving Point Source Maxwell’s Equations</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/time_domain_maxwell.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="ai-method-for-solving-point-source-maxwell's-equations">
<h1>AI Method for Solving Point Source Maxwell’s Equations<a class="headerlink" href="#ai-method-for-solving-point-source-maxwell's-equations" title="Permalink to this headline"></a></h1>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/blob/master/docs/mindelec/docs/source_en/time_domain_maxwell.md"><img alt="View Source On Gitee" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source_en.png" /></a>  </p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline"></a></h2>
<p>The rapid development of AI technology provides a new computing paradigm for scientific computing. The MindSpore Elec toolkit supports both data-driven and physics-driven AI methods to handle typical problems in the scientific computing field. The physics-driven AI method combines physical equations and initial boundary conditions to train the model. Compared with the data-driven method, the physics-driven method doesn’t require any labeled data. This tutorial focuses on physics-driven AI methods for solving point source time-domain Maxwell’s equations.</p>
<blockquote>
<div><p>This current sample is for Ascend 910 AI processor. You can find the complete executable code at
<a class="reference external" href="https://gitee.com/mindspore/mindscience/tree/master/MindElec/examples/physics_driven/time_domain_maxwell">https://gitee.com/mindspore/mindscience/tree/master/MindElec/examples/physics_driven/time_domain_maxwell</a></p>
</div></blockquote>
</section>
<section id="maxwell's-equations">
<h2>Maxwell’s Equations<a class="headerlink" href="#maxwell's-equations" title="Permalink to this headline"></a></h2>
<p>The Maxwell’s equations with sources are classical control equations for electromagnetic simulation. They are a set of partial differential equations that describe how electric and magnetic fields are generated by charges and currents of the fields. The specific forms are described as follows:</p>
<div class="math notranslate nohighlight">
\[
\nabla\times E=-\mu \dfrac{\partial H}{\partial t} - J(x, t),
\]</div>
<div class="math notranslate nohighlight">
\[
\nabla\times H=\epsilon \dfrac{\partial E}{\partial t}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span> are the absolute dielectric constant and the absolute magnetic permeability of the medium, respectively. <span class="math notranslate nohighlight">\(J(x, t)\)</span> is the excitation source in the electromagnetic simulation process, and is usually represented in a form of a port pulse. This is mathematically approximated to the point source represented in the form of a Dirac delta function, and may be expressed as:</p>
<div class="math notranslate nohighlight">
\[
J(x, t)=\delta(x - x_0)g(t)
\]</div>
<p>where <span class="math notranslate nohighlight">\(x_0\)</span> is the position of the excitation source, and <span class="math notranslate nohighlight">\(g(t)\)</span> is a function expression form of the pulse signal.</p>
<p>Because the spatial distribution of the point source is a non-continuous function, the physical field near the point source has a gradient that tends to infinity. In another aspect, the excitation source is usually a superposition of signals of multiple frequencies. The existing AI methods based on the physics-informed neural networks cannot converge to solve the multi-scale and singular problems. In MindSpore Elec, Gaussian distribution function smoothing, multi-channel residual network, sin activation function network structure and adaptive weighted multi-task learning strategy make the solution of this kind of problem superior to other frameworks and methods in terms of accuracy and performance. The following uses 2D TE wave simulation as an example to describe how MindSpore Elec solves the Maxwell’s equations.</p>
</section>
<section id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline"></a></h2>
<p>In this tutorial, the electromagnetic field distribution of 2D TE waves in the rectangular domain is simulated, and the Gaussian excitation source is located in the center of the rectangular domain. The control equation and initial and boundary conditions of the problem are shown in the following figure:</p>
<p><img alt="initial and boundary conditions" src="_images/equation_maxwell.png" /></p>
<p>The process for MindSpore Elec to solve the problem is as follows:</p>
<ol class="arabic simple">
<li><p>Randomly sample the rectangular domain and the initial boundary conditions to create a training dataset.</p></li>
<li><p>Define the control equations and solution conditions, and establish the mapping relationship between datasets and constraints.</p></li>
<li><p>Build a neural network.</p></li>
<li><p>Perform network training and inference.</p></li>
</ol>
</section>
<section id="dependency">
<h2>Dependency<a class="headerlink" href="#dependency" title="Permalink to this headline"></a></h2>
<p>Import the modules on which this tutorial depends.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindelec.data</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">mindelec.geometry</span> <span class="kn">import</span> <span class="n">Disk</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">,</span> <span class="n">TimeDomain</span><span class="p">,</span> <span class="n">GeometryWithTime</span>
<span class="kn">from</span> <span class="nn">mindelec.loss</span> <span class="kn">import</span> <span class="n">Constraints</span>
<span class="kn">from</span> <span class="nn">mindelec.solver</span> <span class="kn">import</span> <span class="n">Solver</span><span class="p">,</span> <span class="n">LossAndTimeMonitor</span>
<span class="kn">from</span> <span class="nn">mindelec.common</span> <span class="kn">import</span> <span class="n">L2</span>
<span class="kn">from</span> <span class="nn">mindelec.architecture</span> <span class="kn">import</span> <span class="n">MultiScaleFCCell</span><span class="p">,</span> <span class="n">MTLWeightedLossCell</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">create_random_dataset</span><span class="p">,</span> <span class="n">get_test_data</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">Maxwell2DMur</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">MultiStepLR</span><span class="p">,</span> <span class="n">PredictCallback</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">visual_result</span>
</pre></div>
</div>
<section id="creating-a-dataset">
<h3>Creating a Dataset<a class="headerlink" href="#creating-a-dataset" title="Permalink to this headline"></a></h3>
<p>In addition to loading dataset files in different formats, MindSpore Elec also supports online generation of sample datasets. The Geometry module allows you to create simple geometry, then create complex geometry through logical operations among the simple geometry, and implement sampling within the geometry and on the boundaries.</p>
<p>We implement uniform sampling inside the rectangular computational domain and implement encrypted sampling near the point source and then use it as a separate training dataset. To create a dataset required for training, five samplings need to be implemented: samplings on the rectangular domain constrained by the control equation and on internal points near the source region; samplings on the rectangular domain constrained by the initial condition and on internal points near the source region; boundary sampling on rectangular domain controlled by boundary conditions. The integration of spatial and temporal sampling data constitutes a training sample.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># src region</span>
<span class="n">disk</span> <span class="o">=</span> <span class="n">Disk</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="n">disk_origin</span><span class="p">,</span> <span class="n">disk_radius</span><span class="p">)</span>
<span class="c1"># no src region</span>
<span class="n">rectangle</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="s2">&quot;rect&quot;</span><span class="p">,</span> <span class="n">coord_min</span><span class="p">,</span> <span class="n">coord_max</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">rectangle</span> <span class="o">-</span> <span class="n">disk</span>

<span class="c1"># time info</span>
<span class="n">time_interval</span> <span class="o">=</span> <span class="n">TimeDomain</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;range_t&quot;</span><span class="p">])</span>

<span class="c1"># geometry merge with time</span>
<span class="n">no_src_region</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">no_src_region</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;no_src&quot;</span><span class="p">)</span>
<span class="n">no_src_region</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">no_src_sampling_config</span><span class="p">))</span>
<span class="n">src_region</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">src_region</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span>
<span class="n">src_region</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">src_sampling_config</span><span class="p">))</span>
<span class="n">boundary</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">rectangle</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">boundary</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;bc&quot;</span><span class="p">)</span>
<span class="n">boundary</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">bc_sampling_config</span><span class="p">))</span>

<span class="c1"># final sampling fields</span>
<span class="n">geom_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">src_region</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;IC&quot;</span><span class="p">],</span>
                 <span class="n">no_src_region</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;IC&quot;</span><span class="p">],</span>
                 <span class="n">boundary</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BC&quot;</span><span class="p">]}</span>
</pre></div>
</div>
<p>The MindSpore Elec Dataset API combines different sampled data into a unified training dataset. Therefore, data offloading needs to be performed only once in the training process, and there is no need to call a training network API for each subdataset.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># create dataset for train</span>
<span class="n">elec_train_dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">geom_dict</span><span class="p">)</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_batch_size&quot;</span><span class="p">],</span>
                                                  <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">prebatched_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="defining-the-control-equation-and-initial-boundary-value-condition">
<h3>Defining the Control Equation and Initial Boundary Value Condition<a class="headerlink" href="#defining-the-control-equation-and-initial-boundary-value-condition" title="Permalink to this headline"></a></h3>
<p>Inherit the Problem class provided by MindSpore Elec and allow you to quickly customize PDE problems. One implementation of this problem class can constrain multiple datasets. The member functions governing_equation, boundary_condition, initial_condition, and constraint_function correspond to the control equation, boundary condition, initial condition, and supervised label or function constraint, respectively. You can transfer the column name of the corresponding sample in the dataset in the constructor function to automatically compute the loss function of the sample set. The core code of the PDE problem is defined as follows. The first-order differential equation can be implemented by calling the Grad API, and the second-order differential equation can be implemented by calling the SecondOrderGrad API.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 2d TE-mode Maxwell&#39;s equation&#39;s with 2nd-order Mur boundary condition and static initial electromagnetic field</span>
<span class="k">class</span> <span class="nc">Maxwell2DMur</span><span class="p">(</span><span class="n">Problem</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">domain_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bc_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ic_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Maxwell2DMur</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain_name</span> <span class="o">=</span> <span class="n">domain_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc_name</span> <span class="o">=</span> <span class="n">bc_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ic_name</span> <span class="o">=</span> <span class="n">ic_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="c1"># operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="n">Grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">PI</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">EPS</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_y</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">EPS</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">MU</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">LIGHT_SPEED</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># gauss-type pulse source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_frq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;src_frq&quot;</span><span class="p">,</span> <span class="mf">1e+9</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">((</span><span class="mf">2.3</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">PI</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_frq</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">3.65</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># src space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_pos&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_pos&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_radius&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord_min</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;coord_min&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord_max</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;coord_max&quot;</span><span class="p">]</span>

        <span class="n">input_scale</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;input_scale&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5e+8</span><span class="p">])</span> <span class="c1"># scale of input data to improve accuracy</span>
        <span class="n">output_scale</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_scale&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">37.67303</span><span class="p">,</span> <span class="mf">37.67303</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span> <span class="c1"># scale of output data to improve accuracy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scale</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scale</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scale</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scale</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">smooth_src</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Incentive sources and Gaussian smoothing of Dirac function&quot;&quot;&quot;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp</span> <span class="o">*</span> <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">((</span><span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">gauss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">gauss</span><span class="p">)</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">governing_equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;maxwell equation of TE mode wave&quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># input data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_name</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># get gradients</span>
        <span class="n">dex_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dex_dy</span><span class="p">,</span> <span class="n">dex_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dex_dxyt</span><span class="p">)</span>
        <span class="n">dey_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dey_dx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dey_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dey_dxyt</span><span class="p">)</span>
        <span class="n">dhz_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dhz_dx</span><span class="p">,</span> <span class="n">dhz_dy</span><span class="p">,</span> <span class="n">dhz_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dhz_dxyt</span><span class="p">)</span>

        <span class="c1"># residual of each equation</span>
        <span class="n">loss_a1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="n">dhz_dy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_x</span><span class="p">)</span>
        <span class="n">loss_a2</span> <span class="o">=</span> <span class="n">dex_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">loss_b1</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="n">dhz_dx</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_y</span><span class="p">)</span>
        <span class="n">loss_b2</span> <span class="o">=</span> <span class="n">dey_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">loss_c1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="n">dey_dx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="n">dex_dy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">)</span>
        <span class="n">loss_c2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_src</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">)</span>

        <span class="n">pde_r1</span> <span class="o">=</span> <span class="n">loss_a1</span> <span class="o">-</span> <span class="n">loss_a2</span>
        <span class="n">pde_r2</span> <span class="o">=</span> <span class="n">loss_b1</span> <span class="o">-</span> <span class="n">loss_b2</span>
        <span class="n">pde_r3</span> <span class="o">=</span> <span class="n">loss_c1</span> <span class="o">-</span> <span class="n">loss_c2</span> <span class="o">-</span> <span class="n">src</span>
        <span class="c1"># total residual</span>
        <span class="n">pde_r</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="mi">1</span><span class="p">)((</span><span class="n">pde_r1</span><span class="p">,</span> <span class="n">pde_r2</span><span class="p">,</span> <span class="n">pde_r3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pde_r</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2nd-order mur boundary condition&quot;&quot;&quot;</span>
        <span class="c1"># network input and output</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc_name</span><span class="p">]</span>

        <span class="c1"># specify each boundary</span>
        <span class="n">coord_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_min</span>
        <span class="n">coord_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_max</span>
        <span class="n">batch_size</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">attr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coord_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">attr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coord_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">attr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coord_min</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">attr</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coord_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># get gradients</span>
        <span class="n">dex_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dex_dy</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dex_dxyt</span><span class="p">)</span>
        <span class="n">dey_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dey_dx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dey_dxyt</span><span class="p">)</span>
        <span class="n">dhz_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dhz_dx</span><span class="p">,</span> <span class="n">dhz_dy</span><span class="p">,</span> <span class="n">dhz_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dhz_dxyt</span><span class="p">)</span>

        <span class="c1"># residual of each boundary</span>
        <span class="n">bc_r1</span> <span class="o">=</span> <span class="n">dhz_dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dex_dy</span>  <span class="c1"># left boundary</span>
        <span class="n">bc_r2</span> <span class="o">=</span> <span class="n">dhz_dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">+</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dex_dy</span>  <span class="c1"># right boundary</span>
        <span class="n">bc_r3</span> <span class="o">=</span> <span class="n">dhz_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dey_dx</span>  <span class="c1"># lower boundary</span>
        <span class="n">bc_r4</span> <span class="o">=</span> <span class="n">dhz_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">+</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dey_dx</span>  <span class="c1"># upper boundary</span>
        <span class="n">bc_r_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">bc_r1</span><span class="p">,</span> <span class="n">bc_r2</span><span class="p">,</span> <span class="n">bc_r3</span><span class="p">,</span> <span class="n">bc_r4</span><span class="p">))</span>
        <span class="n">bc_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">bc_r_all</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bc_r</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">initial_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;initial condition: u = 0&quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>It should be noted that adjusting the input and output of the network to a proper value range (for example, [0,1]) during the experiment can significantly improve the training speed and accuracy of the model. In the preceding code, input_scale and output_scale are scale coefficients for optimization. Therefore, the corresponding Maxwell’s equations and initial boundary condition are also in this form after coordinate scaling. In order to simulate the point source problem effectively, the Dirac function in the equation is approximated by the smooth Gaussian probability distribution. In the preceding code, the excitation source and the function form of Gaussian smoothing approximation are implemented in smooth_src, and a variance of Gaussian smoothing is 0.0025, which produces a very good result.</p>
<p>The Constraint API establishes a mapping between the unified dataset and user-defined problems (for example, Maxwell2DMur inherited from the Problem class). In this way, a constraint condition corresponding to each subdataset is obtained in the network to automatically compute the loss function. To complete this step, a dictionary is created by initializing the corresponding Problem for each subdataset. The dictionary key corresponds to the subdataset, and the key value corresponds to the problem class. The loss function is automatically computed based on the constraint_type attribute of each dataset. The constraint_type supports five forms: control equation, initial condition, boundary condition, label, and function. You need to explicitly define the corresponding control condition in the problem class based on the specific form. For example, for the sampling points in the source-free region, the constraint_type of the dataset is Equation. In this case, you must define the governing_equation function in the problem class Maxwell2DMur to restrict the dataset. You can pass the dataset and problem dictionary to the Constraints API to complete the mapping between the dataset and constraint conditions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># define constraints</span>
<span class="n">train_prob</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">all_datasets</span><span class="p">:</span>
    <span class="n">train_prob</span><span class="p">[</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Maxwell2DMur</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
                                            <span class="n">domain_name</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">,</span>
                                            <span class="n">ic_name</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">,</span>
                                            <span class="n">bc_name</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;check problem: &quot;</span><span class="p">,</span> <span class="n">train_prob</span><span class="p">)</span>
<span class="n">train_constraints</span> <span class="o">=</span> <span class="n">Constraints</span><span class="p">(</span><span class="n">elec_train_dataset</span><span class="p">,</span> <span class="n">train_prob</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="building-a-neural-network">
<h3>Building a Neural Network<a class="headerlink" href="#building-a-neural-network" title="Permalink to this headline"></a></h3>
<p>In this example, the multi-channel residual network and Sin activation function are used to obtain higher accuracy than other methods in the simulation of the problem. The following figure shows the structure of the neural network.</p>
<p><img alt="structure of the neural network" src="_images/multi-scale-NN.png" /></p>
<p>The basic structure of a single-scale network consists of multi-layer residual full-connection networks. The multi-scale network of exponential channels is implemented as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MultiScaleFCCell</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_channel</span><span class="p">,</span>
                 <span class="n">out_channel</span><span class="p">,</span>
                 <span class="n">layers</span><span class="p">,</span>
                 <span class="n">neurons</span><span class="p">,</span>
                 <span class="n">residual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">act</span><span class="o">=</span><span class="s2">&quot;sin&quot;</span><span class="p">,</span>
                 <span class="n">weight_init</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span>
                 <span class="n">has_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">bias_init</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
                 <span class="n">num_scales</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">amp_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">scale_factor</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                 <span class="n">input_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">input_center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">latent_vector</span><span class="o">=</span><span class="kc">None</span>
                 <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiScaleFCCell</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">_check_type</span><span class="p">(</span><span class="n">num_scales</span><span class="p">,</span> <span class="s2">&quot;num_scales&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell_list</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">CellList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_scales</span> <span class="o">=</span> <span class="n">num_scales</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_coef</span> <span class="o">=</span> <span class="p">[</span><span class="n">amp_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">scale_factor</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scales</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">latent_vector</span> <span class="o">=</span> <span class="n">latent_vector</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_check_type</span><span class="p">(</span><span class="n">latent_vector</span><span class="p">,</span> <span class="s2">&quot;latent_vector&quot;</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_scenarios</span> <span class="o">=</span> <span class="n">latent_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span> <span class="o">=</span> <span class="n">latent_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">in_channel</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_scenarios</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># full-connect network</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scales</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FCSequential</span><span class="p">(</span><span class="n">in_channel</span><span class="o">=</span><span class="n">in_channel</span><span class="p">,</span>
                                               <span class="n">out_channel</span><span class="o">=</span><span class="n">out_channel</span><span class="p">,</span>
                                               <span class="n">layers</span><span class="o">=</span><span class="n">layers</span><span class="p">,</span>
                                               <span class="n">neurons</span><span class="o">=</span><span class="n">neurons</span><span class="p">,</span>
                                               <span class="n">residual</span><span class="o">=</span><span class="n">residual</span><span class="p">,</span>
                                               <span class="n">act</span><span class="o">=</span><span class="n">act</span><span class="p">,</span>
                                               <span class="n">weight_init</span><span class="o">=</span><span class="n">weight_init</span><span class="p">,</span>
                                               <span class="n">has_bias</span><span class="o">=</span><span class="n">has_bias</span><span class="p">,</span>
                                               <span class="n">bias_init</span><span class="o">=</span><span class="n">bias_init</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">input_scale</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">=</span> <span class="n">InputScaleNet</span><span class="p">(</span><span class="n">input_scale</span><span class="p">,</span> <span class="n">input_center</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;running multi-scale net&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">latent_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_vector</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scenarios</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_scenarios</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">latent_vectors</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scales</span><span class="p">):</span>
            <span class="n">x_s</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_coef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_list</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x_s</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">MultiScaleFCCell</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_size&quot;</span><span class="p">],</span>
                         <span class="n">config</span><span class="p">[</span><span class="s2">&quot;output_size&quot;</span><span class="p">],</span>
                         <span class="n">layers</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;layers&quot;</span><span class="p">],</span>
                         <span class="n">neurons</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;neurons&quot;</span><span class="p">],</span>
                         <span class="n">input_scale</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_scale&quot;</span><span class="p">],</span>
                         <span class="n">residual</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;residual&quot;</span><span class="p">],</span>
                         <span class="n">weight_init</span><span class="o">=</span><span class="n">HeUniform</span><span class="p">(</span><span class="n">negative_slope</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span>
                         <span class="n">act</span><span class="o">=</span><span class="s2">&quot;sin&quot;</span><span class="p">,</span>
                         <span class="n">num_scales</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_scales&quot;</span><span class="p">],</span>
                         <span class="n">amp_factor</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;amp_factor&quot;</span><span class="p">],</span>
                         <span class="n">scale_factor</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">]</span>
                         <span class="p">)</span>
</pre></div>
</div>
</section>
<section id="adaptive-weighted-loss-function-for-accelerating-convergence">
<h3>Adaptive Weighted Loss Function for Accelerating Convergence<a class="headerlink" href="#adaptive-weighted-loss-function-for-accelerating-convergence" title="Permalink to this headline"></a></h3>
<p>The Physics-Informed Neural Networks (PINNs) directly uses the governing equations for network training. The loss function of the network usually includes residuals of the governing equation, the boundary condition, and the initial condition. In this case, because the encrypted sampling near the source region is viewed as an independent subdataset for network training, the composition of the loss function includes the following five parts: a control equation and an initial condition of the source region, a control equation and an initial condition of the source-free region, and a boundary condition. Experiments show that the five components in the loss function differ greatly in magnitude, so the simple summation of the loss functions will lead to the failure of network training, and the manual adjustment of the weight information of each loss function is very cumbersome. MindSpore Elec develops a weighting algorithm based on uncertainty estimation of multi-task learning. By introducing trainable parameters and adaptively adjusting the weight of each loss function, MindSpore Elec can significantly improve the training speed and accuracy. The algorithm is implemented as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MTLWeightedLossCell</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_losses</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MTLWeightedLossCell</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">auto_prefix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_losses</span> <span class="o">=</span> <span class="n">num_losses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_losses</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pow</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Pow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Log</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">div</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">RealDiv</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">losses</span><span class="p">):</span>
        <span class="n">loss_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_losses</span><span class="p">):</span>
            <span class="n">weighted_loss</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">loss_sum</span> <span class="o">=</span> <span class="n">loss_sum</span> <span class="o">+</span> <span class="n">weighted_loss</span>
        <span class="k">return</span> <span class="n">loss_sum</span>

<span class="c1"># self-adaptive weighting</span>
<span class="n">mtl</span> <span class="o">=</span> <span class="n">MTLWeightedLossCell</span><span class="p">(</span><span class="n">num_losses</span><span class="o">=</span><span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">num_dataset</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="model-testing">
<h3>Model Testing<a class="headerlink" href="#model-testing" title="Permalink to this headline"></a></h3>
<p>MindSpore Elec can use the user-defined callback function to implement training and inference at the same time. You can directly load the test dataset and implement the user-defined callback function to implement inference and analyze the result.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loss_time_callback</span> <span class="o">=</span> <span class="n">LossAndTimeMonitor</span><span class="p">(</span><span class="n">steps_per_epoch</span><span class="p">)</span>
<span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">loss_time_callback</span><span class="p">]</span>
<span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;train_with_eval&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">inputs</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">get_test_data</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;test_data_path&quot;</span><span class="p">])</span>
    <span class="n">predict_callback</span> <span class="o">=</span> <span class="n">PredictCallback</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span> <span class="n">visual_fn</span><span class="o">=</span><span class="n">visual_result</span><span class="p">)</span>
    <span class="n">callbacks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">predict_callback</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="model-training">
<h3>Model Training<a class="headerlink" href="#model-training" title="Permalink to this headline"></a></h3>
<p>The Solver class provided by MindSpore Elec is an API for model training and inference. You can set the optimizer, network model, PDE constraints (train_constraints), and optional parameters such as the adaptive weighting algorithm module to define the solver object. In this tutorial, the MindSpore + Ascend mixed precision mode is used to train the network to solve the Maxwell’s equations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># mixed precision</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">input_scale</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># optimizer</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span> <span class="o">+</span> <span class="n">mtl</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
<span class="n">lr_scheduler</span> <span class="o">=</span> <span class="n">MultiStepLR</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;milestones&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr_gamma&quot;</span><span class="p">],</span> <span class="n">steps_per_epoch</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">])</span>
<span class="n">lr</span> <span class="o">=</span> <span class="n">lr_scheduler</span><span class="o">.</span><span class="n">get_lr</span><span class="p">()</span>
<span class="n">optim</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="n">Tensor</span><span class="p">(</span><span class="n">lr</span><span class="p">))</span>

<span class="c1"># define solver</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">model</span><span class="p">,</span>
                <span class="n">optimizer</span><span class="o">=</span><span class="n">optim</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;PINNs&quot;</span><span class="p">,</span>
                <span class="n">train_constraints</span><span class="o">=</span><span class="n">train_constraints</span><span class="p">,</span>
                <span class="n">test_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">metrics</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;l2&#39;</span><span class="p">:</span> <span class="n">L2</span><span class="p">(),</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">MAE</span><span class="p">()},</span>
                <span class="n">loss_fn</span><span class="o">=</span><span class="s1">&#39;smooth_l1_loss&#39;</span><span class="p">,</span>
                <span class="n">loss_scale_manager</span><span class="o">=</span><span class="n">DynamicLossScaleManager</span><span class="p">(</span><span class="n">init_loss_scale</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span><span class="p">,</span> <span class="n">scale_window</span><span class="o">=</span><span class="mi">2000</span><span class="p">),</span>
                <span class="n">mtl_weighted_cell</span><span class="o">=</span><span class="n">mtl</span><span class="p">,</span>
                <span class="p">)</span>

<span class="n">solver</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">],</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The instantaneous electromagnetic fields compared with the reference labels are depicted in the following figure.</p>
<p><img alt="instantaneous electromagnetic fields" src="_images/maxwell_result.png" /></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="physics_driven.html" class="btn btn-neutral float-left" title="Physics Informed Deep Learning Method for Electromagnetic Simulation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="incremental_learning.html" class="btn btn-neutral float-right" title="Incremental Training for Solving a Family of Maxwell’s Equation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
        <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>