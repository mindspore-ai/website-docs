<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>增量训练求解麦克斯韦方程族 &mdash; MindSpore master 文档</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script><script src="_static/jquery.js"></script>
        <script src="_static/js/theme.js"></script><script src="_static/underscore.js"></script><script src="_static/doctools.js"></script><script src="_static/translations.js"></script><script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/mathjax/MathJax-3.2.2/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="数据驱动的AI电磁仿真方法" href="data_driven.html" />
    <link rel="prev" title="点源时域麦克斯韦方程AI求解" href="time_domain_maxwell.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">安装部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro_and_install.html">MindSpore Elec介绍和安装</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">应用实践</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="physics_driven.html">物理驱动的AI电磁仿真方法</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="time_domain_maxwell.html">点源时域麦克斯韦方程AI求解</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">增量训练求解麦克斯韦方程族</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#概述">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#问题描述">问题描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#基于物理信息的自解码器">基于物理信息的自解码器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#导入依赖">导入依赖</a></li>
<li class="toctree-l4"><a class="reference internal" href="#创建数据集">创建数据集</a></li>
<li class="toctree-l4"><a class="reference internal" href="#定义控制方程及初边值条件">定义控制方程及初边值条件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#构建神经网络">构建神经网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="#自适应加权损失函数加速收敛">自适应加权损失函数加速收敛</a></li>
<li class="toctree-l4"><a class="reference internal" href="#模型测试">模型测试</a></li>
<li class="toctree-l4"><a class="reference internal" href="#模型预训练">模型预训练</a></li>
<li class="toctree-l4"><a class="reference internal" href="#模型增量训练">模型增量训练</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_driven.html">数据驱动的AI电磁仿真方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="AD_FDTD.html">端到端可微分的FDTD方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">电磁仿真结果可视化</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindelec.architecture.html">mindelec.architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.common.html">mindelec.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.data.html">mindelec.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.geometry.html">mindelec.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.loss.html">mindelec.loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.operators.html">mindelec.operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.solver.html">mindelec.solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.vision.html">mindelec.vision</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="physics_driven.html">物理驱动的AI电磁仿真方法</a> &raquo;</li>
      <li>增量训练求解麦克斯韦方程族</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/incremental_learning.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="增量训练求解麦克斯韦方程族">
<h1>增量训练求解麦克斯韦方程族<a class="headerlink" href="#增量训练求解麦克斯韦方程族" title="永久链接至标题"></a></h1>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/blob/master/docs/mindelec/docs/source_zh_cn/incremental_learning.md"><img alt="查看源文件" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source.svg" /></a>  </p>
<section id="概述">
<h2>概述<a class="headerlink" href="#概述" title="永久链接至标题"></a></h2>
<p>原始的PINNs（Physics-Informed Neural Networks, PINNs）方法不具备求解一类方程的能力。当方程中的特征参数（如介电系数等）发生变化时需要重新训练，增加了求解时间。</p>
<p>本教程重点介绍基于MindSpore Elec套件的物理信息自解码器（Physics-Informed Auto-Decoder）增量训练方法，该方法可以快速求解同一类方程，极大减少重新训练的时间。</p>
<blockquote>
<div><p>本例面向Atlas训练系列产品，你可以在这里下载完整的样例代码：
<a class="reference external" href="https://gitee.com/mindspore/mindscience/tree/master/MindElec/examples/physics_driven/incremental_learning">https://gitee.com/mindspore/mindscience/tree/master/MindElec/examples/physics_driven/incremental_learning</a></p>
</div></blockquote>
</section>
<section id="问题描述">
<h2>问题描述<a class="headerlink" href="#问题描述" title="永久链接至标题"></a></h2>
<p>本案例处理点源麦克斯韦方程的介质参数泛化求解问题。控制方程的具体形式以及求解域和激励源配置可以参考<a class="reference external" href="https://www.mindspore.cn/mindelec/docs/zh-CN/master/time_domain_maxwell.html">点源问题的求解教程</a>。</p>
</section>
<section id="基于物理信息的自解码器">
<h2>基于物理信息的自解码器<a class="headerlink" href="#基于物理信息的自解码器" title="永久链接至标题"></a></h2>
<p>通常情况下，待求解方程中的可变参数<span class="math notranslate nohighlight">\(\lambda\)</span> 的分布构成高维空间。为了降低模型复杂度以及训练成本，我们提出了基于物理信息的自解码器来求解同一类的方程族。该方法首先将高维可变参数空间映射到由低维向量表征的低维流形上，然后将流形的特征参数与方程的输入融合作为点源问题求解网络的输入一起参与到PINNs的训练中，由此可以得到预训练模型。针对新给定的可变参数问题，对预训练模型进行微调即可以得到新方程的解。</p>
<p>MindSpore Elec基于物理信息的自解码器求解该问题的具体流程如下：</p>
<ul>
<li><p>基于隐向量和神经网络的结合对一系列方程组进行预训练。与求解单个问题不同，预训练步骤中，神经网络的输入为采样点（X）与隐向量（Z）的融合，具体如下图所示：</p>
<p><img alt="TE_for_Maxwell" src="_images/pretrain_model.png" /></p>
</li>
<li><p>针对新的方程组，对隐向量和神经网络进行增量训练，快速求解新问题。这里我们提供了两种增量训练模式：</p>
<ul class="simple">
<li><p>finetune_latent_with_model: 该方式同时更新隐向量和网络结构，只需要加载预训练的模型进行增量训练即可。</p></li>
<li><p>finetune_latent_only: 如下图所示，该方式固定网络结构，在增量训练中只更新隐向量。</p></li>
</ul>
<p><img alt="TE_for_Maxwell" src="_images/finetune_latent.png" /></p>
</li>
</ul>
<section id="导入依赖">
<h3>导入依赖<a class="headerlink" href="#导入依赖" title="永久链接至标题"></a></h3>
<p>导入本教程依赖的模块与接口：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindelec.data</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">mindelec.geometry</span> <span class="kn">import</span> <span class="n">Disk</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">,</span> <span class="n">TimeDomain</span><span class="p">,</span> <span class="n">GeometryWithTime</span>
<span class="kn">from</span> <span class="nn">mindelec.loss</span> <span class="kn">import</span> <span class="n">Constraints</span>
<span class="kn">from</span> <span class="nn">mindelec.solver</span> <span class="kn">import</span> <span class="n">Solver</span><span class="p">,</span> <span class="n">LossAndTimeMonitor</span>
<span class="kn">from</span> <span class="nn">mindelec.common</span> <span class="kn">import</span> <span class="n">L2</span>
<span class="kn">from</span> <span class="nn">mindelec.architecture</span> <span class="kn">import</span> <span class="n">MultiScaleFCCell</span><span class="p">,</span> <span class="n">MTLWeightedLossCell</span>

<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">get_test_data</span><span class="p">,</span> <span class="n">create_random_dataset</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">MultiStepLR</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">Maxwell2DMur</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">PredictCallback</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">visual_result</span>
</pre></div>
</div>
</section>
<section id="创建数据集">
<h3>创建数据集<a class="headerlink" href="#创建数据集" title="永久链接至标题"></a></h3>
<p>与点源麦克斯韦方程的方式一致，我们在矩形计算域进行5次均匀采样，即由控制方程所约束的矩形域和源区附近的内部点采样；由初始条件所约束的矩形域和源区附近的内部点采样；以及由边界条件所控制的矩形域边界采样。空间采样与时间采样数据组合构成了训练样本。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># src region</span>
<span class="n">disk</span> <span class="o">=</span> <span class="n">Disk</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="n">disk_origin</span><span class="p">,</span> <span class="n">disk_radius</span><span class="p">)</span>
<span class="c1"># no src region</span>
<span class="n">rectangle</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="s2">&quot;rect&quot;</span><span class="p">,</span> <span class="n">coord_min</span><span class="p">,</span> <span class="n">coord_max</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">rectangle</span> <span class="o">-</span> <span class="n">disk</span>

<span class="c1"># time info</span>
<span class="n">time_interval</span> <span class="o">=</span> <span class="n">TimeDomain</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;range_t&quot;</span><span class="p">])</span>

<span class="c1"># geometry merge with time</span>
<span class="n">no_src_region</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">no_src_region</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;no_src&quot;</span><span class="p">)</span>
<span class="n">no_src_region</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">no_src_sampling_config</span><span class="p">))</span>
<span class="n">src_region</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">src_region</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span>
<span class="n">src_region</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">src_sampling_config</span><span class="p">))</span>
<span class="n">boundary</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">rectangle</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">boundary</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;bc&quot;</span><span class="p">)</span>
<span class="n">boundary</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">bc_sampling_config</span><span class="p">))</span>

<span class="c1"># final sampling fields</span>
<span class="n">geom_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">src_region</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;IC&quot;</span><span class="p">],</span>
                <span class="n">no_src_region</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;IC&quot;</span><span class="p">],</span>
                <span class="n">boundary</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BC&quot;</span><span class="p">]}</span>
</pre></div>
</div>
<p>MindSpore Elec提供了将不同的采样数据合并为统一训练数据集的Dataset接口。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># create dataset for train</span>
<span class="n">elec_train_dataset</span> <span class="o">=</span> <span class="n">create_random_dataset</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;batch_size&quot;</span><span class="p">],</span>
                                                  <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">prebatched_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="定义控制方程及初边值条件">
<h3>定义控制方程及初边值条件<a class="headerlink" href="#定义控制方程及初边值条件" title="永久链接至标题"></a></h3>
<p>继承MindSpore Elec提供的Problem类，我们定义该偏微分方程（partial differential equation，PDE）问题的核心代码如下。与求解单个点源问题不同，这里还传入了不同的参数<code class="docutils literal notranslate"><span class="pre">eps_candidates</span></code>， <code class="docutils literal notranslate"><span class="pre">mu_candidates</span></code>代表相对介电常数和相对磁导率。本案例中我们的预训练的参数选择为<span class="math notranslate nohighlight">\((\epsilon_r, \mu_r)\in [1,3,5]*[1,3,5]\)</span>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Maxwell2DMur</span><span class="p">(</span><span class="n">Problem</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">domain_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bc_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ic_column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Maxwell2DMur</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain_column</span> <span class="o">=</span> <span class="n">domain_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc_column</span> <span class="o">=</span> <span class="n">bc_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ic_column</span> <span class="o">=</span> <span class="n">ic_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>

        <span class="c1"># operations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span> <span class="o">=</span> <span class="n">Grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">()</span>

        <span class="c1"># gauss-type pulse source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">PI</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_frq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;src_frq&quot;</span><span class="p">,</span> <span class="mf">1e+9</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">((</span><span class="mf">2.3</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">PI</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_frq</span><span class="p">),</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">3.65</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># src space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_x0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_pos&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_y0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_pos&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_sigma</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_radius&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_coord_min</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;coord_min&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_coord_max</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;coord_max&quot;</span><span class="p">]</span>

        <span class="n">input_scales</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;input_scales&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5e+8</span><span class="p">])</span>
        <span class="n">output_scales</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_scales&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">37.67303</span><span class="p">,</span> <span class="mf">37.67303</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scales</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scales</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scales</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scales</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># set up eps, mu candidates</span>
        <span class="n">eps_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;eps_list&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">EPS</span>
        <span class="n">mu_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;mu_list&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">MU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">eps_candidates</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_y</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">eps_candidates</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">mu_candidates</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">ops</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">()(</span><span class="n">ops</span><span class="o">.</span><span class="n">Mul</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">))</span>

    <span class="c1"># gaussian pulse with gaussian smooth technology</span>
    <span class="k">def</span> <span class="nf">smooth_src</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp</span> <span class="o">*</span> <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">((</span><span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">gauss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">gauss</span><span class="p">)</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">governing_equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;maxwell equation of TE mode wave&quot;&quot;&quot;</span>
        <span class="c1"># net output and sampling input</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_column</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># get gradients</span>
        <span class="n">dex_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dex_dy</span><span class="p">,</span> <span class="n">dex_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dex_dxyt</span><span class="p">)</span>
        <span class="n">dey_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">dey_dx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dey_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dey_dxyt</span><span class="p">)</span>
        <span class="n">dhz_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">dhz_dx</span><span class="p">,</span> <span class="n">dhz_dy</span><span class="p">,</span> <span class="n">dhz_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dhz_dxyt</span><span class="p">)</span>

        <span class="c1"># get equation residual</span>
        <span class="n">loss_a1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="n">dhz_dy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span><span class="p">)</span>
        <span class="n">loss_a2</span> <span class="o">=</span> <span class="n">dex_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">loss_b1</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="n">dhz_dx</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_y</span><span class="p">)</span>
        <span class="n">loss_b2</span> <span class="o">=</span> <span class="n">dey_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">loss_c1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="n">dey_dx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="n">dex_dy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">)</span>
        <span class="n">loss_c2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_src</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">)</span>

        <span class="n">pde_res1</span> <span class="o">=</span> <span class="n">loss_a1</span> <span class="o">-</span> <span class="n">loss_a2</span>
        <span class="n">pde_res2</span> <span class="o">=</span> <span class="n">loss_b1</span> <span class="o">-</span> <span class="n">loss_b2</span>
        <span class="n">pde_res3</span> <span class="o">=</span> <span class="n">loss_c1</span> <span class="o">-</span> <span class="n">loss_c2</span> <span class="o">-</span> <span class="n">source</span>
        <span class="n">pde_r</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="mi">1</span><span class="p">)((</span><span class="n">pde_res1</span><span class="p">,</span> <span class="n">pde_res2</span><span class="p">,</span> <span class="n">pde_res3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pde_r</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2nd-order mur boundary condition&quot;&quot;&quot;</span>
        <span class="c1"># get net output and inputs</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc_column</span><span class="p">]</span>

        <span class="c1"># specify each boundary</span>
        <span class="n">coord_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_coord_min</span>
        <span class="n">coord_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_coord_max</span>
        <span class="n">batch_size</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">bc_attr</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">bc_attr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coord_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">bc_attr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coord_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">bc_attr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coord_min</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">bc_attr</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coord_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="n">dex_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dex_dy</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dex_dxyt</span><span class="p">)</span>
        <span class="n">dey_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dey_dx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dey_dxyt</span><span class="p">)</span>
        <span class="n">dhz_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dhz_dx</span><span class="p">,</span> <span class="n">dhz_dy</span><span class="p">,</span> <span class="n">dhz_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dhz_dxyt</span><span class="p">)</span>

        <span class="n">bc_r1</span> <span class="o">=</span> <span class="n">dhz_dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dex_dy</span>  <span class="c1"># 左边界</span>
        <span class="n">bc_r2</span> <span class="o">=</span> <span class="n">dhz_dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">+</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dex_dy</span>  <span class="c1"># 右边界</span>
        <span class="n">bc_r3</span> <span class="o">=</span> <span class="n">dhz_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dey_dx</span>  <span class="c1"># 下边界</span>
        <span class="n">bc_r4</span> <span class="o">=</span> <span class="n">dhz_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">+</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dey_dx</span>  <span class="c1"># 上边界</span>

        <span class="n">bc_r_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">bc_r1</span><span class="p">,</span> <span class="n">bc_r2</span><span class="p">,</span> <span class="n">bc_r3</span><span class="p">,</span> <span class="n">bc_r4</span><span class="p">))</span>
        <span class="n">bc_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">bc_r_all</span><span class="p">,</span> <span class="n">bc_attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bc_r</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">initial_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;initial condition: u = 0&quot;&quot;&quot;</span>
        <span class="n">net_out</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">net_out</span>
</pre></div>
</div>
<p>对问题约束条件的定义如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># define constraints</span>
<span class="n">train_prob</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">all_datasets</span><span class="p">:</span>
    <span class="n">train_prob</span><span class="p">[</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Maxwell2DMur</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
                                            <span class="n">domain_column</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">,</span>
                                            <span class="n">ic_column</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">,</span>
                                            <span class="n">bc_column</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">)</span>
<span class="n">train_constraints</span> <span class="o">=</span> <span class="n">Constraints</span><span class="p">(</span><span class="n">elec_train_dataset</span><span class="p">,</span> <span class="n">train_prob</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="构建神经网络">
<h3>构建神经网络<a class="headerlink" href="#构建神经网络" title="永久链接至标题"></a></h3>
<p>在基于物理信息的自解码器中，神经网络的输入为采样点（X）与隐向量（Z）的融合，神经网络的主体结构采用多通道残差网络并结合Sin激活函数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># initialize latent vector</span>
<span class="n">num_scenarios</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_scenarios&quot;</span><span class="p">]</span>
<span class="n">latent_size</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;latent_vector_size&quot;</span><span class="p">]</span>
<span class="n">latent_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_scenarios</span><span class="p">,</span> <span class="n">latent_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">latent_size</span><span class="p">)</span>
<span class="n">latent_vector</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">latent_init</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">network</span> <span class="o">=</span> <span class="n">MultiScaleFCCell</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_size&quot;</span><span class="p">],</span>
                           <span class="n">config</span><span class="p">[</span><span class="s2">&quot;output_size&quot;</span><span class="p">],</span>
                           <span class="n">layers</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;layers&quot;</span><span class="p">],</span>
                           <span class="n">neurons</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;neurons&quot;</span><span class="p">],</span>
                           <span class="n">residual</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;residual&quot;</span><span class="p">],</span>
                           <span class="n">weight_init</span><span class="o">=</span><span class="n">HeUniform</span><span class="p">(</span><span class="n">negative_slope</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span>
                           <span class="n">act</span><span class="o">=</span><span class="s2">&quot;sin&quot;</span><span class="p">,</span>
                           <span class="n">num_scales</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_scales&quot;</span><span class="p">],</span>
                           <span class="n">amp_factor</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;amp_factor&quot;</span><span class="p">],</span>
                           <span class="n">scale_factor</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">],</span>
                           <span class="n">input_scale</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_scale&quot;</span><span class="p">],</span>
                           <span class="n">input_center</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_center&quot;</span><span class="p">],</span>
                           <span class="n">latent_vector</span><span class="o">=</span><span class="n">latent_vector</span>
                           <span class="p">)</span>
</pre></div>
</div>
</section>
<section id="自适应加权损失函数加速收敛">
<h3>自适应加权损失函数加速收敛<a class="headerlink" href="#自适应加权损失函数加速收敛" title="永久链接至标题"></a></h3>
<p>在本案例中，由于源区附近区域的加密采样并作为独立子数据集进行网络训练，因此损失函数的构成包含如下五项：有源区域的控制方程和初始条件、无源区域的控制方程和初始条件以及边界条件。实验表明，这五项损失函数量级差异明显，因此简单的损失函数求和会导致网络训练失败，而手动调节每项损失函数的权重信息极为繁琐。MindSpore Elec发展了一种基于多任务学习不确定性估计的加权算法，通过引入可训的参数，自适应地调节每项损失函数的权重，可以显著地提升训练速度和精度。该算法的实现具体如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MTLWeightedLossCell</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_losses</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MTLWeightedLossCell</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">auto_prefix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_losses</span> <span class="o">=</span> <span class="n">num_losses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_losses</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pow</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Pow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Log</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">div</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">RealDiv</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">losses</span><span class="p">):</span>
        <span class="n">loss_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_losses</span><span class="p">):</span>
            <span class="n">weighted_loss</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">loss_sum</span> <span class="o">=</span> <span class="n">loss_sum</span> <span class="o">+</span> <span class="n">weighted_loss</span>
        <span class="k">return</span> <span class="n">loss_sum</span>

<span class="c1"># self-adaptive weighting</span>
<span class="n">mtl</span> <span class="o">=</span> <span class="n">MTLWeightedLossCell</span><span class="p">(</span><span class="n">num_losses</span><span class="o">=</span><span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">num_dataset</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="模型测试">
<h3>模型测试<a class="headerlink" href="#模型测试" title="永久链接至标题"></a></h3>
<p>MindSpore Elec可以通过自定义的callback函数，利用边训练边推理的功能。用户可以直接加载测试数据集，然后实现自定义的callback函数实现推理并分析结果。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">LossAndTimeMonitor</span><span class="p">(</span><span class="n">epoch_steps</span><span class="p">)]</span>
<span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;train_with_eval&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">input_data</span><span class="p">,</span> <span class="n">label_data</span> <span class="o">=</span> <span class="n">get_test_data</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;test_data_path&quot;</span><span class="p">])</span>
    <span class="n">eval_callback</span> <span class="o">=</span> <span class="n">PredictCallback</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">label_data</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span> <span class="n">visual_fn</span><span class="o">=</span><span class="n">visual_result</span><span class="p">)</span>
    <span class="n">callbacks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">eval_callback</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="模型预训练">
<h3>模型预训练<a class="headerlink" href="#模型预训练" title="永久链接至标题"></a></h3>
<p>MindSpore Elec提供的Solver类是模型训练和推理的接口。输入优化器和网络模型以及PDE的约束（train_constraints），以及可选参数如自适应加权算法模块，即可定义求解器对象solver。在该案例中利用MindSpore + Ascend混合精度模式训练网络，从而完成求解麦克斯韦方程。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># mixed precision</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">input_scale</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># optimizer</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span> <span class="o">+</span> <span class="n">mtl</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
<span class="n">lr_scheduler</span> <span class="o">=</span> <span class="n">MultiStepLR</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;milestones&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr_gamma&quot;</span><span class="p">],</span>
                           <span class="n">epoch_steps</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">])</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="n">Tensor</span><span class="p">(</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">get_lr</span><span class="p">()))</span>

<span class="c1"># problem solver</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">network</span><span class="p">,</span>
                <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;PINNs&quot;</span><span class="p">,</span>
                <span class="n">train_constraints</span><span class="o">=</span><span class="n">train_constraints</span><span class="p">,</span>
                <span class="n">test_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">metrics</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;l2&#39;</span><span class="p">:</span> <span class="n">L2</span><span class="p">(),</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">MAE</span><span class="p">()},</span>
                <span class="n">loss_fn</span><span class="o">=</span><span class="s1">&#39;smooth_l1_loss&#39;</span><span class="p">,</span>
                <span class="n">loss_scale_manager</span><span class="o">=</span><span class="n">DynamicLossScaleManager</span><span class="p">(),</span>
                <span class="n">mtl_weighted_cell</span><span class="o">=</span><span class="n">mtl_cell</span><span class="p">,</span>
                <span class="n">latent_vector</span><span class="o">=</span><span class="n">latent_vector</span><span class="p">,</span>
                <span class="n">latent_reg</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;latent_reg&quot;</span><span class="p">]</span>
                <span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">],</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="模型增量训练">
<h3>模型增量训练<a class="headerlink" href="#模型增量训练" title="永久链接至标题"></a></h3>
<p>针对于新的问题参数，以<span class="math notranslate nohighlight">\(（\epsilon_r, \mu_r）=（2,2）\)</span>为例，我们需要加载预训练的网络权重和初始化一个新的隐向量（Z）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># load pretrained ckpt</span>
<span class="n">param_dict</span> <span class="o">=</span> <span class="n">load_checkpoint</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;load_ckpt_path&quot;</span><span class="p">])</span>
<span class="n">loaded_ckpt_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">latent_vector_ckpt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;model.latent_vector&quot;</span><span class="p">:</span>
        <span class="n">latent_vector_ckpt</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="s2">&quot;network&quot;</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="s2">&quot;moment&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">loaded_ckpt_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

<span class="c1"># initialize the new latent vector</span>
<span class="n">num_scenarios</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_scenarios&quot;</span><span class="p">]</span>
<span class="n">latent_size</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;latent_vector_size&quot;</span><span class="p">]</span>
<span class="n">latent_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">latent_vector_ckpt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">latent_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_scenarios</span><span class="p">,</span> <span class="n">latent_size</span><span class="p">))</span>
<span class="n">latent_vector</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">latent_init</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># optimizer</span>
<span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;finetune_model&quot;</span><span class="p">):</span>
    <span class="n">model_params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">model_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;bias&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span>

<span class="n">params</span> <span class="o">=</span> <span class="n">model_params</span> <span class="o">+</span> <span class="n">mtl</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
<span class="n">lr_scheduler</span> <span class="o">=</span> <span class="n">MultiStepLR</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;milestones&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr_gamma&quot;</span><span class="p">],</span>
                            <span class="n">steps_per_epoch</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">])</span>
<span class="n">lr</span> <span class="o">=</span> <span class="n">lr_scheduler</span><span class="o">.</span><span class="n">get_lr</span><span class="p">()</span>
<span class="n">optim</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="n">Tensor</span><span class="p">(</span><span class="n">lr</span><span class="p">))</span>
</pre></div>
</div>
<p>在本教程中，我们采用finetune_latent_with_model的增量训练模式，即同时更新隐向量和网络结构。电磁场的瞬时分布与参考标签数据的对比结果如下图所示。相较于PINNs直接求解单个问题，在达到同等精度（相对误差6%）的情况下，增量训练的方法得到了10倍以上的加速。</p>
<p><img alt="TE_for_Maxwell" src="_images/piad_result.png" /></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="time_domain_maxwell.html" class="btn btn-neutral float-left" title="点源时域麦克斯韦方程AI求解" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="data_driven.html" class="btn btn-neutral float-right" title="数据驱动的AI电磁仿真方法" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 MindSpore.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>