<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>点源时域麦克斯韦方程AI求解 &mdash; MindSpore master 文档</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script><script src="_static/jquery.js"></script>
        <script src="_static/js/theme.js"></script><script src="_static/underscore.js"></script><script src="_static/doctools.js"></script><script src="_static/translations.js"></script><script crossorigin="anonymous" integrity="sha256-1fEPhSsRKlFKGfK3eO710tEweHh1fwokU5wFGDHO+vg=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/mathjax/MathJax-3.2.2/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="增量训练求解麦克斯韦方程族" href="incremental_learning.html" />
    <link rel="prev" title="物理驱动的AI电磁仿真方法" href="physics_driven.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">安装部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro_and_install.html">MindSpore Elec介绍和安装</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">应用实践</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="physics_driven.html">物理驱动的AI电磁仿真方法</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">点源时域麦克斯韦方程AI求解</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#概述">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#麦克斯韦方程组">麦克斯韦方程组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#问题描述">问题描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#导入依赖">导入依赖</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#创建数据集">创建数据集</a></li>
<li class="toctree-l4"><a class="reference internal" href="#定义控制方程及初边值条件">定义控制方程及初边值条件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#构建神经网络">构建神经网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="#自适应加权损失函数加速收敛">自适应加权损失函数加速收敛</a></li>
<li class="toctree-l4"><a class="reference internal" href="#模型测试">模型测试</a></li>
<li class="toctree-l4"><a class="reference internal" href="#模型训练">模型训练</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="incremental_learning.html">增量训练求解麦克斯韦方程族</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_driven.html">数据驱动的AI电磁仿真方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="AD_FDTD.html">端到端可微分的FDTD方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">电磁仿真结果可视化</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindelec.architecture.html">mindelec.architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.common.html">mindelec.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.data.html">mindelec.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.geometry.html">mindelec.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.loss.html">mindelec.loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.operators.html">mindelec.operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.solver.html">mindelec.solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindelec.vision.html">mindelec.vision</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="physics_driven.html">物理驱动的AI电磁仿真方法</a> &raquo;</li>
      <li>点源时域麦克斯韦方程AI求解</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/time_domain_maxwell.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="点源时域麦克斯韦方程ai求解">
<h1>点源时域麦克斯韦方程AI求解<a class="headerlink" href="#点源时域麦克斯韦方程ai求解" title="永久链接至标题"></a></h1>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/blob/r2.0/docs/mindelec/docs/source_zh_cn/time_domain_maxwell.md"><img alt="查看源文件" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.0/resource/_static/logo_source.png" /></a>  </p>
<section id="概述">
<h2>概述<a class="headerlink" href="#概述" title="永久链接至标题"></a></h2>
<p>人工智能技术的蓬勃发展为科学计算提供了新的范式。MindSpore Elec套件提供了物理驱动和数据驱动的AI方法。物理驱动的AI方法结合物理方程和初边界条件进行模型的训练，相比于数据驱动而言，其优势在于无需监督数据。本案例教程重点介绍物理驱动的AI方法求解点源时域麦克斯韦方程。</p>
<blockquote>
<div><p>本例面向Ascend 910 AI处理器，你可以在这里下载完整的样例代码：
<a class="reference external" href="https://gitee.com/mindspore/mindscience/tree/r0.2.0/MindElec/examples/physics_driven/time_domain_maxwell">https://gitee.com/mindspore/mindscience/tree/r0.2.0/MindElec/examples/physics_driven/time_domain_maxwell</a></p>
</div></blockquote>
</section>
<section id="麦克斯韦方程组">
<h2>麦克斯韦方程组<a class="headerlink" href="#麦克斯韦方程组" title="永久链接至标题"></a></h2>
<p>有源麦克斯韦方程是电磁仿真的经典控制方程，它是一组描述电场、磁场与电荷密度、电流密度之间关系的偏微分方程组，具体形式如下：</p>
<div class="math notranslate nohighlight">
\[
\nabla\times E=-\mu \dfrac{\partial H}{\partial t} - J(x, t),
\]</div>
<div class="math notranslate nohighlight">
\[
\nabla\times H=\epsilon \dfrac{\partial E}{\partial t}
\]</div>
<p>其中<span class="math notranslate nohighlight">\(\epsilon,\mu\)</span>分别是介质的绝对介电常数、绝对磁导率。<span class="math notranslate nohighlight">\(J(x, t)\)</span>是电磁仿真过程中的激励源，通常表现为端口脉冲的形式。这在数学意义上近似为狄拉克函数形式所表示的点源，可以表示为：</p>
<div class="math notranslate nohighlight">
\[
J(x, t)=\delta(x - x_0)g(t)
\]</div>
<p>其中<span class="math notranslate nohighlight">\(x_0\)</span>为激励源位置，<span class="math notranslate nohighlight">\(g(t)\)</span>为脉冲信号的函数表达形式。</p>
<p>由于点源的空间分布是非连续的函数，使得源附近的物理场具有趋于无穷大的梯度。另外一个方面，激励源通常是多种频率信号的叠加。已有的基于物理信息神经网络的AI方法求解这种多尺度和奇异性问题通常无法收敛。在MindSpore Elec中，通过高斯分布函数平滑、多通道残差网络结合sin激活函数的网络结构以及自适应加权的多任务学习策略，使得针对该类问题的求解在精度和性能方面均明显优于其他框架及方法。下面将以模拟2D TE波为例，介绍MindSpore Elec求解麦克斯韦方程的具体流程。</p>
</section>
<section id="问题描述">
<h2>问题描述<a class="headerlink" href="#问题描述" title="永久链接至标题"></a></h2>
<p>本案例模拟二维的TE波在矩形域的电磁场分布，高斯激励源位于矩形域的中心。该问题的控制方程以及初始和边界条件如下图所示:</p>
<p><img alt="控制方程以及初始和边界条件" src="_images/equation_maxwell.png" /></p>
<p>MindSpore Elec求解该问题的具体流程如下：</p>
<ol class="arabic simple">
<li><p>对求解域以及初边值条件进行随机采样，创建训练数据集。</p></li>
<li><p>定义控制方程以及定解条件，建立数据集与约束条件的映射关系。</p></li>
<li><p>构建神经网络。</p></li>
<li><p>网络训练与推理。</p></li>
</ol>
</section>
<section id="导入依赖">
<h2>导入依赖<a class="headerlink" href="#导入依赖" title="永久链接至标题"></a></h2>
<p>导入本教程所依赖模块与接口:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindelec.data</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">mindelec.geometry</span> <span class="kn">import</span> <span class="n">Disk</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">,</span> <span class="n">TimeDomain</span><span class="p">,</span> <span class="n">GeometryWithTime</span>
<span class="kn">from</span> <span class="nn">mindelec.loss</span> <span class="kn">import</span> <span class="n">Constraints</span>
<span class="kn">from</span> <span class="nn">mindelec.solver</span> <span class="kn">import</span> <span class="n">Solver</span><span class="p">,</span> <span class="n">LossAndTimeMonitor</span>
<span class="kn">from</span> <span class="nn">mindelec.common</span> <span class="kn">import</span> <span class="n">L2</span>
<span class="kn">from</span> <span class="nn">mindelec.architecture</span> <span class="kn">import</span> <span class="n">MultiScaleFCCell</span><span class="p">,</span> <span class="n">MTLWeightedLossCell</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">create_random_dataset</span><span class="p">,</span> <span class="n">get_test_data</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">Maxwell2DMur</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">MultiStepLR</span><span class="p">,</span> <span class="n">PredictCallback</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">visual_result</span>
</pre></div>
</div>
<section id="创建数据集">
<h3>创建数据集<a class="headerlink" href="#创建数据集" title="永久链接至标题"></a></h3>
<p>除了支持加载不同格式的数据集文件以外，MindSpore Elec同样支持在线生成采样数据集。Geometry模块支持创建简单几何体，然后通过不同几何体之间的逻辑运算创建复杂几何构型，并实现在几何体内部以及边界的采样。</p>
<p>在上述问题中，我们在矩形计算域内部均匀采样，并且在点源附近进行加密采样然后作为独立的训练数据集。因此为创建训练所需的数据集，需要实现5次采样，即由控制方程所约束的矩形域和点源附近区域的内部点采样；由初始条件所约束的矩形域和点源附近区域的内部点采样；以及由边界条件所控制的矩形域边界采样。空间采样与时间采样数据的集成构成了训练样本。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># src region</span>
<span class="n">disk</span> <span class="o">=</span> <span class="n">Disk</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="n">disk_origin</span><span class="p">,</span> <span class="n">disk_radius</span><span class="p">)</span>
<span class="c1"># no src region</span>
<span class="n">rectangle</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="s2">&quot;rect&quot;</span><span class="p">,</span> <span class="n">coord_min</span><span class="p">,</span> <span class="n">coord_max</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">rectangle</span> <span class="o">-</span> <span class="n">disk</span>

<span class="c1"># time info</span>
<span class="n">time_interval</span> <span class="o">=</span> <span class="n">TimeDomain</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;range_t&quot;</span><span class="p">])</span>

<span class="c1"># geometry merge with time</span>
<span class="n">no_src_region</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">no_src_region</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;no_src&quot;</span><span class="p">)</span>
<span class="n">no_src_region</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">no_src_sampling_config</span><span class="p">))</span>
<span class="n">src_region</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">src_region</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span>
<span class="n">src_region</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">src_sampling_config</span><span class="p">))</span>
<span class="n">boundary</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">rectangle</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">boundary</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;bc&quot;</span><span class="p">)</span>
<span class="n">boundary</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">bc_sampling_config</span><span class="p">))</span>

<span class="c1"># final sampling fields</span>
<span class="n">geom_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">src_region</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;IC&quot;</span><span class="p">],</span>
                 <span class="n">no_src_region</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;IC&quot;</span><span class="p">],</span>
                 <span class="n">boundary</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BC&quot;</span><span class="p">]}</span>
</pre></div>
</div>
<p>MindSpore Elec的Dataset接口实现了将不同的采样数据合并为统一训练数据集。因此在训练过程中只需要进行一次数据下沉，无需针对每个子数据集分别调用训练网络接口。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># create dataset for train</span>
<span class="n">elec_train_dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">geom_dict</span><span class="p">)</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_batch_size&quot;</span><span class="p">],</span>
                                                  <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">prebatched_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="定义控制方程及初边值条件">
<h3>定义控制方程及初边值条件<a class="headerlink" href="#定义控制方程及初边值条件" title="永久链接至标题"></a></h3>
<p>继承MindSpore Elec提供的Problem类，用户可以快速自定义Partial differential equation（PDE）问题。该问题类的一次实现即可以约束多个数据集。成员函数governing_equation、boundary_conditon、initial_condition以及constraint_function分别对应于控制方程、边界条件、初始条件以及有监督的标签或者函数约束。用户在构造函数中传入对应样本在数据集中的列名就可以自动实现对该类样本集的损失函数计算。以该问题为例，我们定义的PDE问题核心代码如下, 其中对于方程中的一阶微分可以调用梯度接口Grad来实现，相应的二阶微分可以调用接口SecondOrderGrad来完成。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 2d TE-mode Maxwell equation with 2nd-order Mur boundary condition and static initial electromagnetic field</span>
<span class="k">class</span> <span class="nc">Maxwell2DMur</span><span class="p">(</span><span class="n">Problem</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">domain_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bc_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ic_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Maxwell2DMur</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain_name</span> <span class="o">=</span> <span class="n">domain_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc_name</span> <span class="o">=</span> <span class="n">bc_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ic_name</span> <span class="o">=</span> <span class="n">ic_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="c1"># operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="n">Grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">PI</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">EPS</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_y</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">EPS</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">MU</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">LIGHT_SPEED</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># gauss-type pulse source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_frq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;src_frq&quot;</span><span class="p">,</span> <span class="mf">1e+9</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">((</span><span class="mf">2.3</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">PI</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_frq</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">3.65</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># src space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_pos&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_pos&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_radius&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord_min</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;coord_min&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord_max</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;coord_max&quot;</span><span class="p">]</span>

        <span class="n">input_scale</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;input_scale&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5e+8</span><span class="p">])</span> <span class="c1"># scale of input data to improve accuracy</span>
        <span class="n">output_scale</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_scale&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">37.67303</span><span class="p">,</span> <span class="mf">37.67303</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span> <span class="c1"># scale of output data to improve accuracy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scale</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scale</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scale</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scale</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">smooth_src</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Incentive sources and Gaussian smoothing of Dirac function&quot;&quot;&quot;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp</span> <span class="o">*</span> <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">((</span><span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">gauss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">gauss</span><span class="p">)</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">governing_equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;maxwell equation of TE mode wave&quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># input data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_name</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># get gradients</span>
        <span class="n">dex_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dex_dy</span><span class="p">,</span> <span class="n">dex_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dex_dxyt</span><span class="p">)</span>
        <span class="n">dey_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dey_dx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dey_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dey_dxyt</span><span class="p">)</span>
        <span class="n">dhz_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dhz_dx</span><span class="p">,</span> <span class="n">dhz_dy</span><span class="p">,</span> <span class="n">dhz_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dhz_dxyt</span><span class="p">)</span>

        <span class="c1"># residual of each equation</span>
        <span class="n">loss_a1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="n">dhz_dy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_x</span><span class="p">)</span>
        <span class="n">loss_a2</span> <span class="o">=</span> <span class="n">dex_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">loss_b1</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="n">dhz_dx</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_y</span><span class="p">)</span>
        <span class="n">loss_b2</span> <span class="o">=</span> <span class="n">dey_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">loss_c1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="n">dey_dx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="n">dex_dy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">)</span>
        <span class="n">loss_c2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_src</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">)</span>

        <span class="n">pde_r1</span> <span class="o">=</span> <span class="n">loss_a1</span> <span class="o">-</span> <span class="n">loss_a2</span>
        <span class="n">pde_r2</span> <span class="o">=</span> <span class="n">loss_b1</span> <span class="o">-</span> <span class="n">loss_b2</span>
        <span class="n">pde_r3</span> <span class="o">=</span> <span class="n">loss_c1</span> <span class="o">-</span> <span class="n">loss_c2</span> <span class="o">-</span> <span class="n">src</span>
        <span class="c1"># total residual</span>
        <span class="n">pde_r</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="mi">1</span><span class="p">)((</span><span class="n">pde_r1</span><span class="p">,</span> <span class="n">pde_r2</span><span class="p">,</span> <span class="n">pde_r3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pde_r</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2nd-order mur boundary condition&quot;&quot;&quot;</span>
        <span class="c1"># network input and output</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc_name</span><span class="p">]</span>

        <span class="c1"># specify each boundary</span>
        <span class="n">coord_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_min</span>
        <span class="n">coord_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_max</span>
        <span class="n">batch_size</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">attr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coord_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">attr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coord_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">attr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coord_min</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">attr</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coord_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># get gradients</span>
        <span class="n">dex_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dex_dy</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dex_dxyt</span><span class="p">)</span>
        <span class="n">dey_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dey_dx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dey_dxyt</span><span class="p">)</span>
        <span class="n">dhz_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dhz_dx</span><span class="p">,</span> <span class="n">dhz_dy</span><span class="p">,</span> <span class="n">dhz_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dhz_dxyt</span><span class="p">)</span>

        <span class="c1"># residual of each boundary</span>
        <span class="n">bc_r1</span> <span class="o">=</span> <span class="n">dhz_dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dex_dy</span>  <span class="c1"># 左边界</span>
        <span class="n">bc_r2</span> <span class="o">=</span> <span class="n">dhz_dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">+</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dex_dy</span>  <span class="c1"># 右边界</span>
        <span class="n">bc_r3</span> <span class="o">=</span> <span class="n">dhz_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dey_dx</span>  <span class="c1"># 下边界</span>
        <span class="n">bc_r4</span> <span class="o">=</span> <span class="n">dhz_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">+</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dey_dx</span>  <span class="c1"># 上边界</span>
        <span class="n">bc_r_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">bc_r1</span><span class="p">,</span> <span class="n">bc_r2</span><span class="p">,</span> <span class="n">bc_r3</span><span class="p">,</span> <span class="n">bc_r4</span><span class="p">))</span>
        <span class="n">bc_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">bc_r_all</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bc_r</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">initial_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;initial condition: u = 0&quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>值得注意的是，在实验过程中将网络的输入输出调整到合适数值范围（比如[0,1]）可以显著提升模型的训练速度和精度。上述代码中的input_scale和output_scale是调优的缩放系数，因此对应的麦克斯韦方程以及初边值条件也是坐标缩放之后的形式。为了有效的模拟点源问题，方程中的Dirac函数通过光滑的高斯概率分布来逼近。激励源以及高斯平滑逼近的函数形式在上述代码的smooth_src中实现，高斯平滑的方差为0.0025可以很好的结果。</p>
<p>Constraint接口在统一后的数据集和用户自定义的问题（如上述继承自Problem类的Maxwell2DMur）之间建立映射关系，以此在网络中获取对应每个子数据集的约束条件从而自动完成相应损失函数的计算。为了完成此步骤，针对每个子数据集初始化相应的Problem从而建立一个字典，其中字典的key对应子数据集，键值为对应的问题类。constraint_type属性用于自动获取每个数据集所对应的损失函数的计算方式，该属性支持控制方程、初始条件、边界条件、标签、函数五种形式。用户需要针对具体的形式在问题类中显式定义相应的控制条件。比如对于无源区域的采样点，该部分数据集的constrain_type为<code class="docutils literal notranslate"><span class="pre">Equation</span></code>，那么用户在问题类Maxwell2DMur中必须定义governing_equation函数来对应该数据集的约束。将数据集和问题字典传入Constraints接口即可完成数据集与约束条件的映射。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># define constraints</span>
<span class="n">train_prob</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">all_datasets</span><span class="p">:</span>
    <span class="n">train_prob</span><span class="p">[</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Maxwell2DMur</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
                                            <span class="n">domain_name</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">,</span>
                                            <span class="n">ic_name</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">,</span>
                                            <span class="n">bc_name</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;check problem: &quot;</span><span class="p">,</span> <span class="n">train_prob</span><span class="p">)</span>
<span class="n">train_constraints</span> <span class="o">=</span> <span class="n">Constraints</span><span class="p">(</span><span class="n">elec_train_dataset</span><span class="p">,</span> <span class="n">train_prob</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="构建神经网络">
<h3>构建神经网络<a class="headerlink" href="#构建神经网络" title="永久链接至标题"></a></h3>
<p>本例中所使用多通道残差网络并结合Sin激活函数，在该问题的模拟中取得了相比其他方法更高的精度。该神经网络的结构如下图所示：</p>
<p><img alt="神经网络的结构" src="_images/multi-scale-NN.png" /></p>
<p>单尺度网络的基础结构由多层残差全连接网络构成，指数通道的多尺度网络实现如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MultiScaleFCCell</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_channel</span><span class="p">,</span>
                 <span class="n">out_channel</span><span class="p">,</span>
                 <span class="n">layers</span><span class="p">,</span>
                 <span class="n">neurons</span><span class="p">,</span>
                 <span class="n">residual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">act</span><span class="o">=</span><span class="s2">&quot;sin&quot;</span><span class="p">,</span>
                 <span class="n">weight_init</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span>
                 <span class="n">has_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">bias_init</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
                 <span class="n">num_scales</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">amp_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">scale_factor</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                 <span class="n">input_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">input_center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">latent_vector</span><span class="o">=</span><span class="kc">None</span>
                 <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiScaleFCCell</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">_check_type</span><span class="p">(</span><span class="n">num_scales</span><span class="p">,</span> <span class="s2">&quot;num_scales&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell_list</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">CellList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_scales</span> <span class="o">=</span> <span class="n">num_scales</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_coef</span> <span class="o">=</span> <span class="p">[</span><span class="n">amp_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">scale_factor</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scales</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">latent_vector</span> <span class="o">=</span> <span class="n">latent_vector</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_check_type</span><span class="p">(</span><span class="n">latent_vector</span><span class="p">,</span> <span class="s2">&quot;latent_vector&quot;</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_scenarios</span> <span class="o">=</span> <span class="n">latent_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span> <span class="o">=</span> <span class="n">latent_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">in_channel</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_scenarios</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># full-connect network</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scales</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FCSequential</span><span class="p">(</span><span class="n">in_channel</span><span class="o">=</span><span class="n">in_channel</span><span class="p">,</span>
                                               <span class="n">out_channel</span><span class="o">=</span><span class="n">out_channel</span><span class="p">,</span>
                                               <span class="n">layers</span><span class="o">=</span><span class="n">layers</span><span class="p">,</span>
                                               <span class="n">neurons</span><span class="o">=</span><span class="n">neurons</span><span class="p">,</span>
                                               <span class="n">residual</span><span class="o">=</span><span class="n">residual</span><span class="p">,</span>
                                               <span class="n">act</span><span class="o">=</span><span class="n">act</span><span class="p">,</span>
                                               <span class="n">weight_init</span><span class="o">=</span><span class="n">weight_init</span><span class="p">,</span>
                                               <span class="n">has_bias</span><span class="o">=</span><span class="n">has_bias</span><span class="p">,</span>
                                               <span class="n">bias_init</span><span class="o">=</span><span class="n">bias_init</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">input_scale</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">=</span> <span class="n">InputScaleNet</span><span class="p">(</span><span class="n">input_scale</span><span class="p">,</span> <span class="n">input_center</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;running multi-scale net&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">latent_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_vector</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scenarios</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_scenarios</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_size</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">latent_vectors</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_scales</span><span class="p">):</span>
            <span class="n">x_s</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_coef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_list</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x_s</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">MultiScaleFCCell</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_size&quot;</span><span class="p">],</span>
                         <span class="n">config</span><span class="p">[</span><span class="s2">&quot;output_size&quot;</span><span class="p">],</span>
                         <span class="n">layers</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;layers&quot;</span><span class="p">],</span>
                         <span class="n">neurons</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;neurons&quot;</span><span class="p">],</span>
                         <span class="n">input_scale</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_scale&quot;</span><span class="p">],</span>
                         <span class="n">residual</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;residual&quot;</span><span class="p">],</span>
                         <span class="n">weight_init</span><span class="o">=</span><span class="n">HeUniform</span><span class="p">(</span><span class="n">negative_slope</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span>
                         <span class="n">act</span><span class="o">=</span><span class="s2">&quot;sin&quot;</span><span class="p">,</span>
                         <span class="n">num_scales</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_scales&quot;</span><span class="p">],</span>
                         <span class="n">amp_factor</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;amp_factor&quot;</span><span class="p">],</span>
                         <span class="n">scale_factor</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">]</span>
                         <span class="p">)</span>
</pre></div>
</div>
</section>
<section id="自适应加权损失函数加速收敛">
<h3>自适应加权损失函数加速收敛<a class="headerlink" href="#自适应加权损失函数加速收敛" title="永久链接至标题"></a></h3>
<p>物理信息神经网络直接利用控制方程进行网络训练。相应的该网络的损失函数通常包含控制方程、边界条件以及初始条件这三项的残差。在本案例中，由于点源附近区域的加密采样并作为独立子数据集进行网络训练，因此损失函数的构成包含如下五项：有源区域的控制方程和初始条件、无源区域的控制方程和初始条件以及边界条件。实验表明，这五项损失函数量级差异明显，因此简单的损失函数求和会导致网络训练失败，而手动调节每项损失函数的权重信息极为繁琐。MindSpore Elec发展了一种基于多任务学习不确定性估计的加权算法，通过引入可训的参数，自适应的调节每项损失函数的权重，可以显著的提升训练速度和精度。该算法的实现具体如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MTLWeightedLossCell</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_losses</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MTLWeightedLossCell</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">auto_prefix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_losses</span> <span class="o">=</span> <span class="n">num_losses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_losses</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pow</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Pow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Log</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">div</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">RealDiv</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">losses</span><span class="p">):</span>
        <span class="n">loss_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_losses</span><span class="p">):</span>
            <span class="n">weighted_loss</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">loss_sum</span> <span class="o">=</span> <span class="n">loss_sum</span> <span class="o">+</span> <span class="n">weighted_loss</span>
        <span class="k">return</span> <span class="n">loss_sum</span>

<span class="c1"># self-adaptive weighting</span>
<span class="n">mtl</span> <span class="o">=</span> <span class="n">MTLWeightedLossCell</span><span class="p">(</span><span class="n">num_losses</span><span class="o">=</span><span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">num_dataset</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="模型测试">
<h3>模型测试<a class="headerlink" href="#模型测试" title="永久链接至标题"></a></h3>
<p>MindSpore Elec可以通过自定义的callback函数，实现边训练边推理的功能。用户可以直接加载测试数据集，然后实现自定义的callback函数实现推理并分析结果。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loss_time_callback</span> <span class="o">=</span> <span class="n">LossAndTimeMonitor</span><span class="p">(</span><span class="n">steps_per_epoch</span><span class="p">)</span>
<span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">loss_time_callback</span><span class="p">]</span>
<span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;train_with_eval&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">inputs</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">get_test_data</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;test_data_path&quot;</span><span class="p">])</span>
    <span class="n">predict_callback</span> <span class="o">=</span> <span class="n">PredictCallback</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span> <span class="n">visual_fn</span><span class="o">=</span><span class="n">visual_result</span><span class="p">)</span>
    <span class="n">callbacks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">predict_callback</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="模型训练">
<h3>模型训练<a class="headerlink" href="#模型训练" title="永久链接至标题"></a></h3>
<p>MindSpore Elec提供的Solver类是模型训练和推理的接口。输入优化器、网络模型、PDE的约束（train_constraints）和可选参数（如自适应加权算法模块），即可定义求解器对象solver。在该案例中利用MindSpore + Ascend混合精度模式，训练网络，从而完成求解麦克斯韦方程。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># mixed precision</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">input_scale</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># optimizer</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span> <span class="o">+</span> <span class="n">mtl</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
<span class="n">lr_scheduler</span> <span class="o">=</span> <span class="n">MultiStepLR</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;milestones&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr_gamma&quot;</span><span class="p">],</span> <span class="n">steps_per_epoch</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">])</span>
<span class="n">lr</span> <span class="o">=</span> <span class="n">lr_scheduler</span><span class="o">.</span><span class="n">get_lr</span><span class="p">()</span>
<span class="n">optim</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="n">Tensor</span><span class="p">(</span><span class="n">lr</span><span class="p">))</span>

<span class="c1"># define solver</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">model</span><span class="p">,</span>
                <span class="n">optimizer</span><span class="o">=</span><span class="n">optim</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;PINNs&quot;</span><span class="p">,</span>
                <span class="n">train_constraints</span><span class="o">=</span><span class="n">train_constraints</span><span class="p">,</span>
                <span class="n">test_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">metrics</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;l2&#39;</span><span class="p">:</span> <span class="n">L2</span><span class="p">(),</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">MAE</span><span class="p">()},</span>
                <span class="n">loss_fn</span><span class="o">=</span><span class="s1">&#39;smooth_l1_loss&#39;</span><span class="p">,</span>
                <span class="n">loss_scale_manager</span><span class="o">=</span><span class="n">DynamicLossScaleManager</span><span class="p">(</span><span class="n">init_loss_scale</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span><span class="p">,</span> <span class="n">scale_window</span><span class="o">=</span><span class="mi">2000</span><span class="p">),</span>
                <span class="n">mtl_weighted_cell</span><span class="o">=</span><span class="n">mtl</span><span class="p">,</span>
                <span class="p">)</span>

<span class="n">solver</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">],</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>基于上述方法求解得到的瞬时电磁场分布与参考标签数据的对比结果如下图所示。</p>
<p><img alt="瞬时电磁场分布" src="_images/maxwell_result.png" /></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="physics_driven.html" class="btn btn-neutral float-left" title="物理驱动的AI电磁仿真方法" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="incremental_learning.html" class="btn btn-neutral float-right" title="增量训练求解麦克斯韦方程族" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 MindSpore.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>