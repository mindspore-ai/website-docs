<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum Approximate Optimization Algorithm &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script><script src="../_static/jquery.js"></script>
        <script src="../_static/js/theme.js"></script><script src="../_static/underscore.js"></script><script src="../_static/doctools.js"></script><script crossorigin="anonymous" integrity="sha256-1fEPhSsRKlFKGfK3eO710tEweHh1fwokU5wFGDHO+vg=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/mathjax/MathJax-3.2.2/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Classification of IRIS by Quantum Neural Network" href="classification_of_iris_by_qnn.html" />
    <link rel="prev" title="Quantum Phase Estimation Algorithm" href="quantum_phase_estimation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Beginner Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/beginner.html">Beginner Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/quantum_simulator.html">Quantum Simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/quantum_measurement.html">Quantum Measurement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/advanced_operations_of_quantum_circuit.html">Advanced Operations of Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/bloch_sphere.html">Bloch Sphere</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Middle Level Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../middle_level/middle_level.html">Middle Level Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../middle_level/noise.html">Noisy Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../middle_level/noise_simulator.html">Noise Simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../middle_level/qubit_mapping.html">Qubit Mapping</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../advanced/advanced.html">Advanced Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/get_gradient_of_PQC_with_mindquantum.html">Advanced Gradient Calculation of Variational Quantum Circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/initial_experience_of_quantum_neural_network.html">Initial Experience of Quantum Neural Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/equivalence_checking_of_PQC.html">Equivalence Checking of Parameterized Quantum Circuits</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Case Library</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="case_library.html">Case Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">Grover Search and Long Algorithms Based on MindSpore Quantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">Shor’s Algorithm Based on MindSpore Quantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="hhl_algorithm.html">HHL Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quantum Approximate Optimization Algorithm</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#environment-preparation">Environment Preparation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#max-cut-problem-description">Max-Cut Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="#max-cut-problem-quantization">Max-Cut Problem Quantization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#importing-dependencies">Importing Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-graph-to-be-solved">Building a Graph to Be Solved</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-process-of-qaqa-algorithm">The Process of QAQA Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-a-qaoa-quantum-circuit">Setting up a QAOA Quantum Circuit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ansatz-circuit">ansatz Circuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generating-a-complete-quantum-circuit-and-the-hamiltonian-corresponding-to-the-graph">Generating a Complete Quantum Circuit and the Hamiltonian Corresponding to the Graph</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#approach-one-use-traditional-optimization-method">Approach One: Use Traditional Optimization Method</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generating-gradient-operator">Generating Gradient Operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#training-process">Training Process</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#approach-two-use-mindspore-to-train-quantum-neural-network">Approach two: Use MindSpore to Train Quantum Neural Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#building-a-quantum-neural-network-to-be-trained">Building a Quantum Neural Network to Be Trained</a></li>
<li class="toctree-l3"><a class="reference internal" href="#training-and-displaying-results">Training and Displaying Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimal-parameter">Optimal Parameter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#probabilistic-graph">Probabilistic Graph</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">Classification of IRIS by Quantum Neural Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">VQE Application in Quantum Chemistry Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">The Application of Quantum Neural Network in NLP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.dtype.html">mindquantum.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.device.html">mindquantum.device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Paper with Code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../paper_with_code.html">Paper with Code</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE.html">Release Notes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum_install.html">MindSpore Quantum Installation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Quantum Approximate Optimization Algorithm</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/case_library/quantum_approximate_optimization_algorithm.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="quantum-approximate-optimization-algorithm">
<h1>Quantum Approximate Optimization Algorithm<a class="headerlink" href="#quantum-approximate-optimization-algorithm" title="Permalink to this headline"></a></h1>
<p><a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/en/case_library/mindspore_quantum_approximate_optimization_algorithm.ipynb"><img alt="Download Notebook" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_notebook_en.svg" /></a>  <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/en/case_library/mindspore_quantum_approximate_optimization_algorithm.py"><img alt="Download Code" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_download_code_en.svg" /></a>  <a class="reference external" href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_en/case_library/quantum_approximate_optimization_algorithm.ipynb"><img alt="View source on Gitee" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source_en.svg" /></a></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline"></a></h2>
<p>Quantum approximate optimization algorithm (QAOA) is a quantum algorithm that uses quantum computers to solve combination optimization problems. It was first proposed by Farhi et al. in 2014. In this tutorial, we will use QAOA to solve the Max-Cut problem and get familiar with the construction and training of quantum circuits in MindSpore Quantum.</p>
</section>
<section id="environment-preparation">
<h2>Environment Preparation<a class="headerlink" href="#environment-preparation" title="Permalink to this headline"></a></h2>
<p>This tutorial requires the following library:</p>
<ul class="simple">
<li><p>networkx</p></li>
</ul>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> is a library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks. You can install it with:</p>
</div></blockquote>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip3<span class="w"> </span>install<span class="w"> </span>networkx
</pre></div>
</div>
</section>
<section id="max-cut-problem-description">
<h2>Max-Cut Problem Description<a class="headerlink" href="#max-cut-problem-description" title="Permalink to this headline"></a></h2>
<p>The Max-Cut problem is an NP-complete problem in the graph theory. It needs to divide vertices of a graph into two parts and make the most edges be cut. As shown in the following figure (a), a graph consists of five vertices, and the interconnected edges are <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1),</span> <span class="pre">(0,</span> <span class="pre">2),</span> <span class="pre">(1,</span> <span class="pre">2),</span> <span class="pre">(2,</span> <span class="pre">3),</span> <span class="pre">(3,</span> <span class="pre">4),</span> <span class="pre">and</span> <span class="pre">(0,</span> <span class="pre">4)</span></code>. To maximize the number of edges to be cut, we divide 1, 2, and 4 into one group, and 0 and 3 into another group, as shown in the figure (b). Therefore, five edges are to be cut. When
the number of vertices in a graph increases, it is difficult to find an effective typical algorithm to solve the Max-Cut problem. The following describes how to transform the Max-Cut problem into a Hamiltonian ground state capability solution problem.</p>
<p><img alt="max cut" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_en/images/Max_Cut.png" /></p>
</section>
<section id="max-cut-problem-quantization">
<h2>Max-Cut Problem Quantization<a class="headerlink" href="#max-cut-problem-quantization" title="Permalink to this headline"></a></h2>
<p>Assign each vertex a quantum bit. If the vertex is allocated to the left side, its quantum bit is set to the <span class="math notranslate nohighlight">\(\left|0\right&gt;\)</span> state. If the vertex is on the right side, its quantum bit is set to the <span class="math notranslate nohighlight">\(\left|1\right&gt;\)</span> state. When two vertices are in different sets, the bits on the two vertices are in different quantum states. For the vertex 0 and the vertex 1, when their connection line is cut, quantum states corresponding to bits on the two vertices may be <span class="math notranslate nohighlight">\(|01\rangle\)</span> (vertax
1: left, vertax 0: right) or <span class="math notranslate nohighlight">\(|10\rangle\)</span> (vertax 1: right, vertax 0: left). If they are partitioned to the same side, the corresponding quantum state is <span class="math notranslate nohighlight">\(|00\rangle\)</span> or <span class="math notranslate nohighlight">\(|11\rangle\)</span>. So we just need to find a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> that makes the expectation value of the Hamiltonian to -1 when there are connected two vertices in different quantum states, i.e.</p>
<div class="math notranslate nohighlight">
\[\langle 01|H|01\rangle=-1,\quad \langle 10|H|10\rangle=-1\]</div>
<p>When vertices are in the same quantum state, the expected value of Hamiltonian quantity is 0, i.e</p>
<div class="math notranslate nohighlight">
\[\langle 00|H|00\rangle=0,\quad \langle 11|H|11\rangle=0\]</div>
<p>Subsequently the maximum number of cut edges, and the corresponding grouping case at that point, can be found by simply minimizing the expected value of the Hamiltonian quantity. The reason why the expected value at different quantum states is set to -1 is that in the training of the quantum neural network, the gradient of the parameters in Ansatz keeps decreasing, and also the measured value keeps decreasing. The training method is aimed at finding the minimum value, and here we use it to find
the ground state energy of the Hamiltonian quantity. At this point, we choose the Hamiltonian <span class="math notranslate nohighlight">\(H=(Z_1Z_0-1)/2\)</span>, where <span class="math notranslate nohighlight">\(Z\)</span> is the Pauli <span class="math notranslate nohighlight">\(Z\)</span> operator. We can see that:</p>
<div class="math notranslate nohighlight">
\[Z_1Z_0|00\rangle=|00\rangle,\quad Z_1Z_0|11\rangle=|11\rangle, \quad Z_1Z_0|01\rangle=-|01\rangle, \quad Z_1Z_0|10\rangle=-|10\rangle\]</div>
<p>Thus when the vertices are partitioned into different sets:</p>
<div class="math notranslate nohighlight">
\[\left&lt;01\right|H\left|01\right&gt;=\frac{1}{2}\left&lt;01\right|Z_1Z_0\left|01\right&gt;-\frac{1}{2}=-1\]</div>
<div class="math notranslate nohighlight">
\[\left&lt;10\right|H\left|10\right&gt;=\frac{1}{2}\left&lt;10\right|Z_1Z_0\left|10\right&gt;-\frac{1}{2}=-1\]</div>
<p>And when the vertices are partitioned into the same set, it is not difficult to verify that:</p>
<div class="math notranslate nohighlight">
\[\left&lt;00\right|H\left|00\right&gt;=\frac{1}{2}\left&lt;00\right|Z_1Z_0\left|00\right&gt;-\frac{1}{2}=0\]</div>
<div class="math notranslate nohighlight">
\[\left&lt;11\right|H\left|11\right&gt;=\frac{1}{2}\left&lt;11\right|Z_1Z_0\left|11\right&gt;-\frac{1}{2}=0\]</div>
<p>Therefore, we just write the above Hamiltonian for each edge in the graph and then sum up all the edges to write the Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> corresponding to the graph. Using a quantum computer to find the ground state energy and ground state of <span class="math notranslate nohighlight">\(H\)</span>, we can get the Max-Cut cutting scheme and the maximum number of cutting edges of the graph. We write down the set of all edges as <span class="math notranslate nohighlight">\(C\)</span> and the number of all edge strips as <span class="math notranslate nohighlight">\(c\)</span>, then the Hamiltonian quantity can be written as:</p>
<div class="math notranslate nohighlight">
\[H=\sum_{(i,j)\in C}(Z_iZ_j-1)/2\]</div>
</section>
<section id="importing-dependencies">
<h2>Importing Dependencies<a class="headerlink" href="#importing-dependencies" title="Permalink to this headline"></a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">UN</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">H</span><span class="p">,</span> <span class="n">Rzz</span><span class="p">,</span> <span class="n">RX</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">Hamiltonian</span><span class="p">,</span> <span class="n">QubitOperator</span>
<span class="kn">from</span> <span class="nn">mindquantum.framework</span> <span class="kn">import</span> <span class="n">MQAnsatzOnlyLayer</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
</pre></div>
</div>
</div>
</section>
<section id="building-a-graph-to-be-solved">
<h2>Building a Graph to Be Solved<a class="headerlink" href="#building-a-graph-to-be-solved" title="Permalink to this headline"></a></h2>
<p>Use <code class="docutils literal notranslate"><span class="pre">add_path</span></code> to add edges to a graph. Then, the graph structure is drawn.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/case_library_quantum_approximate_optimization_algorithm_3_0.png" src="../_images/case_library_quantum_approximate_optimization_algorithm_3_0.png" />
</div>
</div>
<p>As shown in the preceding figure, a graph structure consisting of five vertices and six edges is obtained.</p>
<p>Next we use the exhaustive method to see the number of cutting edges for all cases.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;one size:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;cut=&#39;</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">cut_size</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">]))</span>            <span class="c1"># All cases with 1 node in one group and 4 nodes in the other group</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;one size:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cut=&#39;</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">cut_size</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>  <span class="c1"># All cases with 2 nodes in one group and 3 nodes in the other group</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
one size: [0] cut= 3
one size: [1] cut= 2
one size: [1, 0] cut= 3
one size: [2] cut= 3
one size: [2, 0] cut= 4
one size: [2, 1] cut= 3
one size: [3] cut= 2
one size: [3, 0] cut= 5
one size: [3, 1] cut= 4
one size: [3, 2] cut= 3
one size: [4] cut= 2
one size: [4, 0] cut= 3
one size: [4, 1] cut= 4
one size: [4, 2] cut= 5
one size: [4, 3] cut= 2
</pre></div></div>
</div>
<p>From the above results, it can be seen that the maximum number of cutting edges obtained by the exhaustive method is 5. If a distinction is made between the left and right of the node grouping, there are a total of 4 grouping methods that maximize the number of cutting edges, i.e., there are 4 simplex solutions to the problem.</p>
</section>
<section id="the-process-of-qaqa-algorithm">
<h2>The Process of QAQA Algorithm<a class="headerlink" href="#the-process-of-qaqa-algorithm" title="Permalink to this headline"></a></h2>
<ol class="arabic simple">
<li><p>Build a QAOA quantum circuit, where the ansatz circuit contains parameters that can be trained</p></li>
<li><p>Initialize the parameters in the circuit</p></li>
<li><p>Run this quantum circuit and get the quantum state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span></p></li>
<li><p>Compute the expected value <span class="math notranslate nohighlight">\(\langle\psi|H_C|\psi\rangle\)</span> of the target Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span></p></li>
<li><p>Based on the results of step 4, use the Adam optimizer to optimize the parameters in the circuit</p></li>
<li><p>Repeat steps 3-5 until the results in step 4 are basically unchanged</p></li>
<li><p>Based on the result of step 4, the approximate solution of the target problem is calculated</p></li>
</ol>
<p>In this process, steps 2-6 can all be implemented by packages and functions available in MindSpore and MindSpore Quantum, so we will focus on step 1: building the quantum circuit.</p>
<p><img alt="Flowchart" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_en/images/QAOA_Flowchart.png" /></p>
</section>
<section id="setting-up-a-qaoa-quantum-circuit">
<h2>Setting up a QAOA Quantum Circuit<a class="headerlink" href="#setting-up-a-qaoa-quantum-circuit" title="Permalink to this headline"></a></h2>
<p>As mentioned previously, we need to combine the Hamiltonian quantities corresponding to the problem:</p>
<div class="math notranslate nohighlight">
\[H_C=\sum_{(i,j)\in C}(Z_iZ_j-1)/2\]</div>
<p>Minimization to find the solution of the problem, which means we have to find the ground state of that Hamiltonian quantity. We can use quantum adiabatic evolution to make the system first on the ground state of some simple Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span>, and then make the simple Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span> evolve adiabatically and slowly to some complex Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>. According to the adiabatic theorem, the system will always remain on the ground state of the Hamiltonian, and finally reach the
ground state of the complex Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>.</p>
<p>The quantum circuit we are going to build is using the above idea, choosing the initial simple Hamiltonian quantity as:</p>
<div class="math notranslate nohighlight">
\[H_B=\sum_i -X_i\]</div>
<p>Prepare the quantum circuit to the ground state <span class="math notranslate nohighlight">\(|s\rangle=|+\rangle^{\otimes n}\)</span> of <span class="math notranslate nohighlight">\(H_B\)</span>, which can be achieved here by acting <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/en/master/core/gates/mindquantum.core.gates.HGate.html">Hadamard</a> gate on all quantum bits. Then the ansatz circuits are connected, and by continuously optimizing the parameters, the ansatz circuits can be made closer to the real adiabatic evolution, and the finally obtained quantum circuits can be regarded as
simulating a real adiabatic evolution.</p>
<section id="ansatz-circuit">
<h3>ansatz Circuit<a class="headerlink" href="#ansatz-circuit" title="Permalink to this headline"></a></h3>
<p>In the quantum adiabatic evolution, the initial Hamiltonian quantities are first selected</p>
<div class="math notranslate nohighlight">
\[H_B=\sum_i -X_i\]</div>
<p>Put the system in the <span class="math notranslate nohighlight">\(H_B\)</span> ground state <span class="math notranslate nohighlight">\(|s\rangle=|+\rangle^{\otimes n}\)</span>. Then slowly act on the following time-dependent Hamiltonian:</p>
<div class="math notranslate nohighlight">
\[H(t)=(1-\frac{t}{T})H_B+(\frac{t}{T})H_C\]</div>
<p>Notice that <span class="math notranslate nohighlight">\(H(T)=H_C\)</span> when <span class="math notranslate nohighlight">\(t=T\)</span>. When the chosen <span class="math notranslate nohighlight">\(T\)</span> is large enough (satisfying the adiabatic condition), the system will always be on the instantaneous ground state of <span class="math notranslate nohighlight">\(H(t)\)</span>, when the quantum state of the system will evolve adiabatically from the ground state <span class="math notranslate nohighlight">\(|\psi (0)\rangle\)</span> of the initial Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span> to the ground state <span class="math notranslate nohighlight">\(|\psi (T)\rangle\)</span> of the target Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>, i.e.</p>
<div class="math notranslate nohighlight">
\[|\psi (T)\rangle=\mathcal{T}e^{-i\int^{T}_{0} H(t)dt}|\psi(0)\rangle\]</div>
<p>That is, the ansatz circuit needs to model the evolution process <span class="math notranslate nohighlight">\(\mathcal{T}e^{-i\int^{T}_{0} H(t)dt}\)</span>. Next we will make some approximations and simplifications to this equation to make it into a form that can be implemented in quantum circuits.</p>
<p>Considering the following trotter formula:</p>
<div class="math notranslate nohighlight">
\[\mathcal{T}e^{-i\int^T_0 H(t)dt}=\lim_{N\rightarrow \infty}\prod^N_{l=1}e^{-iH(t_l)\Delta t},\quad \Delta t=\frac{T}{N},\quad t_l=l\Delta t\]</div>
<p>Omitting the <span class="math notranslate nohighlight">\(O(\Delta t^2)\)</span> term, we obtain:</p>
<div class="math notranslate nohighlight">
\[\mathcal{T}e^{-i\int^T_0 H(t)dt}\approx \lim_{N\rightarrow \infty}\prod^N_{l=1}e^{-iH_B(1-t_l/T)\Delta t}e^{-iH_C t_l\Delta t/T}\]</div>
<p>Let <span class="math notranslate nohighlight">\(\beta_l=(1-t_l/T)\Delta t\)</span>, <span class="math notranslate nohighlight">\(\gamma_l=t_l\Delta t/T\)</span>, and take <span class="math notranslate nohighlight">\(N\)</span> as a finite large integer, that is, the ansatz of QAOA is obtained:</p>
<div class="math notranslate nohighlight">
\[|\psi(\gamma,\beta)\rangle=\prod^p_{l=1}e^{-i\beta_l H_B}e^{-i\gamma_l H_C}|\psi_{in}\rangle\]</div>
<p>Thus the ansatz line we need to build consists of <span class="math notranslate nohighlight">\(U_C(\gamma)\)</span> and <span class="math notranslate nohighlight">\(U_B(\beta)\)</span> which alternate the two unitary transformations, where <span class="math notranslate nohighlight">\(U_C(\gamma)=e^{-i\gamma \sum_{\langle i,j\rangle}Z_i Z_j}\)</span> can be implemented by the <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/en/master/core/gates/mindquantum.core.gates.Rzz.html">Rzz</a> gate. <span class="math notranslate nohighlight">\(U_B(\beta)=e^{i\beta \sum_i X_i}\)</span> is then equivalent to acting a
<a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/en/master/core/gates/mindquantum.core.gates.RX.html">RX</a> revolving gate on each quantum bit, with <span class="math notranslate nohighlight">\(\gamma\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> as trainable parameters.</p>
<p>Build the quantum circuit corresponding to <span class="math notranslate nohighlight">\(U_C(\gamma)\)</span>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_hc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">para</span><span class="p">):</span>
    <span class="n">hc</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                  <span class="c1"># Build quantum circuit</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">hc</span> <span class="o">+=</span> <span class="n">Rzz</span><span class="p">(</span><span class="n">para</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>       <span class="c1"># Act Rzz gate on each edge of the diagram</span>
    <span class="n">hc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>                    <span class="c1"># Add Barrier for easy display of circuits</span>
    <span class="k">return</span> <span class="n">hc</span>
</pre></div>
</div>
</div>
<p>Display the circuits:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">build_hc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../_images/case_library_quantum_approximate_optimization_algorithm_9_0.svg" src="../_images/case_library_quantum_approximate_optimization_algorithm_9_0.svg" /></div>
</div>
<p>Build the quantum circuits corresponding to <span class="math notranslate nohighlight">\(U_B(\beta)\)</span>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_hb</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">para</span><span class="p">):</span>
    <span class="n">hb</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>              <span class="c1"># Build quantum circuit</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">hb</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="n">para</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>    <span class="c1"># Act RX gate on each node</span>
    <span class="n">hb</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>                <span class="c1"># Add Barrier for easy display of circuits</span>
    <span class="k">return</span> <span class="n">hb</span>
</pre></div>
</div>
</div>
<p>Display the circuits:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">build_hb</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../_images/case_library_quantum_approximate_optimization_algorithm_13_0.svg" src="../_images/case_library_quantum_approximate_optimization_algorithm_13_0.svg" /></div>
</div>
<p>The ansatz circuit that implements a layer of unitary transform <span class="math notranslate nohighlight">\(U_B(\beta) U_C(\gamma)\)</span> is shown below:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">build_hc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">build_hb</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../_images/case_library_quantum_approximate_optimization_algorithm_15_0.svg" src="../_images/case_library_quantum_approximate_optimization_algorithm_15_0.svg" /></div>
</div>
<p>In order to make the final optimization result accurate enough, we need to repeat the quantum circuit several times, so we build a multilayer training network by the following function:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># g is the graph of the max-cut problem, and p is the number of layers of the ansatz circuit</span>
<span class="k">def</span> <span class="nf">build_ansatz</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>  <span class="c1"># Build quantum circuit</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="c1"># Add the circuit corresponding to Uc, with parameters noted as g0, g1, g2...</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">build_hc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;g</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Add the circuit corresponding to Ub, with parameters noted as b0, b1, b2...</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">build_hb</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;b</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
</div>
<p>The Hamiltonian quantity <span class="math notranslate nohighlight">\(H_C=\sum_{(i,j)\in C}(Z_iZ_j-1)/2\)</span> corresponding to construction graph(ignoring the constant terms and coefficients).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_ham</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="n">ham</span> <span class="o">=</span> <span class="n">QubitOperator</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">ham</span> <span class="o">+=</span> <span class="n">QubitOperator</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Z</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> Z</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># Generate hamiltonian Hc</span>
    <span class="k">return</span> <span class="n">ham</span>
</pre></div>
</div>
</div>
</section>
<section id="generating-a-complete-quantum-circuit-and-the-hamiltonian-corresponding-to-the-graph">
<h3>Generating a Complete Quantum Circuit and the Hamiltonian Corresponding to the Graph<a class="headerlink" href="#generating-a-complete-quantum-circuit-and-the-hamiltonian-corresponding-to-the-graph" title="Permalink to this headline"></a></h3>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">4</span></code> is selected, indicating that the four-layer QAOA quantum circuit is used. <code class="docutils literal notranslate"><span class="pre">ansatz</span></code> is a quantum circuit for solving the problem, and <code class="docutils literal notranslate"><span class="pre">init_state_circ</span></code> is a quantum circuit for preparing a quantum state on a uniformly superposed state.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">ham</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">build_ham</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span>     <span class="c1"># Generate Hamiltonian quantities</span>
<span class="n">init_state_circ</span> <span class="o">=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>    <span class="c1"># Generate uniform superposition states, i.e., act H-gate on all quantum bits</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">build_ansatz</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>         <span class="c1"># Generate ansatz circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">init_state_circ</span> <span class="o">+</span> <span class="n">ansatz</span>         <span class="c1"># Combine the initialized circuit and the ansatz circuit into one circuit</span>
<span class="n">circ</span><span class="o">.</span><span class="n">svg</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1200</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../_images/case_library_quantum_approximate_optimization_algorithm_21_0.svg" src="../_images/case_library_quantum_approximate_optimization_algorithm_21_0.svg" /></div>
</div>
</section>
</section>
<section id="approach-one-use-traditional-optimization-method">
<h2>Approach One: Use Traditional Optimization Method<a class="headerlink" href="#approach-one-use-traditional-optimization-method" title="Permalink to this headline"></a></h2>
<section id="generating-gradient-operator">
<h3>Generating Gradient Operator<a class="headerlink" href="#generating-gradient-operator" title="Permalink to this headline"></a></h3>
<p>First, we use a simulator to generate computational operators for calculating expectations and gradients of QAOA variational quantum circuit.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>
<span class="n">grad_ops</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">grad_ops</span></code> is a operator to calculate the expectation and gradient. For example, we can use this operator to calculate the expectation and gradient at <code class="docutils literal notranslate"><span class="pre">p0</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">p0</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">params_name</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">grad_ops</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Expectation Value: &#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Expectation Value Shape: &#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Gradient: &#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Gradient Shape: &#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Expectation Value:  [[2.2839928+4.88195544e-17j]]
Expectation Value Shape:  (1, 1)
Gradient:  [[[ 0.60966156+0.j -0.50977303+0.j  1.96920626+0.j -1.89443604+0.j
    0.9840882 +0.j -1.85238736+0.j  1.27387126+0.j -0.03135037+0.j]]]
Gradient Shape:  (1, 1, 8)
</pre></div></div>
</div>
<p>Here, we get the expectation values as an <span class="math notranslate nohighlight">\((m=1,n=1)\)</span>-dimensional array, where <span class="math notranslate nohighlight">\(m\)</span> represents how many data points were encoded into a quantum state during this computation. Since QAOA tasks do not require an encoder, the default value for <span class="math notranslate nohighlight">\(m\)</span> is 1. Meanwhile, <span class="math notranslate nohighlight">\(n\)</span> represents how many Hamiltonian expectation values were computed in this operation (MindQuantum supports parallel processing of multiple Hamiltonians). In this case, we only calculate the expectation value for
<code class="docutils literal notranslate"><span class="pre">ham</span></code>, so <span class="math notranslate nohighlight">\(n=1\)</span>. Similarly, for the gradient values, their dimensions are <span class="math notranslate nohighlight">\((m=1,n=1,k=8)\)</span>, where the additional dimension <span class="math notranslate nohighlight">\(k=8\)</span> represents the number of ansatz variational parameters in the entire circuit.</p>
<p>We introduce the second-order optimizer BFGS from scipy to optimize the Max-Cut problem. To do this, we first define the function to be optimized:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0604</span>
<span class="k">global</span> <span class="n">step</span>
<span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">grad_ops</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">step</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">grad_ops</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">g</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;train step: </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2"> , cut: [</span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span>


<span class="n">fun</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">grad_ops</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(2.2839927952206174,
 array([ 0.60966156, -0.50977303,  1.96920626, -1.89443604,  0.9840882 ,
        -1.85238736,  1.27387126, -0.03135037]))
</pre></div></div>
</div>
</section>
<section id="training-process">
<h3>Training Process<a class="headerlink" href="#training-process" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">BFGS</span></code> is a second-order optimizer that performs well. By specifying <code class="docutils literal notranslate"><span class="pre">jac=True</span></code>, you are telling the optimizer that the function to be optimized will return both the function value and the gradient at the same time. If set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the optimizer will use finite differences to approximate the gradient on its own, which can be computationally expensive.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>

<span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">,</span> <span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
train step: 10 , cut: [3.5103176644442238]
train step: 20 , cut: [3.868695972469235]
train step: 30 , cut: [4.194720830469368]
train step: 40 , cut: [4.649109856438022]
train step: 50 , cut: [4.752059940467564]
train step: 60 , cut: [4.777656304269479]
train step: 70 , cut: [4.820166856240324]
train step: 80 , cut: [4.825019042509073]
train step: 90 , cut: [4.826176814772741]
</pre></div></div>
</div>
<p>At the optimal solution, the variational parameters obtained from training are:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">params_name</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
{&#39;g0&#39;: -0.7937405245633787, &#39;b0&#39;: 0.24377670109607055, &#39;g1&#39;: 1.6118673525265843, &#39;b1&#39;: -2.0908435247717794, &#39;g2&#39;: -0.21919996577600231, &#39;b2&#39;: -1.955308095101507, &#39;g3&#39;: 1.2663769844140762, &#39;b3&#39;: 2.752892656008665}
</pre></div></div>
</div>
</section>
</section>
<section id="approach-two-use-mindspore-to-train-quantum-neural-network">
<h2>Approach two: Use MindSpore to Train Quantum Neural Network<a class="headerlink" href="#approach-two-use-mindspore-to-train-quantum-neural-network" title="Permalink to this headline"></a></h2>
<section id="building-a-quantum-neural-network-to-be-trained">
<h3>Building a Quantum Neural Network to Be Trained<a class="headerlink" href="#building-a-quantum-neural-network-to-be-trained" title="Permalink to this headline"></a></h3>
<p>This problem does not require a coding-layer quantum circuit, so we use <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/en/master/framework/layer/mindquantum.framework.MQAnsatzOnlyLayer.html">MQAnsatzOnlyLayer</a> as a quantum neural network to be trained and an <a class="reference external" href="https://www.mindspore.cn/docs/en/master/api_python/nn/mindspore.nn.Adam.html">Adam</a> optimizer.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>    <span class="c1"># Create a simulator, backend uses &#39;mqvector&#39; and can simulate 5 bits (the number of bits contained in the &#39;circ&#39; line)</span>

<span class="c1"># Obtain the operator to calculate the expectation and gradient of the variational quantum circuit</span>
<span class="n">grad_ops</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">circ</span><span class="p">)</span>

<span class="c1"># Generate the neural network to be trained</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">MQAnsatzOnlyLayer</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">)</span>

<span class="c1"># Set the Adam optimizer for all trainable parameters in the network with a learning rate of 0.05</span>
<span class="n">opti</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="c1"># One-step training of neural networks</span>
<span class="n">train_net</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">TrainOneStepCell</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">opti</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="training-and-displaying-results">
<h3>Training and Displaying Results<a class="headerlink" href="#training-and-displaying-results" title="Permalink to this headline"></a></h3>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">):</span>
    <span class="c1"># Train the neural network for one step and calculate the result (number of cut edges). Note: Every time &#39;train_net()&#39; is run, the neural network is trained for one step</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="o">-</span> <span class="n">train_net</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train step:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;, cut:&quot;</span><span class="p">,</span> <span class="n">cut</span><span class="p">)</span>   <span class="c1"># For every 10 training steps, print the current number of training steps and the current number of cutting edges obtained</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
train step: 0 , cut: [3.0004191]
train step: 10 , cut: [4.440877]
train step: 20 , cut: [4.699215]
train step: 30 , cut: [4.7900705]
train step: 40 , cut: [4.8516107]
train step: 50 , cut: [4.8745494]
train step: 60 , cut: [4.89936]
train step: 70 , cut: [4.9250917]
train step: 80 , cut: [4.938618]
train step: 90 , cut: [4.937195]
train step: 100 , cut: [4.9391575]
train step: 110 , cut: [4.939012]
train step: 120 , cut: [4.9392276]
train step: 130 , cut: [4.939231]
train step: 140 , cut: [4.9392524]
train step: 150 , cut: [4.9392548]
train step: 160 , cut: [4.9392567]
train step: 170 , cut: [4.939257]
train step: 180 , cut: [4.939257]
train step: 190 , cut: [4.939257]
</pre></div></div>
</div>
<p>Based on the above training results, we find that the number of cut edges corresponding to the ground state energy of Hamiltonian is close to 5.</p>
</section>
<section id="optimal-parameter">
<h3>Optimal Parameter<a class="headerlink" href="#optimal-parameter" title="Permalink to this headline"></a></h3>
<p>Previously, we obtained the optimal values of the parameters in the quantum circuit by training. In the following, we extract the optimal parameters and store them as dictionary types, which correspond to the parameters named in the previous circuit.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">params_name</span><span class="p">,</span> <span class="n">net</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>  <span class="c1"># Obtain circuit parameters</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
{&#39;g0&#39;: 0.44889548, &#39;b0&#39;: -1.1389917, &#39;g1&#39;: 0.9062595, &#39;b1&#39;: -0.94462746, &#39;g2&#39;: 1.0675684, &#39;b2&#39;: -0.6775048, &#39;g3&#39;: 1.1679738, &#39;b3&#39;: -0.38228452}
</pre></div></div>
</div>
</section>
<section id="probabilistic-graph">
<h3>Probabilistic Graph<a class="headerlink" href="#probabilistic-graph" title="Permalink to this headline"></a></h3>
<p>We substitute the optimal parameters into the quantum circuit and draw the probability distribution of the final quantum state under the computed vector by sampling the quantum circuit 1000 times:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>                            <span class="c1"># Add measurement gates for all bits in the circuit</span>
<span class="n">sim</span><span class="o">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">pr</span><span class="o">=</span><span class="n">pr</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>   <span class="c1"># Run the circuit 1000 times and print the results</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../_images/case_library_quantum_approximate_optimization_algorithm_39_0.svg" src="../_images/case_library_quantum_approximate_optimization_algorithm_39_0.svg" /></div>
</div>
<p>According to the probability distribution diagram, the Max-Cut problem has four degenerate solutions, and the probability corresponding to each solution is about 25%.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">01001</span></code>: The vertices numbered 1, 2, and 4 are on the left, and the vertices numbered 0 and 3 are on the right.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">10110</span></code>: The vertices numbered 0 and 3 are on the left, and the vertices numbered 1, 2, and 4 are on the right.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">01011</span></code>: The vertices numbered 2 and 4 are on the left, and the vertices numbered 0, 1, and 3 are on the right.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">10100</span></code>: The vertices numbered 0, 1, and 3 are on the left, and the vertices numbered 2 and 4 are on the right.</p></li>
</ul>
<p>It can be found that the above results are consistent with the previous results obtained by the exhaustive method.</p>
</section>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline"></a></h2>
<p>We use the quantum approximation optimization algorithm to solve the Max-Cut problem and obtain the Max-Cut solution corresponding to the graph in the case.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.utils.show_info</span> <span class="kn">import</span> <span class="n">InfoTable</span>

<span class="n">InfoTable</span><span class="p">(</span><span class="s1">&#39;mindquantum&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<table border="1">
  <tr>
    <th>Software</th>
    <th>Version</th>
  </tr>
<tr><td>mindquantum</td><td>0.9.11</td></tr>
<tr><td>scipy</td><td>1.10.1</td></tr>
<tr><td>numpy</td><td>1.21.6</td></tr>
<tr>
    <th>System</th>
    <th>Info</th>
</tr>
<tr><td>Python</td><td>3.9.13</td></tr><tr><td>OS</td><td>Linux x86_64</td></tr><tr><td>Memory</td><td>16.62 GB</td></tr><tr><td>CPU Max Thread</td><td>16</td></tr><tr><td>Date</td><td>Mon Oct 30 20:17:07 2023</td></tr>
</table></div>
</div>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<p>[1] Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. <a class="reference external" href="https://arxiv.org/pdf/1411.4028.pdf">A Quantum Approximate Optimization Algorithm</a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="quantum_phase_estimation.html" class="btn btn-neutral float-left" title="Quantum Phase Estimation Algorithm" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="classification_of_iris_by_qnn.html" class="btn btn-neutral float-right" title="Classification of IRIS by Quantum Neural Network" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>