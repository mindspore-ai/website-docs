<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Equivalence Checking of Parameterized Quantum Circuits &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script><script src="_static/jquery.js"></script>
        <script src="_static/js/theme.js"></script><script src="_static/underscore.js"></script><script src="_static/doctools.js"></script><script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script><script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Quantum Phase Estimation Algorithm" href="quantum_phase_estimation.html" />
    <link rel="prev" title="VQE Application in Quantum Chemistry Computing" href="vqe_for_quantum_chemistry.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">MindSpore Quantum Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_simulator.html">Quantum simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">Initial experience of quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">Advanced gradient calculation of variational quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_operations_of_quantum_circuit.html">Advanced operations of quantum circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_measurement.html">Quantum Measurement</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Noisy Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_simulator.html">Noise simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="qubit_mapping.html">Qubit Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="bloch_sphere.html">Bloch Sphere</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variational Quantum Algorithm</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">Classification of iris by quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">The Application of Quantum Neural Network in NLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">VQE Application in Quantum Chemistry Computing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Equivalence Checking of Parameterized Quantum Circuits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-1-prepare-the-quantum-circuits">Step 1: prepare the quantum circuits</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setp-2-draw-the-complete-circuit-into-zx-diagram">Setp 2: draw the complete circuit into ZX diagram</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-3-simplify-the-zx-diagram">Step 3: simplify the ZX diagram</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-4-if-zx-calculus-not-sure-then-verify-by-instantiating-the-parameter">Step 4: if ZX calculus not sure then verify by instantiating the parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#final-step-merge-the-above-process-into-a-complete-function">Final step: merge the above process into a complete function</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">Grover search and Long algorithms based on MindSpore Quantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">Shor’s algorithm based on MindSpore Quantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.dtype.html">mindquantum.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.device.html">mindquantum.device</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Equivalence Checking of Parameterized Quantum Circuits</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/equivalence_checking_of_PQC.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="equivalence-checking-of-parameterized-quantum-circuits">
<h1>Equivalence Checking of Parameterized Quantum Circuits<a class="headerlink" href="#equivalence-checking-of-parameterized-quantum-circuits" title="Permalink to this headline"></a></h1>
<p><a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/en/mindspore_equivalence_checking_of_PQC.ipynb"><img alt="Download Notebook" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_notebook_en.svg" /></a>  <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/en/mindspore_equivalence_checking_of_PQC.py"><img alt="Download Code" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_download_code_en.svg" /></a>  <a class="reference external" href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_en/equivalence_checking_of_PQC.ipynb"><img alt="View source on Gitee" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source_en.svg" /></a></p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>Before running on a quantum device, a parameterized quantum circuit needs to be compiled into a new circuit consisting of the set of quantum gates supported by the device. Therefore, it is necessary to check the equivalence of the two circuits before and after compilation.</p>
<p>In the paper Equivalence Checking of Parameterized Quantum Circuits, a method for checking the equivalence of parameterized quantum circuits based on ZX calculus is proposed. This tutorial attempts to reproduce the method in the MindSpore Quantum architecture.</p>
<p>Paper link: <a class="reference external" href="https://doi.org/10.1145/3566097.3567932">https://doi.org/10.1145/3566097.3567932</a></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># import libraries</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">H</span><span class="p">,</span> <span class="n">CNOT</span><span class="p">,</span> <span class="n">RX</span><span class="p">,</span> <span class="n">RZ</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">dagger</span>
</pre></div>
</div>
</div>
</section>
<section id="step-1-prepare-the-quantum-circuits">
<h2>Step 1: prepare the quantum circuits<a class="headerlink" href="#step-1-prepare-the-quantum-circuits" title="Permalink to this headline"></a></h2>
<p>Take the TwoLocal-Circular circuit in the Qiskit circuits library as an example. The TwoLocal circuit is a parameterized circuit composed of alternating rotation layers and entanglement layers. Rotation layer consists of single qubit gates acting on all qubits. Entanglement layer consists of double qubit gates to entangle qubits according to the entanglement strategy.</p>
<p>Construct a TwoLocal-Circular circuit acting on 127-bit qubits, consisting of three sets of rotation layers and entanglement layers alternately, containing a total of 508 parameters. The rotation layer is RX gates acting on each qubit. The entanglement layer is a CNOT gate on the first qubit controlled by the last qubit and CNOT gates on the next qubit controlled by the previous qubit.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ansatz = rotation layer + entanglement layer</span>
<span class="k">def</span> <span class="nf">build_ansatz</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>    <span class="c1"># initialize a quantum circuit</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
            <span class="n">circ</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="n">i</span><span class="o">*</span><span class="n">n_qubits</span><span class="o">+</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>    <span class="c1"># RX gate on each qubit</span>
        <span class="c1"># CNOT gate on the first qubit controlled by the last qubit</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># CNOT gate on the next qubit controlled by the previous qubit</span>
            <span class="n">circ</span> <span class="o">+=</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="n">depth</span><span class="o">*</span><span class="n">n_qubits</span><span class="o">+</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>    <span class="c1"># RX gate on each qubit</span>

    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># example ansatz: 3 qubits and 1 layer</span>
<span class="n">build_ansatz</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/equivalence_checking_of_PQC_4_0.svg" src="_images/equivalence_checking_of_PQC_4_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># initial circuit: 127 qubits and 3 layer</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">127</span>
<span class="n">depth</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">circ1</span> <span class="o">=</span> <span class="n">build_ansatz</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
<span class="n">circ1</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
==============================================Circuit Summary==============================================
|Total number of gates  : 889.                                                                            |
|Parameter gates        : 508.                                                                            |
|with 508 parameters are:                                                                                 |
|theta0, theta1, theta2, theta3, theta4, theta5, theta6, theta7, theta8, theta9..                        .|
|Number qubit of circuit: 127                                                                             |
===========================================================================================================
</pre></div></div>
</div>
<p>Then do the compilation.</p>
<p>Suppose the set of quantum gates before compilation is: H, CNOT, RZ, RX. The compiled set of quantum gates is: H, CNOT, RZ. The compilation rule is that the H, CNOT, and RZ gates remain unchanged, and the RX gates are compiled into a combination of H,RZ,H.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compile_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">):</span>
    <span class="n">circ_compiled</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">gate</span> <span class="ow">in</span> <span class="n">circ</span><span class="p">:</span>    <span class="c1"># traverse the gates in the initial circuit</span>
        <span class="c1"># the H, CNOT, and RZ gates remain unchanged</span>
        <span class="k">if</span> <span class="n">gate</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span> <span class="ow">or</span> <span class="n">gate</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;CNOT&#39;</span> <span class="ow">or</span> <span class="n">gate</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;RZ&#39;</span><span class="p">:</span>
            <span class="n">circ_compiled</span> <span class="o">+=</span> <span class="n">gate</span>
        <span class="c1"># the RX gates are compiled into a combination of H*RZ*H</span>
        <span class="k">elif</span> <span class="n">gate</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;RX&#39;</span><span class="p">:</span>
            <span class="n">circ_compiled</span> <span class="o">+=</span> <span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">)</span>
            <span class="n">circ_compiled</span> <span class="o">+=</span> <span class="n">RZ</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">)</span>
            <span class="n">circ_compiled</span> <span class="o">+=</span> <span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circ_compiled</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we can see that all RX gates have changed according to the compilation rules</span>
<span class="n">compile_circuit</span><span class="p">(</span><span class="n">build_ansatz</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/equivalence_checking_of_PQC_8_0.svg" src="_images/equivalence_checking_of_PQC_8_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># compile initial circuit</span>
<span class="n">circ2</span> <span class="o">=</span> <span class="n">compile_circuit</span><span class="p">(</span><span class="n">circ1</span><span class="p">)</span>
<span class="n">circ2</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
==============================================Circuit Summary==============================================
|Total number of gates  : 1905.                                                                           |
|Parameter gates        : 508.                                                                            |
|with 508 parameters are:                                                                                 |
|theta0, theta1, theta2, theta3, theta4, theta5, theta6, theta7, theta8, theta9..                        .|
|Number qubit of circuit: 127                                                                             |
===========================================================================================================
</pre></div></div>
</div>
<p>Finally, construct the complete cicuit.</p>
<p>According to the reversibility of the quantum circuit, if the two circuits are equivalent, then applying one circuit and the reversion of the other circuit, the final quantum state is equivalent to the state before the application. Thus, the complete quantum circuit consists of the compiled circuit and the reversion of the initial circuit.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># complete circuit</span>
<span class="n">circ1_inv</span> <span class="o">=</span> <span class="n">dagger</span><span class="p">(</span><span class="n">circ1</span><span class="p">)</span>    <span class="c1"># dagger() reverse the circuit</span>
<span class="c1"># complete circuit = reversion of initial circuit + circuit after compilation</span>
<span class="n">circ_all</span> <span class="o">=</span> <span class="n">circ1_inv</span> <span class="o">+</span> <span class="n">circ2</span>
<span class="n">circ_all</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
========================================================Circuit Summary========================================================
|Total number of gates  : 2794.                                                                                               |
|Parameter gates        : 1016.                                                                                               |
|with 508 parameters are:                                                                                                     |
|theta507, theta506, theta505, theta504, theta503, theta502, theta501, theta500, theta499, theta498..                        .|
|Number qubit of circuit: 127                                                                                                 |
===============================================================================================================================
</pre></div></div>
</div>
</section>
<section id="setp-2-draw-the-complete-circuit-into-zx-diagram">
<h2>Setp 2: draw the complete circuit into ZX diagram<a class="headerlink" href="#setp-2-draw-the-complete-circuit-into-zx-diagram" title="Permalink to this headline"></a></h2>
<p>The equivalence checking of parameterized quantum circuits is based on the ZX calculus. Then the quantum circuits need to be converted into ZX diagrams.</p>
<p>The quantum gate is the vertex in the ZX diagram, divided into 3 colors. The H gate is represented as a yellow vertex, the RX gate is a red vertex with parameters, and the RZ gate is a green vertex with parameters. The target qubit of the CNOT gate is a red vertex, and the control qubit is a green vertex, which two are neighbors. The vertices of two adjacent quantum gates on the same qubit are neighbors to each other.</p>
<p>Start by defining the vertex class and graph class.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vertex</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">qubit</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>    <span class="c1"># the number of the vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>    <span class="c1"># the color of the vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span>   <span class="c1"># the parameter of the vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span> <span class="o">=</span> <span class="n">qubit</span>     <span class="c1"># the qubit of the vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span> <span class="o">=</span> <span class="n">neighbor</span>    <span class="c1"># the neighbor of the vertex</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># count: the total number of vertices</span>
        <span class="c1"># which only increases but does not decrease</span>
        <span class="c1"># count is also used to name new vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># add an edge from the start to the end</span>
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_vertex</span><span class="p">,</span> <span class="n">to_vertex</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_vertex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">qubit</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># add edges from the current vertex to its neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">qubit</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">phase</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="p">:</span>    <span class="c1"># add edges from its neighbors to it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;==================graph message==================&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">neighbor</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">phase</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># clear the loops produced during adding or deleting</span>
    <span class="c1"># there is no loop in ZX-diagram(loop which made of a single edge)</span>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">while</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                <span class="c1"># remove the vertex from its own neighbors</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                <span class="c1"># delete edges whose end is the current vertex</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># delete edges whose start is the current vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># if two circuits are equivalent</span>
    <span class="k">def</span> <span class="nf">equiv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if equivalent, after simplification, there is no vertex</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Equivalent!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not sure!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Then draw the quantum circuit into a ZX diagram.</p>
<p>Traverse all the quantum gates in the circuit and plot them as vertices in the ZX diagram. If there is no gate on the current qubit, the current quantum gate has no neighbors. If there has at least one quantum gate on the current qubit, the current quantum gate and the last quantum gate on the qubit are neighbors. The CNOT gate adds a neighbor relationship between the control qubit and the target qubit.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">draw_graph</span><span class="p">(</span><span class="n">circ</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="c1"># last_name saves the last vertex on each qubit</span>
    <span class="n">last_name</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_qubits</span>
    <span class="k">for</span> <span class="n">gate</span> <span class="ow">in</span> <span class="n">circ</span><span class="p">:</span>    <span class="c1"># traverse all the quantum gates</span>
        <span class="k">if</span> <span class="n">gate</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>    <span class="c1"># H gate = yellow vertex</span>
            <span class="c1"># there are vertices on the current qubit</span>
            <span class="k">if</span> <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                             <span class="p">[</span><span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
            <span class="k">else</span><span class="p">:</span>    <span class="c1"># there is no vertex on the current qubit</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[])</span>
            <span class="c1"># update the last vertex on the current qubit to the current vertex</span>
            <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">gate</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;RX&#39;</span><span class="p">:</span>    <span class="c1"># RX gate = red vertex</span>
            <span class="k">if</span> <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                             <span class="p">[</span><span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">gate</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[],</span> <span class="n">gate</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
            <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">gate</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;RZ&#39;</span><span class="p">:</span>    <span class="c1"># RZ gate = green vertex</span>
            <span class="k">if</span> <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                             <span class="p">[</span><span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">gate</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[],</span> <span class="n">gate</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
            <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">gate</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;CNOT&#39;</span><span class="p">:</span>
            <span class="c1"># control qubit = green vertex</span>
            <span class="k">if</span> <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                             <span class="p">[</span><span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[])</span>
            <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span>
            <span class="c1"># target qubit = red vertex</span>
            <span class="k">if</span> <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                             <span class="p">[</span><span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">g</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">last_name</span><span class="p">[</span><span class="n">gate</span><span class="o">.</span><span class="n">obj_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">g</span>
</pre></div>
</div>
</div>
<p>Finally, draw the complete quantum circuit into a ZX diagram.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">draw_graph</span><span class="p">(</span><span class="n">circ_all</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="step-3-simplify-the-zx-diagram">
<h2>Step 3: simplify the ZX diagram<a class="headerlink" href="#step-3-simplify-the-zx-diagram" title="Permalink to this headline"></a></h2>
<p>The ZX calculus consists of ZX diagrams and reduction rules, according to which the vertices and neighbor relations in the ZX diagram are simplified.</p>
<p>Here lists some of the rules, and will not be repeated one by one.</p>
<p>rule 1: red or green vertices with parameter 0 that are not adjacent to vertices on other qubits can be deleted.</p>
<p><img alt="equivalence checking of PQC rule 1" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_en/images/equivalence_checking_of_PQC_rule_1.jpg" /></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rule_1</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
    <span class="c1"># during the ZX calculus, the vertices will increase or decrease</span>
    <span class="c1"># use list() to get all the initial vertices</span>
    <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="c1"># whether the current vertex has been deleted during simplification</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">continue</span>    <span class="c1"># deleted, pass</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="c1"># parameter = 0</span>
        <span class="k">if</span> <span class="n">v1</span><span class="o">.</span><span class="n">phase</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">phase</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">phase</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="c1"># whether the current vertex is related to vertices on other qubits</span>
            <span class="c1"># and if so, it cannot be deleted</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
                <span class="c1"># related to vertices on other qubits</span>
                <span class="k">if</span> <span class="n">v2</span><span class="o">.</span><span class="n">qubit</span> <span class="o">!=</span> <span class="n">v1</span><span class="o">.</span><span class="n">qubit</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>    <span class="c1"># not related to vertices on other qubits</span>
                <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
                    <span class="c1"># connect the previous vertex to the next vertex</span>
                    <span class="n">v2</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>    <span class="c1"># remove rings that may arise</span>
                <span class="n">g</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>    <span class="c1"># delete the current vertex</span>
</pre></div>
</div>
</div>
<p>rule 2: two adjacent, red or green vertices of the same color can be merged.</p>
<p><img alt="equivalence checking of PQC rule 2" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_en/images/equivalence_checking_of_PQC_rule_2.jpg" /></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rule_2</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">v1</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;red&#39;</span> <span class="ow">or</span> <span class="n">v1</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;green&#39;</span><span class="p">:</span>    <span class="c1"># red or green</span>
            <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>    <span class="c1"># adjacent</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">v2</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">v1</span><span class="o">.</span><span class="n">color</span><span class="p">:</span>    <span class="c1"># same color</span>
                    <span class="n">v2</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">v2</span><span class="o">.</span><span class="n">phase</span> <span class="o">+</span> <span class="n">v1</span><span class="o">.</span><span class="n">phase</span>    <span class="c1"># add the parameters</span>
                    <span class="c1"># merge these two vertices</span>
                    <span class="n">v2</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">v3</span> <span class="ow">in</span> <span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>    <span class="c1"># update the neighbors</span>
                        <span class="n">v3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v3</span><span class="p">]</span>
                        <span class="n">v3</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="c1"># delete the vertex that has been merged</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>rule 3: green vertices whose neighbors are yellow vertices can become red vertices and remove adjacent yellow vertices.</p>
<p><img alt="equivalence checking of PQC rule 3" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_en/images/equivalence_checking_of_PQC_rule_3.jpg" /></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rule_3</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">v1</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;green&#39;</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>    <span class="c1"># if all neighbors yellow</span>
            <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">v2</span><span class="o">.</span><span class="n">color</span> <span class="o">!=</span> <span class="s1">&#39;yellow&#39;</span><span class="p">:</span>    <span class="c1"># not all neighbors yellow</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>    <span class="c1"># all neighbors yellow</span>
                <span class="n">v1</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>    <span class="c1"># turn into red</span>
                <span class="n">v1_neighbor</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v1_neighbor</span><span class="p">:</span>    <span class="c1"># delete these yellow vertices</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
                    <span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v2</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">v3</span> <span class="ow">in</span> <span class="n">v2</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                        <span class="n">v3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v3</span><span class="p">]</span>
                        <span class="n">v3</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="n">v2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>rule 4: two edges between adjacent red and green vertices can be deleted.</p>
<p><img alt="equivalence checking of PQC rule 4" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_en/images/equivalence_checking_of_PQC_rule_4.jpg" /></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rule_4</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">v1</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;green&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
                <span class="c1"># adjacent red and green vertices with two edges</span>
                <span class="k">if</span> <span class="n">v2</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;red&#39;</span> <span class="ow">and</span> <span class="n">v2</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># delete these two edges</span>
                    <span class="k">while</span> <span class="n">v2</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                        <span class="n">v1</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">while</span> <span class="n">v1</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                        <span class="n">v2</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Then, use the above rules to simplify the ZX diagram. If no vertex is deleted in a round, the simplification is considered to be complete.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># whether vertices have been deleted in the current round</span>
    <span class="c1"># if no vertex is removed in the current round</span>
    <span class="c1"># the simplification is considered complete</span>
    <span class="k">while</span> <span class="n">temp</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">rule_3</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">rule_2</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">rule_4</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">rule_1</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The complete circuit is large in scale, and a single-layer circuit acting on three qubits can be constructed for testing.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_circ1</span> <span class="o">=</span> <span class="n">build_ansatz</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">test_circ1_inv</span> <span class="o">=</span> <span class="n">dagger</span><span class="p">(</span><span class="n">test_circ1</span><span class="p">)</span>
<span class="n">test_circ2</span> <span class="o">=</span> <span class="n">compile_circuit</span><span class="p">(</span><span class="n">test_circ1</span><span class="p">)</span>

<span class="n">test_circ_all</span> <span class="o">=</span> <span class="n">test_circ1_inv</span> <span class="o">+</span> <span class="n">test_circ2</span>

<span class="n">test_circ_all</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/equivalence_checking_of_PQC_30_0.svg" src="_images/equivalence_checking_of_PQC_30_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># draw the testing circuit into a ZX diagram</span>
<span class="n">test_g</span> <span class="o">=</span> <span class="n">draw_graph</span><span class="p">(</span><span class="n">test_circ_all</span><span class="p">)</span>
<span class="n">test_g</span><span class="o">.</span><span class="n">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
==================graph message==================
0        [4]     red     -theta5
1        [3]     red     -theta4
2        [5]     red     -theta3
3        [1, 4, 6]       green   0.0
4        [0, 3, 7]       red     0.0
5        [2, 6, 8]       green   0.0
6        [3, 5, 10]      red     0.0
7        [4, 8, 9]       green   0.0
8        [5, 7, 11]      red     0.0
9        [7, 18]         red     -theta2
10       [6, 15]         red     -theta1
11       [8, 12]         red     -theta0
12       [11, 13]        yellow          0.0
13       [12, 14]        green   theta0
14       [13, 22]        yellow          0.0
15       [10, 16]        yellow          0.0
16       [15, 17]        green   theta1
17       [16, 24]        yellow          0.0
18       [9, 19]         yellow          0.0
19       [18, 20]        green   theta2
20       [19, 21]        yellow          0.0
21       [20, 22, 26]    green   0.0
22       [14, 21, 23]    red     0.0
23       [22, 24, 27]    green   0.0
24       [17, 23, 25]    red     0.0
25       [24, 26, 30]    green   0.0
26       [21, 25, 33]    red     0.0
27       [23, 28]        yellow          0.0
28       [27, 29]        green   theta3
29       [28]    yellow          0.0
30       [25, 31]        yellow          0.0
31       [30, 32]        green   theta4
32       [31]    yellow          0.0
33       [26, 34]        yellow          0.0
34       [33, 35]        green   theta5
35       [34]    yellow          0.0


</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># simplify the testing circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before simplification:&quot;</span><span class="p">)</span>
<span class="n">test_g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>

<span class="n">simplify</span><span class="p">(</span><span class="n">test_g</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after simplification:&quot;</span><span class="p">)</span>
<span class="n">test_g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
before simplification:
Not sure!
after simplification:
Equivalent!
</pre></div></div>
</div>
<p>After passing the simplification function test, we can try to simplify the ZX diagram of the complete circuit. The result shows that the two circuits before and after compilation are equivalent.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># simplify the complete circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before simplification:&quot;</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>

<span class="n">simplify</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after simplification:&quot;</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
before simplification:
Not sure!
after simplification:
Equivalent!
</pre></div></div>
</div>
</section>
<section id="step-4-if-zx-calculus-not-sure-then-verify-by-instantiating-the-parameter">
<h2>Step 4: if ZX calculus not sure then verify by instantiating the parameter<a class="headerlink" href="#step-4-if-zx-calculus-not-sure-then-verify-by-instantiating-the-parameter" title="Permalink to this headline"></a></h2>
<p>The ZX calculus cannot directly give the result of the equivalent circuits. In this case, we need to instantiate the parameters in the circuits to determine whether the two circuits after instantiation are equivalent.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># counterexample</span>
<span class="n">neq_circ1</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">neq_circ1</span> <span class="o">+=</span> <span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">neq_circ1</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">neq_circ1</span> <span class="o">+=</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">neq_circ1</span> <span class="o">+=</span> <span class="n">RZ</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">neq_circ1</span> <span class="o">+=</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">neq_circ1</span> <span class="o">+=</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">neq_circ1</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">neq_circ1</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/equivalence_checking_of_PQC_36_0.svg" src="_images/equivalence_checking_of_PQC_36_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">neq_circ2</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">neq_circ2</span> <span class="o">+=</span> <span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">neq_circ2</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">neq_circ2</span> <span class="o">+=</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">neq_circ2</span> <span class="o">+=</span> <span class="n">RZ</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">neq_circ2</span> <span class="o">+=</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">neq_circ2</span> <span class="o">+=</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">neq_circ2</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">({</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">neq_circ2</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/equivalence_checking_of_PQC_37_0.svg" src="_images/equivalence_checking_of_PQC_37_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">neq_circ1_inv</span> <span class="o">=</span> <span class="n">dagger</span><span class="p">(</span><span class="n">neq_circ1</span><span class="p">)</span>
<span class="n">neq_circ_all</span> <span class="o">=</span> <span class="n">neq_circ1_inv</span> <span class="o">+</span> <span class="n">neq_circ2</span>    <span class="c1"># construct the complete circuit of the counterexample</span>
<span class="n">neq_circ_all</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/equivalence_checking_of_PQC_38_0.svg" src="_images/equivalence_checking_of_PQC_38_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># draw the counterexample into ZX diagram and simplify it</span>
<span class="n">neq_g</span> <span class="o">=</span> <span class="n">draw_graph</span><span class="p">(</span><span class="n">neq_circ_all</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before simplification:&quot;</span><span class="p">)</span>
<span class="n">neq_g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>

<span class="n">simplify</span><span class="p">(</span><span class="n">neq_g</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after simplification:&quot;</span><span class="p">)</span>
<span class="n">neq_g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
before simplification:
Not sure!
after simplification:
Not sure!
</pre></div></div>
</div>
<p>In this case, after simplification, there are still undeleted vertices in the ZX diagram. So the ZX calculus cannot determine its equivalence and needs to be verified by instantiating parameters.</p>
<p>The instantiation has two steps:</p>
<p>First, directly compare whether the matrices of the two circuits are equivalent after instantiation according to the map function, and stop if not.</p>
<p>Second, if the instantiation according to the map function does not get the result, randomly instantiate the parameters, and then directly compare whether the matrices of the two circuits after instantiation are equivalent. If unequivalent, the two circuits are unequivalent, otherwise equivalent.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># instantiation according to the map function</span>
<span class="k">def</span> <span class="nf">map_para</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">para</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">para</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">para</span>


<span class="c1"># randomly instantiate the parameters</span>
<span class="k">def</span> <span class="nf">random_para</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">para</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">para</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">para</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># verify by instantiating parameters</span>
<span class="k">def</span> <span class="nf">verify_by_para</span><span class="p">(</span><span class="n">circ1</span><span class="p">,</span> <span class="n">circ2</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="c1"># there are n parameters in the circuit</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">circ1</span><span class="o">.</span><span class="n">params_name</span><span class="o">+</span><span class="n">circ2</span><span class="o">.</span><span class="n">params_name</span><span class="p">)))</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>    <span class="c1"># whether the previous r-1 round has a result</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>    <span class="c1"># instantiation according to the map function</span>
        <span class="n">para</span> <span class="o">=</span> <span class="n">map_para</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># whether the matrices of the two circuits are equivalent</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">circ1</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">para</span><span class="p">),</span> <span class="n">circ2</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">para</span><span class="p">)):</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not equivalent!&#39;</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>    <span class="c1"># get a result</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>    <span class="c1"># randomly instantiate the parameters</span>
        <span class="n">para</span> <span class="o">=</span> <span class="n">random_para</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">circ1</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">para</span><span class="p">),</span> <span class="n">circ2</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">para</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Equivalent!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not equivalent!&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Verify the equivalence of the two counterexample circuits by instantiation.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">verify_by_para</span><span class="p">(</span><span class="n">neq_circ1</span><span class="p">,</span> <span class="n">neq_circ2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Not equivalent!
</pre></div></div>
</div>
</section>
<section id="final-step-merge-the-above-process-into-a-complete-function">
<h2>Final step: merge the above process into a complete function<a class="headerlink" href="#final-step-merge-the-above-process-into-a-complete-function" title="Permalink to this headline"></a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[30]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ZXcalculus</span><span class="p">(</span><span class="n">circ1</span><span class="p">,</span> <span class="n">circ2</span><span class="p">):</span>
    <span class="n">circ1_inv</span> <span class="o">=</span> <span class="n">dagger</span><span class="p">(</span><span class="n">circ1</span><span class="p">)</span>    <span class="c1"># reverse the initial circuit</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">circ1_inv</span> <span class="o">+</span> <span class="n">circ2</span>    <span class="c1"># construct the complete circuit</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">draw_graph</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>    <span class="c1"># draw the complete circuit into ZX diagram</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before simplification:&quot;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>
    <span class="n">simplify</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>    <span class="c1"># simplify by the rules</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after simplification:&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>    <span class="c1"># get a result by ZX calculus</span>
        <span class="n">g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>    <span class="c1"># need to verify by instantiation</span>
        <span class="n">g</span><span class="o">.</span><span class="n">equiv</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;verify by instantiation:&quot;</span><span class="p">)</span>
        <span class="n">verify_by_para</span><span class="p">(</span><span class="n">circ1</span><span class="p">,</span> <span class="n">circ2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.utils.show_info</span> <span class="kn">import</span> <span class="n">InfoTable</span>

<span class="n">InfoTable</span><span class="p">(</span><span class="s1">&#39;mindquantum&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<table border="1">
  <tr>
    <th>Software</th>
    <th>Version</th>
  </tr>
<tr><td>mindquantum</td><td>0.9.0</td></tr>
<tr><td>scipy</td><td>1.10.1</td></tr>
<tr><td>numpy</td><td>1.23.5</td></tr>
<tr>
    <th>System</th>
    <th>Info</th>
</tr>
<tr><td>Python</td><td>3.8.17</td></tr><tr><td>OS</td><td>Windows AMD64</td></tr><tr><td>Memory</td><td>8.39 GB</td></tr><tr><td>CPU Max Thread</td><td>8</td></tr><tr><td>Date</td><td>Mon Sep 18 14:13:25 2023</td></tr>
</table></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vqe_for_quantum_chemistry.html" class="btn btn-neutral float-left" title="VQE Application in Quantum Chemistry Computing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="quantum_phase_estimation.html" class="btn btn-neutral float-right" title="Quantum Phase Estimation Algorithm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>