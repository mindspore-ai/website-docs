<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Initial experience of quantum neural network &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script><script src="_static/jquery.js"></script>
        <script src="_static/js/theme.js"></script><script src="_static/underscore.js"></script><script src="_static/doctools.js"></script><script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script><script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Advanced gradient calculation of variational quantum circuits" href="get_gradient_of_PQC_with_mindquantum.html" />
    <link rel="prev" title="Quantum simulator" href="quantum_simulator.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">MindSpore Quantum Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_simulator.html">Quantum simulator</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Initial experience of quantum neural network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#structure-of-quantum-neural-network">Structure of Quantum Neural Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simple-example">Simple Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#environment-preparation">Environment Preparation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-encoder">Building Encoder</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-ansatz">Building Ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-hamiltonian">Building Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generate-variational-quantum-circuit-simulation-operators">Generate Variational Quantum Circuit Simulation Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-quantum-neural-network">Building a quantum neural network</a></li>
<li class="toctree-l2"><a class="reference internal" href="#training">Training</a></li>
<li class="toctree-l2"><a class="reference internal" href="#result-presentation">Result Presentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">Advanced gradient calculation of variational quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_operations_of_quantum_circuit.html">Advanced operations of quantum circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_measurement.html">Quantum Measurement</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Noisy Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_simulator.html">Noise simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="qubit_mapping.html">Qubit Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="bloch_sphere.html">Bloch Sphere</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variational Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">Classification of iris by quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">The Application of Quantum Neural Network in NLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">VQE Application in Quantum Chemistry Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="equivalence_checking_of_PQC.html">Equivalence Checking of Parameterized Quantum Circuits</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">Grover search and Long algorithms based on MindSpore Quantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">Shor’s algorithm based on MindSpore Quantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.dtype.html">mindquantum.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.device.html">mindquantum.device</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Initial experience of quantum neural network</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/initial_experience_of_quantum_neural_network.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="initial-experience-of-quantum-neural-network">
<h1>Initial experience of quantum neural network<a class="headerlink" href="#initial-experience-of-quantum-neural-network" title="Permalink to this headline"></a></h1>
<p>Translator: <a class="reference external" href="https://gitee.com/unseenme">unseenme</a></p>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_en/initial_experience_of_quantum_neural_network.md"><img alt="View Source On Gitee" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source_en.png" /></a></p>
<section id="structure-of-quantum-neural-network">
<h2>Structure of Quantum Neural Network<a class="headerlink" href="#structure-of-quantum-neural-network" title="Permalink to this headline"></a></h2>
<p>In MindSpore Quantum, the structure of the Quantum Neural Network (QNN) is shown in the figure below, which usually consists of three parts:</p>
<p>(1) One (or more) encoding circuit(s) for encoding classical data to quantum data (usually called Encoder);</p>
<p>(2) One (or more) training circuit(s) for training parameters in a quantum gate with parameters (usually called Ansatz);</p>
<p>(3) One (or more) measurement(s) for detecting whether the measurement value (for example, the measurement in the Z direction is the projection of the quantum state of a qubit on the Z axis, and the measurement obtains the expected value of the quantum state with respect to the Pauli Z operator (not limited to the Pauli Z operator, it can be replaced by other operators)) is close to the target expected value.</p>
<p><img alt="mindquantum" src="_images/mindquantum.png" /></p>
<p>Below, we use a simple example to experience how to use MindSpore Quantum.</p>
</section>
<section id="simple-example">
<h2>Simple Example<a class="headerlink" href="#simple-example" title="Permalink to this headline"></a></h2>
<p><img alt="example circuit" src="_images/example_circuit.png" /></p>
<p>We build a quantum neural network as shown in the figure above, where the Encoder consists of an <code class="docutils literal notranslate"><span class="pre">H</span></code> gate, an <code class="docutils literal notranslate"><span class="pre">RX</span></code> gate, an <code class="docutils literal notranslate"><span class="pre">RY</span></code> gate and an <code class="docutils literal notranslate"><span class="pre">RZ</span></code> gate, Ansatz consists of an <code class="docutils literal notranslate"><span class="pre">RX</span></code> gate and an <code class="docutils literal notranslate"><span class="pre">RY</span></code> gate, and the measurement is The Pauli <code class="docutils literal notranslate"><span class="pre">Z</span></code> operator acting on the 0th qubit.</p>
<p>Problem description: We regard the Encoder as the error effect of the system on the initial quantum state (the parameters <span class="math notranslate nohighlight">\(\alpha_0, \alpha_1\)</span> and <span class="math notranslate nohighlight">\(\alpha_2\)</span> are a fixed value obtained by preprocessing the original classical data (optional), that is, the known value, which is set to 0.2, 0.3 and 0.4 here respectively). We need to train an Ansatz to cancel out this error, so that the final quantum state is still in the <span class="math notranslate nohighlight">\(|0\rangle\)</span> state.</p>
<p>Idea: Perform the Pauli <code class="docutils literal notranslate"><span class="pre">Z</span></code> operator measurement in the final state, and the measurement value at this time is the expected value of the quantum state at this time about the Pauli <code class="docutils literal notranslate"><span class="pre">Z</span></code> operator. Since <span class="math notranslate nohighlight">\(|0\rangle\)</span> is the eigenstate of operator <code class="docutils literal notranslate"><span class="pre">Z</span></code>, and the eigenvalue is 1, it is easy to know <span class="math notranslate nohighlight">\( \langle 0|Z|0\rangle=1\)</span>. That is, the target expectation is 1. Whether the state at this time is <span class="math notranslate nohighlight">\(|0\rangle\)</span> can be verified by measuring the expected value.</p>
<p>Solution: By training the parameters in the Ansatz, we hope that the measurement value is close to the target expected value. In other words, we only need to make the measurement value as close as possible to the expected value corresponding to the <span class="math notranslate nohighlight">\(|0\rangle\)</span> state with respect to the Pauli <code class="docutils literal notranslate"><span class="pre">Z</span></code> operator, then the state is <span class="math notranslate nohighlight">\(|0\rangle\)</span>, that is, the Ansatz cancels the error generated by the Encoder on the initial quantum state.</p>
</section>
<section id="environment-preparation">
<h2>Environment Preparation<a class="headerlink" href="#environment-preparation" title="Permalink to this headline"></a></h2>
<p>Import the modules that this tutorial depends on.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>                            <span class="c1"># Import the numpy library and abbreviated as np</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>          <span class="c1"># Import the Circuit module for building quantum circuits</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">H</span><span class="p">,</span> <span class="n">RX</span><span class="p">,</span> <span class="n">RY</span><span class="p">,</span> <span class="n">RZ</span>    <span class="c1"># Import quantum gates H, RX, RY, RZ</span>
</pre></div>
</div>
</section>
<section id="building-encoder">
<h2>Building Encoder<a class="headerlink" href="#building-encoder" title="Permalink to this headline"></a></h2>
<p>According to the quantum circuit diagram shown, we can build the Encoder in MindSpore Quantum.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">encoder</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                   <span class="c1"># Initialize the quantum circuit</span>
<span class="n">encoder</span> <span class="o">+=</span> <span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                    <span class="c1"># The H gate acts on the 0th qubit</span>
<span class="n">encoder</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;alpha</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># The RX(alpha_0) gate acts on the 0th qubit</span>
<span class="n">encoder</span> <span class="o">+=</span> <span class="n">RY</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;alpha</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># The RY(alpha_1) gate acts on the 0th qubit</span>
<span class="n">encoder</span> <span class="o">+=</span> <span class="n">RZ</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;alpha</span><span class="si">{</span><span class="mi">2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># The RZ(alpha_2) gate acts on the 0th qubit</span>
<span class="n">encoder</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>           <span class="c1"># As the first layer of the entire quantum neural network, the Encoder does not need to take the derivative of the gradient in the encoding circuit, so no_grad() is added.</span>
<span class="n">encoder</span><span class="o">.</span><span class="n">as_encoder</span><span class="p">()</span>
<span class="n">encoder</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>                     <span class="c1"># Print the summary of Encoder</span>
<span class="n">encoder</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>==================Circuit Summary==================
|Total number of gates  : 4.                      |
|Parameter gates        : 3.                      |
|with 3 parameters are  : alpha0, alpha1, alpha2. |
|Number qubit of circuit: 1                       |
===================================================
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>q0: ──H────RX(alpha0)────RY(alpha1)────RZ(alpha2)──
</pre></div>
</div>
<p>As can be seen from the Summary of Encoder, the quantum circuit consists of 4 quantum gates, of which there are 3 quantum gates with parameters and the parameters are <span class="math notranslate nohighlight">\(\alpha_0,\alpha_1,\alpha_2\)</span>​​​​, and the number of qubits regulated by the quantum circuit is 1.</p>
<p>Then, we need to assign values to the parameters in the Encoder. Since the parameters <span class="math notranslate nohighlight">\(\alpha_0, \alpha_1\)</span> and <span class="math notranslate nohighlight">\(\alpha_2\)</span>​ in the Encoder are known values of 0.2, 0.3 and 0.4, respectively, the values are assigned direactly on the parameters and the state at this time can be printed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">alpha0</span><span class="p">,</span> <span class="n">alpha1</span><span class="p">,</span> <span class="n">alpha2</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span>              <span class="c1"># alpha0, alpha1, alpha2 are known fixed values, assigned 0.2, 0.3 and 0.4 respectively</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;alpha0&#39;</span><span class="p">:</span> <span class="n">alpha0</span><span class="p">,</span> <span class="s1">&#39;alpha1&#39;</span><span class="p">:</span> <span class="n">alpha1</span><span class="p">,</span> <span class="s1">&#39;alpha2&#39;</span><span class="p">:</span> <span class="n">alpha2</span><span class="p">},</span> <span class="n">ket</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(0.5669903122552596-0.1753906567580312j)¦0⟩
(0.800814626197614+0.08034947292077024j)¦1⟩
</pre></div>
</div>
<p>The above steps are in order to show that MindSpore Quantum can evolve the quantum circuit (if the quantum gate in the quantum circuit has parameters, you need to assign values to the parameters) and obtain the final state after evolution. It can be seen from the above printing that the final state obtained after evolution is a superposition state composed of <span class="math notranslate nohighlight">\(|0\rangle\)</span> ​​​and <span class="math notranslate nohighlight">\(|1\rangle\)</span>, and the corresponding amplitude of each item is the value corresponding to the left side of the above-printed state.</p>
<p>Note:</p>
<p>(1) By calling the <code class="docutils literal notranslate"><span class="pre">get_qs</span></code> function of the quantum circuit, we can obtain the quantum state evolved from the quantum circuit based on the all-zero state.</p>
<p>(2) The <code class="docutils literal notranslate"><span class="pre">pr</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">get_qs</span></code> represents the parameter value in the variational quantum circuit, and the <code class="docutils literal notranslate"><span class="pre">ket</span></code> represents whether to output the quantum state as a right vector form.</p>
</section>
<section id="building-ansatz">
<h2>Building Ansatz<a class="headerlink" href="#building-ansatz" title="Permalink to this headline"></a></h2>
<p>Similarly, we can also build Ansatz in MindSpore Quantum.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                           <span class="c1"># Initialize the quantum circuit</span>
<span class="n">ansatz</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>              <span class="c1"># The RX(theta_0) gate acts on the 0th qubit</span>
<span class="n">ansatz</span> <span class="o">+=</span> <span class="n">RY</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>              <span class="c1"># The RY(theta_1) gate acts on the 0th qubit</span>
<span class="n">ansatz</span><span class="o">.</span><span class="n">as_ansatz</span><span class="p">()</span>                                      <span class="c1"># Printing quantum circuits</span>
<span class="n">ansatz</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>q0: ──RX(theta0)────RY(theta1)──
</pre></div>
</div>
<p>It can be seen from the summary of Ansatz that the quantum circuit consists of 2 quantum gates, of which there are 2 quantum gates with parameters and the parameters are <span class="math notranslate nohighlight">\(\theta_0,\theta_1\)</span>, and the number of qubits regulated by the quantum circuit is 1.</p>
<p>Then, assigning values to the parameters in Ansatz. Since Ansatz is a quantum circuit that needs to be trained, the parameters <span class="math notranslate nohighlight">\(\theta_0\)</span>​​ and <span class="math notranslate nohighlight">\(\theta_1\)</span>​​ in Ansatz can be set randomly, and are usually set to the initial value of 0 by default. We can also print the quantum state at this time, but this is not a necessary step, just to get familiar with the get_qs function again.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>                        <span class="c1"># Assign theta0, theta1 to the initial value 0, 0</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">params_name</span><span class="p">,</span> <span class="p">[</span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">])),</span> <span class="n">ket</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1¦0⟩
</pre></div>
</div>
<p>As you can see from the above print, the state at this time is <span class="math notranslate nohighlight">\(|0\rangle\)</span> ​​and the amplitude is 1. This is because for Ansatz, the default input quantum state is <span class="math notranslate nohighlight">\(|0\rangle\)</span>​​, and the parameters <span class="math notranslate nohighlight">\(\theta_0\)</span>​​ and <span class="math notranslate nohighlight">\(\theta_1\)</span> are both 0. At this time, the <code class="docutils literal notranslate"><span class="pre">RX(0)</span></code> gate and the <code class="docutils literal notranslate"><span class="pre">RY(0)</span></code> gate are both equivalent to the I gate, so the entire circuit evolution process is <span class="math notranslate nohighlight">\(|0\rangle\)</span> ​​passing after <span class="math notranslate nohighlight">\(I\cdot I\)</span>, then the final output state is of course <span class="math notranslate nohighlight">\(|0\rangle\)</span>​​​.</p>
<p>Then the complete quantum circuit is Encoder plus Ansatz.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">as_encoder</span><span class="p">()</span> <span class="o">+</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">as_ansatz</span><span class="p">()</span>                   <span class="c1"># The complete quantum circuit consists of Encoder and Ansatz</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>q0: ──H────RX(alpha0)────RY(alpha1)────RZ(alpha2)────RX(theta0)────RY(theta1)──
</pre></div>
</div>
<p>From the summary of the complete quantum circuit, it can be seen that the quantum circuit consists of 6 quantum gates, of which there are 5 quantum gates with parameters and the parameters are <span class="math notranslate nohighlight">\(\alpha_0,\alpha_1,\alpha_2,\theta_0,\theta_1\)</span>​​​, and the number of qubits regulated by the quantum circuit is 1.</p>
</section>
<section id="building-hamiltonian">
<h2>Building Hamiltonian<a class="headerlink" href="#building-hamiltonian" title="Permalink to this headline"></a></h2>
<p>We perform a Pauli <code class="docutils literal notranslate"><span class="pre">Z</span></code> operator measurement on the 0th qubit to construct the corresponding Hamiltonian.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">QubitOperator</span>           <span class="c1"># Import the QubitOperator module for constructing the Pauli operator</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">Hamiltonian</span>             <span class="c1"># Import the Hamiltonian module for building the Hamiltonian</span>

<span class="n">ham</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">QubitOperator</span><span class="p">(</span><span class="s1">&#39;Z0&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>           <span class="c1"># Perform the Pauli Z operator measurement on the 0th qubit and set the coefficient to -1 to construct the corresponding Hamiltonian</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>-1 [Z0]
</pre></div>
</div>
<p>As can be seen from the above printing, the Hamiltonian constructed at this time is to perform the Pauli <code class="docutils literal notranslate"><span class="pre">Z</span></code> operator measurement on the 0th qubit, and the coefficient is -1. The reason why the coefficient is set to -1 is that during the training of the quantum neural network, the gradient of the parameters in Ansatz will always decrease, and the measurement value will always decrease. If it finally converges to -1, the corresponding quantum state is <span class="math notranslate nohighlight">\(|1\rangle\)</span> instead of <span class="math notranslate nohighlight">\(|0\rangle\)</span>​, as shown below</p>
<div class="math notranslate nohighlight">
\[ \langle 1|Z|1\rangle=-1. \]</div>
<p>What we want is the <span class="math notranslate nohighlight">\(|0\rangle\)</span> state. Therefore, set the coefficient to -1, then when the measurement value is -1, the corresponding quantum state is the <span class="math notranslate nohighlight">\(|0\rangle\)</span> state, as shown below</p>
<div class="math notranslate nohighlight">
\[ \langle 0|(-Z)|0\rangle=-1. \]</div>
<p>Note:</p>
<p>(1) QubitOperator is the sum of operators acting on qubits and is mainly used to construct Pauli operators; the general format is as follows: QubitOperator(term=None, coefficient=1.0);</p>
<p>(2) Hamiltonian is a Hamiltonian wrapper, which is mainly used to construct a Hamiltonian. The general format is as follows: Hamiltonian(QubitOperator(‘X0 Y2’, 0.5)), X0 and Y2 indicate that the Pauli <code class="docutils literal notranslate"><span class="pre">X</span></code> operator acts on the 0th position Qubit, and the Pauli <code class="docutils literal notranslate"><span class="pre">Y</span></code> operator acts on the second qubit with a coefficient of 0.5.</p>
</section>
<section id="generate-variational-quantum-circuit-simulation-operators">
<h2>Generate Variational Quantum Circuit Simulation Operators<a class="headerlink" href="#generate-variational-quantum-circuit-simulation-operators" title="Permalink to this headline"></a></h2>
<p>For the quantum circuit built above, we can generate a variational quantum circuit simulation operator in MindSpore Quantum to simulate it.</p>
<p>First, for convenience, we name the parameter arrays in Encoder and Ansatz as encoder_names and ansatz_names, respectively.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">encoder_names</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">params_name</span>                   <span class="c1"># An array of all parameters in the Encoder, the system will automatically generate encoder.para_name</span>
<span class="n">ansatz_names</span> <span class="o">=</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">params_name</span>                     <span class="c1"># An array of all parameters in the Ansatz, the system will automatically generate ansatz.para_name</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;encoder_names = &#39;</span><span class="p">,</span> <span class="n">encoder</span><span class="o">.</span><span class="n">params_name</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">ansatz_names =&#39;</span><span class="p">,</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">params_name</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>encoder_names =  [&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;]
ansatz_names = [&#39;theta0&#39;, &#39;theta1&#39;]
</pre></div>
</div>
<p>As can be seen from the above print, encoder_names is an array composed of all parameters <span class="math notranslate nohighlight">\(\alpha_0, \alpha_1, \alpha_2\)</span>​ in Encoder, ansatz_names is an array composed of all parameters <span class="math notranslate nohighlight">\(\theta_0,\theta_1\)</span> in Ansatz, these two arrays will be used to generate variational quantum circuit simulation operators.</p>
<p>Then, we obtain the operator for the evolution of the variational quantum circuit and the gradient solution by the <code class="docutils literal notranslate"><span class="pre">Simulator</span></code> module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import Simulator module</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>

<span class="c1"># Generate a simulator based on the mqvector backend, and set the number of bits of the simulator to the number of bits of the quantum circuit.</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>

<span class="c1"># Obtain the evolution of the quantum circuit based on the current quantum state of the simulator and the expectation and gradient solution operators</span>
<span class="n">grad_ops</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span>
                                         <span class="n">circuit</span><span class="p">)</span>

<span class="c1"># An array of three parameters alpha0, alpha1, alpha2 in Encoder,</span>
<span class="c1"># Convert its data type to float32 and store it in encoder_data.</span>
<span class="c1"># MindSpore Quantum supports batch training with multiple samples. The Encoder array is two dimensions.</span>
<span class="c1"># The first dimension is the sample, and the second dimension is the feature (ie parameter)</span>
<span class="n">encoder_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">alpha0</span><span class="p">,</span> <span class="n">alpha1</span><span class="p">,</span> <span class="n">alpha2</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># The array composed of theta0 and theta1 parameters in Ansatz, convert its data type to float32,</span>
<span class="c1"># And stored in ansatzr_data, Ansatz data has only one dimension, features (ie parameters)</span>
<span class="n">ansatz_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># According to the data of the Encoder and Ansatz, output the measurement value of the variable sub-circuit, the derivative of the parameter in the Encoder and the derivative of the parameter in Ansatz</span>
<span class="n">measure_result</span><span class="p">,</span> <span class="n">encoder_grad</span><span class="p">,</span> <span class="n">ansatz_grad</span> <span class="o">=</span> <span class="n">grad_ops</span><span class="p">(</span><span class="n">encoder_data</span><span class="p">,</span> <span class="n">ansatz_data</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Measurement result: &#39;</span><span class="p">,</span> <span class="n">measure_result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Gradient of encoder parameters: &#39;</span><span class="p">,</span> <span class="n">encoder_grad</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Gradient of ansatz parameters: &#39;</span><span class="p">,</span> <span class="n">ansatz_grad</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Measurement result:  [[0.29552022+0.j]]
Gradient of encoder parameters:  [[[0.+0.j 0.+0.j 0.+0.j]]]
Gradient of ansatz parameters:  [[[-0.37202556+0.j  0.87992317+0.j]]]
</pre></div>
</div>
<p>As can be seen from the above print, the measurement result (expected value) is 0.29552022, the derivatives of the 3 parameters in the Encoder are 0, 0, 0 (because we set no_grad() to the Encoder), and the derivatives of the 2 parameters in Ansatz are -0.37202555 and -0.87992316.</p>
<p>Here, what is generated by <code class="docutils literal notranslate"><span class="pre">get_expectation_with_grad</span></code> is just an operator, which cannot be trained yet. It can only be trained by putting it in the quantum neural network. By training the parameters in Ansatz, the derivative of the parameters in Ansatz can be kept decreasing and close to 0, so the measurement value will also be close to -1.</p>
<p>Note:</p>
<p>(1) The <code class="docutils literal notranslate"><span class="pre">get_expectation_with_grad</span></code> of the <code class="docutils literal notranslate"><span class="pre">Simulator</span></code> is used to generate a variational quantum circuit to simulate the operator. The general format is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Simulator</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span>
                                    <span class="n">circ_right</span><span class="p">,</span>
                                    <span class="n">circ_left</span><span class="p">,</span>
                                    <span class="n">parallel_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This function is suitable for computing the following models: <span class="math notranslate nohighlight">\(E=\left&lt;0\right|U^\dagger_l(\theta) H U_r(\theta)\left|0\right&gt;\)</span> Where <code class="docutils literal notranslate"><span class="pre">circ_right</span></code> is <code class="docutils literal notranslate"><span class="pre">Ur</span></code>, <code class="docutils literal notranslate"><span class="pre">circ_left</span></code> is <code class="docutils literal notranslate"><span class="pre">Ul</span></code>, when not provided, the default is the same circuit as <code class="docutils literal notranslate"><span class="pre">circ_right</span></code>,
<code class="docutils literal notranslate"><span class="pre">parallel_worker</span></code> specifies the number of parallels. When the classical data to be encoded is a batch, setting this parameter reasonably can improve the calculation efficiency.</p>
<p>(2) MindSpore is a full-scene deep learning framework, aiming to achieve three goals of easy development, efficient execution, and full-scene coverage, provides tensor-differentiable programmability that supports heterogeneous acceleration, supports cloud, server, edge and end multiple hardware platforms.</p>
</section>
<section id="building-a-quantum-neural-network">
<h2>Building a quantum neural network<a class="headerlink" href="#building-a-quantum-neural-network" title="Permalink to this headline"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="kn">from</span> <span class="nn">mindquantum.framework</span> <span class="kn">import</span> <span class="n">MQLayer</span>          <span class="c1"># Import MQLayer</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>                             <span class="c1"># Import mindspore</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                                     <span class="c1"># Set the seed for generating random numbers</span>
<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>

<span class="n">QuantumNet</span> <span class="o">=</span> <span class="n">MQLayer</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">)</span>
<span class="n">QuantumNet</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>MQLayer&lt;
  (evolution): MQOps&lt;1 qubit mqvector VQA Operator&gt;
  &gt;
</pre></div>
</div>
<p>As can be seen from the above printing, we have successfully built a quantum machine learning layer, which can seamlessly form a larger machine learning network with other operators in MindSpore.</p>
<p>Note:</p>
<p>(1) The quantum circuit gradient calculation operators in MindSpore Quantum are all under PYNATIVE_MODE, so the operation mode of MindSpore needs to be set.</p>
<p>(2) We can also build the quantum machine learning layer by the following code, but in MindSpore Quantum, the following code has been packaged, so that we can directly use the MQLayer module to build the quantum machine learning layer. For more complex quantum-classical hybrid neural networks, the following construction will demonstrate its advantages.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">nn</span>

<span class="k">class</span> <span class="nc">MQLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expectation_with_grad</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MQLayer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evolution</span> <span class="o">=</span> <span class="n">MQOps</span><span class="p">(</span><span class="n">expectation_with_grad</span><span class="p">)</span>
        <span class="n">weight_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evolution</span><span class="o">.</span><span class="n">expectation_with_grad</span><span class="o">.</span><span class="n">ansatz_params_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">initializer</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span>
                                            <span class="n">weight_size</span><span class="p">,</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ansatz_weight&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evolution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="training">
<h2>Training<a class="headerlink" href="#training" title="Permalink to this headline"></a></h2>
<p>We use the Adam optimizer to optimize the parameters in Ansatz.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore.nn</span> <span class="kn">import</span> <span class="n">Adam</span><span class="p">,</span> <span class="n">TrainOneStepCell</span>                   <span class="c1"># Import Adam module and TrainOneStepCell module</span>

<span class="n">opti</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">QuantumNet</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>     <span class="c1"># What needs to be optimized is the trainable parameters in Quantumnet, and the learning rate is set to 0.5</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">TrainOneStepCell</span><span class="p">(</span><span class="n">QuantumNet</span><span class="p">,</span> <span class="n">opti</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">encoder_data</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;: &#39;</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0 :  [[0.2837115]]
10 :  [[-0.8851233]]
20 :  [[-0.97001773]]
30 :  [[-0.9929431]]
40 :  [[-0.9939507]]
50 :  [[-0.9967015]]
60 :  [[-0.99878186]]
70 :  [[-0.9995535]]
80 :  [[-0.9999011]]
90 :  [[-0.99998033]]
100 :  [[-0.9999989]]
110 :  [[-0.99999785]]
120 :  [[-0.999997]]
130 :  [[-0.9999987]]
140 :  [[-0.9999998]]
150 :  [[-1.]]
160 :  [[-0.99999994]]
170 :  [[-1.]]
180 :  [[-1.]]
190 :  [[-1.]]
</pre></div>
</div>
<p>As you can see from the above print, finally the measured value converges to -1.</p>
<p>Note:</p>
<p>(1) The Adam module updates the gradient by the adaptive moment estimation algorithm, which can optimize the parameters in Ansazt, and the input is the trainable parameters in the neural network; the general format is as follows: nn.Adam(net.trainable_params(), learning_rate=0.5) ;</p>
<p>(2) The TrainOneStepCell module is a network training package class that wraps the network with an optimizer. The resulting cells are trained with the input “inputs”, an inverse graph will be generated in the constructor to update the parameters, and there are different parallel modes available for training. The general format is as follows: nn.TrainOneStepCell(network, optimizer, sens=1.0).</p>
</section>
<section id="result-presentation">
<h2>Result Presentation<a class="headerlink" href="#result-presentation" title="Permalink to this headline"></a></h2>
<p>Since the measurements have converged to -1, we can print the parameters in Ansatz at this time.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span> <span class="o">=</span> <span class="n">QuantumNet</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">QuantumNet</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[ 2.2420275 -1.0756909]
</pre></div>
</div>
<p>As can be seen from the above printing, the parameters <span class="math notranslate nohighlight">\(\theta_1\)</span> and <span class="math notranslate nohighlight">\(\theta_2\)</span> in Ansatz at this time are 2.2420275 and -1.0756909 respectively.</p>
<p>By <code class="docutils literal notranslate"><span class="pre">get_qs</span></code>, the quantum state of the quantum circuit at the optimal parameters can be output.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;alpha0&#39;</span><span class="p">:</span> <span class="n">alpha0</span><span class="p">,</span> <span class="s1">&#39;alpha1&#39;</span><span class="p">:</span> <span class="n">alpha1</span><span class="p">,</span> <span class="s1">&#39;alpha2&#39;</span><span class="p">:</span> <span class="n">alpha2</span><span class="p">,</span> <span class="s1">&#39;theta0&#39;</span><span class="p">:</span> <span class="n">theta0</span><span class="p">,</span> <span class="s1">&#39;theta1&#39;</span><span class="p">:</span> <span class="n">theta1</span><span class="p">}</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="n">pr</span><span class="p">,</span> <span class="n">ket</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(0.37129760050057437-0.9285139157007681j)¦0⟩
(1.4564552975271372e-05+6.455516706194153e-07j)¦1⟩
</pre></div>
</div>
<p>As can be seen from the above printing, this is the quantum state of the quantum circuit at the optimal parameters. As can be seen from its numerical representation, this is a state close to the target state <span class="math notranslate nohighlight">\(|0\rangle\)</span>. Finally, we calculate the fidelity of this quantum state to the target state <span class="math notranslate nohighlight">\(|0\rangle\)</span> (to verify how similar the two quantum states are), and print the fidelity.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="n">pr</span><span class="p">)</span>
<span class="n">fid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>            <span class="c1"># Fidelity is the modulus square of the absolute value of the vector inner product, that is, the modulus square of the inner product of the vector corresponding to the quantum state and the vector [1,0] corresponding to the |0&gt; state at this time is calculated.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0.9999999997874573
</pre></div>
</div>
<p>It can be seen that the fidelity at this time is 100.00%, that is to say, the similarity between this state and the target state <span class="math notranslate nohighlight">\(|0\rangle\)</span> is 100.00%.</p>
<p>To sum up, we built a simple quantum neural network. By training the parameters in Ansatz, the error generated by the Encoder on the initial quantum state was offset, so that the final quantum state was still <span class="math notranslate nohighlight">\(|0\rangle\)</span>, and the fidelity reached 100.00%.</p>
<p>So far, we have completed the first experience of quantum neural network by MindSpore Quantum! Hurry up and experience the fun of quantum programming!</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="quantum_simulator.html" class="btn btn-neutral float-left" title="Quantum simulator" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="get_gradient_of_PQC_with_mindquantum.html" class="btn btn-neutral float-right" title="Advanced gradient calculation of variational quantum circuits" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>