

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Quantum Approximate Optimization Algorithm &mdash; MindSpore master documentation</title>
  

  
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
   
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The Application of Quantum Neural Network in NLP" href="qnn_for_nlp.html" />
    <link rel="prev" title="Classification of iris by quantum neural network" href="classification_of_iris_by_qnn.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">MindSpore Quantum Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_simulator.html">Quantum simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">Initial experience of quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">Advanced gradient calculation of variational quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_operations_of_quantum_circuit.html">Advanced operations of quantum circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_measurement.html">Quantum Measurement</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Noisy Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="bloch_sphere.html">Bloch Sphere</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variational Quantum Algorithm</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">Classification of iris by quantum neural network</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quantum Approximate Optimization Algorithm</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#environment-preparation">Environment Preparation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#max-cut-problem-description">Max-Cut Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="#max-cut-problem-quantization">Max-Cut Problem Quantization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#importing-dependencies">Importing Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-graph-to-be-solved">Building a Graph to Be Solved</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-process-of-qaqa-algorithm">The Process of QAQA Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-a-qaoa-quantum-circuit">Setting up a QAOA Quantum Circuit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ansatz-circuit">ansatz Circuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generating-a-complete-quantum-circuit-and-the-hamiltonian-corresponding-to-the-graph">Generating a Complete Quantum Circuit and the Hamiltonian Corresponding to the Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-a-quantum-neural-network-to-be-trained">Building a Quantum Neural Network to Be Trained</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#displaying-training-results">Displaying Training Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#optimal-parameter">Optimal Parameter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#probabilistic-graph">Probabilistic Graph</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">The Application of Quantum Neural Network in NLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">VQE Application in Quantum Chemistry Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="equivalence_checking_of_PQC.html">Equivalence Checking of Parameterized Quantum Circuits</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">Grover search and Long algorithms based on MindSpore Quantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">Shor’s algorithm based on MindSpore Quantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.device.html">mindquantum.device</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Quantum Approximate Optimization Algorithm</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/quantum_approximate_optimization_algorithm.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section class="tex2jax_ignore mathjax_ignore" id="quantum-approximate-optimization-algorithm">
<h1>Quantum Approximate Optimization Algorithm<a class="headerlink" href="#quantum-approximate-optimization-algorithm" title="Permalink to this headline"></a></h1>
<p><a href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_en/quantum_approximate_optimization_algorithm.md" target="_blank"><img src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source_en.png"></a></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline"></a></h2>
<p>Quantum approximate optimization algorithm (QAOA) is a quantum algorithm that uses quantum computers to solve combination optimization problems. It was first proposed by Farhi et al. in 2014. In this tutorial, we will use QAOA to solve the Max-Cut problem and get familiar with the construction and training of quantum circuits in MindSpore Quantum.</p>
<blockquote>
<div><p>This document applies to the CPU environment.</p>
</div></blockquote>
</section>
<section id="environment-preparation">
<h2>Environment Preparation<a class="headerlink" href="#environment-preparation" title="Permalink to this headline"></a></h2>
<p>This tutorial requires the following library:</p>
<ul class="simple">
<li><p>networkx</p></li>
</ul>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> is a library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks. You can run the <code class="docutils literal notranslate"><span class="pre">pip3</span> <span class="pre">install</span> <span class="pre">networkx</span></code> command to install it.</p>
</div></blockquote>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip3<span class="w"> </span>install<span class="w"> </span>networkx
</pre></div>
</div>
</section>
<section id="max-cut-problem-description">
<h2>Max-Cut Problem Description<a class="headerlink" href="#max-cut-problem-description" title="Permalink to this headline"></a></h2>
<p>The Max-Cut problem is an NP-complete problem in the graph theory. It needs to divide vertices of a graph into two parts and make the most edges be cut. As shown in the following figure (a), a graph consists of five vertices, and the interconnected edges are <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1),</span> <span class="pre">(0,</span> <span class="pre">2),</span> <span class="pre">(1,</span> <span class="pre">2),</span> <span class="pre">(2,</span> <span class="pre">3),</span> <span class="pre">(3,</span> <span class="pre">4),</span> <span class="pre">and</span> <span class="pre">(0,</span> <span class="pre">4)</span></code>. To maximize the number of edges to be cut, we divide 1, 2, and 4 into one group, and 0 and 3 into another group, as shown in the figure (b). Therefore, five edges are to be cut. When the number of vertices in a graph increases, it is difficult to find an effective typical algorithm to solve the Max-Cut problem. The following describes how to transform the Max-Cut problem into a Hamiltonian ground state capability solution problem.</p>
<p><img alt="max cut" src="_images/Max_Cut.png" /></p>
</section>
<section id="max-cut-problem-quantization">
<h2>Max-Cut Problem Quantization<a class="headerlink" href="#max-cut-problem-quantization" title="Permalink to this headline"></a></h2>
<p>Assign each vertex a quantum bit. If the vertex is allocated to the left side, its quantum bit is set to the <span class="math notranslate nohighlight">\(\left|0\right&gt;\)</span> state. If the vertex is on the right side, its quantum bit is set to the <span class="math notranslate nohighlight">\(\left|1\right&gt;\)</span> state. When two vertices are in different sets, the bits on the two vertices are in different quantum states. For the vertex 0 and the vertex 1, when their connection line is cut, quantum states corresponding to bits on the two vertices may be <span class="math notranslate nohighlight">\(|01\rangle\)</span> (vertax 1: left, vertax 0: right) or <span class="math notranslate nohighlight">\(|10\rangle\)</span> (vertax 1: right, vertax 0: left). If they are partitioned to the same side, the corresponding quantum state is <span class="math notranslate nohighlight">\(|00\rangle\)</span> or <span class="math notranslate nohighlight">\(|11\rangle\)</span>. So we just need to find a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> that makes the expectation value of the Hamiltonian to -1 when there are connected two vertices in different quantum states, i.e.</p>
<div class="math notranslate nohighlight">
\[
\langle 01|H|01\rangle=-1,\quad \langle 10|H|10\rangle=-1
\]</div>
<p>When vertices are in the same quantum state, the expected value of Hamiltonian quantity is 0, i.e</p>
<div class="math notranslate nohighlight">
\[
\langle 00|H|00\rangle=0,\quad \langle 11|H|11\rangle=0
\]</div>
<p>Subsequently the maximum number of cut edges, and the corresponding grouping case at that point, can be found by simply minimizing the expected value of the Hamiltonian quantity. The reason why the expected value at different quantum states is set to -1 is that in the training of the quantum neural network, the gradient of the parameters in Ansatz keeps decreasing, and also the measured value keeps decreasing. The training method is aimed at finding the minimum value, and here we use it to find the ground state energy of the Hamiltonian quantity. At this point, we choose the Hamiltonian <span class="math notranslate nohighlight">\(H=(Z_1Z_0-1)/2\)</span>, where <span class="math notranslate nohighlight">\(Z\)</span> is the Pauli <span class="math notranslate nohighlight">\(Z\)</span> operator. We can see that:</p>
<div class="math notranslate nohighlight">
\[
Z_1Z_0|00\rangle=|00\rangle,\quad Z_1Z_0|11\rangle=|11\rangle, \quad Z_1Z_0|01\rangle=-|01\rangle, \quad Z_1Z_0|10\rangle=-|10\rangle
\]</div>
<p>Thus when the vertices are partitioned into different sets:</p>
<div class="math notranslate nohighlight">
\[
\left&lt;01\right|H\left|01\right&gt;=\frac{1}{2}\left&lt;01\right|Z_1Z_0\left|01\right&gt;-\frac{1}{2}=-1
\]</div>
<div class="math notranslate nohighlight">
\[
\left&lt;10\right|H\left|10\right&gt;=\frac{1}{2}\left&lt;10\right|Z_1Z_0\left|10\right&gt;-\frac{1}{2}=-1
\]</div>
<p>And when the vertices are partitioned into the same set, it is not difficult to verify that:</p>
<div class="math notranslate nohighlight">
\[
\left&lt;00\right|H\left|00\right&gt;=\frac{1}{2}\left&lt;00\right|Z_1Z_0\left|00\right&gt;-\frac{1}{2}=0
\]</div>
<div class="math notranslate nohighlight">
\[
\left&lt;11\right|H\left|11\right&gt;=\frac{1}{2}\left&lt;11\right|Z_1Z_0\left|11\right&gt;-\frac{1}{2}=0
\]</div>
<p>Therefore, we just write the above Hamiltonian for each edge in the graph and then sum up all the edges to write the Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> corresponding to the graph. Using a quantum computer to find the ground state energy and ground state of <span class="math notranslate nohighlight">\(H\)</span>, we can get the Max-Cut cutting scheme and the maximum number of cutting edges of the graph. We write down the set of all edges as <span class="math notranslate nohighlight">\(C\)</span> and the number of all edge strips as <span class="math notranslate nohighlight">\(c\)</span>, then the Hamiltonian quantity can be written as:</p>
<div class="math notranslate nohighlight">
\[
H=\sum_{(i,j)\in C}(Z_iZ_j-1)/2
\]</div>
</section>
<section id="importing-dependencies">
<h2>Importing Dependencies<a class="headerlink" href="#importing-dependencies" title="Permalink to this headline"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">UN</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">H</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">RX</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">Hamiltonian</span><span class="p">,</span> <span class="n">QubitOperator</span>
<span class="kn">from</span> <span class="nn">mindquantum.framework</span> <span class="kn">import</span> <span class="n">MQAnsatzOnlyLayer</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
</pre></div>
</div>
</section>
<section id="building-a-graph-to-be-solved">
<h2>Building a Graph to Be Solved<a class="headerlink" href="#building-a-graph-to-be-solved" title="Permalink to this headline"></a></h2>
<p>Use <code class="docutils literal notranslate"><span class="pre">add_path</span></code> to add edges to a graph. Then, the graph structure is drawn.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="png" src="_images/maxcut_graph.png" /></p>
<p>As shown in the preceding figure, a graph structure consisting of five vertices and six edges is obtained.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;one size:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;cut=&#39;</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">cut_size</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;one size:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cut=&#39;</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">cut_size</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
</pre></div>
</div>
</section>
<section id="the-process-of-qaqa-algorithm">
<h2>The Process of QAQA Algorithm<a class="headerlink" href="#the-process-of-qaqa-algorithm" title="Permalink to this headline"></a></h2>
<ol class="arabic simple">
<li><p>Build a QAOA quantum circuit, where the ansatz circuit contains parameters that can be trained</p></li>
<li><p>Initialize the parameters in the circuit</p></li>
<li><p>Run this quantum circuit and get the quantum state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span></p></li>
<li><p>ompute the expected value <span class="math notranslate nohighlight">\(\langle\psi|H_C|\psi\rangle\)</span> of the target Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span></p></li>
<li><p>Based on the results of step 4, use the Adam optimizer to optimize the parameters in the circuit</p></li>
<li><p>Repeat steps 3-5 until the results in step 4 are basically unchanged</p></li>
<li><p>Based on the result of step 4, the approximate solution of the target problem is calculated</p></li>
</ol>
<p>In this process, steps 2-6 can all be implemented by packages and functions available in MindSpore and MindSpore Quantum, so we will focus on step 1: building the quantum circuit.</p>
</section>
<section id="setting-up-a-qaoa-quantum-circuit">
<h2>Setting up a QAOA Quantum Circuit<a class="headerlink" href="#setting-up-a-qaoa-quantum-circuit" title="Permalink to this headline"></a></h2>
<p>As mentioned previously, we need to combine the Hamiltonian quantities corresponding to the problem:</p>
<div class="math notranslate nohighlight">
\[
H_C=\sum_{(i,j)\in C}(Z_iZ_j-1)/2
\]</div>
<p>Minimization to find the solution of the problem, which means we have to find the ground state of that Hamiltonian quantity. We can use quantum adiabatic evolution to make the system first on the ground state of some simple Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span>, and then make the simple Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span> evolve adiabatically and slowly to some complex Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>. According to the adiabatic theorem, the system will always remain on the ground state of the Hamiltonian, and finally reach the ground state of the complex Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>.</p>
<p>The quantum circuit we are going to build is using the above idea, choosing the initial simple Hamiltonian quantity as:</p>
<div class="math notranslate nohighlight">
\[
H_B=\sum_i X_i
\]</div>
<p>Prepare the quantum circuit to the ground state <span class="math notranslate nohighlight">\(|s\rangle=|+\rangle^{\otimes n}\)</span> of <span class="math notranslate nohighlight">\(H_B\)</span>, which can be achieved here by acting <code class="docutils literal notranslate"><span class="pre">Hadamard</span></code> gate on all quantum bits. Then the ansatz circuits are connected, and by continuously optimizing the parameters, the ansatz circuits can be made closer to the real adiabatic evolution, and the finally obtained quantum circuits can be regarded as simulating a real adiabatic evolution.</p>
<section id="ansatz-circuit">
<h3>ansatz Circuit<a class="headerlink" href="#ansatz-circuit" title="Permalink to this headline"></a></h3>
<p>In the quantum adiabatic evolution, the initial Hamiltonian quantities are first selected</p>
<div class="math notranslate nohighlight">
\[
H_B=\sum_i X_i
\]</div>
<p>Put the system in the <span class="math notranslate nohighlight">\(H_B\)</span> ground state <span class="math notranslate nohighlight">\(|s\rangle=|+\rangle^{\otimes n}\)</span>. Then slowly act on the following time-dependent Hamiltonian:</p>
<div class="math notranslate nohighlight">
\[
H(t)=(1-\frac{t}{T})H_B+(\frac{t}{T})H_C
\]</div>
<p>Notice that <span class="math notranslate nohighlight">\(H(T)=H_C\)</span> when <span class="math notranslate nohighlight">\(t=T\)</span>. When the chosen <span class="math notranslate nohighlight">\(T\)</span> is large enough (satisfying the adiabatic condition), the system will always be on the instantaneous ground state of <span class="math notranslate nohighlight">\(H(t)\)</span>, when the quantum state of the system will evolve adiabatically from the ground state <span class="math notranslate nohighlight">\(|\psi (0)\rangle\)</span> of the initial Hamiltonian <span class="math notranslate nohighlight">\(H_B\)</span> to the ground state <span class="math notranslate nohighlight">\(|\psi (T)\rangle\)</span> of the target Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span>, i.e.</p>
<div class="math notranslate nohighlight">
\[
|\psi (T)\rangle=\mathcal{T}e^{-i\int^{T}_{0} H(t)dt}|\psi(0)\rangle
\]</div>
<p>That is, the ansatz circuit needs to model the evolution process <span class="math notranslate nohighlight">\(\mathcal{T}e^{-i\int^{T}_{0} H(t)dt}\)</span>. Next we will make some approximations and simplifications to this equation to make it into a form that can be implemented in quantum circuits.</p>
<p>Considering the following trotter formula:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{T}e^{-i\int^T_0 H(t)dt}=\lim_{N\rightarrow \infty}\prod^N_{l=1}e^{-iH(t_l)\Delta t},\quad \Delta t=\frac{T}{N},\quad t_l=l\Delta t
\]</div>
<p>Omitting the <span class="math notranslate nohighlight">\(O(\Delta t^2)\)</span> term, we obtain:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{T}e^{-i\int^T_0 H(t)dt}\approx \lim_{N\rightarrow \infty}\prod^N_{l=1}e^{-iH_B(1-t_l/T)\Delta t}e^{-iH_C t_l\Delta t/T}
\]</div>
<p>Let <span class="math notranslate nohighlight">\(\beta_l=(1-t_l/T)\Delta t\)</span>, <span class="math notranslate nohighlight">\(\gamma_l=t_l\Delta t/T\)</span>, and take <span class="math notranslate nohighlight">\(N\)</span> as a finite large integer, that is, the ansatz of QAOA is obtained:</p>
<div class="math notranslate nohighlight">
\[
|\psi(\gamma,\beta)\rangle=\prod^p_{l=1}e^{-i\beta_l H_B}e^{-i\gamma_l H_C}|\psi_{in}\rangle
\]</div>
<p>Thus the ansatz line we need to build consists of <span class="math notranslate nohighlight">\(U_C(\gamma)\)</span> and <span class="math notranslate nohighlight">\(U_B(\beta)\)</span> which alternate the two unitary transformations, where <span class="math notranslate nohighlight">\(U_C(\gamma)=e^{-i\gamma \sum_{\langle i,j\rangle}Z_i Z_j}\)</span> can be implemented by the <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> gate. <span class="math notranslate nohighlight">\(U_B(\beta)=e^{-i\beta \sum_i X_i}\)</span> is then equivalent to acting a <code class="docutils literal notranslate"><span class="pre">RX</span></code> revolving gate on each quantum bit, with <span class="math notranslate nohighlight">\(\gamma\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> as trainable parameters.</p>
<p>Build the quantum circuit corresponding to <span class="math notranslate nohighlight">\(U_C(\gamma)\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_hc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">para</span><span class="p">):</span>
    <span class="n">hc</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                  <span class="c1"># Build quantum circuit</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">hc</span> <span class="o">+=</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">para</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>        <span class="c1"># Act ZZ gate on each edge of the diagram</span>
    <span class="n">hc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>                    <span class="c1"># Add Barrier for easy display of circuits</span>
    <span class="k">return</span> <span class="n">hc</span>
</pre></div>
</div>
<p>Display the circuits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">build_hc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
<p>Build the quantum circuits corresponding to <span class="math notranslate nohighlight">\(U_B(\beta)\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_hb</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">para</span><span class="p">):</span>
    <span class="n">hb</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                  <span class="c1"># Build quantum circuit</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">hb</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="n">para</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>        <span class="c1"># Act RX gate on each node</span>
    <span class="n">hb</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>                    <span class="c1"># Add Barrier for easy display of circuits</span>
    <span class="k">return</span> <span class="n">hb</span>
</pre></div>
</div>
<p>Display the circuits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">build_hb</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
<p>The ansatz circuit that implements a layer of unitary transform <span class="math notranslate nohighlight">\(U_B(\beta) U_C(\gamma)\)</span> is shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">build_hc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">build_hb</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
<p>In order to make the final optimization result accurate enough, we need to repeat the quantum circuit several times, so we build a multilayer training network by the following function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_ansatz</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>                    <span class="c1"># g is the graph of the max-cut problem, and p is the number of layers of the ansatz circuit</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                       <span class="c1"># Build quantum circuit</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">build_hc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;g</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>       <span class="c1"># Add the circuit corresponding to Uc, with parameters noted as g0, g1, g2...</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">build_hb</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;b</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>       <span class="c1"># Add the circuit corresponding to Ub, with parameters noted as b0, b1, b2...</span>
    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
<p>The Hamiltonian quantity <span class="math notranslate nohighlight">\(H_C=\sum_{(i,j)\in C}(Z_iZ_j-1)/2\)</span> corresponding to construction graph(ignoring the constant terms and coefficients).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_ham</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="n">ham</span> <span class="o">=</span> <span class="n">QubitOperator</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">ham</span> <span class="o">+=</span> <span class="n">QubitOperator</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Z</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> Z</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># Generate the Hamiltonian quantity Hc</span>
    <span class="k">return</span> <span class="n">ham</span>
</pre></div>
</div>
</section>
<section id="generating-a-complete-quantum-circuit-and-the-hamiltonian-corresponding-to-the-graph">
<h3>Generating a Complete Quantum Circuit and the Hamiltonian Corresponding to the Graph<a class="headerlink" href="#generating-a-complete-quantum-circuit-and-the-hamiltonian-corresponding-to-the-graph" title="Permalink to this headline"></a></h3>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">4</span></code> is selected, indicating that the four-layer QAOA quantum circuit is used. <code class="docutils literal notranslate"><span class="pre">ansatz</span></code> is a quantum circuit for solving the problem, and <code class="docutils literal notranslate"><span class="pre">init_state_circ</span></code> is a quantum circuit for preparing a quantum state on a uniformly superposed state.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">ham</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">build_ham</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>              <span class="c1"># Generate Hamiltonian quantities</span>
<span class="n">init_state_circ</span> <span class="o">=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>             <span class="c1"># Generate uniform superposition states, i.e., act H-gate on all quantum bits</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">build_ansatz</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>                  <span class="c1"># Generate ansatz circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">init_state_circ</span> <span class="o">+</span> <span class="n">ansatz</span>              <span class="c1"># Combine the initialized circuit and the ansatz circuit into one circuit</span>
<span class="n">circ</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="building-a-quantum-neural-network-to-be-trained">
<h3>Building a Quantum Neural Network to Be Trained<a class="headerlink" href="#building-a-quantum-neural-network-to-be-trained" title="Permalink to this headline"></a></h3>
<p>This problem does not require a coding-layer quantum circuit, so we use <code class="docutils literal notranslate"><span class="pre">MQAnsatzOnlyLayer</span></code> as a quantum neural network to be trained and an <code class="docutils literal notranslate"><span class="pre">Adam</span></code> optimizer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>                     <span class="c1"># Create the simulator, backend using &#39;mqvector&#39;, capable of simulating 5 bits (the number of bits contained in the &#39;circ&#39; line)</span>
<span class="n">grad_ops</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">circ</span><span class="p">)</span>            <span class="c1"># Obtain the operator to calculate the expectation and gradient of the variational quantum circuit</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">MQAnsatzOnlyLayer</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">)</span>                              <span class="c1"># Generate the neural network to be trained</span>
<span class="n">opti</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>     <span class="c1"># Set the Adam optimizer for all trainable parameters in the network with a learning rate of 0.05</span>
<span class="n">train_net</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">TrainOneStepCell</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">opti</span><span class="p">)</span>                     <span class="c1"># One-step training of neural networks</span>
</pre></div>
</div>
</section>
</section>
<section id="displaying-training-results">
<h2>Displaying Training Results<a class="headerlink" href="#displaying-training-results" title="Permalink to this headline"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">):</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="o">-</span> <span class="n">train_net</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>      <span class="c1"># Train the neural network for one step and calculate the result (number of cut edges). Note: Every time &#39;train_net()&#39; is run, the neural network is trained for one step</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train step:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;, cut:&quot;</span><span class="p">,</span> <span class="n">cut</span><span class="p">)</span>  <span class="c1"># Every 10 training steps, print the current number of training steps and the current number of cutting edges obtained</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>train step: 0 , cut: [3.0001478]
train step: 10 , cut: [4.1718774]
train step: 20 , cut: [4.6871986]
train step: 30 , cut: [4.7258005]
train step: 40 , cut: [4.804503]
train step: 50 , cut: [4.8477592]
train step: 60 , cut: [4.8705964]
train step: 70 , cut: [4.9060946]
train step: 80 , cut: [4.933446]
train step: 90 , cut: [4.9356637]
train step: 100 , cut: [4.938308]
train step: 110 , cut: [4.9390197]
train step: 120 , cut: [4.939068]
train step: 130 , cut: [4.9392157]
train step: 140 , cut: [4.939249]
train step: 150 , cut: [4.939247]
train step: 160 , cut: [4.939255]
train step: 170 , cut: [4.939257]
train step: 180 , cut: [4.939257]
train step: 190 , cut: [4.939257]
</pre></div>
</div>
<p>Based on the above training results, we find that the number of cut edges corresponding to the ground state energy of Hamiltonian is close to 5.</p>
<section id="optimal-parameter">
<h3>Optimal Parameter<a class="headerlink" href="#optimal-parameter" title="Permalink to this headline"></a></h3>
<p>Previously, we obtained the optimal values of the parameters in the quantum circuit by training. In the following, we extract the optimal parameters and store them as dictionary types, which correspond to the parameters named in the previous circuit.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">params_name</span><span class="p">,</span> <span class="n">net</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span> <span class="c1"># Obtain circuit parameters</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{&#39;g0&#39;: 0.22448167, &#39;b0&#39;: -1.1390871, &#39;g1&#39;: 0.45314747, &#39;b1&#39;: -0.94472605, &#39;g2&#39;: 0.5338268, &#39;b2&#39;: -0.67756957, &#39;g3&#39;: 0.58400834, &#39;b3&#39;: -0.38243017}
</pre></div>
</div>
</section>
<section id="probabilistic-graph">
<h3>Probabilistic Graph<a class="headerlink" href="#probabilistic-graph" title="Permalink to this headline"></a></h3>
<p>We substitute the optimal parameters into the quantum circuit and draw the probability distribution of the final quantum state under the computed vector by sampling the quantum circuit 1000 times:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>                               <span class="c1"># Add measurement gates for all bits in the circuit</span>
<span class="n">sim</span><span class="o">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">pr</span><span class="o">=</span><span class="n">pr</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>      <span class="c1"># Run the circuit 1000 times and print the results</span>
</pre></div>
</div>
<p>According to the probability distribution diagram, the Max-Cut problem has four degenerate solutions, and the probability corresponding to each solution is about 25%.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">01001</span></code>: The vertices numbered 1, 2, and 4 are on the left, and the vertices numbered 0 and 3 are on the right.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">10110</span></code>: The vertices numbered 0 and 3 are on the left, and the vertices numbered 1, 2, and 4 are on the right.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">01011</span></code>: The vertices numbered 2 and 4 are on the left, and the vertices numbered 0, 1, and 3 are on the right.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">10100</span></code>: The vertices numbered 0, 1, and 3 are on the left, and the vertices numbered 2 and 4 are on the right.</p></li>
</ul>
<p>It can be found that the above results are consistent with the previous results obtained by the exhaustive method.</p>
</section>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline"></a></h2>
<p>We use the quantum approximation optimization algorithm to solve the Max-Cut problem and obtain the Max-Cut solution corresponding to the graph in the case.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<p>[1] Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. <a class="reference external" href="https://arxiv.org/pdf/1411.4028.pdf">A Quantum Approximate Optimization Algorithm</a></p>
</section>
</section>


           </div>
           
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="classification_of_iris_by_qnn.html" class="btn btn-neutral float-left" title="Classification of iris by quantum neural network" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="qnn_for_nlp.html" class="btn btn-neutral float-right" title="The Application of Quantum Neural Network in NLP" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>