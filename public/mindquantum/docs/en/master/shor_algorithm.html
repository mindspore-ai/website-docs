<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Shor’s algorithm based on MindSpore Quantum &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script><script src="_static/jquery.js"></script>
        <script src="_static/js/theme.js"></script><script src="_static/underscore.js"></script><script src="_static/doctools.js"></script><script crossorigin="anonymous" integrity="sha256-1fEPhSsRKlFKGfK3eO710tEweHh1fwokU5wFGDHO+vg=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/mathjax/MathJax-3.2.2/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="HHL Algorithm" href="hhl_algorithm.html" />
    <link rel="prev" title="Grover search and Long algorithms based on MindSpore Quantum" href="grover_search_algorithm.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">MindSpore Quantum Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_simulator.html">Quantum simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">Initial experience of quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">Advanced Gradient Calculation of Variational Quantum Circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_operations_of_quantum_circuit.html">Advanced Operations of Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_measurement.html">Quantum Measurement</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Noisy Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_simulator.html">Noise simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="qubit_mapping.html">Qubit Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="bloch_sphere.html">Bloch Sphere</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variational Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">Classification of IRIS by Quantum Neural Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">The Application of Quantum Neural Network in NLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">VQE Application in Quantum Chemistry Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="equivalence_checking_of_PQC.html">Equivalence Checking of Parameterized Quantum Circuits</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General Quantum Algorithm</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">Grover search and Long algorithms based on MindSpore Quantum</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Shor’s algorithm based on MindSpore Quantum</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-to-shor’s-algorithm">Introduction to Shor’s Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-idea-of-shor’s-algorithm">Basic Idea of Shor’s algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implement-shor’s-algorithm-using-mindspore-quantum">Implement Shor’s Algorithm Using MindSpore Quantum</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#construct-the-oracle">Construct the Oracle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#period-finding-subroutine">Period Finding Subroutine</a></li>
<li class="toctree-l3"><a class="reference internal" href="#classic-computer-part">Classic Computer Part</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="hhl_algorithm.html">HHL Algorithm</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.dtype.html">mindquantum.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.device.html">mindquantum.device</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Shor’s algorithm based on MindSpore Quantum</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/shor_algorithm.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="shor’s-algorithm-based-on-mindspore-quantum">
<h1>Shor’s algorithm based on MindSpore Quantum<a class="headerlink" href="#shor’s-algorithm-based-on-mindspore-quantum" title="Permalink to this headline"></a></h1>
<p><a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/en/mindspore_shor_algorithm.ipynb"><img alt="Download Notebook" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_notebook_en.svg" /></a>  <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/en/mindspore_shor_algorithm.py"><img alt="Download Code" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_download_code_en.svg" /></a>  <a class="reference external" href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_en/shor_algorithm.ipynb"><img alt="View source on Gitee" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source_en.svg" /></a></p>
<section id="introduction-to-shor’s-algorithm">
<h2>Introduction to Shor’s Algorithm<a class="headerlink" href="#introduction-to-shor’s-algorithm" title="Permalink to this headline"></a></h2>
<p>The time complexity of Shor’s algorithm to decompose an integer <span class="math notranslate nohighlight">\(N\)</span> on a quantum computer is <span class="math notranslate nohighlight">\(logN\)</span>, which is almost exponential <span class="math notranslate nohighlight">\(e\)</span> speedup over the most efficient known classical factorization algorithm, and this speedup may break the modern cryptography such as RSA on a quantum computer.</p>
</section>
<section id="basic-idea-of-shor’s-algorithm">
<h2>Basic Idea of Shor’s algorithm<a class="headerlink" href="#basic-idea-of-shor’s-algorithm" title="Permalink to this headline"></a></h2>
<p>Shor’s algorithm aims to solve the problem: given an integer <span class="math notranslate nohighlight">\(N\)</span>, find its prime factors. That is, for a given large number <span class="math notranslate nohighlight">\(N\)</span>, determine two prime factors <span class="math notranslate nohighlight">\(p1\)</span> and <span class="math notranslate nohighlight">\(p2\)</span> in polynomial time to satisfy <span class="math notranslate nohighlight">\(p1\cdot p2=N\)</span>. Before introducing the Shor’s algorithm, let’s learn some basic knowledge of number theory.</p>
<p>We need to learn some basic number theory in order to understand the factorization problem. We can simplified the problem by finding the period of <span class="math notranslate nohighlight">\(a\)</span> in the following function:</p>
<div class="math notranslate nohighlight">
\[f(x) = a^x \mod N\]</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(N\)</span> are relatively prime, otherwise a factor can be obtained immediately by calling <span class="math notranslate nohighlight">\(gcd(a,N)\)</span>. Since the function <span class="math notranslate nohighlight">\(f(x)\)</span> has a period of <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(f(x)=f(x+r)\)</span> is satisfied. In this case, we can get</p>
<div class="math notranslate nohighlight">
\[a^x = a^{x+r} \mod N \forall x\]</div>
<p>Set <span class="math notranslate nohighlight">\(x=0\)</span>, we can get <span class="math notranslate nohighlight">\(a^r=1+qN\)</span>, where <span class="math notranslate nohighlight">\(q\)</span> is an integer,</p>
<div class="math notranslate nohighlight">
\[a^r-1=(a^{r/2}-1)(a^{r/2}+1)=qN\]</div>
<p>It indicates that the factors of <span class="math notranslate nohighlight">\(N\)</span> can be found through finding greatest common divisor.</p>
<p>Therefore, the main idea of Shor’s algorithm is to transform the problem of factoring large numbers into the problem of finding the function’s period. Since we can use the superposition principle to perform parallel computing in quantum computing, we can quickly find the period <span class="math notranslate nohighlight">\(r\)</span> of the function <span class="math notranslate nohighlight">\(f(x)\)</span> through quantum algorithms (for specific principles and steps, please refer to the <code class="docutils literal notranslate"><span class="pre">period</span> <span class="pre">finding</span> <span class="pre">algorithm</span></code> in this document ). In general, we need to implement the function:
<span class="math notranslate nohighlight">\(f(|x\rangle)=a^{|x\rangle}\ mod\ N\)</span> in the quantum circuit. We can construct a unitary matrix $U_{a,N} $ where <span class="math notranslate nohighlight">\(U_{a,N}|x\rangle |y\rangle \rightarrow |x\rangle |y \oplus f(x) \rangle\)</span>, and then using Quantum Fourier Transform to find the period <span class="math notranslate nohighlight">\(r\)</span> which satisfies $ a^r:nbsphinx-math:<a href="#id1"><span class="problematic" id="id2">`</span></a>equiv 1`( mod N)$.</p>
<p>Taking <span class="math notranslate nohighlight">\(N=15\)</span> as an example, the steps of Shor’s algorithm is introduced as follows,</p>
<ol class="arabic simple">
<li><p>Randomly choose a number, such as <span class="math notranslate nohighlight">\(a=2(&lt;15)\)</span></p></li>
<li><p>Find the greatest common divisor, <span class="math notranslate nohighlight">\(\rm gcd(a,N)=gcd(2,15)=1\)</span></p></li>
<li><p>Find the period of the function <span class="math notranslate nohighlight">\(f(x)=a^x\ mod\ N\)</span>, so that <span class="math notranslate nohighlight">\(f(x+r)=f(x)\)</span></p></li>
<li><p>Running the quantum circuit we can get <span class="math notranslate nohighlight">\(r=4\)</span></p></li>
<li><p>Find the greatest common divisor, <span class="math notranslate nohighlight">\(\gcd(a^{r/2}+1,N)=\gcd(5,15)=5\)</span></p></li>
<li><p>Find the greatest common divisor, <span class="math notranslate nohighlight">\(\gcd(a^{r/2}-1,N)=\gcd(3,15)=3\)</span></p></li>
<li><p>Hence, the prime factor of 15 are 3 and 5, and the decomposition operation is complete.</p></li>
</ol>
<p>The quantum circuit of Shor’s algorithm is shown as follows,</p>
<p><img alt="shor’s algorithm circuit" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_zh_cn/images/shor_algorithm_circuit.png" /></p>
</section>
<section id="implement-shor’s-algorithm-using-mindspore-quantum">
<h2>Implement Shor’s Algorithm Using MindSpore Quantum<a class="headerlink" href="#implement-shor’s-algorithm-using-mindspore-quantum" title="Permalink to this headline"></a></h2>
<p>First, we need to import some required modules.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#pylint: disable=W0611</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">import</span> <span class="nn">mindquantum</span> <span class="k">as</span> <span class="nn">mq</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">UnivMathGate</span><span class="p">,</span> <span class="n">Measure</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">controlled</span><span class="p">,</span> <span class="n">UN</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.library</span> <span class="kn">import</span> <span class="n">qft</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>
</pre></div>
</div>
</div>
<p>From the basic idea of Shor’s algorithm, we can see that the main part of Shor’s algorithm is period finding subroutine processed by quantum computers, and the most difficult part of the period search algorithm is the operator <span class="math notranslate nohighlight">\(U\)</span> which convert the state <span class="math notranslate nohighlight">\(|x\rangle |y\rangle\)</span> into <span class="math notranslate nohighlight">\(|x\rangle |y \oplus f(x) \rangle\)</span>. The quantum circuit structure of this operator is more complicated. Therefore, we will first calculate the operator <span class="math notranslate nohighlight">\(U\)</span> through a classical computer and use
it as Make an Oracle so that this document can demonstrate Shor’s algorithm as a whole and intuitively.</p>
<section id="construct-the-oracle">
<h3>Construct the Oracle<a class="headerlink" href="#construct-the-oracle" title="Permalink to this headline"></a></h3>
<p>The construction of Oracle is merely 3 steps,</p>
<ol class="arabic simple">
<li><p>Exhaustively enumerate all possible <span class="math notranslate nohighlight">\(x\)</span> before the transformation (<span class="math notranslate nohighlight">\(N\)</span> times from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(N-1\)</span>), and calculate the corresponding <span class="math notranslate nohighlight">\(f(x)=a^x\ mod\ N\)</span>.</p></li>
<li><p>For each <span class="math notranslate nohighlight">\(x\)</span>, we can write the matrix representation of the state before transformation <span class="math notranslate nohighlight">\(|x\rangle |0\rangle\)</span> and the state after transformation <span class="math notranslate nohighlight">\(|x\rangle |f(x)\rangle\)</span>, we can get the transformation matrix corresponding to each <span class="math notranslate nohighlight">\(x\)</span> by there tensor product, and then sum all the matrices to get the matrix representation of the operator <span class="math notranslate nohighlight">\(U\)</span>, that is:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[U=\sum_{x=0}^{N-1} |x\rangle |0\rangle \langle x|\langle f(x)|\]</div>
<ol class="arabic simple" start="3">
<li><p>Use the matrix <span class="math notranslate nohighlight">\(U\)</span> to generate the custom gate.</p></li>
</ol>
<p>Example: <span class="math notranslate nohighlight">\(N=15, a=2\)</span>, we can obtain <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(f(x)\)</span>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># number of qubits</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">q</span><span class="p">):</span>
    <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x: &#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;f(x): &#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
x:  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
f(x):  [1, 2, 4, 8, 1, 2, 4, 8, 1, 2, 4, 8, 1, 2, 4, 8]
</pre></div></div>
</div>
<p>We then compute <span class="math notranslate nohighlight">\(|0\rangle |0\rangle \langle 0| \langle 1|+|1\rangle |0\rangle \langle 1| \langle 2|+|2\rangle |0\rangle \langle 2|\langle 4|+...\)</span> what we get is the matrix representation of the transformation <span class="math notranslate nohighlight">\(U\)</span>, where <span class="math notranslate nohighlight">\(|0\rangle |0\rangle\)</span>, <span class="math notranslate nohighlight">\(|0\rangle |1\rangle\)</span>, <span class="math notranslate nohighlight">\(|0\rangle |2\rangle\)</span>… can be expressed as mutually orthogonal column vectors with 256 entries, in which only one entity is 1 and the rest are 0. For example the first element in
<span class="math notranslate nohighlight">\(|0\rangle |0\rangle\)</span> is 1, the second element in <span class="math notranslate nohighlight">\(|0\rangle |1\rangle\)</span> is 1, the 17th element in <span class="math notranslate nohighlight">\(|1\rangle |0\rangle\)</span> is 1, and so on.</p>
<p>However, the current version of MindSpore Quantum’s Simulator has a limit on the number of bits of the custom gate (which cannot be greater than 5 bits), but when we decomposing the smallest non-even prime factor integer 15=3*5 requires at least 8 bits, so we need to take a much more complicated approach to construct this Oracle using a compromise method, that is, register 1 (4 bits) is used as the control bit, and the corresponding transform <span class="math notranslate nohighlight">\(T_x\)</span> is applied to each <span class="math notranslate nohighlight">\(x\)</span> in register
2 (4 bits):</p>
<div class="math notranslate nohighlight">
\[T_x|x\rangle \rightarrow |a^x\ mod\ N\rangle\]</div>
<p>Each <span class="math notranslate nohighlight">\(T_x\)</span> is controlled by register 1, and they only works when the number stored in register 1 is <span class="math notranslate nohighlight">\(x\)</span>. Finally, there are a total of <span class="math notranslate nohighlight">\(N\)</span> gates, and the entire circuit including these <span class="math notranslate nohighlight">\(N\)</span> gates corresponds to the operator <span class="math notranslate nohighlight">\(U\)</span>. Note that <span class="math notranslate nohighlight">\(T_x\)</span> is not itself a gate, since it is not a reversible operation. Therefore, only when register 2 is in the <span class="math notranslate nohighlight">\(|0\rangle\)</span> state, the oracle can give the correct output.</p>
<p>The following is the compromised Oracle construction method:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">U_operator</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">register1</span><span class="p">,</span> <span class="n">register2</span><span class="p">):</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">register1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span><span class="p">)</span>  <span class="c1"># Compute f(x)</span>

    <span class="c1"># Create a matrix representation of the quantum state |register2&gt;</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Calculate the matrix that maps Tx</span>
        <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UnivMathGate</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;f(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">matrix</span><span class="p">))</span>  <span class="c1"># Construct Tx &quot;gate&quot; with transformation matrix</span>

<span class="c1"># Create a control circuit and get the operator U. For each Tx &quot;gate&quot;, it is controlled by all bits in register 1.</span>
<span class="c1"># The bit in the binary corresponding to x is a normal control node,</span>
<span class="c1"># and if the bit is 0, the X gate is applied on both sides of the control node, flipping control bit.</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">bin_x</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># Convert x to binary</span>
        <span class="n">flip_control_qubit</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">register1</span><span class="p">)))</span>  <span class="c1"># Initialize the list of bits that need to act on the X gate</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_x</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">bin_x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_x</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>  <span class="c1"># Get the &#39;1&#39; bits in the binary of x</span>
                <span class="n">flip_control_qubit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>  <span class="c1"># Remove control bits from the list that do not need to be applied X gate</span>

        <span class="n">circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>  <span class="c1"># add barrier</span>
        <span class="n">circuit</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">flip_control_qubit</span><span class="p">)</span>  <span class="c1"># Apply the X gate before the control node</span>
        <span class="n">circuit</span> <span class="o">+=</span> <span class="n">T</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">register2</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">register1</span><span class="p">))</span>  <span class="c1"># Connect the control bits to the Tx &quot;gate&quot;</span>
        <span class="n">circuit</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">flip_control_qubit</span><span class="p">)</span>  <span class="c1"># Apply the X gate after the control node</span>

    <span class="k">return</span> <span class="n">circuit</span>
</pre></div>
</div>
</div>
<p>Now, the <code class="docutils literal notranslate"><span class="pre">U_operator()</span></code> function can perform the modular exponentiation operation on the quantum state <span class="math notranslate nohighlight">\(|x\rangle\)</span> in register 1, and store the result <span class="math notranslate nohighlight">\(a^{|x\rangle}\ mod\ N\)</span> in the register 2.</p>
<p>For example: in the case of <span class="math notranslate nohighlight">\(N=15, a=2\)</span>, we construct the corresponding <span class="math notranslate nohighlight">\(U\)</span> operator and verify that we can get the correct result (register 1 and register 2 each require 4 bits to store <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(f(x)\)</span>):</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">register1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">register2</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># Create a circuit where the input state is |0100⟩|0000⟩, that is, x=8, |8⟩|0⟩</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">U_operator</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">register1</span><span class="p">,</span> <span class="n">register2</span><span class="p">)</span>  <span class="c1"># Apply the U operator</span>

<span class="nb">print</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">ket</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># Print the final state</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span> <span class="c1"># Print circuit</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
1¦00010100⟩
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/shor_algorithm_7_1.svg" src="_images/shor_algorithm_7_1.svg" /></div>
</div>
<p>The result in register 1 is 0100 or |0100⟩, and the result in register 2 is 0001 or |0001⟩. We have previously calculated <span class="math notranslate nohighlight">\(f(8)=2^8\ mod\ 15=1\)</span>, so the output is correct. Although the circuit looks complicated, it is actually just 16 controlled 4-bit gates that act in sequence. The <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/en/master/core/gates/mindquantum.core.gates.XGate.html">X</a> gate on the first four bits is used to flip the control bit.</p>
<p>Next we need to implement the period finding algorithm.</p>
</section>
<section id="period-finding-subroutine">
<h3>Period Finding Subroutine<a class="headerlink" href="#period-finding-subroutine" title="Permalink to this headline"></a></h3>
<ol class="arabic">
<li><p>In register 1, we need <span class="math notranslate nohighlight">\(q&gt;log_2 N\)</span> qubits to record the binary number of the variable <span class="math notranslate nohighlight">\(x \in [0,N-1]\)</span>, and we also need <span class="math notranslate nohighlight">\(q\)</span> qubits in register 2 to record <span class="math notranslate nohighlight">\(f (x)=a^x\ mod\ N\ \in [0,N-1]\)</span> binary form. At this time, register 1 and register 2 can respectively record the integers of <span class="math notranslate nohighlight">\([0, Q-1]\)</span>, where <span class="math notranslate nohighlight">\(Q=2^q&gt;N\)</span>.</p></li>
<li><p>The <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/en/master/core/gates/mindquantum.core.gates.HGate.html">Hadamard</a> gate is applied to all bits in register 1, and the bits in register 1 are in a uniform superposition state of all integers in <span class="math notranslate nohighlight">\([0,Q-1]\)</span></p>
<div class="math notranslate nohighlight">
\[|\psi\rangle=\sum_{x=0}^{Q-1}|x\rangle\]</div>
</li>
<li><p>Perform function operation <span class="math notranslate nohighlight">\(a^{|\psi\rangle}\ mod\ N\)</span> on the state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> stored in register 1, and store the result in register 2. This step is completed by the previously constructed U_operator . Due to the direct operation on the superposition state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, this step can completed in one step, which shows the Quantum Advantage - parallel computing. At this time, the state stored in the circuit is an entangled state, which can be expressed as</p>
<div class="math notranslate nohighlight">
\[\sum_{x=0}^{Q-1}|x\rangle|f(x)\rangle=\sum_{i=0}^{r-1}(|i\rangle+|i+r\rangle+| i+2r\rangle+...)\ |f(i)\rangle\]</div>
</li>
<li><p>Perform an inverse Fourier transform on register 1. This transform uses a <span class="math notranslate nohighlight">\(Q\)</span>-order unit root <span class="math notranslate nohighlight">\(\omega^{2\pi i/Q}\)</span>, which evenly distributes the amplitude of any given state <span class="math notranslate nohighlight">\(|x\rangle\)</span> on <span class="math notranslate nohighlight">\(Q\)</span> states of <span class="math notranslate nohighlight">\(|y\rangle\)</span>. As shown in step 3, the equivalent states of <span class="math notranslate nohighlight">\(|i\rangle\)</span> and <span class="math notranslate nohighlight">\(|i+r\rangle\)</span> in register 1 are both entangled with the same state <span class="math notranslate nohighlight">\(|f(i)\rangle\)</span> in register 2, with the Quantum interference effect, and finally, when the unit vector
<span class="math notranslate nohighlight">\(\omega^{2\pi iry/Q}\)</span> is closer to 1 (pointing to the positive real number axis), the probability of measuring the state <span class="math notranslate nohighlight">\(|y\rangle\)</span> is greater. In other words, our measured state <span class="math notranslate nohighlight">\(|y\rangle\)</span> has a high probability to make <span class="math notranslate nohighlight">\(\frac{ry}{Q}\)</span> close to a certain integer <span class="math notranslate nohighlight">\(c\)</span>. For a more detailed mathematical description, please refer to the link: <a class="reference external" href="https://en.wikipedia.org/wiki/Shor%27s_algorithm">https://en.wikipedia.org/wiki/Shor%27s_algorithm</a>.</p></li>
<li><p>Measure register 1 to get the binary string. Convert the binary string to the decimal number <span class="math notranslate nohighlight">\(y\)</span>, at this time <span class="math notranslate nohighlight">\(\frac{y}{Q}\sim\frac{c}{r}\)</span>, where <span class="math notranslate nohighlight">\(c\)</span> is an unknown integer. Calculate the irreducible fraction (the denominator is not greater than <span class="math notranslate nohighlight">\(N\)</span>) approximated by <span class="math notranslate nohighlight">\(\frac{y}{Q}\)</span> using the continued fraction factorization method, the period <span class="math notranslate nohighlight">\(r\)</span> is its denominator. However, among irreducible fractions which denominator is less than <span class="math notranslate nohighlight">\(N\)</span>, there may be
fractions that are closer to <span class="math notranslate nohighlight">\(\frac{y}{Q}\)</span> than <span class="math notranslate nohighlight">\(\frac{c}{r}\)</span>, or <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(r\)</span> have a common factor, the obtained <span class="math notranslate nohighlight">\(r\)</span> will be the factor of the real function period. At this time, the calculation fails, we need to recalculate.</p></li>
</ol>
<p>Taking the example of <span class="math notranslate nohighlight">\(N=15, a=2\)</span> again, in <code class="docutils literal notranslate"><span class="pre">constructing</span> <span class="pre">Oracle</span></code>, we calculated each <span class="math notranslate nohighlight">\(f(x)\)</span>, from which we can directly see that the function period is 4. Now we can build the corresponding period-finding subroutine and run 100 simulations to see what we get.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span> <span class="c1"># Create a quantum circuit</span>
<span class="n">register1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># Set the first 4 bits to register 1</span>
<span class="n">register2</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1"># Set the last 4 bits to register 2</span>

<span class="n">circuit</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">register1</span><span class="p">)</span> <span class="c1"># Apply H gate to all bits in register 1</span>

<span class="c1"># Perform a modular multiplication operation on register 1 and store the result in register 2, which is done by a large U gate</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">U_operator</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">register1</span><span class="p">,</span> <span class="n">register2</span><span class="p">)</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span> <span class="c1"># Add barrier</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">qft</span><span class="p">(</span><span class="n">register1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">hermitian</span><span class="p">()</span> <span class="c1"># Perform the inverse Fourier transform on register 1, pay attention to the bit order of the Fourier transform, reversing the order is required here</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span> <span class="c1"># Add barrier</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">Measure</span><span class="p">(),</span> <span class="n">register1</span><span class="p">)</span> <span class="c1"># Measure register 1</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span> <span class="c1"># Draw a circuit diagram</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/shor_algorithm_9_0.svg" src="_images/shor_algorithm_9_0.svg" /></div>
</div>
<p>As shown in the quantum circuit, it includes four parts in the order-finding subroutine,</p>
<ol class="arabic simple">
<li><p>superposition states generation</p></li>
<li><p>functional operation</p></li>
<li><p>inverse Fourier transform</p></li>
<li><p>measurement</p></li>
</ol>
<p>Next, execute the circuit for 100 times and record the results.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span> <span class="c1"># Create a quantum circuit simulator</span>

<span class="c1"># Simulate the circuit 100 times, print the measurement results, set the random seed to a random integer within 100</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>

<span class="n">result</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/shor_algorithm_11_0.svg" src="_images/shor_algorithm_11_0.svg" /></div>
</div>
<p>We can see from the statistical results that only 4 states can be measured in the last register 1, which are <span class="math notranslate nohighlight">\(y=[0,4,8,12]\)</span>, this is due to <span class="math notranslate nohighlight">\(\omega^{2\pi iry/Q} \ (Q=16)\)</span> When <span class="math notranslate nohighlight">\(y\)</span> takes these four values, it is exactly 1, and other states cause the probability amplitude canceling to zero due to quantum interference. Substituting the measurement results into <span class="math notranslate nohighlight">\(\frac{y}{Q}\sim\frac{c}{r}\)</span>, we can see that the formula is indeed true, we have about 50% probability to get the
correct period <span class="math notranslate nohighlight">\(r\)</span>, but there are about 25% probability of getting the factor of <span class="math notranslate nohighlight">\(r\)</span>, and 25% probability of getting the 0 state, the latter two cases need to be recalculated.</p>
<p>Next we are going to construct a general period-finding algorithm.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">period_finder</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>  <span class="c1"># Create a quantum circuit</span>
    <span class="n">register1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># Set the first q bits to register 1</span>
    <span class="n">register2</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span>  <span class="c1"># Set the last q bits to register 2</span>

    <span class="n">circuit</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">register1</span><span class="p">)</span>  <span class="c1"># Apply H gate to all bits in register 1</span>

    <span class="c1"># Perform a modular multiplication operation on register 1 and store the result in register 2, which is done by a large U gate</span>
    <span class="n">circuit</span> <span class="o">+=</span> <span class="n">U_operator</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">register1</span><span class="p">,</span> <span class="n">register2</span><span class="p">)</span>

    <span class="n">circuit</span> <span class="o">+=</span> <span class="n">qft</span><span class="p">(</span><span class="n">register1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">hermitian</span><span class="p">()</span>  <span class="c1"># Perform the inverse Fourier transform on register 1, pay attention to the bit order of the Fourier transform, reversing the order is required here</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>  <span class="c1"># Add barrier</span>
    <span class="n">circuit</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">Measure</span><span class="p">(),</span> <span class="n">register1</span><span class="p">)</span>  <span class="c1"># Measure register 1</span>

    <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>  <span class="c1"># Create a quantum circuit simulator</span>

    <span class="c1"># Simulate the circuit, collect the measurement results, set the random seed to a random integer within 100</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>

    <span class="c1"># result.data is a dictionary, the key is the measurement result, and the value is the frequency of occurrence. We only sampled once, so there is only one key, and the value must be 1</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Read the key</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Convert the result from binary to decimal</span>

    <span class="c1"># Using the continued fraction factorization method to calculate the irreducible fraction approximated by result/2**q, the denominator cannot be greater than N</span>
    <span class="n">eigenphase</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">result</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Fraction</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="n">eigenphase</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">denominator</span>  <span class="c1"># Take the denominator of f to get the period r</span>

    <span class="c1"># r may be a factor of the period, so it needs to be verified, if and only if r is the function period itself, return r, otherwise return None</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">**</span><span class="n">r</span> <span class="o">%</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</section>
<section id="classic-computer-part">
<h3>Classic Computer Part<a class="headerlink" href="#classic-computer-part" title="Permalink to this headline"></a></h3>
<p>The classical computer part is responsible for transforming the factorization problem into the problem of finding function period. The specific steps are as follows:</p>
<ol class="arabic simple">
<li><p>Randomly pick an integer <span class="math notranslate nohighlight">\(a\)</span> less than <span class="math notranslate nohighlight">\(N\)</span>, use the gcd algorithm to verify whether <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(N\)</span> are mutually prime, if there is a common factor between <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(N\)</span>, then we directly get one of <span class="math notranslate nohighlight">\(N\)</span>’s factor, output the result.</p></li>
<li><p>The computation requires <span class="math notranslate nohighlight">\(q\)</span> bits to store the binary number of <span class="math notranslate nohighlight">\(N\)</span>.</p></li>
<li><p>Use the period finding algorithm to get the period <span class="math notranslate nohighlight">\(r\)</span> of the function <span class="math notranslate nohighlight">\(f(x)=a^x\ mod\ N\)</span>.</p></li>
<li><p>Determine whether <span class="math notranslate nohighlight">\(r\)</span> is an even number, if not, go back to the first step.</p></li>
<li><p>Calculate <span class="math notranslate nohighlight">\(a^{r/2}+1\)</span> and <span class="math notranslate nohighlight">\(a^{r/2}-1\)</span>, one of them must have a non-1 common factor with <span class="math notranslate nohighlight">\(N\)</span>. However, <span class="math notranslate nohighlight">\(a^{r/2}+1\)</span> may be divisible by <span class="math notranslate nohighlight">\(N\)</span>, so the final output may still be <span class="math notranslate nohighlight">\(N\)</span> itself.</p></li>
</ol>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#pylint: disable=C0121,R1705</span>
<span class="k">def</span> <span class="nf">shor</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># Generate a random integer a in the interval [2,N-1]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>  <span class="c1"># Get the greatest common factor b of a and N</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># If b is not equal to 1, then b is a prime factor of N, return the decomposition result</span>

        <span class="c1"># Get enough bits q to represent N in binary</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">q</span>
            <span class="k">if</span> <span class="n">Q</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">q</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">period_finder</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>  <span class="c1"># Use period finding algorithm to get r</span>

        <span class="c1"># Determine whether r is an even number, if so, jump out of the loop, if not, re-select a random integer a</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Calculate a**(r/2)+1 and a**(r/2)-1, then verify if they have a common divisor with N, if so, output the result</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">%</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Since classical computer simulation of quantum algorithms requires a lot of memory, and the previously mentioned simulator in MindSpore Quantum cannot implement multi-qubit gates, such as 5 qubit gates so far. We cannot use Shor’s algorithm to calculate the case of <span class="math notranslate nohighlight">\(N&gt;21\)</span> for the time being. Finally let’s try to decompose <span class="math notranslate nohighlight">\(N=15\)</span> using the written Shor’s algorithm.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">15</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Factoring N = p * q =&quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

<span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">shor</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;p =&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;q =&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Factoring N = p * q = 15
p = 3
q = 5
</pre></div></div>
</div>
<p>As we can see from the results, we successfully decomposed 15 into two prime factors 3 and 5.</p>
<p>So far, we have successfully implemented the Shor’s algorithm using MindSpore Quantum.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.utils.show_info</span> <span class="kn">import</span> <span class="n">InfoTable</span>

<span class="n">InfoTable</span><span class="p">(</span><span class="s1">&#39;mindquantum&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<table border="1">
  <tr>
    <th>Software</th>
    <th>Version</th>
  </tr>
<tr><td>mindquantum</td><td>0.9.11</td></tr>
<tr><td>scipy</td><td>1.10.1</td></tr>
<tr><td>numpy</td><td>1.23.5</td></tr>
<tr>
    <th>System</th>
    <th>Info</th>
</tr>
<tr><td>Python</td><td>3.9.16</td></tr><tr><td>OS</td><td>Linux x86_64</td></tr><tr><td>Memory</td><td>8.3 GB</td></tr><tr><td>CPU Max Thread</td><td>8</td></tr><tr><td>Date</td><td>Sat Dec 30 22:54:16 2023</td></tr>
</table></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="grover_search_algorithm.html" class="btn btn-neutral float-left" title="Grover search and Long algorithms based on MindSpore Quantum" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="hhl_algorithm.html" class="btn btn-neutral float-right" title="HHL Algorithm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>