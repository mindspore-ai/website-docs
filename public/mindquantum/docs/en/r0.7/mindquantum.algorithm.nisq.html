<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindquantum.algorithm.nisq &mdash; MindSpore master documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="mindquantum.io" href="mindquantum.io.html" />
    <link rel="prev" title="mindquantum.algorithm.library" href="mindquantum.algorithm.library.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">MindQuantum Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">Initial experience of quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">Advanced gradient calculation of variational quantum circuits</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variational Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">Classification of iris by quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">The Application of Quantum Neural Network in NLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">VQE Application in Quantum Chemistry Computing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">Grover search algorithm based on MindQuantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">Shor’s algorithm based on MindQuantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="mindquantum.algorithm.library.html">mindquantum.algorithm.library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">mindquantum.algorithm.nisq</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="mindquantum.algorithm.html">mindquantum.algorithm</a> &raquo;</li>
      <li>mindquantum.algorithm.nisq</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/mindquantum.algorithm.nisq.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="module-mindquantum.algorithm.nisq">
<span id="mindquantum-algorithm-nisq"></span><h1>mindquantum.algorithm.nisq<a class="headerlink" href="#module-mindquantum.algorithm.nisq" title="Permalink to this headline"></a></h1>
<p>Noisy Intermediate Scale Quantum (NISQ) algorithms.</p>
<p>In NISQ, the quantum qubits number and quantum circuit depth are very limited
and the quantum gate fidelity is also limited.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Ansatz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">Ansatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/_ansatz.html#Ansatz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Ansatz" title="Permalink to this definition"></a></dt>
<dd><p>Basic class for Ansatz.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The name of this ansatz.</p></li>
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – How many qubits this ansatz act on.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Ansatz.circuit">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">circuit</span></span><a class="headerlink" href="#mindquantum.algorithm.nisq.Ansatz.circuit" title="Permalink to this definition"></a></dt>
<dd><p>Get the quantum circuit of this ansatz.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Circuit, the quantum circuit of this ansatz.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.HardwareEfficientAnsatz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">HardwareEfficientAnsatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">single_rot_gate_seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entangle_gate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entangle_mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/hardware_efficient_ansatz.html#HardwareEfficientAnsatz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.HardwareEfficientAnsatz" title="Permalink to this definition"></a></dt>
<dd><p>HardwareEfficientAnsatz is a kind of ansatz that can be easily implement on quantum chip.</p>
<p>The hardware efficient is constructed by a layer of single qubit rotation gate and a layer
of two qubits entanglement gate. The single qubit rotation gate layer is constructed by one
or several rotation gate that act on every qubit. The two qubits entanglement gate layer is
constructed by CNOT, CZ, XX, YY, ZZ, etc. acting on entangle_mapping. For more detail, please
refers <a class="reference external" href="https://www.nature.com/articles/nature23879">Hardware-efficient variational quantum eigensolver for small molecules and quantum
magnets</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – number of qubit that this ansatz act on.</p></li>
<li><p><strong>single_rot_gate_seq</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>[</em><a class="reference internal" href="mindquantum.core.gates.html#mindquantum.core.gates.BasicGate" title="mindquantum.core.gates.BasicGate"><em>BasicGate</em></a><em>]</em>) – A list of parameterized rotation gate that act on
each qubit.</p></li>
<li><p><strong>entangle_gate</strong> (<a class="reference internal" href="mindquantum.core.gates.html#mindquantum.core.gates.BasicGate" title="mindquantum.core.gates.BasicGate"><em>BasicGate</em></a>) – The non parameterized entanglement gate. If it is a single qubit
gate, than the control version will be used. Default: XGate.</p></li>
<li><p><strong>entangle_mapping</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em><em>]</em>) – The entanglement mapping of entanglement gate.
‘linear’ means the entanglement gate will be act on every neighboring qubits. ‘all’ means
the entanglemtn gate will be act on any two qbuits. Besides, you can specific which two
qubits you want to do entanglement by setting the entangle_mapping to a list of two qubits
tuple. Default: “linear”.</p></li>
<li><p><strong>depth</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The depth of ansatz. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">HardwareEfficientAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">RY</span><span class="p">,</span> <span class="n">RZ</span><span class="p">,</span> <span class="n">Z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hea</span> <span class="o">=</span> <span class="n">HardwareEfficientAnsatz</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">RY</span><span class="p">,</span> <span class="n">RZ</span><span class="p">],</span> <span class="n">Z</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hea</span><span class="o">.</span><span class="n">circuit</span>
<span class="go">q0: ──RY(d0_n0_0)────RZ(d0_n0_1)────●────●────RY(d1_n0_0)────RZ(d1_n0_1)──</span>
<span class="go">                                    │    │</span>
<span class="go">q1: ──RY(d0_n1_0)────RZ(d0_n1_1)────Z────┼────RY(d1_n1_0)────RZ(d1_n1_1)──</span>
<span class="go">                                         │</span>
<span class="go">q2: ──RY(d0_n2_0)────RZ(d0_n2_1)─────────Z────RY(d1_n2_0)────RZ(d1_n2_1)──</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.IQPEncoding">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">IQPEncoding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_feature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_rotation_gate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">RZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_rotation_gate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">RZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qnn/iqp_encoding.html#IQPEncoding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.IQPEncoding" title="Permalink to this definition"></a></dt>
<dd><p>General IQP Encoding.</p>
<p>For more information, please refer to <a class="reference external" href="https://www.nature.com/articles/s41586-019-0980-2">Supervised learning with quantum-enhanced feature
spaces</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_feature</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of feature of data you want to encode with IQPEncoding.</p></li>
<li><p><strong>first_rotation_gate</strong> (<em>ParamaterGate</em>) – One of the rotation gate RX, RY or RZ.</p></li>
<li><p><strong>second_rotation_gate</strong> (<em>ParamaterGate</em>) – One of the rotation gate RX, RY or RZ.</p></li>
<li><p><strong>num_repeats</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of encoding iterations.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">IQPEncoding</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span> <span class="o">=</span> <span class="n">IQPEncoding</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">circuit</span>
<span class="go">q0: ──H────RZ(alpha0)────●───────────────────────────●───────────────────────────────────</span>
<span class="go">                         │                           │</span>
<span class="go">q1: ──H────RZ(alpha1)────X────RZ(alpha0 * alpha1)────X────●───────────────────────────●──</span>
<span class="go">                                                          │                           │</span>
<span class="go">q2: ──H────RZ(alpha2)─────────────────────────────────────X────RZ(alpha1 * alpha2)────X──</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">params_name</span>
<span class="go">[&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;alpha0 * alpha1&#39;, &#39;alpha1 * alpha2&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">params_name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 0, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="n">iqp</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">array([-0.28324704-0.21159186j, -0.28324704-0.21159186j,</span>
<span class="go">        0.31027229+0.16950252j,  0.31027229+0.16950252j,</span>
<span class="go">        0.02500938+0.35266773j,  0.02500938+0.35266773j,</span>
<span class="go">        0.31027229+0.16950252j,  0.31027229+0.16950252j])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.IQPEncoding.data_preparation">
<span class="sig-name descname"><span class="pre">data_preparation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qnn/iqp_encoding.html#IQPEncoding.data_preparation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.IQPEncoding.data_preparation" title="Permalink to this definition"></a></dt>
<dd><p>Prepare the classical data into suitable dimension for IQPEncoding.</p>
<p>The IQPEncoding ansatz provides an ansatz to encode classical data into quantum state.</p>
<p>Suppose the origin data has <span class="math notranslate nohighlight">\(n\)</span> features, then the output data will have <span class="math notranslate nohighlight">\(2n-1\)</span> features,
with first <span class="math notranslate nohighlight">\(n\)</span> features will be the original data. For <span class="math notranslate nohighlight">\(m &gt; n\)</span>,</p>
<div class="math notranslate nohighlight">
\[\text{data}_m = \text{data}_{m - n} * \text{data}_{m - n - 1}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>, </em><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a><em>]</em>) – The classical data need to encode with IQPEncoding ansatz.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray, the prepared data that is suitable for this ansatz.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Max2SATAnsatz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">Max2SATAnsatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_2_sat_ansatz.html#Max2SATAnsatz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Max2SATAnsatz" title="Permalink to this definition"></a></dt>
<dd><p>The Max-2-SAT ansatz.</p>
<p>For more detail, please refer to <a class="reference external" href="https://arxiv.org/abs/1906.11259.pdf">Reachability Deficits
in Quantum Approximate Optimization</a>.</p>
<div class="math notranslate nohighlight">
\[U(\beta, \gamma) = e^{-\beta_pH_b}e^{-\gamma_pH_c}
\cdots e^{-\beta_0H_b}e^{-\gamma_0H_c}H^{\otimes n}\]</div>
<p>Where,</p>
<div class="math notranslate nohighlight">
\[H_b = \sum_{i\in n}X_{i}, H_c = \sum_{l\in m}P(l)\]</div>
<p>Here <span class="math notranslate nohighlight">\(n\)</span> is the number of Boolean variables and <span class="math notranslate nohighlight">\(m\)</span> is the number
of total clauses and <span class="math notranslate nohighlight">\(P(l)\)</span> is rank-one projector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clauses</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The Max-2-SAT structure. Every element of list
is a clause represented by a tuple with length two. The element of
tuple must be non-zero integer. For example, (2, -3) stands for clause
<span class="math notranslate nohighlight">\(x_2\lor\lnot x_3\)</span>.</p></li>
<li><p><strong>depth</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The depth of Max-2-SAT ansatz. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">Max2SATAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clauses</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max2sat</span> <span class="o">=</span> <span class="n">Max2SATAnsatz</span><span class="p">(</span><span class="n">clauses</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max2sat</span><span class="o">.</span><span class="n">circuit</span>
<span class="go">q1: ──H─────RZ(beta_0)────●───────────────────────●────RX(alpha_0)──</span>
<span class="go">                          │                       │</span>
<span class="go">q2: ──H────RZ(-beta_0)────X────RZ(-1/2*beta_0)────X────RX(alpha_0)──</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max2sat</span><span class="o">.</span><span class="n">hamiltonian</span>
<span class="go">1/4 [] +</span>
<span class="go">1/4 [Z1] +</span>
<span class="go">-1/4 [Z1 Z2] +</span>
<span class="go">-1/4 [Z2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sats</span> <span class="o">=</span> <span class="n">max2sat</span><span class="o">.</span><span class="n">get_sat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sats</span>
<span class="go">[&#39;001&#39;, &#39;000&#39;, &#39;011&#39;, &#39;010&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sats</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sat value: </span><span class="si">{</span><span class="n">max2sat</span><span class="o">.</span><span class="n">get_sat_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">sat value: 1</span>
<span class="go">sat value: 0</span>
<span class="go">sat value: 2</span>
<span class="go">sat value: 1</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Max2SATAnsatz.get_sat">
<span class="sig-name descname"><span class="pre">get_sat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_2_sat_ansatz.html#Max2SATAnsatz.get_sat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Max2SATAnsatz.get_sat" title="Permalink to this definition"></a></dt>
<dd><p>Get the strings of this max-2-sat problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_n</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – how many strings you want.</p></li>
<li><p><strong>weight</strong> (<em>Union</em><em>[</em><a class="reference internal" href="mindquantum.core.parameterresolver.html#mindquantum.core.parameterresolver.ParameterResolver" title="mindquantum.core.parameterresolver.ParameterResolver"><em>ParameterResolver</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a><em>, </em><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/numbers.html#numbers.Number" title="(in Python v3.8)"><em>numbers.Number</em></a><em>]</em>) – parameter
value for Max-2-SAT ansatz.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list, a list of strings.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Max2SATAnsatz.get_sat_value">
<span class="sig-name descname"><span class="pre">get_sat_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_2_sat_ansatz.html#Max2SATAnsatz.get_sat_value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Max2SATAnsatz.get_sat_value" title="Permalink to this definition"></a></dt>
<dd><p>Get the sat values for given strings.</p>
<p>The string is a str that satisfies all the clauses of the given max-2-sat problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – a string of the max-2-sat problem consided.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>int, sat_value under the given string.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Max2SATAnsatz.hamiltonian">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hamiltonian</span></span><a class="headerlink" href="#mindquantum.algorithm.nisq.Max2SATAnsatz.hamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>Get the hamiltonian of this max-2-sat problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, hamiltonian of this max-2-sat problem.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.MaxCutAnsatz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">MaxCutAnsatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_cut_ansatz.html#MaxCutAnsatz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.MaxCutAnsatz" title="Permalink to this definition"></a></dt>
<dd><p>The MaxCut ansatz.</p>
<p>For more detail, please refer to <a class="reference external" href="https://arxiv.org/abs/1411.4028.pdf">A Quantum Approximate Optimization
Algorithm</a>.</p>
<div class="math notranslate nohighlight">
\[U(\beta, \gamma) = e^{-\beta_pH_b}e^{-\gamma_pH_c}
\cdots e^{-\beta_0H_b}e^{-\gamma_0H_c}H^{\otimes n}\]</div>
<p>Where,</p>
<div class="math notranslate nohighlight">
\[H_b = \sum_{i\in n}X_{i}, H_c = \sum_{(i,j)\in C}Z_iZ_j\]</div>
<p>Here <span class="math notranslate nohighlight">\(n\)</span> is the set of nodes and <span class="math notranslate nohighlight">\(C\)</span> is the set of
edges of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The graph structure. Every element of graph
is a edge that constructed by two nodes. For example, <cite>[(0, 1), (1, 2)]</cite> means
the graph has three nodes which are <cite>0</cite> , <cite>1</cite> and <cite>2</cite> with one edge connect between
node <cite>0</cite> and node <cite>1</cite> and another connect between node <cite>1</cite> and node <cite>2</cite>.</p></li>
<li><p><strong>depth</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The depth of max cut ansatz. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">MaxCutAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxcut</span> <span class="o">=</span> <span class="n">MaxCutAnsatz</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxcut</span><span class="o">.</span><span class="n">circuit</span>
<span class="go">q0: ──H────ZZ(beta_0)──────────────────ZZ(beta_0)────RX(alpha_0)──</span>
<span class="go">               │                           │</span>
<span class="go">q1: ──H────ZZ(beta_0)────ZZ(beta_0)────────┼─────────RX(alpha_0)──</span>
<span class="go">                             │             │</span>
<span class="go">q2: ──H──────────────────ZZ(beta_0)────ZZ(beta_0)────RX(alpha_0)──</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maxcut</span><span class="o">.</span><span class="n">hamiltonian</span>
<span class="go">3/2 [] +</span>
<span class="go">-1/2 [Z0 Z1] +</span>
<span class="go">-1/2 [Z0 Z2] +</span>
<span class="go">-1/2 [Z1 Z2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxcut</span><span class="o">.</span><span class="n">hamiltonian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">partitions</span> <span class="o">=</span> <span class="n">maxcut</span><span class="o">.</span><span class="n">get_partition</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;partition: left: </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">, right: </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">, cut value: </span><span class="si">{</span><span class="n">maxcut</span><span class="o">.</span><span class="n">get_cut_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">partition: left: [2], right: [0, 1], cut value: 2</span>
<span class="go">partition: left: [0, 1], right: [2], cut value: 2</span>
<span class="go">partition: left: [0], right: [1, 2], cut value: 2</span>
<span class="go">partition: left: [0, 1, 2], right: [], cut value: 0</span>
<span class="go">partition: left: [], right: [0, 1, 2], cut value: 0</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.MaxCutAnsatz.get_cut_value">
<span class="sig-name descname"><span class="pre">get_cut_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_cut_ansatz.html#MaxCutAnsatz.get_cut_value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.MaxCutAnsatz.get_cut_value" title="Permalink to this definition"></a></dt>
<dd><p>Get the cut values for given partitions.</p>
<p>The partition is a list that contains two lists, each list contains the nodes of the given graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>partition</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – a partition of the graph consided.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>int, cut_value under the given partition.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.MaxCutAnsatz.get_partition">
<span class="sig-name descname"><span class="pre">get_partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_cut_ansatz.html#MaxCutAnsatz.get_partition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.MaxCutAnsatz.get_partition" title="Permalink to this definition"></a></dt>
<dd><p>Get the partitions of this max-cut problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_n</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – how many partitions you want.</p></li>
<li><p><strong>weight</strong> (<em>Union</em><em>[</em><a class="reference internal" href="mindquantum.core.parameterresolver.html#mindquantum.core.parameterresolver.ParameterResolver" title="mindquantum.core.parameterresolver.ParameterResolver"><em>ParameterResolver</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a><em>, </em><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/numbers.html#numbers.Number" title="(in Python v3.8)"><em>numbers.Number</em></a><em>]</em>) – parameter
value for max-cut ansatz.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list, a list of partitions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.MaxCutAnsatz.hamiltonian">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hamiltonian</span></span><a class="headerlink" href="#mindquantum.algorithm.nisq.MaxCutAnsatz.hamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>Get the hamiltonian of this max cut problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, hamiltonian of this max cut problem.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.QubitUCCAnsatz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">QubitUCCAnsatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vir_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trotter_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/qubit_ucc_ansatz.html#QubitUCCAnsatz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.QubitUCCAnsatz" title="Permalink to this definition"></a></dt>
<dd><p>Qubit Unitary Coupled-Cluster (qUCC) ansatz class.</p>
<p>Qubit Unitary Coupled-Cluster (qUCC) ansatz is a variant of unitary
coupled-cluster ansatz which uses qubit excitation operators instead of
Fermion excitation operators. The Fock space spanned by qubit excitation
operators is equivalent as Fermion operators, therefore the exact
wave function can be approximated using qubit excitation operators at
the expense of a higher order of Trotterization.</p>
<p>The greatest advantange of qUCC is that the number of CNOT gates is much
smaller than the original version of UCC, even using a 3rd or 4th order
Trotterization. Also, the accuracy is greatly improved despite that the
number of variational parameters is increased.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Hartree-Fock circuit is not included.
Currently, generalized=True is not allowed since the theory needs verification.
Reference: <a class="reference external" href="https://doi.org/10.1103/PhysRevA.102.062612">Efficient quantum circuits for quantum computational
chemistry</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of qubits (spin-orbitals) in the simulation. Default: None.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of electrons of the given molecule. Default: None.</p></li>
<li><p><strong>occ_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned occupied spatial orbitals. Default: None.</p></li>
<li><p><strong>vir_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned virtual spatial orbitals. Default: None.</p></li>
<li><p><strong>generalized</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to use generalized excitations which
do not distinguish occupied or virtual orbitals (qUCCGSD). Currently,
generalized=True is not allowed since the theory needs verification. Default: False.</p></li>
<li><p><strong>trotter_step</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of Trotter steps. Default is one. It is
recommended to set a value larger than or equal to 2 to achieve a
good accuracy. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">QubitUCCAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QubitUCCAnsatz</span><span class="p">()</span><span class="o">.</span><span class="n">n_qubits</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc</span> <span class="o">=</span> <span class="n">QubitUCCAnsatz</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">trotter_step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc</span><span class="o">.</span><span class="n">circuit</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">q0: ──X──────────●──────────X───────────────────────────────X──────────●──────────X───────</span>
<span class="go">      │          │          │                               │          │          │</span>
<span class="go">q1: ──┼──────────┼──────────┼────X──────────●──────────X────┼──────────┼──────────┼────X──</span>
<span class="go">      │          │          │    │          │          │    │          │          │    │</span>
<span class="go">q2: ──●────RY(t_0_q_s_0)────●────●────RY(t_0_q_s_1)────●────┼──────────┼──────────┼────┼──</span>
<span class="go">                                                            │          │          │    │</span>
<span class="go">q3: ────────────────────────────────────────────────────────●────RY(t_0_q_s_2)────●────●──</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc</span><span class="o">.</span><span class="n">n_qubits</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc_2</span> <span class="o">=</span> <span class="n">QubitUCCAnsatz</span><span class="p">(</span><span class="n">occ_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vir_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc_2</span><span class="o">.</span><span class="n">operator_pool</span>
<span class="go">[-1.0*t_0_q_s_0 [Q0^ Q4] +</span>
<span class="go">1.0*t_0_q_s_0 [Q4^ Q0] , -1.0*t_0_q_s_1 [Q1^ Q4] +</span>
<span class="go">1.0*t_0_q_s_1 [Q4^ Q1] , -1.0*t_0_q_s_2 [Q2^ Q4] +</span>
<span class="go">1.0*t_0_q_s_2 [Q4^ Q2] , -1.0*t_0_q_s_3 [Q3^ Q4] +</span>
<span class="go">1.0*t_0_q_s_3 [Q4^ Q3] , -1.0*t_0_q_s_4 [Q0^ Q5] +</span>
<span class="go">1.0*t_0_q_s_4 [Q5^ Q0] , -1.0*t_0_q_s_5 [Q1^ Q5] +</span>
<span class="go">1.0*t_0_q_s_5 [Q5^ Q1] , -1.0*t_0_q_s_6 [Q2^ Q5] +</span>
<span class="go">1.0*t_0_q_s_6 [Q5^ Q2] , -1.0*t_0_q_s_7 [Q3^ Q5] +</span>
<span class="go">1.0*t_0_q_s_7 [Q5^ Q3] , -1.0*t_0_q_d_0 [Q1^ Q0^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_0 [Q5^ Q4^ Q1 Q0] , -1.0*t_0_q_d_1 [Q2^ Q0^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_1 [Q5^ Q4^ Q2 Q0] , -1.0*t_0_q_d_2 [Q2^ Q1^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_2 [Q5^ Q4^ Q2 Q1] , -1.0*t_0_q_d_3 [Q3^ Q0^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_3 [Q5^ Q4^ Q3 Q0] , -1.0*t_0_q_d_4 [Q3^ Q1^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_4 [Q5^ Q4^ Q3 Q1] , -1.0*t_0_q_d_5 [Q3^ Q2^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_5 [Q5^ Q4^ Q3 Q2] ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Transform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">Transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform" title="Permalink to this definition"></a></dt>
<dd><p>Class for transforms of fermionic and qubit operators.</p>
<p><cite>jordan_wigner</cite>, <cite>parity</cite>, <cite>bravyi_kitaev</cite>, <cite>bravyi_kitaev_tree</cite>,
<cite>bravyi_kitaev_superfast</cite> will transform <cite>FermionOperator</cite> to
<cite>QubitOperator</cite>. <cite>reversed_jordan_wigner</cite> will transform <cite>QubitOperator</cite>
to <cite>FermionOperator</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<em>Union</em><em>[</em><a class="reference internal" href="mindquantum.core.operators.html#mindquantum.core.operators.FermionOperator" title="mindquantum.core.operators.FermionOperator"><em>FermionOperator</em></a><em>, </em><a class="reference internal" href="mindquantum.core.operators.html#mindquantum.core.operators.QubitOperator" title="mindquantum.core.operators.QubitOperator"><em>QubitOperator</em></a><em>]</em>) – The input
FermionOperator or QubitOperator that need to do transform.</p></li>
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The total qubits of given operator. If None, then we will count it automatically.
Default: None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">FermionOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op1</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">(</span><span class="s1">&#39;1^&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op1</span>
<span class="go">1.0 [1^]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span><span class="o">.</span><span class="n">jordan_wigner</span><span class="p">()</span>
<span class="go">0.5 [Z0 X1] +</span>
<span class="go">-0.5j [Z0 Y1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span><span class="o">.</span><span class="n">parity</span><span class="p">()</span>
<span class="go">0.5 [Z0 X1] +</span>
<span class="go">-0.5j [Y1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span><span class="o">.</span><span class="n">bravyi_kitaev</span><span class="p">()</span>
<span class="go">0.5 [Z0 X1] +</span>
<span class="go">-0.5j [Y1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span><span class="o">.</span><span class="n">ternary_tree</span><span class="p">()</span>
<span class="go">0.5 [X0 Z1] +</span>
<span class="go">-0.5j [Y0 X2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op2</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">(</span><span class="s1">&#39;1^&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Transform</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span><span class="o">.</span><span class="n">jordan_wigner</span><span class="p">()</span>
<span class="go">0.5*a [Z0 X1] +</span>
<span class="go">-0.5*I*a [Z0 Y1]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Transform.bravyi_kitaev">
<span class="sig-name descname"><span class="pre">bravyi_kitaev</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.bravyi_kitaev"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.bravyi_kitaev" title="Permalink to this definition"></a></dt>
<dd><p>Apply Bravyi-Kitaev transform.</p>
<p>The Bravyi-Kitaev basis is a middle between Jordan-Wigner
and parity transform. That is, it balances the locality of occupation and parity information
for improved simulation efficiency. In this scheme, qubits store the parity
of a set of <span class="math notranslate nohighlight">\(2^x\)</span> orbitals, where <span class="math notranslate nohighlight">\(x \ge 0\)</span>. A qubit of index j always
stores orbital <span class="math notranslate nohighlight">\(j\)</span>.
For even values of <span class="math notranslate nohighlight">\(j\)</span>, this is the only orbital
that it stores, but for odd values of <span class="math notranslate nohighlight">\(j\)</span>, it also stores a certain
set of adjacent orbitals with index less than <span class="math notranslate nohighlight">\(j\)</span>.
For the occupation transformation, we follow the
formular:</p>
<div class="math notranslate nohighlight">
\[b_{i} = \sum{[\beta_{n}]_{i,j}} f_{j},\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta_{n}\)</span> is the <span class="math notranslate nohighlight">\(N\times N\)</span> square matrix,
<span class="math notranslate nohighlight">\(N\)</span> is the total qubit number.
The qubits index are divide into three sets,
the parity set, the update set and flip set.
The parity of this set of qubits has
the same parity as the set of orbitals with index less than <span class="math notranslate nohighlight">\(j\)</span>,
and so we will call this set of qubit indices the “parity set” of
index <span class="math notranslate nohighlight">\(j\)</span>, or <span class="math notranslate nohighlight">\(P(j)\)</span>.</p>
<p>The update set of index <span class="math notranslate nohighlight">\(j\)</span>, or <span class="math notranslate nohighlight">\(U(j)\)</span> contains the set of qubits (other than
qubit <span class="math notranslate nohighlight">\(j\)</span>) that must be updated when the occupation of orbital <span class="math notranslate nohighlight">\(j\)</span></p>
<p>The flip set of index <span class="math notranslate nohighlight">\(j\)</span>, or <span class="math notranslate nohighlight">\(F(j)\)</span> contains the set of BravyiKitaev qubits determines
whether qubit <span class="math notranslate nohighlight">\(j\)</span> has the same parity or inverted parity with
respect to orbital <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>Please see some detail explanation in the paper <a class="reference external" href="https://doi.org/10.1063/1.4768229">The Bravyi-Kitaev transformation for
quantum computation of electronic structure</a>.</p>
<p>Implementation from <a class="reference external" href="https://arxiv.org/abs/quant-ph/0003137">Fermionic quantum computation</a> and
<a class="reference external" href="https://doi.org/10.1002/spe.4380240306">A New Data Structure for Cumulative Frequency Tables</a>
by Peter M. Fenwick.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubit operator after bravyi_kitaev transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Transform.bravyi_kitaev_superfast">
<span class="sig-name descname"><span class="pre">bravyi_kitaev_superfast</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.bravyi_kitaev_superfast"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.bravyi_kitaev_superfast" title="Permalink to this definition"></a></dt>
<dd><p>Apply Bravyi-Kitaev Superfast transform.</p>
<p>Implementation from <a class="reference external" href="https://arxiv.org/abs/1712.00446">Bravyi-Kitaev Superfast simulation of fermions on a
quantum computer</a>.</p>
<p>Note that only hermitian operators of form will be transformed.</p>
<div class="math notranslate nohighlight">
\[C + \sum_{p, q} h_{p, q} a^\dagger_p a_q +
    \sum_{p, q, r, s} h_{p, q, r, s} a^\dagger_p a^\dagger_q a_r a_s\]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is a constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubit operator after bravyi_kitaev_superfast.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Transform.jordan_wigner">
<span class="sig-name descname"><span class="pre">jordan_wigner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.jordan_wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.jordan_wigner" title="Permalink to this definition"></a></dt>
<dd><p>Apply Jordan-Wigner transform.</p>
<p>The Jordan-Wigner transform holds the initial occupation number locally, which change the formular of
fermion operator into qubit operator following the equation.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}a^\dagger_{j}\rightarrow \sigma^{-}_{j} X \prod_{i=0}^{j-1}\sigma^{Z}_{i}\\a_{j}\rightarrow \sigma^{+}_{j} X \prod_{i=0}^{j-1}\sigma^{Z}_{i},\end{aligned}\end{align} \]</div>
<p>where the <span class="math notranslate nohighlight">\(\sigma_{+}= \sigma^{X} + i \sigma^{Y}\)</span> and <span class="math notranslate nohighlight">\(\sigma_{-} = \sigma^{X} - i\sigma^{Y}\)</span> is the
Pauli spin raising and lowring operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubit operator after jordan_wigner transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Transform.parity">
<span class="sig-name descname"><span class="pre">parity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.parity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.parity" title="Permalink to this definition"></a></dt>
<dd><p>Apply parity transform.</p>
<p>The parity transform stores the initial occupation number nonlocally,
with the formular:</p>
<div class="math notranslate nohighlight">
\[\left|f_{M-1}, f_{M-2},\cdots, f_0\right&gt; \rightarrow \left|q_{M−1}, q_{M−2},\cdots, q_0\right&gt;,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[q_{m} = \left|\left(\sum_{i=0}^{m-1}f_{i}\right) mod\ 2 \right&gt;\]</div>
<p>Basically, this formular could be written as this,</p>
<div class="math notranslate nohighlight">
\[p_{i} = \sum{[\pi_{n}]_{i,j}} f_{j},\]</div>
<p>where <span class="math notranslate nohighlight">\(\pi_{n}\)</span> is the <span class="math notranslate nohighlight">\(N\times N\)</span> square matrix,
<span class="math notranslate nohighlight">\(N\)</span> is the total qubit number. The operator changes follows the following equation as:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}a^\dagger_{j}\rightarrow\frac{1}{2}\left(\prod_{i=j+1}^N
\left(\sigma_i^X X\right)\right)\left( \sigma^{X}_{j}-i\sigma_j^Y\right) X \sigma^{Z}_{j-1}\\a_{j}\rightarrow\frac{1}{2}\left(\prod_{i=j+1}^N
\left(\sigma_i^X X\right)\right)\left( \sigma^{X}_{j}+i\sigma_j^Y\right) X \sigma^{Z}_{j-1}\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubits operator after parity transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Transform.reversed_jordan_wigner">
<span class="sig-name descname"><span class="pre">reversed_jordan_wigner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.reversed_jordan_wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.reversed_jordan_wigner" title="Permalink to this definition"></a></dt>
<dd><p>Apply reversed Jordan-Wigner transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>FermionOperator, fermion operator after reversed_jordan_wigner transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.Transform.ternary_tree">
<span class="sig-name descname"><span class="pre">ternary_tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.ternary_tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.ternary_tree" title="Permalink to this definition"></a></dt>
<dd><p>Apply Ternary tree transform.</p>
<p>Implementation from <a class="reference external" href="https://arxiv.org/abs/1910.10746">Optimal fermion-to-qubit mapping via ternary trees with
applications to reduced quantum states learning</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubit operator after ternary_tree transformation.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.UCCAnsatz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">UCCAnsatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vir_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trotter_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/unitary_cc.html#UCCAnsatz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.UCCAnsatz" title="Permalink to this definition"></a></dt>
<dd><p>The unitary coupled-cluster ansatz for molecular simulations.</p>
<div class="math notranslate nohighlight">
\[U(\vec{\theta}) = \prod_{j=1}^{N(N\ge1)}{\prod_{i=0}^{N_{j}}{\exp{(\theta_{i}\hat{\tau}_{i})}}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\tau}\)</span> are anti-Hermitian operators.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the circuit is construncted using JW transformation.
In addition, the reference state wave function (Hartree-Fock) will NOT be
included.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of qubits (spin-orbitals). Default: None.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons (occupied spin-orbitals). Default: None.</p></li>
<li><p><strong>occ_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned occupied spatial
orbitals, for ansatz construction only. Default: None.</p></li>
<li><p><strong>vir_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned virtual spatial
orbitals, for ansatz construction only. Default: None.</p></li>
<li><p><strong>generalized</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to use generalized excitations which
do not distinguish occupied or virtual orbitals (UCCGSD). Default: False.</p></li>
<li><p><strong>trotter_step</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The order of Trotterization step. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">UCCAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ucc</span> <span class="o">=</span> <span class="n">UCCAnsatz</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">occ_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                <span class="n">vir_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                <span class="n">generalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">trotter_step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span> <span class="o">=</span> <span class="n">ucc</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">remove_barrier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
<span class="go">3624</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params_list</span> <span class="o">=</span> <span class="n">ucc</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">params_name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">params_list</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]</span>
<span class="go">q5: ──●────RX(7π/2)───────H───────●────────────────────────────●───────H──────</span>
<span class="go">      │                           │                            │</span>
<span class="go">q7: ──X───────H────────RX(π/2)────X────RZ(-0.5*t_1_d0_d_17)────X────RX(7π/2)──</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.generate_uccsd">
<span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">generate_uccsd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/uccsd.html#generate_uccsd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.generate_uccsd" title="Permalink to this definition"></a></dt>
<dd><p>Generate a uccsd quantum circuit based on a molecular data generated by Openfermion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecular</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>MolecularData</em><em>]</em>) – the name of the molecular data file,
or openfermion MolecularData.</p></li>
<li><p><strong>threshold</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – the threshold to filt the uccsd amplitude. We only keep the
excitation operator with absolute value of amplitude greater than <cite>threshold</cite>, so
that if <cite>threshold=0</cite>, we only keep excitation operator with non zero amplitude. Default: 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>uccsd_circuit</strong> (Circuit), the ansatz circuit generated by uccsd method.</p></li>
<li><p><strong>initial_amplitudes</strong> (numpy.ndarray), the initial parameter values of uccsd circuit.</p></li>
<li><p><strong>parameters_name</strong> (list[str]), the name of initial parameters.</p></li>
<li><p><strong>qubit_hamiltonian</strong> (QubitOperator), the hamiltonian of the molecule.</p></li>
<li><p><strong>n_qubits</strong> (int), the number of qubits in simulation.</p></li>
<li><p><strong>n_electrons</strong> (int), the number of electrons of the molecule.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.get_qubit_hamiltonian">
<span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">get_qubit_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/qubit_hamiltonian.html#get_qubit_hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.get_qubit_hamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>Get the qubit hamiltonian of a molecular data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mol</strong> (<em>MolecularData</em>) – molecular data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>QubitOperator, qubit operator of this molecular.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.quccsd_generator">
<span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">quccsd_generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_hermitian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vir_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/quccsd.html#quccsd_generator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.quccsd_generator" title="Permalink to this definition"></a></dt>
<dd><p>Generate qubit-UCCSD (qUCCSD) ansatz using qubit-excitation operators.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, unrestricted version is implemented, i.e., excitations from the
same spatial-orbital but with different spins will use distinct variational
parameters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of qubits (spin-orbitals). Default: None.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons (occupied spin-orbitals). Default: None.</p></li>
<li><p><strong>anti_hermitian</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to subtract the hermitian conjugate
to form anti-Hermitian operators. Default: True.</p></li>
<li><p><strong>occ_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned occupied spatial
orbitals. Default: None.</p></li>
<li><p><strong>vir_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned virtual spatial
orbitals. Default: None.</p></li>
<li><p><strong>generalized</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to use generalized excitations which
do not distinguish occupied or virtual orbitals (qUCCGSD). Default: False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>QubitExcitationOperator, Generator of the qUCCSD operators.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">quccsd_generator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quccsd_generator</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quccsd_generator</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-1.0*q_s_0 [Q0^ Q2] +</span>
<span class="go">-1.0*q_s_2 [Q0^ Q3] +</span>
<span class="go">-1.0*q_d_0 [Q1^ Q0^ Q3 Q2] +</span>
<span class="go">-1.0*q_s_1 [Q1^ Q2] +</span>
<span class="go">-1.0*q_s_3 [Q1^ Q3] +</span>
<span class="go">1.0*q_s_0 [Q2^ Q0] +</span>
<span class="go">1.0*q_s_1 [Q2^ Q1] +</span>
<span class="go">1.0*q_s_2 [Q3^ Q0] +</span>
<span class="go">1.0*q_s_3 [Q3^ Q1] +</span>
<span class="go">1.0*q_d_0 [Q3^ Q2^ Q1 Q0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q_op</span> <span class="o">=</span> <span class="n">quccsd_generator</span><span class="p">(</span><span class="n">occ_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vir_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">generalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q_qubit_op</span> <span class="o">=</span> <span class="n">q_op</span><span class="o">.</span><span class="n">to_qubit_operator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q_qubit_op</span><span class="p">)[:</span><span class="mi">315</span><span class="p">])</span>
<span class="go">0.125*I*q_d_4 + 0.125*I*q_d_7 + 0.125*I*q_d_9 [X0 X1 X2 Y3] +</span>
<span class="go">0.125*I*q_d_4 - 0.125*I*q_d_7 - 0.125*I*q_d_9 [X0 X1 Y2 X3] +</span>
<span class="go">0.25*I*q_d_12 + 0.25*I*q_d_5 + 0.5*I*q_s_0 - 0.5*I*q_s_3 [X0 Y1] +</span>
<span class="go">-0.125*I*q_d_4 + 0.125*I*q_d_7 - 0.125*I*q_d_9 [X0 Y1 X2 X3] +</span>
<span class="go">0.125*I*q_d_4 + 0.125*I*q_d_7 - 0.125*I*q_d_9 [X0 Y1 Y2 Y3] +</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.uccsd0_singlet_generator">
<span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">uccsd0_singlet_generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_hermitian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vir_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/uccsd0.html#uccsd0_singlet_generator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.uccsd0_singlet_generator" title="Permalink to this definition"></a></dt>
<dd><p>Generate UCCSD operators using CCD0 ansatz for molecular systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Manually assigned occ_orb or vir_orb are indices of spatial orbitals
instead of spin-orbitals. They will override n_electrons and
n_qubits. This is to some degree similar to the active space,
therefore can reduce the number of variational parameters. However, it
may not reduce the number of required qubits, since Fermion
excitation operators are non-local, i.e.,
<span class="math notranslate nohighlight">\(a_{7}^{\dagger} a_{0}\)</span> involves not only the 0th and 7th
qubit, but also the 1st, 2nd, … 6th qubit.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of qubits (spin-orbitals). Default: None.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons (occupied spin-orbitals). Default: None.</p></li>
<li><p><strong>anti_hermitian</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to subtract the hermitian conjugate
to form anti-Hermitian operators. Default: True.</p></li>
<li><p><strong>occ_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned occupied spatial
orbitals. Default: None.</p></li>
<li><p><strong>vir_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned virtual spatial
orbitals. Default: None.</p></li>
<li><p><strong>generalized</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to use generalized excitations which
do not distinguish occupied or virtual orbitals (UCCGSD). Default: False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>FermionOperator, Generator of the UCCSD operators that uses CCD0 ansatz.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">uccsd0_singlet_generator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd0_singlet_generator</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-1.0*d0_s_0 [0^ 2] +</span>
<span class="go">2.0*d0_d_0 [1^ 0^ 3 2] +</span>
<span class="go">-1.0*d0_s_0 [1^ 3] +</span>
<span class="go">1.0*d0_s_0 [2^ 0] +</span>
<span class="go">1.0*d0_s_0 [3^ 1] +</span>
<span class="go">-2.0*d0_d_0 [3^ 2^ 1 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd0_singlet_generator</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">generalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">1.0*d0_s_0 - 1.0*d0_s_1 [0^ 2] +</span>
<span class="go">1.0*d0_d_0 [1^ 0^ 2 1] +</span>
<span class="go">-1.0*d0_d_0 [1^ 0^ 3 0] +</span>
<span class="go">-2.0*d0_d_1 [1^ 0^ 3 2] +</span>
<span class="go">1.0*d0_s_0 - 1.0*d0_s_1 [1^ 3] +</span>
<span class="go">-1.0*d0_s_0 + 1.0*d0_s_1 [2^ 0] +</span>
<span class="go">-1.0*d0_d_0 [2^ 1^ 1 0] +</span>
<span class="go">1.0*d0_d_2 [2^ 1^ 3 2] +</span>
<span class="go">1.0*d0_d_0 [3^ 0^ 1 0] +</span>
<span class="go">-1.0*d0_d_2 [3^ 0^ 3 2] +</span>
<span class="go">-1.0*d0_s_0 + 1.0*d0_s_1 [3^ 1] +</span>
<span class="go">2.0*d0_d_1 [3^ 2^ 1 0] +</span>
<span class="go">-1.0*d0_d_2 [3^ 2^ 2 1] +</span>
<span class="go">1.0*d0_d_2 [3^ 2^ 3 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd0_singlet_generator</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">occ_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vir_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">-1.0*d0_s_0 [0^ 2] +</span>
<span class="go">2.0*d0_d_0 [1^ 0^ 3 2] +</span>
<span class="go">-1.0*d0_s_0 [1^ 3] +</span>
<span class="go">1.0*d0_s_0 [2^ 0] +</span>
<span class="go">1.0*d0_s_0 [3^ 1] +</span>
<span class="go">-2.0*d0_d_0 [3^ 2^ 1 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.uccsd_singlet_generator">
<span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">uccsd_singlet_generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_hermitian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/third_party/unitary_cc.html#uccsd_singlet_generator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.uccsd_singlet_generator" title="Permalink to this definition"></a></dt>
<dd><p>Create a singlet UCCSD generator for a system with n_electrons.</p>
<p>This function generates a FermionOperator for a UCCSD generator designed
to act on a single reference state consisting of n_qubits spin orbitals
and n_electrons electrons, that is a spin singlet operator, meaning it
conserves spin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of spin-orbitals used to represent the system,
which also corresponds to number of qubits in a non-compact map.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons in the physical system.</p></li>
<li><p><strong>anti_hermitian</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Flag to generate only normal CCSD operator
rather than unitary variant, primarily for testing</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>FermionOperator, Generator of the UCCSD operator that
builds the UCCSD wavefunction.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">uccsd_singlet_generator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd_singlet_generator</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-s_0 [0^ 2] +</span>
<span class="go">-d1_0 [0^ 2 1^ 3] +</span>
<span class="go">-s_0 [1^ 3] +</span>
<span class="go">-d1_0 [1^ 3 0^ 2] +</span>
<span class="go">s_0 [2^ 0] +</span>
<span class="go">d1_0 [2^ 0 3^ 1] +</span>
<span class="go">s_0 [3^ 1] +</span>
<span class="go">d1_0 [3^ 1 2^ 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mindquantum.algorithm.nisq.uccsd_singlet_get_packed_amplitudes">
<span class="sig-prename descclassname"><span class="pre">mindquantum.algorithm.nisq.</span></span><span class="sig-name descname"><span class="pre">uccsd_singlet_get_packed_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">single_amplitudes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double_amplitudes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/third_party/unitary_cc.html#uccsd_singlet_get_packed_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.uccsd_singlet_get_packed_amplitudes" title="Permalink to this definition"></a></dt>
<dd><p>Convert amplitudes for use with singlet UCCSD.</p>
<p>The output list contains only those amplitudes that are relevant to
singlet UCCSD, in an order suitable for use with the function
<cite>uccsd_singlet_generator</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_amplitudes</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – <span class="math notranslate nohighlight">\(N\times N\)</span> array storing single excitation
amplitudes corresponding to <span class="math notranslate nohighlight">\(t_{i,j} * (a_i^\dagger a_j - \text{H.C.})\)</span>.</p></li>
<li><p><strong>double_amplitudes</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – <span class="math notranslate nohighlight">\(N\times N\times N\times N\)</span> array storing double
excitation amplitudes corresponding to
<span class="math notranslate nohighlight">\(t_{i,j,k,l} * (a_i^\dagger a_j a_k^\dagger a_l - \text{H.C.})\)</span>.</p></li>
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of spin-orbitals used to represent the system,
which also corresponds to number of qubits in a non-compact map.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons in the physical system.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ParameterResolver, List storing the unique single
and double excitation amplitudes for a singlet UCCSD operator.
The ordering lists unique single excitations before double
excitations.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_electrons</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ccsd_single_amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ccsd_double_amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd_singlet_get_packed_amplitudes</span><span class="p">(</span><span class="n">ccsd_single_amps</span><span class="p">,</span> <span class="n">ccsd_double_amps</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_electrons</span><span class="p">)</span>
<span class="go">{&#39;d1_0&#39;: 0.76162, &#39;s_0&#39;: 0.601115}, const: 0</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mindquantum.algorithm.library.html" class="btn btn-neutral float-left" title="mindquantum.algorithm.library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mindquantum.io.html" class="btn btn-neutral float-right" title="mindquantum.io" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
        <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>