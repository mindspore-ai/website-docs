

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Application of Quantum Neural Network in NLP &mdash; MindSpore master documentation</title>
  

  
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
   
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="VQE Application in Quantum Chemistry Computing" href="vqe_for_quantum_chemistry.html" />
    <link rel="prev" title="Quantum Approximate Optimization Algorithm" href="quantum_approximate_optimization_algorithm.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">MindQuantum Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">Initial experience of quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">Advanced gradient calculation of variational quantum circuits</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variational Quantum Algorithm</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">Classification of iris by quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Application of Quantum Neural Network in NLP</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#environment-preparation">Environment Preparation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-pre-processing">Data Pre-processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#encoding-ccircuitircuit">Encoding Ccircuitircuit</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ansatz-circuicircuitt">Ansatz Circuicircuitt</a></li>
<li class="toctree-l2"><a class="reference internal" href="#measurement">Measurement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-word-embedding-layer">Quantum Word Embedding Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classical-word-embedding-layer">Classical Word Embedding Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">VQE Application in Quantum Chemistry Computing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">Grover search algorithm based on MindQuantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">Shor’s algorithm based on MindQuantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>The Application of Quantum Neural Network in NLP</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/qnn_for_nlp.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="the-application-of-quantum-neural-network-in-nlp">
<h1>The Application of Quantum Neural Network in NLP<a class="headerlink" href="#the-application-of-quantum-neural-network-in-nlp" title="Permalink to this headline"></a></h1>
<p><a href="https://gitee.com/mindspore/docs/blob/r1.8/docs/mindquantum/docs/source_en/qnn_for_nlp.md" target="_blank"><img src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.8/resource/_static/logo_source_en.png"></a></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline"></a></h2>
<p>Word embedding plays a key role in natural language processing. It embeds a high-dimension word vector to lower dimension space. When more information is added to the neural network, the training task will become more difficult. By taking advantage of the characteristics of quantum mechanics (e.g., state superposition and entanglement), a quantum neural network can process such classical information during training, thereby improving the accuracy of convergence. In the following, we will build a simple mixed quantum neural network for completing word embedding task.</p>
</section>
<section id="environment-preparation">
<h2>Environment Preparation<a class="headerlink" href="#environment-preparation" title="Permalink to this headline"></a></h2>
<p>Set the thread number of cpu in use.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;OMP_NUM_THREADS&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
</pre></div>
</div>
<p>Import relevant dependencies of the tutorial.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">import</span> <span class="nn">mindspore.ops</span> <span class="k">as</span> <span class="nn">ops</span>
<span class="kn">import</span> <span class="nn">mindspore.dataset</span> <span class="k">as</span> <span class="nn">ds</span>
<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">mindquantum.framework</span> <span class="kn">import</span> <span class="n">MQLayer</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">RX</span><span class="p">,</span> <span class="n">RY</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">H</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">UN</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">Hamiltonian</span><span class="p">,</span> <span class="n">QubitOperator</span>
</pre></div>
</div>
<p>This tutorial implements a <a class="reference external" href="https://blog.csdn.net/u010665216/article/details/78724856">CBOW model</a>, which predicts a word based on its position. For example, “I love natural language processing”, this sentence can be divided by five words, which are [“I”, “love”, “natural”, “language”, “processing”]. When the selected window is 2, the task to be completed would be to predict the word “natural” given [“I”, “love”, “language”, “processing”]. In the following, we will build a quantum neural network for word embedding to deal with the this task.</p>
<p><img alt="quantum word embedding" src="_images/qcbow.png" /></p>
<p>Here, the encoding information of “I”, “love”, “language”, and “processing” will be encoded to the quantum circuit. This quantum circuit to be trained consists of four Ansatz circuits. At last, we measure the qubit in the <span class="math notranslate nohighlight">\(\text{Z}\)</span> base vector for the quantum circuit end. The number of measured qubits is determined by the embedded dimenson.</p>
</section>
<section id="data-pre-processing">
<h2>Data Pre-processing<a class="headerlink" href="#data-pre-processing" title="Permalink to this headline"></a></h2>
<p>It is necessary to form a dictionary for the setence to be processed and determine the samples according to the size of the window.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GenerateWordDictAndSample</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">all_words</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">word_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_words</span><span class="p">))</span>
    <span class="n">word_set</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">word_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">word_set</span><span class="p">)}</span>
    <span class="n">sampling</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_words</span><span class="p">[</span><span class="n">window</span><span class="p">:</span><span class="o">-</span><span class="n">window</span><span class="p">]):</span>
        <span class="n">around</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">window</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">index</span> <span class="o">+</span> <span class="n">window</span><span class="p">:</span>
                <span class="n">around</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_words</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">sampling</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">around</span><span class="p">,</span><span class="n">all_words</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">window</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">word_dict</span><span class="p">,</span> <span class="n">sampling</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">word_dict</span><span class="p">,</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">GenerateWordDictAndSample</span><span class="p">(</span><span class="s2">&quot;I love natural language processing&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">word_dict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;word dict size: &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_dict</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;samples: &#39;</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of samples: &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{&#39;I&#39;: 0, &#39;language&#39;: 1, &#39;love&#39;: 2, &#39;natural&#39;: 3, &#39;processing&#39;: 4}
    word dict size:  5
    samples:  [[[&#39;I&#39;, &#39;love&#39;, &#39;language&#39;, &#39;processing&#39;], &#39;natural&#39;]]
    number of samples:  1
</pre></div>
</div>
<p>According to the above information, the size of the dictionary is 5 and it is enough to select a sample.</p>
</section>
<section id="encoding-ccircuitircuit">
<h2>Encoding Ccircuitircuit<a class="headerlink" href="#encoding-ccircuitircuit" title="Permalink to this headline"></a></h2>
<p>For simplification, we use the RX revolving door to construct the encoding circuit. The structure is as follows.</p>
<p><img alt="encoder circuit" src="_images/encoder.png" /></p>
<p>We apply a <span class="math notranslate nohighlight">\(\text{RX}\)</span> revolving door to each quantum.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GenerateEncoderCircuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">prefix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">RX</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">GenerateEncoderCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>    q0: ──RX(e_0)──

    q1: ──RX(e_1)──

    q2: ──RX(e_2)──
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(\left|0\right&gt;\)</span> and <span class="math notranslate nohighlight">\(\left|1\right&gt;\)</span> are used to mark the two states of a two-level qubit. According to the state superposition theory, qubit can also be in the superposition of these two states:</p>
<div class="math notranslate nohighlight">
\[\left|\psi\right&gt;=\alpha\left|0\right&gt;+\beta\left|1\right&gt;\]</div>
<p>For the quantum state of a <span class="math notranslate nohighlight">\(n\)</span> bits, it can be in a <span class="math notranslate nohighlight">\(2^n\)</span> Hilbert space. For the dictionary composed by the above 5 words, we only need <span class="math notranslate nohighlight">\(\lceil \log_2 5 \rceil=3\)</span> qubits to complete the encoding task, which demonstrates the superiority of quantum computing.</p>
<p>For example. given the word “love” in the above dictionary, its corresponding label is 2, represented by <code class="docutils literal notranslate"><span class="pre">010</span></code> in the binary format. We only need to set <code class="docutils literal notranslate"><span class="pre">e_0</span></code>, <code class="docutils literal notranslate"><span class="pre">e_1</span></code>, and <code class="docutils literal notranslate"><span class="pre">e_2</span></code> to <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(\pi\)</span>, and <span class="math notranslate nohighlight">\(0\)</span> respectively. In the following, we use the <code class="docutils literal notranslate"><span class="pre">Evolution</span></code> operator for verification.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>

<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># number of qubits of this quantum circuit</span>
<span class="n">label</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># label need to encode</span>
<span class="n">label_bin</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">label</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="c1"># binary form of label</span>
<span class="n">label_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">label_bin</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># parameter value of encoder</span>
<span class="n">encoder</span> <span class="o">=</span> <span class="n">GenerateEncoderCircuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span> <span class="c1"># encoder circuit</span>
<span class="n">encoder_params_name</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">params_name</span> <span class="c1"># parameter names of encoder</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Label is: &quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Binary label is: &quot;</span><span class="p">,</span> <span class="n">label_bin</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parameters of encoder is: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">label_array</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Encoder circuit is: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">encoder</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Encoder parameter names are: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">encoder_params_name</span><span class="p">)</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>

<span class="n">state</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="n">label_array</span><span class="p">)</span>
<span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Amplitude of quantum state is: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">amp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Label in quantum state is: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">amp</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>    Label is:  2
    Binary label is:  010
    Parameters of encoder is:
     [0.      3.14159 0.     ]
    Encoder circuit is:
     RX(e_0|0)
    RX(e_1|1)
    RX(e_2|2)
    Encoder parameter names are:
     [&#39;e_0&#39;, &#39;e_1&#39;, &#39;e_2&#39;]
    Amplitude of quantum state is:
     [0. 0. 1. 0. 0. 0. 0. 0.]
    Label in quantum state is:  2
</pre></div>
</div>
<p>Through the above verification, for the data with label 2, the position where the largest amplitude of the quantum state is finally obtained is also 2. Therefore, the obtained quantum state is exactly the encoding information of input label. We summarize the process of generating parameter values through data encoding information into the following function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GenerateTrainData</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">word_dict</span><span class="p">):</span>
    <span class="n">n_qubits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">word_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
    <span class="n">data_x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data_y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">around</span><span class="p">,</span> <span class="n">center</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">:</span>
        <span class="n">data_x</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">around</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">word_dict</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
            <span class="n">label_bin</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">label</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
            <span class="n">label_array</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">label_bin</span><span class="p">]</span>
            <span class="n">data_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">label_array</span><span class="p">)</span>
        <span class="n">data_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word_dict</span><span class="p">[</span><span class="n">center</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">GenerateTrainData</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">word_dict</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>    (array([[0.       , 0.       , 0.       , 0.       , 3.1415927, 0.       ,
             3.1415927, 0.       , 0.       , 0.       , 0.       , 3.1415927]],
           dtype=float32),
     array([3], dtype=int32))
</pre></div>
</div>
<p>According to the above result, we merge the encoding information of these 4 input words into a longer vector for further usage of the neural network.</p>
</section>
<section id="ansatz-circuicircuitt">
<h2>Ansatz Circuicircuitt<a class="headerlink" href="#ansatz-circuicircuitt" title="Permalink to this headline"></a></h2>
<p>There is a variety of selections for the Ansatz circuits. We select the below quantum circuit as the Ansatz circuit. A single unit of the Ansatz circuit consists of a <span class="math notranslate nohighlight">\(\text{RY}\)</span> door and a <span class="math notranslate nohighlight">\(\text{CNOT}\)</span> door. The full Ansatz circuit can be obtained by repeating <span class="math notranslate nohighlight">\(p\)</span> times over this single unit.</p>
<p><img alt="ansatz circuit" src="_images/ansatz.png" /></p>
<p>The following function is defined to construct the Ansatz circuit.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GenerateAnsatzCircuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">prefix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
            <span class="n">circ</span> <span class="o">+=</span> <span class="n">RY</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_qubits</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n_qubits</span><span class="p">:</span>
                <span class="n">circ</span> <span class="o">+=</span> <span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">GenerateAnsatzCircuit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>q0: ──RY(a_0_0)────────●────────RY(a_1_0)───────
                       │
q1: ──RY(a_0_1)────────X────────RY(a_1_1)────●──
                                             │
q2: ──RY(a_0_2)────────●────────RY(a_1_2)────X──
                       │
q3: ──RY(a_0_3)────────X────────RY(a_1_3)────●──
                                             │
q4: ──RY(a_0_4)────RY(a_1_4)─────────────────X──
</pre></div>
</div>
</section>
<section id="measurement">
<h2>Measurement<a class="headerlink" href="#measurement" title="Permalink to this headline"></a></h2>
<p>We treat the measurements of different qubits as the data after dimension reduction. This process is similar to qubit encoding. For example, when we want to reduce the dimension of the word vector to 5, we can process the data in the 3rd dimension as follows:</p>
<ul class="simple">
<li><p>3 in the binary format is 00011.</p></li>
<li><p>Measure the expectation value of the Z0Z1 hams at the quantum circuit end.</p></li>
</ul>
<p>The below function gives the hams to generate the data in all dimension, where n_qubits represents the number of qubits, dims represents the dimension of word embedding.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GenerateEmbeddingHamiltonian</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">):</span>
    <span class="n">hams</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;Z&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
        <span class="n">hams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="n">QubitOperator</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">hams</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">GenerateEmbeddingHamiltonian</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>    [1.0 Z0, 1.0 Z1, 1.0 Z0 Z1, 1.0 Z2, 1.0 Z0 Z2]
</pre></div>
</div>
</section>
<section id="quantum-word-embedding-layer">
<h2>Quantum Word Embedding Layer<a class="headerlink" href="#quantum-word-embedding-layer" title="Permalink to this headline"></a></h2>
<p>The quantum word embedding layer combines the above-mentioned encoding quantum circuit, the quantum circuit to be trained, and the measurement of hams. <code class="docutils literal notranslate"><span class="pre">num_embedding</span></code> words can be embedded into a word vector with <code class="docutils literal notranslate"><span class="pre">embedding_dim</span></code> dimension. Here, a Hadamard door is added at the beginning of the quantum circuit. The initialization state is set to average superposition state for improving the representation ability of the quantum neural network.</p>
<p>In the following, we define a quantum embedding layer and it returns a quantum circuit simulation operator.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">QEmbedding</span><span class="p">(</span><span class="n">num_embedding</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">n_threads</span><span class="p">):</span>
    <span class="n">n_qubits</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">num_embedding</span><span class="p">)))</span>
    <span class="n">hams</span> <span class="o">=</span> <span class="n">GenerateEmbeddingHamiltonian</span><span class="p">(</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
    <span class="n">encoder_params_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ansatz_params_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">window</span><span class="p">):</span>
        <span class="n">encoder</span> <span class="o">=</span> <span class="n">GenerateEncoderCircuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="s1">&#39;Encoder_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="n">ansatz</span> <span class="o">=</span> <span class="n">GenerateAnsatzCircuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="s1">&#39;Ansatz_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="n">encoder</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">encoder</span>
        <span class="n">circ</span> <span class="o">+=</span> <span class="n">ansatz</span>
        <span class="n">encoder_params_name</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">encoder</span><span class="o">.</span><span class="n">params_name</span><span class="p">)</span>
        <span class="n">ansatz_params_name</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">params_name</span><span class="p">)</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;projectq&#39;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>
    <span class="n">grad_ops</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">hams</span><span class="p">,</span>
                                             <span class="n">circ</span><span class="p">,</span>
                                             <span class="n">encoder_params_name</span><span class="o">=</span><span class="n">encoder_params_name</span><span class="p">,</span>
                                             <span class="n">ansatz_params_name</span><span class="o">=</span><span class="n">ansatz_params_name</span><span class="p">,</span>
                                             <span class="n">parallel_worker</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">MQLayer</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">net</span>
</pre></div>
</div>
<p>The training model is similar to a classical network, composed by an embedded layer and two fully-connected layers. However, the embedded layer here is constructed by a quantum neural network. The following defines the quantum neural network CBOW.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CBOW</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_embedding</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">n_threads</span><span class="p">,</span>
                 <span class="n">hidden_dim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CBOW</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">QEmbedding</span><span class="p">(</span><span class="n">num_embedding</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span>
                                    <span class="n">layers</span><span class="p">,</span> <span class="n">n_threads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">num_embedding</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">embed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense1</span><span class="p">(</span><span class="n">embed</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
<p>In the following, we use a longer sentence for training. Firstly, we define <code class="docutils literal notranslate"><span class="pre">LossMonitorWithCollection</span></code> to supervise the convergence process and record the loss.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LossMonitorWithCollection</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">LossMonitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">per_print_times</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LossMonitorWithCollection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">per_print_times</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_context</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">begin_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_context</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total time used: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin_time</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">epoch_begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_context</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch_begin_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">epoch_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_context</span><span class="p">):</span>
        <span class="n">cb_params</span> <span class="o">=</span> <span class="n">run_context</span><span class="o">.</span><span class="n">original_args</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch_end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per_print_times</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cb_params</span><span class="o">.</span><span class="n">cur_step_num</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per_print_times</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">step_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_context</span><span class="p">):</span>
        <span class="n">cb_params</span> <span class="o">=</span> <span class="n">run_context</span><span class="o">.</span><span class="n">original_args</span><span class="p">()</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">cb_params</span><span class="o">.</span><span class="n">net_outputs</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>

        <span class="n">cur_step_in_epoch</span> <span class="o">=</span> <span class="p">(</span><span class="n">cb_params</span><span class="o">.</span><span class="n">cur_step_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">cb_params</span><span class="o">.</span><span class="n">batch_num</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">loss</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;epoch: </span><span class="si">{}</span><span class="s2"> step: </span><span class="si">{}</span><span class="s2">. Invalid loss, terminating training.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">cb_params</span><span class="o">.</span><span class="n">cur_epoch_num</span><span class="p">,</span> <span class="n">cur_step_in_epoch</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per_print_times</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cb_params</span><span class="o">.</span><span class="n">cur_step_num</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per_print_times</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">epoch: </span><span class="si">%+3s</span><span class="s2"> step: </span><span class="si">%+3s</span><span class="s2"> time: </span><span class="si">%5.5s</span><span class="s2">, loss is </span><span class="si">%5.5s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cb_params</span><span class="o">.</span><span class="n">cur_epoch_num</span><span class="p">,</span> <span class="n">cur_step_in_epoch</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_begin_time</span><span class="p">,</span> <span class="n">loss</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

</pre></div>
</div>
<p>Next, embed a long setence by using the quantum <code class="docutils literal notranslate"><span class="pre">CBOW</span></code>. Please execute this command <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">OMP_NUM_THREADS=4</span></code> in the terminal in advance. This command sets the thread of the quantum simulators to 4. When the number of qubits to be simulated is large, more threads can be set to improve the simulation efficiency.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>
<span class="n">corpus</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;We are about to study the idea of a computational process.</span>
<span class="s2">Computational processes are abstract beings that inhabit computers.</span>
<span class="s2">As they evolve, processes manipulate other abstract things called data.</span>
<span class="s2">The evolution of a process is directed by a pattern of rules</span>
<span class="s2">called a program. People create programs to direct processes. In effect,</span>
<span class="s2">we conjure the spirits of the computer with our spells.&quot;&quot;&quot;</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">window_size</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">embedding_dim</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">hidden_dim</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">word_dict</span><span class="p">,</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">GenerateWordDictAndSample</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_size</span><span class="p">)</span>
<span class="n">train_x</span><span class="p">,</span><span class="n">train_y</span> <span class="o">=</span> <span class="n">GenerateTrainData</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">word_dict</span><span class="p">)</span>

<span class="n">train_loader</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">({</span>
    <span class="s2">&quot;around&quot;</span><span class="p">:</span> <span class="n">train_x</span><span class="p">,</span>
    <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">train_y</span>
<span class="p">},</span><span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">CBOW</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word_dict</span><span class="p">),</span> <span class="n">embedding_dim</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">)</span>
<span class="n">net_loss</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">SoftmaxCrossEntropyWithLogits</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="n">net_opt</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Momentum</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="n">loss_monitor</span> <span class="o">=</span> <span class="n">LossMonitorWithCollection</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">net_loss</span><span class="p">,</span> <span class="n">net_opt</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="mi">350</span><span class="p">,</span> <span class="n">train_loader</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">loss_monitor</span><span class="p">],</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>    epoch:  25 step:  20 time: 0.592, loss is 3.154
    epoch:  50 step:  20 time: 0.614, loss is 2.944
    epoch:  75 step:  20 time: 0.572, loss is 0.224
    epoch: 100 step:  20 time: 0.562, loss is 0.015
    epoch: 125 step:  20 time: 0.545, loss is 0.009
    epoch: 150 step:  20 time: 0.599, loss is 0.003
    epoch: 175 step:  20 time: 0.586, loss is 0.002
    epoch: 200 step:  20 time: 0.552, loss is 0.045
    epoch: 225 step:  20 time: 0.590, loss is 0.001
    epoch: 250 step:  20 time: 0.643, loss is 0.001
    epoch: 275 step:  20 time: 0.562, loss is 0.001
    epoch: 300 step:  20 time: 0.584, loss is 0.001
    epoch: 325 step:  20 time: 0.566, loss is 0.000
    epoch: 350 step:  20 time: 0.578, loss is 0.000
    Total time used: 206.29734826087952
</pre></div>
</div>
<p>Print the loss value during convergence:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loss_monitor</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Steps&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The convergence figure is as follows</p>
<p><img alt="nlp loss" src="_images/nlp_loss.png" /></p>
<p>The method of printing the parameters of the quantum embedded layer is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>    array([ 1.52044818e-01,  1.71521559e-01,  2.35021308e-01, -3.95286232e-01,
           -3.71680595e-03,  7.96886325e-01, -4.04954888e-02,  1.55393332e-01,
            4.11805660e-02,  7.79824018e-01,  2.96543002e-01, -2.21819162e-01,
           -4.67430688e-02,  4.66759771e-01,  2.75283188e-01,  1.35858059e-01,
           -3.23841363e-01, -2.31937021e-01, -4.68942285e-01, -1.96520030e-01,
            2.16065589e-02,  1.23866223e-01, -9.68078300e-02,  1.69127151e-01,
           -8.90062153e-01,  2.56734312e-01,  8.37369189e-02, -1.15734830e-01,
           -1.34410933e-01, -3.12207133e-01, -8.90189946e-01,  1.97006428e+00,
           -2.49193460e-02,  2.25960299e-01, -3.90179232e-02, -3.03875893e-01,
            2.02030335e-02, -7.07065910e-02, -4.81521547e-01,  5.04257262e-01,
           -1.32081115e+00,  2.83502758e-01,  2.80248702e-01,  1.63375765e-01,
           -6.91465080e-01,  6.82975233e-01, -2.67829001e-01,  2.29658693e-01,
            2.78859794e-01, -1.04206935e-01, -5.57148576e-01,  4.41706657e-01,
           -6.76973104e-01,  2.47751385e-01, -2.96468334e-03, -1.66827604e-01,
           -3.47717047e-01, -9.04396921e-03, -7.69433856e-01,  4.33617719e-02,
           -2.09145937e-02, -1.55236557e-01, -2.16777384e-01, -2.26556376e-01,
           -6.16374731e-01,  2.05871137e-03, -3.08128931e-02, -1.63372140e-02,
            1.46710426e-01,  2.31793106e-01,  4.16066934e-04, -9.28813033e-03],
          dtype=float32)
</pre></div>
</div>
</section>
<section id="classical-word-embedding-layer">
<h2>Classical Word Embedding Layer<a class="headerlink" href="#classical-word-embedding-layer" title="Permalink to this headline"></a></h2>
<p>Here, we construct a classical CBOW neural network with the classical word embedding layer. This classical CBOW is compared with the quantum one.</p>
<p>Firstly, we construct the classical CBOW neural network and the parameters are similar to the ones in the quantum CBOW.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CBOWClassical</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_embedding</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CBOWClassical</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">window</span> <span class="o">*</span> <span class="n">embedding_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">num_embedding</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dense2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">num_embedding</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">embed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">embed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">embed</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense1</span><span class="p">(</span><span class="n">embed</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
<p>Generate the dataset for the classical CBOW neural network.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">train_x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">train_y</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">:</span>
    <span class="n">around</span><span class="p">,</span> <span class="n">center</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">train_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word_dict</span><span class="p">[</span><span class="n">center</span><span class="p">])</span>
    <span class="n">train_x</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">around</span><span class="p">:</span>
        <span class="n">train_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word_dict</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
<span class="n">train_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">train_x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">train_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">train_y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train_x shape: &quot;</span><span class="p">,</span> <span class="n">train_x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;train_y shape: &quot;</span><span class="p">,</span> <span class="n">train_y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>    train_x shape:  (58, 4)
    train_y shape:  (58,)
</pre></div>
</div>
<p>Train the classical CBOW network.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">train_loader</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">NumpySlicesDataset</span><span class="p">({</span>
    <span class="s2">&quot;around&quot;</span><span class="p">:</span> <span class="n">train_x</span><span class="p">,</span>
    <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">train_y</span>
<span class="p">},</span><span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">CBOWClassical</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word_dict</span><span class="p">),</span> <span class="n">embedding_dim</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">)</span>
<span class="n">net_loss</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">SoftmaxCrossEntropyWithLogits</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="n">net_opt</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Momentum</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="n">loss_monitor</span> <span class="o">=</span> <span class="n">LossMonitorWithCollection</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">net_loss</span><span class="p">,</span> <span class="n">net_opt</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="mi">350</span><span class="p">,</span> <span class="n">train_loader</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">loss_monitor</span><span class="p">],</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>    epoch:  25 step:  20 time: 0.008, loss is 3.155
    epoch:  50 step:  20 time: 0.026, loss is 3.027
    epoch:  75 step:  20 time: 0.010, loss is 3.010
    epoch: 100 step:  20 time: 0.009, loss is 2.955
    epoch: 125 step:  20 time: 0.008, loss is 0.630
    epoch: 150 step:  20 time: 0.008, loss is 0.059
    epoch: 175 step:  20 time: 0.009, loss is 0.008
    epoch: 200 step:  20 time: 0.008, loss is 0.003
    epoch: 225 step:  20 time: 0.017, loss is 0.001
    epoch: 250 step:  20 time: 0.008, loss is 0.001
    epoch: 275 step:  20 time: 0.016, loss is 0.000
    epoch: 300 step:  20 time: 0.008, loss is 0.000
    epoch: 325 step:  20 time: 0.016, loss is 0.000
    epoch: 350 step:  20 time: 0.008, loss is 0.000
    Total time used: 5.06074857711792
</pre></div>
</div>
<p>Print the loss value during convergence:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loss_monitor</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Steps&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The convergence figure is as follows</p>
<p><img alt="classical nlp loss" src="_images/classical_nlp_loss.png" /></p>
<p>According to the above result, it can be seen that the quantum word embedding model generated by the quantum simulation can complete the word embedding task perfectly. When classical computers cannot handle the large quantity of data, the quantum computers can easily deal with large data.</p>
</section>
<section id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline"></a></h2>
<p>[1] Tomas Mikolov, Kai Chen, Greg Corrado, Jeffrey Dean. <a class="reference external" href="https://arxiv.org/pdf/1301.3781.pdf">Efficient Estimation of Word Representations in Vector Space</a></p>
</section>
</section>


           </div>
           
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="quantum_approximate_optimization_algorithm.html" class="btn btn-neutral float-left" title="Quantum Approximate Optimization Algorithm" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="vqe_for_quantum_chemistry.html" class="btn btn-neutral float-right" title="VQE Application in Quantum Chemistry Computing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>