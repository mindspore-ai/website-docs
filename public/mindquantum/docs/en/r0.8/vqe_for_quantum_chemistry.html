

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>VQE Application in Quantum Chemistry Computing &mdash; MindSpore master documentation</title>
  

  
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
   
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Quantum Phase Estimation Algorithm" href="quantum_phase_estimation.html" />
    <link rel="prev" title="The Application of Quantum Neural Network in NLP" href="qnn_for_nlp.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">MindQuantum Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">Initial experience of quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">Advanced gradient calculation of variational quantum circuits</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variational Quantum Algorithm</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">Classification of iris by quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">The Application of Quantum Neural Network in NLP</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">VQE Application in Quantum Chemistry Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#environment-preparation">Environment Preparation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#importing-dependencies">Importing Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-chemistry-computing-method">Quantum Chemistry Computing Method</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#wave-function">Wave Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#second-quantization">Second Quantization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#variational-quantum-eigensolver-vqe">Variational Quantum Eigensolver (VQE)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variational-principle">Variational Principle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initial-state-preparation">Initial State Preparation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wave-function-ansatz">Wave Function Ansatz</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vqe-procedure">VQE Procedure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-unitary-coupled-cluster-ansatz-step-by-step">Building a Unitary Coupled-Cluster Ansatz Step by Step</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">Grover search and Long algorithms based on MindQuantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">Shor’s algorithm based on MindQuantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>VQE Application in Quantum Chemistry Computing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/vqe_for_quantum_chemistry.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section class="tex2jax_ignore mathjax_ignore" id="vqe-application-in-quantum-chemistry-computing">
<h1>VQE Application in Quantum Chemistry Computing<a class="headerlink" href="#vqe-application-in-quantum-chemistry-computing" title="Permalink to this headline"></a></h1>
<p><a href="https://gitee.com/mindspore/docs/blob/r2.0.0-alpha/docs/mindquantum/docs/source_en/vqe_for_quantum_chemistry.md" target="_blank"><img src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.0.0-alpha/resource/_static/logo_source_en.png"></a></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline"></a></h2>
<p>Quantum chemistry refers to solving the numerical values of the time-dependent or time-independent Schrödinger equations by using the basic theory and method of quantum mechanics. Quantum chemical simulation on high-performance computers has become an important method to study the physical and chemical properties of materials. However, the exact solution of the Schrödinger equation has exponential complexity, which severely constrains the scale of the chemical system that can be simulated. The development of quantum computing in recent years provides a feasible way to solve this problem. It is expected that the Schrödinger equation can be solved with high accuracy on quantum computers under the complexity of polynomials.</p>
<p><a class="reference external" href="https://doi.org/10.1038/ncomms5213">Peruzzo et al.</a> first applied the VQE and <a class="reference external" href="https://linkinghub.elsevier.com/retrieve/pii/S0009261489873725">unitary coupled-cluster theory</a> to quantum chemistry simulation in 2014 to solve the ground state energy of He-H<sup>+</sup>. The VQE is a hybrid quantum-classical algorithm and is widely used in chemical simulation based on quantum algorithms. This tutorial describes how to use the VQE to solve the ground-state energy of a molecular system.</p>
<p>This tutorial consists of the following parts:</p>
<ol class="arabic simple">
<li><p>Introduction to the quantum chemistry</p></li>
<li><p>VQE application</p></li>
<li><p>Using MindQuantum to perform VQE simulation with efficient and automatic derivation</p></li>
</ol>
<blockquote>
<div><p>This document applies to the CPU environment.
You can obtain the complete executable sample code at <a class="reference external" href="https://gitee.com/mindspore/mindquantum/blob/r0.8/tutorials/source/7.vqe_for_quantum_chemistry.py">https://gitee.com/mindspore/mindquantum/blob/r0.8/tutorials/source/7.vqe_for_quantum_chemistry.py</a>.</p>
</div></blockquote>
</section>
<section id="environment-preparation">
<h2>Environment Preparation<a class="headerlink" href="#environment-preparation" title="Permalink to this headline"></a></h2>
<p>In this tutorial, the following environments need to be installed:</p>
<ul class="simple">
<li><p>NumPy</p></li>
<li><p>SciPy</p></li>
<li><p><a class="reference external" href="https://gitee.com/mindspore/mindquantum">MindQuantum</a></p></li>
<li><p><a class="reference external" href="https://gitee.com/mindspore/mindspore">MindSpore</a></p></li>
<li><p>PySCF</p></li>
<li><p>OpenFermion</p></li>
<li><p>OpenFermion-PySCF</p></li>
</ul>
<blockquote>
<div><p>The preceding dependencies can be installed by running the <code class="docutils literal notranslate"><span class="pre">pip</span></code> command.</p>
</div></blockquote>
</section>
<section id="importing-dependencies">
<h2>Importing Dependencies<a class="headerlink" href="#importing-dependencies" title="Permalink to this headline"></a></h2>
<p>Import the modules on which this tutorial depends.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openfermion.chem</span> <span class="kn">import</span> <span class="n">MolecularData</span>
<span class="kn">from</span> <span class="nn">openfermionpyscf</span> <span class="kn">import</span> <span class="n">run_pyscf</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">X</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">Hamiltonian</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">generate_uccsd</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="quantum-chemistry-computing-method">
<h2>Quantum Chemistry Computing Method<a class="headerlink" href="#quantum-chemistry-computing-method" title="Permalink to this headline"></a></h2>
<p>The core of quantum chemistry is to solve the Schrödinger equation. In general, the solution of time-dependent Schrödinger equation is more complex, so Born-Oppenheimer approximation (BO approximation) is introduced. In BO approximation, the mass of the nucleus is far greater than that of electrons, and the velocity of the nucleus is far lower than that of electrons. Therefore, the nucleus and electrons can be separated from each other, and the time-independent electron motion equation (also called the time-independent Schrödinger equation) can be obtained as follows:</p>
<div class="math notranslate nohighlight">
\[
\hat{H} |\Psi\rangle = E |\Psi\rangle
\]</div>
<p><span class="math notranslate nohighlight">\(\hat{H}\)</span> contains the following three items:</p>
<div class="math notranslate nohighlight">
\[
\hat{H} = \hat{K} _{e} + \hat{V} _{ee} + \hat{V} _{Ne}
\]</div>
<p>They are electron kinetic energy, electron-electron potential energy and electron-nuclear potential energy.</p>
<p>There are many numerical algorithms that can be used to solve the time-independent Schrödinger equation. This tutorial introduces one of these methods: the wave function. Wave function directly solves the eigenfunction and eigenenergy of a given molecular Hamiltonian. At present, there are a large number of open-source software packages, such as <a class="reference external" href="http://pyscf.org/">PySCF</a>, which can be implemented. Here is a simple example: lithium hydride molecules, using the OpenFermion and OpenFermion-PySCF plug-ins. First, define the molecular structure:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;Li&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">dist</span><span class="p">]],</span>
    <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span>  <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">dist</span><span class="p">]],</span>
<span class="p">]</span>
<span class="n">basis</span> <span class="o">=</span> <span class="s2">&quot;sto3g&quot;</span>
<span class="n">spin</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Geometry: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Geometry:
<span class="w">    </span><span class="o">[[</span><span class="s1">&#39;Li&#39;</span>,<span class="w"> </span><span class="o">[</span><span class="m">0</span>.0,<span class="w"> </span><span class="m">0</span>.0,<span class="w"> </span><span class="m">0</span>.0<span class="o">]]</span>,<span class="w"> </span><span class="o">[</span><span class="s1">&#39;H&#39;</span>,<span class="w"> </span><span class="o">[</span><span class="m">0</span>.0,<span class="w"> </span><span class="m">0</span>.0,<span class="w"> </span><span class="m">1</span>.5<span class="o">]]]</span>
</pre></div>
</div>
<p>The code above defines a Li-H key with a length of 1.5Å molecules. The STO-3G basis set is used for computing. Then, OpenFermion-PySCF is used to call PySCF to perform Hartree-Fock (HF), coupled-cluster with singles and doubles (CCSD), and full configuration interaction (FCI) computing. These three methods belong to the wave function. Before starting the computing, first make a brief introduction to these methods.</p>
<section id="wave-function">
<h3>Wave Function<a class="headerlink" href="#wave-function" title="Permalink to this headline"></a></h3>
<p>One of the methods to solve the time-independent Schrödinger equation is the <a class="reference external" href="https://doi.org/10.1098/rspa.1935.0085">Hartree-Fock (HF)</a> method, which was proposed by Hartree et al. in the 1930s and is the basic method in quantum chemistry computing. The HF method introduces a single determinant approximation, that is, a wave function of the <span class="math notranslate nohighlight">\(N\)</span>-electronic system is represented by a wave function in a determinant form:</p>
<div class="math notranslate nohighlight">
\[
| \Psi \rangle = | \psi_{1} \psi_{2} \psi_{3} \dots \psi_{N} \rangle
\]</div>
<p>Where <span class="math notranslate nohighlight">\(| \psi_{1} \psi_{2} \psi_{3} \dots \rangle\)</span> represents the Nth-order determinants formed by a set of spin-orbit wave functions <span class="math notranslate nohighlight">\(\{ \pi_{i} \}\)</span>.
The spin-orbit wave function <span class="math notranslate nohighlight">\(\psi_{i}\)</span> may be further expanded with a set of basis functions in known forms:</p>
<div class="math notranslate nohighlight">
\[\psi_{i} = \phi_{i} \eta_{i}\]</div>
<div class="math notranslate nohighlight">
\[\phi_{i} = \sum_{\mu}{C_{\mu i} \chi_{\mu}}\]</div>
<p><span class="math notranslate nohighlight">\(\{\chi_{\mu}\}\)</span> is referred to as a basis function, and may be a Gaussian function or the like.
This approximation considers the exchange between electrons, but neglects the correlation between electrons, so it cannot correctly compute the properties such as dissociation energy.</p>
<p>The improvement of the HF method can be derived from the wave function expansion theorem. The wave function expansion theorem can be expressed as follows: if <span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span> is a complete set of spin-orbit wave functions, the <span class="math notranslate nohighlight">\(N\)</span>-electronic system wave function may be accurately expanded by a determinant wave function formed by <span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
| \Psi \rangle = \sum^{\infty} _ {i_{1} &lt; i_{2} &lt; \dots &lt; i_{N}} {C_{i_{1} i_{2} \dots i_{N}} | \psi_{i_{1}} \psi_{i_{2}} \dots \psi_{i_{N}} \rangle}
\]</div>
<p>You can obtain the configuration interaction (CI) method:</p>
<div class="math notranslate nohighlight">
\[
| \Psi_{CI} \rangle = C_{0} | \Psi_{HF} \rangle + \sum^{a\rightarrow\infty} _{i\in occ, a\not\in occ}{C^{a} _{i} | \Psi^{a} _{i} \rangle } + \sum^{ab\rightarrow\infty} _{ij\in occ, ab\not\in occ}{C^{ab} _{ij} | \Psi^{ab} _{ij} \rangle }
\]</div>
<p><span class="math notranslate nohighlight">\(| \Psi^{a}_{i} \rangle + \dots\)</span> in the preceding formula represents a single excitation wave function of the electron from the orbit <span class="math notranslate nohighlight">\(i\)</span> to the orbit <span class="math notranslate nohighlight">\(a\)</span>, and so on. A CI that considers only single excitation and double excitation is called a configuration interaction with singles and doubles (CISD). The CI that takes into account all the ground-state HF wave functions to N excitation wave functions is called full configuration interaction (FCI). The FCI wave function is the exact solution of the time-independent Schrödinger equation under the given basis function.</p>
</section>
<section id="second-quantization">
<h3>Second Quantization<a class="headerlink" href="#second-quantization" title="Permalink to this headline"></a></h3>
<p>Under the second quantization expression, the Hamiltonian of the system has the following form:</p>
<div class="math notranslate nohighlight">
\[
\hat{H} = \sum_{p, q}{h^p_q E^p_q} + \sum_{p, q, r, s}{\frac{1}{2} g^{pq} _ {rs} E^{pq}_{rs}}
\]</div>
<p><span class="math notranslate nohighlight">\(E^{p} _{q}\)</span> and <span class="math notranslate nohighlight">\(E^{pq}_ {rs}\)</span> are as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
E^{pq} _{rs} &amp;= a^{\dagger} _{p} a^{\dagger} _{q} a _ {r} a _ {s}\\
E^p_q &amp;= a^{\dagger}_pa_q
\end{align*}
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(a^{\dagger} _{p}\)</span> and <span class="math notranslate nohighlight">\(a_ {q}\)</span> are creation operator and annihilation operator, respectively.</p>
<p>The excited-state wave function can be expressed conveniently by using a second quantization expression method:</p>
<div class="math notranslate nohighlight">
\[
| \Psi^{abc\dots} _ {ijk\dots} \rangle = a^{\dagger} _ {a} a^{\dagger} _ {b} a^{\dagger} _ {c} \dots a _ {i} a_{j} a_{k} \dots | \Psi \rangle
\]</div>
<p>An improvement to the CI method is the coupled-cluster theory (CC). Exponential operators are introduced to CC:</p>
<div class="math notranslate nohighlight">
\[
| \Psi_{CC} \rangle = \exp{(\hat{T})} | \Psi_{HF} \rangle
\]</div>
<p>The coupled-cluster operator <span class="math notranslate nohighlight">\(\hat{T}\)</span> is the sum of excitation operators.</p>
<div class="math notranslate nohighlight">
\[
\hat{T} = \sum_{p\not\in occ, q\in occ}{\theta^{p} _ {q} E^{p} _ {q}} + \sum_{pq\not\in occ, rs\in occ}{\theta^{pq} _ {rs} E^{pq} _ {rs}} + \dots
\]</div>
<p><span class="math notranslate nohighlight">\(\theta\)</span> is similar to <span class="math notranslate nohighlight">\(C\)</span> in the CI method, and is the parameter to be solved. It is easy to know from the Taylor’s expansion of the exponent that even if the coupled-cluster operator <span class="math notranslate nohighlight">\(\hat{T}\)</span> includes only a low-order excitation term, the <span class="math notranslate nohighlight">\(\exp{(\hat{T})}\)</span> may also implicitly include a high-order excitation term. This also makes a convergence speed of the CC method to the FCI wave function much faster than that of the CI. For truncation to K excitation, for example, K=2, the accuracy of the CCSD exceeds that of the CISD.</p>
<!--
Generally, if a method can achieve chemical accuracy, that is, the difference between the energy computed by this method and the FCI energy is less than 1 kcal/mol, it is considered that the method has good accuracy. Truncation to three-excited CCSD(T) can meet this standard in most cases.
-->
<p>The effect of electron correlation is to reduce the total energy, so the ground state energy of HF is slightly higher than that of CCSD and FCI. In addition, it is easy to find that the computing volume of FCI is much greater than that of CCSD and HF. The <code class="docutils literal notranslate"><span class="pre">MolecularData</span></code> function encapsulated by OpenFermion and the <code class="docutils literal notranslate"><span class="pre">run_pyscf</span></code> function encapsulated by OpenFermion-PySCF are used for demonstration.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_of</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">,</span>
    <span class="n">multiplicity</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">)</span>
<span class="n">molecule_of</span> <span class="o">=</span> <span class="n">run_pyscf</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="p">,</span>
    <span class="n">run_scf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">run_ccsd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">run_fci</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hartree-Fock energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">hf_energy</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CCSD energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_energy</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FCI energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">fci_energy</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Hartree-Fock<span class="w"> </span>energy:<span class="w">  </span>-7.8633576215351200<span class="w"> </span>Ha
CCSD<span class="w"> </span>energy:<span class="w">  </span>-7.8823529091527051<span class="w"> </span>Ha
FCI<span class="w"> </span>energy:<span class="w">  </span>-7.8823622867987249<span class="w"> </span>Ha
</pre></div>
</div>
<p>In the preceding example, HF, CCSD, and FCI are used to compute the total energy. If you collect statistics on the runtime, you will find that <span class="math notranslate nohighlight">\(T_{HF}&lt;T_{CCSD}\ll T_{FCI}\)</span>. It is more obvious if you use the system with larger calculation amount, such as ethylene molecule. In addition, for the total computed energy, you will find that <span class="math notranslate nohighlight">\(E_{HF}&gt;E_{CCSD}&gt;E_{FCI}\)</span>. After the computing is complete, save the result to the <code class="docutils literal notranslate"><span class="pre">molecule_file</span></code> file (<code class="docutils literal notranslate"><span class="pre">molecule_of.filename</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_of</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">molecule_file</span> <span class="o">=</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">filename</span>
<span class="nb">print</span><span class="p">(</span><span class="n">molecule_file</span><span class="p">)</span>
</pre></div>
</div>
<p>One of the major obstacles to quantum chemistry is the volume of computation. As the system size (electron number and atomic number) increases, the time required for solving the FCI wave function and ground state energy increases by about <span class="math notranslate nohighlight">\(2^{N}\)</span>. Even for small molecules such as ethylene molecules, FCI computing is not easy. Quantum computers provide a possible solution to this problem. Research shows that quantum computers can simulate the time-dependent evolution of Hamiltonian in terms of polynomial time complexity. Compared with classical computers, quantum computers exponentially accelerate the chemical simulation on quantum processors. This tutorial introduces one of the quantum algorithms: VQE.</p>
</section>
</section>
<section id="variational-quantum-eigensolver-vqe">
<h2>Variational Quantum Eigensolver (VQE)<a class="headerlink" href="#variational-quantum-eigensolver-vqe" title="Permalink to this headline"></a></h2>
<p>The VQE is a hybrid quantum-classical algorithm. It uses the variational principle to solve the ground state wave function. The optimization of variational parameters is carried out on the classical computer.</p>
<section id="variational-principle">
<h3>Variational Principle<a class="headerlink" href="#variational-principle" title="Permalink to this headline"></a></h3>
<p>The variational principle may be expressed in the following form:</p>
<div class="math notranslate nohighlight">
\[
E_{0} \le \frac{\langle \Psi_{t} | \hat{H} | \Psi_{t} \rangle}{\langle \Psi_{t} | \Psi_{t} \rangle}
\]</div>
<p>In the preceding formula, <span class="math notranslate nohighlight">\(| \Psi_{t} \rangle\)</span> indicates the probe wave function. The variational principle shows that the ground state energy obtained by any probe wave function is always greater than or equal to the real ground state energy under certain conditions. The variational principle provides a method for solving the molecular ground state Schrödinger equation. A parameterized function <span class="math notranslate nohighlight">\(f(\theta)\)</span> is used as an approximation of the accurate ground state wave function, and the accurate ground state energy is approximated by optimizing the parameter <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
</section>
<section id="initial-state-preparation">
<h3>Initial State Preparation<a class="headerlink" href="#initial-state-preparation" title="Permalink to this headline"></a></h3>
<p>The <span class="math notranslate nohighlight">\(N\)</span>-electron HF wave function also has a very concise form under the quadratic quantization expression:</p>
<div class="math notranslate nohighlight">
\[
| \Psi_{HF} \rangle = \prod^{i=0} _{N-1}{a^{\dagger} _{i}| 0 \rangle}
\]</div>
<p>The above formula builds a bridge from quantum chemical wave function to quantum computing: <span class="math notranslate nohighlight">\(|0\rangle\)</span> is used to represent a non-occupied orbit, and <span class="math notranslate nohighlight">\(|1\rangle\)</span> is used to represent an orbit occupied by an electron. Therefore, the <span class="math notranslate nohighlight">\(N\)</span>-electron HF wave function may be mapped to a string of <span class="math notranslate nohighlight">\(M+N\)</span> quantum bits <span class="math notranslate nohighlight">\(| 00\dots 11\dots \rangle\)</span>. <span class="math notranslate nohighlight">\(M\)</span> indicates the number of unoccupied tracks.</p>
<p>The following code builds an HF initial state wave function corresponding to the LiH molecule. In Jordan-Wigner transformation, <span class="math notranslate nohighlight">\(N\)</span> <span class="math notranslate nohighlight">\(\text{X}\)</span> gates are applied to <span class="math notranslate nohighlight">\(|000\dots\rangle\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hartreefock_wfn_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">([</span><span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hartreefock_wfn_circuit</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>q0:<span class="w"> </span>──X──

q1:<span class="w"> </span>──X──

q2:<span class="w"> </span>──X──

q3:<span class="w"> </span>──X──
</pre></div>
</div>
<p>We can build a probe wave function in the following form:</p>
<div class="math notranslate nohighlight">
\[
| \Psi_{t} \rangle = U(\theta) | \Psi_{HF} \rangle
\]</div>
<p><span class="math notranslate nohighlight">\(U(\theta)\)</span> represents a unitary transformation that may be simulated by using a quantum circuit. <span class="math notranslate nohighlight">\(| \Psi_{HF} \rangle\)</span> is used as an initial state, and may be conveniently prepared by using a plurality of single-bit <span class="math notranslate nohighlight">\(\text{X}\)</span> gates. A specific form of the <span class="math notranslate nohighlight">\(U(\theta) | \Psi_{HF} \rangle\)</span> is also referred to as wave function ansatz.</p>
</section>
<section id="wave-function-ansatz">
<h3>Wave Function Ansatz<a class="headerlink" href="#wave-function-ansatz" title="Permalink to this headline"></a></h3>
<p>The coupled-cluster theory mentioned above is a very efficient wave function ansatz. To use it on a quantum computer, you need to make the following modifications:</p>
<div class="math notranslate nohighlight">
\[
| \Psi_{UCC} \rangle = \exp{(\hat{T} - \hat{T}^{\dagger})} | \Psi_{HF} \rangle
\]</div>
<p>UCC is short for unitary coupled-cluster theory. <span class="math notranslate nohighlight">\(\hat{T}^{\dagger}\)</span> represents the Hermite conjugate of <span class="math notranslate nohighlight">\(\hat{T}\)</span>. In this way, <span class="math notranslate nohighlight">\(\exp{(\hat{T} - \hat{T}^{\dagger})}\)</span> is the unitary operator. <a class="reference external" href="https://doi.org/10.1038/ncomms5213">Peruzzo et al.</a> first performed chemical simulation experiments on quantum computers using VQE and unitary coupled-cluster with singles and doubles (UCCSD) in 2014. It should be noted that, by default, the parameter <span class="math notranslate nohighlight">\(\{\theta\}\)</span> in the coupled-cluster operator is a real number. There is no problem with this hypothesis in molecular systems. In periodic systems, the study of <a class="reference external" href="https://doi.org/10.1021/acs.jctc.0c00881">Liu Jie et al.</a> suggests that a unitary coupled-cluster can result in errors due to the neglect of the complex numbers. This tutorial does not discuss the application of unitary coupled-cluster in periodic systems.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code> function in the circuit module of MindQuantum can be used to read the computing result saved in <code class="docutils literal notranslate"><span class="pre">molecule_file</span></code>, build the UCCSD wave function by one click, and obtain the corresponding quantum circuit.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ansatz_circuit</span><span class="p">,</span> \
<span class="n">init_amplitudes</span><span class="p">,</span> \
<span class="n">ansatz_parameter_names</span><span class="p">,</span> \
<span class="n">hamiltonian_QubitOp</span><span class="p">,</span> \
<span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">generate_uccsd</span><span class="p">(</span><span class="n">molecule_file</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ccsd:-7.882352909152705.
fci:-7.882362286798725.
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code> packs functions related to the unitary coupled-cluster, including multiple steps such as deriving a molecular Hamiltonian, building a unitary coupled-cluster ansatz operator, and extracting a coupled-cluster coefficient computed by CCSD. This function reads the molecule by entering its file path. The parameter <code class="docutils literal notranslate"><span class="pre">th</span></code> indicates the to-be-updated gradient threshold of a parameter in the quantum circuit. In the section <span class="xref myst">Building a Unitary Coupled-Cluster Ansatz Step by Step</span>, we will demonstrate how to use the related interfaces of MindQuantum to complete the steps. A complete quantum circuit includes an HF initial state and a UCCSD ansatz, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">total_circuit</span> <span class="o">=</span> <span class="n">hartreefock_wfn_circuit</span> <span class="o">+</span> <span class="n">ansatz_circuit</span>
<span class="n">total_circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of parameters: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ansatz_parameter_names</span><span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">============================</span>Circuit<span class="w"> </span><span class="nv">Summary</span><span class="o">============================</span>
<span class="p">|</span>Total<span class="w"> </span>number<span class="w"> </span>of<span class="w"> </span>gates<span class="w">  </span>:<span class="w"> </span><span class="m">15172</span>.<span class="w">                                      </span><span class="p">|</span>
<span class="p">|</span>Parameter<span class="w"> </span>gates<span class="w">        </span>:<span class="w"> </span><span class="m">640</span>.<span class="w">                                        </span><span class="p">|</span>
<span class="p">|</span>with<span class="w"> </span><span class="m">44</span><span class="w"> </span>parameters<span class="w"> </span>are<span class="w"> </span>:<span class="w"> </span>p0,<span class="w"> </span>p8,<span class="w"> </span>p1,<span class="w"> </span>p9,<span class="w"> </span>p2,<span class="w"> </span>p10,<span class="w"> </span>p3,<span class="w"> </span>p11,<span class="w"> </span>p4,<span class="w"> </span>p12...<span class="p">|</span>
<span class="p">|</span>Number<span class="w"> </span>qubit<span class="w"> </span>of<span class="w"> </span>circuit:<span class="w"> </span><span class="m">12</span><span class="w">                                          </span><span class="p">|</span>
<span class="o">=======================================================================</span>
Number<span class="w"> </span>of<span class="w"> </span>parameters:<span class="w"> </span><span class="m">44</span>
</pre></div>
</div>
<p>For the LiH molecule, the UCCSD wave function ansatz includes 44 variational parameters. The total number of quantum bit gates of the circuit is 12612, and a total of 12 quantum bits are needed for simulation.</p>
</section>
<section id="vqe-procedure">
<h3>VQE Procedure<a class="headerlink" href="#vqe-procedure" title="Permalink to this headline"></a></h3>
<p>The procedure for solving the molecular ground state by using the VQE is as follows:</p>
<ol class="arabic simple">
<li><p>Prepare the HF initial state: <span class="math notranslate nohighlight">\(| 00\dots11\dots \rangle\)</span>.</p></li>
<li><p>Define the wave function ansatz, such as UCCSD.</p></li>
<li><p>Convert the wave function into a variational quantum circuit.</p></li>
<li><p>Initialize the variational parameters, for example, set all parameters to 0.</p></li>
<li><p>Obtain the energy <span class="math notranslate nohighlight">\(E(\theta)\)</span> of the molecular Hamiltonian under the set of variational parameters and the derivative <span class="math notranslate nohighlight">\(\{ {\partial E} / {\partial \theta_{i}} \}\)</span> of the energy about the parameters by means of multiple measurements on the quantum computer.</p></li>
<li><p>Use optimization algorithms, such as gradient descent and BFGS, to update variational parameters on classical computers.</p></li>
<li><p>Transfer the new variational parameters to the quantum circuit for updating.</p></li>
<li><p>Repeat steps 5 to 7 until the convergence criteria are met.</p></li>
<li><p>End.</p></li>
</ol>
<p>In step 5, the derivative <span class="math notranslate nohighlight">\(\{ {\partial E} / {\partial \theta_{i}} \}\)</span> of the energy about the parameter may be computed by using a parameter-shift rule on a quantum computer, or may be computed by simulating a parameter-shift rule or a finite difference method in a simulator. This is a relatively time-consuming process. Based on the MindSpore framework, MindQuantum provides the automatic derivation function similar to machine learning, which can efficiently compute the derivatives of variational quantum circuits in simulation. The following uses MindQuantum to build a parameterized UCCSD quantum circuit with an automatic derivation function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">total_circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>
<span class="n">molecule_pqc</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="n">hamiltonian_QubitOp</span><span class="p">),</span> <span class="n">total_circuit</span><span class="p">)</span>
</pre></div>
</div>
<p>You can obtain the energy <span class="math notranslate nohighlight">\(E(\theta)=\langle \Psi_{UCC}(\theta) | \hat{H} | \Psi_{UCC}(\theta) \rangle\)</span> corresponding to the variational parameter and the derivative of each variational parameter by transferring a specific value of the parameter to <code class="docutils literal notranslate"><span class="pre">molecule_pqc</span></code>.</p>
<p>Next, steps 5 to 7 in VQE optimization need to be performed, that is, parameterized quantum circuits need to be optimized. Based on the MindSpore framework, you can use the parameterized quantum circuit operator <code class="docutils literal notranslate"><span class="pre">molecule_pqc</span></code> to build a neural network model, and then optimize the variational parameters by using a method similar to training the neural network.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.framework</span> <span class="kn">import</span> <span class="n">MQAnsatzOnlyLayer</span>

<span class="n">molecule_pqcnet</span> <span class="o">=</span> <span class="n">MQAnsatzOnlyLayer</span><span class="p">(</span><span class="n">molecule_pqc</span><span class="p">,</span> <span class="s1">&#39;Zeros&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we manually build a basic <code class="docutils literal notranslate"><span class="pre">MQAnsatzOnlyLayer</span></code> as a model example. This model can be used similar to a conventional machine learning model, for example, optimizing weights and calculating derivatives.</p>
<p>The built <code class="docutils literal notranslate"><span class="pre">MQAnsatzOnlyLayer</span></code> uses the <code class="docutils literal notranslate"><span class="pre">&quot;Zeros&quot;</span></code> keyword to initialize all variational parameters to 0. The computing result of CCSD or second order Møller-Plesset perturbation theory (MP2) can also be used as the initial value of the variational parameters of unitary coupled-clusters. In this case, <span class="math notranslate nohighlight">\(E(\vec{0})=\langle \Psi_{UCC}(\vec{0}) | \hat{H} | \Psi_{UCC}(\vec{0}) \rangle = E_{HF}\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">initial_energy</span> <span class="o">=</span> <span class="n">molecule_pqcnet</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial energy: </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">initial_energy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Initial<span class="w"> </span>energy:<span class="w">  </span>-7.8633575439453125
</pre></div>
</div>
<p>Finally, the Adam optimizer of MindSpore is used for optimization. The learning rate is set to <span class="math notranslate nohighlight">\(1\times 10^{-2}\)</span>, and the optimization termination standard is set to <span class="math notranslate nohighlight">\(\left.|\epsilon|\right. = \left.|E^{k+1} - E^{k}|\right. \le 1\times 10^{-8}\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Adagrad</span><span class="p">(</span><span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">4e-2</span><span class="p">)</span>
<span class="n">train_pqcnet</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">TrainOneStepCell</span><span class="p">(</span><span class="n">molecule_pqcnet</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)</span>

<span class="n">eps</span> <span class="o">=</span> <span class="mf">1.e-8</span>
<span class="n">energy_diff</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="mi">1000</span>
<span class="n">energy_last</span> <span class="o">=</span> <span class="n">initial_energy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">+</span> <span class="n">energy_diff</span>
<span class="n">iter_idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">energy_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
    <span class="n">energy_i</span> <span class="o">=</span> <span class="n">train_pqcnet</span><span class="p">()</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">iter_idx</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step </span><span class="si">%3d</span><span class="s2"> energy </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_idx</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">energy_i</span><span class="p">)))</span>
    <span class="n">energy_diff</span> <span class="o">=</span> <span class="n">energy_last</span> <span class="o">-</span> <span class="n">energy_i</span>
    <span class="n">energy_last</span> <span class="o">=</span> <span class="n">energy_i</span>
    <span class="n">iter_idx</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimization completed at step </span><span class="si">%3d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized energy: </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">energy_i</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized amplitudes: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Step<span class="w">   </span><span class="m">0</span><span class="w"> </span>energy<span class="w">  </span>-7.8633575439453125
Step<span class="w">   </span><span class="m">5</span><span class="w"> </span>energy<span class="w">  </span>-7.8726239204406738
Step<span class="w">  </span><span class="m">10</span><span class="w"> </span>energy<span class="w">  </span>-7.8821778297424316
Step<span class="w">  </span><span class="m">15</span><span class="w"> </span>energy<span class="w">  </span>-7.8822836875915527
Step<span class="w">  </span><span class="m">20</span><span class="w"> </span>energy<span class="w">  </span>-7.8823199272155762
Step<span class="w">  </span><span class="m">25</span><span class="w"> </span>energy<span class="w">  </span>-7.8823370933532715
Optimization<span class="w"> </span>completed<span class="w"> </span>at<span class="w"> </span>step<span class="w">  </span><span class="m">27</span>
Optimized<span class="w"> </span>energy:<span class="w">  </span>-7.8823390007019043
Optimized<span class="w"> </span>amplitudes:
<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="m">2</span>.7273933e-04<span class="w">  </span><span class="m">1</span>.9072455e-03<span class="w">  </span><span class="m">2</span>.9598266e-02<span class="w">  </span><span class="m">1</span>.5151843e-02
<span class="w">  </span><span class="m">1</span>.5533751e-06<span class="w">  </span><span class="m">9</span>.0890197e-04<span class="w"> </span>-5.1002303e-07<span class="w">  </span><span class="m">1</span>.4072354e-02
<span class="w"> </span>-1.2779084e-05<span class="w">  </span><span class="m">9</span>.0818782e-04<span class="w">  </span><span class="m">4</span>.1782801e-06<span class="w">  </span><span class="m">1</span>.4077923e-02
<span class="w"> </span>-5.2711589e-04<span class="w">  </span><span class="m">4</span>.2598479e-04<span class="w">  </span><span class="m">2</span>.6523003e-03<span class="w">  </span><span class="m">5</span>.3988658e-02
<span class="w">  </span><span class="m">1</span>.9281749e-04<span class="w"> </span>-1.2321149e-07<span class="w"> </span>-3.1405324e-07<span class="w">  </span><span class="m">1</span>.9214883e-06
<span class="w">  </span><span class="m">1</span>.0062347e-06<span class="w">  </span><span class="m">1</span>.0903094e-06<span class="w"> </span>-1.4285328e-05<span class="w"> </span>-7.8342858e-08
<span class="w">  </span><span class="m">7</span>.5983076e-04<span class="w"> </span>-1.1218661e-04<span class="w">  </span><span class="m">8</span>.8862755e-08<span class="w"> </span>-7.2354385e-07
<span class="w"> </span>-5.3567935e-02<span class="w">  </span><span class="m">3</span>.0693393e-03<span class="w"> </span>-1.3467404e-10<span class="w"> </span>-4.6068820e-09
<span class="w">  </span><span class="m">4</span>.5405173e-09<span class="w">  </span><span class="m">1</span>.1786257e-06<span class="w">  </span><span class="m">8</span>.9121182e-05<span class="w"> </span>-9.4004070e-05
<span class="w"> </span>-1.0432483e-10<span class="w"> </span>-2.8091000e-07<span class="w">  </span><span class="m">3</span>.0693379e-03<span class="w"> </span>-9.6705053e-06
<span class="w">  </span><span class="m">7</span>.7026058e-04<span class="w"> </span>-7.3031953e-04<span class="w">  </span><span class="m">2</span>.3029093e-06<span class="w">  </span><span class="m">3</span>.5888454e-04<span class="o">]</span>
</pre></div>
</div>
<p>It can be seen that the computing result of unitary coupled-cluster is very close to that of FCI, and has good accuracy.</p>
</section>
</section>
<section id="building-a-unitary-coupled-cluster-ansatz-step-by-step">
<h2>Building a Unitary Coupled-Cluster Ansatz Step by Step<a class="headerlink" href="#building-a-unitary-coupled-cluster-ansatz-step-by-step" title="Permalink to this headline"></a></h2>
<p><a id="step-by-step"></a></p>
<p>In the preceding part, the <code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code> is used to build all the content required for designing the unitary coupled-cluster. In this section, the steps are split, we get the coupled-cluster operator, the corresponding quantum circuit and the initial guess of the variational parameters from the classical CCSD results.
First, import some extra dependencies, including the related functions of the HiQfermion module in MindQuantum.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">get_qubit_hamiltonian</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">uccsd_singlet_generator</span><span class="p">,</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">TimeEvolution</span>
<span class="kn">from</span> <span class="nn">mindquantum.framework</span> <span class="kn">import</span> <span class="n">MQAnsatzOnlyLayer</span>
</pre></div>
</div>
<p>The molecule Hamiltonian uses <code class="docutils literal notranslate"><span class="pre">get_qubit_hamiltonian</span></code> to read the previous computing result. The result is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_QubitOp</span> <span class="o">=</span> <span class="n">get_qubit_hamiltonian</span><span class="p">(</span><span class="n">molecule_of</span><span class="p">)</span>
</pre></div>
</div>
<p>The unitary coupled-cluster operator <span class="math notranslate nohighlight">\(\hat{T} - \hat{T}^{\dagger}\)</span> can be built using <code class="docutils literal notranslate"><span class="pre">uccsd_singlet_generator</span></code>. Provide the total number of quantum bits (total number of spin orbits) and the total number of electrons, and set <code class="docutils literal notranslate"><span class="pre">anti_hermitian=True</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ucc_fermion_ops</span> <span class="o">=</span> <span class="n">uccsd_singlet_generator</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span> <span class="n">anti_hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ucc_fermion_ops</span></code> built in the previous step is parameterized. Use the Jordan-Wigner transformation to map the Fermi excitation operator to the Pauli operator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ucc_qubit_ops</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="n">ucc_fermion_ops</span><span class="p">)</span><span class="o">.</span><span class="n">jordan_wigner</span><span class="p">()</span>
</pre></div>
</div>
<p>Next, we need to obtain the quantum circuit corresponding to the unitary operator <span class="math notranslate nohighlight">\(\exp{(\hat{T} - \hat{T}^{\dagger})}\)</span>. <code class="docutils literal notranslate"><span class="pre">TimeEvolution</span></code> can generate the circuit corresponding to <span class="math notranslate nohighlight">\(\exp{(-i\hat{H}t)}\)</span>, where <span class="math notranslate nohighlight">\(\hat{H}\)</span> is a Hermitian operator, and <span class="math notranslate nohighlight">\(t\)</span> is a real number. Note that when <code class="docutils literal notranslate"><span class="pre">TimeEvolution</span></code> is used, <code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code> already contains the complex number factor <span class="math notranslate nohighlight">\(i\)</span>. Therefore, you need to divide <code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code> by <span class="math notranslate nohighlight">\(i\)</span> or extract the imaginary part of <code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">TimeEvolution</span><span class="p">(</span><span class="n">ucc_qubit_ops</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">circuit</span>
<span class="n">ansatz_parameter_names</span> <span class="o">=</span> <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">params_name</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ansatz_parameter_names</span></code> is used to record the parameter names in the circuit. So far, we have obtained the contents required by the VQE quantum circuit, including the Hamiltonian <code class="docutils literal notranslate"><span class="pre">hamiltonian_QubitOp</span></code> and the parameterized wave function ansatz <code class="docutils literal notranslate"><span class="pre">ansatz_circuit</span></code>. By referring to the preceding steps, we can obtain a complete state preparation circuit. <code class="docutils literal notranslate"><span class="pre">hartreefock_wfn_circuit</span></code> mentioned above is used as the Hartree-Fock reference state:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">total_circuit</span> <span class="o">=</span> <span class="n">hartreefock_wfn_circuit</span> <span class="o">+</span> <span class="n">ansatz_circuit</span>
<span class="n">total_circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">==================================</span>Circuit<span class="w"> </span><span class="nv">Summary</span><span class="o">==================================</span>
<span class="p">|</span>Total<span class="w"> </span>number<span class="w"> </span>of<span class="w"> </span>gates<span class="w">  </span>:<span class="w"> </span><span class="m">15172</span>.<span class="w">                                                  </span><span class="p">|</span>
<span class="p">|</span>Parameter<span class="w"> </span>gates<span class="w">        </span>:<span class="w"> </span><span class="m">640</span>.<span class="w">                                                    </span><span class="p">|</span>
<span class="p">|</span>with<span class="w"> </span><span class="m">44</span><span class="w"> </span>parameters<span class="w"> </span>are<span class="w"> </span>:<span class="w"> </span>s_0,<span class="w"> </span>d1_0,<span class="w"> </span>s_1,<span class="w"> </span>d1_1,<span class="w"> </span>s_2,<span class="w"> </span>d1_2,<span class="w"> </span>s_3,<span class="w"> </span>d1_3,<span class="w"> </span>s_4,<span class="w"> </span>d1_4...<span class="p">|</span>
<span class="p">|</span>Number<span class="w"> </span>qubit<span class="w"> </span>of<span class="w"> </span>circuit:<span class="w"> </span><span class="m">12</span><span class="w">                                                      </span><span class="p">|</span>
<span class="o">===================================================================================</span>
</pre></div>
</div>
<p>Next, you need to provide a reasonable initial value for the variational parameter. The <code class="docutils literal notranslate"><span class="pre">PQCNet</span></code> built in the preceding text uses 0 as the initial guess by default, which is feasible in most cases. However, using CCSD’s computational data as a starting point for UCC may be better. Use the <code class="docutils literal notranslate"><span class="pre">uccsd_singlet_get_packed_amplitudes</span></code> function to extract CCSD parameters from <code class="docutils literal notranslate"><span class="pre">molecule_of</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">init_amplitudes_ccsd</span> <span class="o">=</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_single_amps</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_double_amps</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)</span>
<span class="n">init_amplitudes_ccsd</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_amplitudes_ccsd</span><span class="p">[</span><span class="n">param_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">param_i</span> <span class="ow">in</span> <span class="n">ansatz_parameter_names</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MQAnsatzOnlyLayer</span></code> can be used to easily obtain a machine learning model based on a variational quantum circuit by using a parameter and a quantum circuit:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grad_ops</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">total_circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span>
    <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">hamiltonian_QubitOp</span><span class="o">.</span><span class="n">real</span><span class="p">),</span>
    <span class="n">total_circuit</span><span class="p">)</span>

<span class="n">molecule_pqcnet</span> <span class="o">=</span> <span class="n">MQAnsatzOnlyLayer</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">init_amplitudes_ccsd</span></code> (coupled-cluster coefficient computed by CCSD) is used as an initial variational parameter:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">init_amplitudes_ccsd</span><span class="p">,</span> <span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
<span class="n">initial_energy</span> <span class="o">=</span> <span class="n">molecule_pqcnet</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial energy: </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">initial_energy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Initial<span class="w"> </span>energy:<span class="w">  </span>-7.8173098564147949
</pre></div>
</div>
<p>In this example, CCSD’s initial guess does not provide a better starting point. You can test and explore more molecules and more types of initial values (such as initial guesses of random numbers). Finally, the VQE is optimized. The optimizer still uses Adam, and the convergence standard remains unchanged. The code used for optimization is basically the same as that described in the preceding sections. You only need to update the corresponding variables.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Adagrad</span><span class="p">(</span><span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">4e-2</span><span class="p">)</span>
<span class="n">train_pqcnet</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">TrainOneStepCell</span><span class="p">(</span><span class="n">molecule_pqcnet</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;eps: &quot;</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
<span class="n">energy_diff</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="mi">1000</span>
<span class="n">energy_last</span> <span class="o">=</span> <span class="n">initial_energy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">+</span> <span class="n">energy_diff</span>
<span class="n">iter_idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">energy_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
    <span class="n">energy_i</span> <span class="o">=</span> <span class="n">train_pqcnet</span><span class="p">()</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">iter_idx</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step </span><span class="si">%3d</span><span class="s2"> energy </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_idx</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">energy_i</span><span class="p">)))</span>
    <span class="n">energy_diff</span> <span class="o">=</span> <span class="n">energy_last</span> <span class="o">-</span> <span class="n">energy_i</span>
    <span class="n">energy_last</span> <span class="o">=</span> <span class="n">energy_i</span>
    <span class="n">iter_idx</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimization completed at step </span><span class="si">%3d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized energy: </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">energy_i</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized amplitudes: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>eps:<span class="w">  </span>1e-08
Step<span class="w">   </span><span class="m">0</span><span class="w"> </span>energy<span class="w">  </span>-7.8173098564147949
Step<span class="w">   </span><span class="m">5</span><span class="w"> </span>energy<span class="w">  </span>-7.8740758895874023
Step<span class="w">  </span><span class="m">10</span><span class="w"> </span>energy<span class="w">  </span>-7.8818783760070801
Step<span class="w">  </span><span class="m">15</span><span class="w"> </span>energy<span class="w">  </span>-7.8821649551391602
Step<span class="w">  </span><span class="m">20</span><span class="w"> </span>energy<span class="w">  </span>-7.8822622299194336
Step<span class="w">  </span><span class="m">25</span><span class="w"> </span>energy<span class="w">  </span>-7.8823080062866211
Optimization<span class="w"> </span>completed<span class="w"> </span>at<span class="w"> </span>step<span class="w">  </span><span class="m">28</span>
Optimized<span class="w"> </span>energy:<span class="w">  </span>-7.8823189735412598
Optimized<span class="w"> </span>amplitudes:
<span class="w"> </span><span class="o">[</span>-2.92540470e-04<span class="w">  </span><span class="m">1</span>.91678782e-03<span class="w"> </span>-2.62904949e-02<span class="w">  </span><span class="m">1</span>.46486172e-02
<span class="w"> </span>-1.80548541e-05<span class="w">  </span><span class="m">9</span>.08615650e-04<span class="w">  </span><span class="m">6</span>.06753974e-06<span class="w">  </span><span class="m">1</span>.40150227e-02
<span class="w"> </span>-7.58499027e-06<span class="w">  </span><span class="m">9</span>.07906622e-04<span class="w">  </span><span class="m">2</span>.58140676e-06<span class="w">  </span><span class="m">1</span>.40205137e-02
<span class="w">  </span><span class="m">5</span>.15393389e-04<span class="w">  </span><span class="m">4</span>.25452046e-04<span class="w"> </span>-2.52626487e-03<span class="w">  </span><span class="m">5</span>.41330352e-02
<span class="w">  </span><span class="m">1</span>.68450730e-04<span class="w"> </span>-1.45874014e-06<span class="w">  </span><span class="m">2</span>.46176114e-05<span class="w"> </span>-5.74097339e-06
<span class="w"> </span>-6.37176697e-07<span class="w">  </span><span class="m">1</span>.41116643e-05<span class="w"> </span>-6.13132488e-06<span class="w"> </span>-7.78824597e-06
<span class="w">  </span><span class="m">7</span>.36984774e-04<span class="w"> </span>-1.16545329e-04<span class="w">  </span><span class="m">1</span>.00961029e-06<span class="w">  </span><span class="m">4</span>.41450794e-07
<span class="w"> </span>-5.27810790e-02<span class="w">  </span><span class="m">3</span>.05663864e-03<span class="w">  </span><span class="m">5</span>.34516487e-10<span class="w"> </span>-1.11836842e-08
<span class="w">  </span><span class="m">1</span>.16560805e-08<span class="w">  </span><span class="m">1</span>.39018812e-05<span class="w">  </span><span class="m">1</span>.05607708e-03<span class="w"> </span>-1.11408660e-03
<span class="w">  </span><span class="m">7</span>.64744101e-10<span class="w"> </span>-3.32643208e-06<span class="w">  </span><span class="m">3</span>.05663352e-03<span class="w">  </span><span class="m">5</span>.93083496e-06
<span class="w">  </span><span class="m">4</span>.49250219e-04<span class="w"> </span>-4.74061235e-04<span class="w"> </span>-1.41295470e-06<span class="w">  </span><span class="m">3</span>.50885763e-04<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline"></a></h2>
<p>In this case, the ground state energy of the LiH molecule is obtained by using the quantum neural network in two methods. In the first method, we use the <code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code> function packaged by MindQuantum to generate a quantum neural network that can solve this problem. In the second method, we build a similar quantum neural network step by step. The final results are the same.</p>
</section>
</section>


           </div>
           
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="qnn_for_nlp.html" class="btn btn-neutral float-left" title="The Application of Quantum Neural Network in NLP" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="quantum_phase_estimation.html" class="btn btn-neutral float-right" title="Quantum Phase Estimation Algorithm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>