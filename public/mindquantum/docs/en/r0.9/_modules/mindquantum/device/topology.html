<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindquantum.device.topology &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script><script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/js/theme.js"></script><script src="../../../_static/underscore.js"></script><script src="../../../_static/doctools.js"></script><script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum_install.html">MindSpore Quantum Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../parameterized_quantum_circuit.html">Variational Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quantum_simulator.html">Quantum simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../initial_experience_of_quantum_neural_network.html">Initial experience of quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_gradient_of_PQC_with_mindquantum.html">Advanced gradient calculation of variational quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced_operations_of_quantum_circuit.html">Advanced operations of quantum circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quantum_measurement.html">Quantum Measurement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../noise.html">Noisy Quantum Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../noise_simulator.html">Noise simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qubit_mapping.html">Qubit Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bloch_sphere.html">Bloch Sphere</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variational Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../classification_of_iris_by_qnn.html">Classification of iris by quantum neural network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quantum_approximate_optimization_algorithm.html">Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qnn_for_nlp.html">The Application of Quantum Neural Network in NLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vqe_for_quantum_chemistry.html">VQE Application in Quantum Chemistry Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../equivalence_checking_of_PQC.html">Equivalence Checking of Parameterized Quantum Circuits</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General Quantum Algorithm</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quantum_phase_estimation.html">Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../grover_search_algorithm.html">Grover search and Long algorithms based on MindSpore Quantum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../shor_algorithm.html">Shorâ€™s algorithm based on MindSpore Quantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.dtype.html">mindquantum.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.device.html">mindquantum.device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>mindquantum.device.topology</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mindquantum.device.topology</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2023 Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>
<span class="sd">&quot;&quot;&quot;Qubit node an topology of quantum chip.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">typing</span>

<span class="kn">from</span> <span class="nn">mindquantum.utils.type_value_check</span> <span class="kn">import</span> <span class="n">_check_input_type</span><span class="p">,</span> <span class="n">_check_int_type</span>

<span class="kn">from</span> <span class="nn">..mqbackend.device</span> <span class="kn">import</span> <span class="n">QubitNode</span> <span class="k">as</span> <span class="n">QubitNode_</span>
<span class="kn">from</span> <span class="nn">..mqbackend.device</span> <span class="kn">import</span> <span class="n">QubitsTopology</span> <span class="k">as</span> <span class="n">QubitsTopology_</span>


<div class="viewcode-block" id="QubitNode"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitNode.html#mindquantum.device.QubitNode">[docs]</a><span class="k">class</span> <span class="nc">QubitNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Qubit node.</span>

<span class="sd">    A qubit node has a id, a position and a color (if you want to draw it). You can connect two qubits with</span>
<span class="sd">    &#39;&gt;&gt;&#39; or &#39;&lt;&lt;&#39; and disconnect two qubits with &#39;&lt;&#39; or &#39;&gt;&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        qubit_id (int): the identity number of this qubit.</span>
<span class="sd">        color (str): the face color of this qubit.</span>
<span class="sd">        poi_x (float): x position in canvas.</span>
<span class="sd">        poi_y (float): y position in canvas.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">        &gt;&gt;&gt; q0 = QubitNode(0)</span>
<span class="sd">        &gt;&gt;&gt; q1 = QubitNode(1)</span>
<span class="sd">        &gt;&gt;&gt; q = q0 &lt;&lt; q1</span>
<span class="sd">        &gt;&gt;&gt; q0.qubit_id == q.qubit_id</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;#000000&#39;</span><span class="p">,</span> <span class="n">poi_x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">poi_y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a qubit node.&quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;qubit_id&quot;</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">)</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;poi_x&quot;</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">poi_x</span><span class="p">)</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;poi_y&quot;</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">poi_y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_</span> <span class="o">=</span> <span class="n">qubit_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_</span> <span class="o">=</span> <span class="n">color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poi_x_</span> <span class="o">=</span> <span class="n">poi_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poi_y_</span> <span class="o">=</span> <span class="n">poi_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__get_cpp_obj__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get cpp obj.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QubitNode_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">poi_x_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">poi_y_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;QubitNode&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QubitNode&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnect with other qubit node and return rhs.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (:class:`~.device.QubitNode`): qubit node you want to disconnect with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`~.device.QubitNode`, the right hand size qubit.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology</span>
<span class="sd">            &gt;&gt;&gt; q0 = QubitNode(0)</span>
<span class="sd">            &gt;&gt;&gt; q1 = QubitNode(1)</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([q0, q1])</span>
<span class="sd">            &gt;&gt;&gt; q0 &lt;&lt; q1</span>
<span class="sd">            &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; q0 &gt; q1</span>
<span class="sd">            &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot disconnect itself.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the qubit to int.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int, the id of qubit.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">            &gt;&gt;&gt; q0 = QubitNode(0)</span>
<span class="sd">            &gt;&gt;&gt; int(q0)</span>
<span class="sd">            0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span>

    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;QubitNode&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QubitNode&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect with other qubit node and return lhs.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (:class:`~.device.QubitNode`): qubit node you want to connect with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`~.device.QubitNode`, the left hand size qubit.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology</span>
<span class="sd">            &gt;&gt;&gt; q0 = QubitNode(0)</span>
<span class="sd">            &gt;&gt;&gt; q1 = QubitNode(1)</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([q0, q1])</span>
<span class="sd">            &gt;&gt;&gt; q = q0 &lt;&lt; q1</span>
<span class="sd">            &gt;&gt;&gt; q.qubit_id == q0.qubit_id</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="n">QubitNode</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot disconnect itself.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;QubitNode&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QubitNode&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnect with other qubit node and return lhs.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (:class:`~.device.QubitNode`): qubit node you want to connect with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`~.device.QubitNode`, the left hand size qubit.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology</span>
<span class="sd">            &gt;&gt;&gt; q0 = QubitNode(0)</span>
<span class="sd">            &gt;&gt;&gt; q1 = QubitNode(1)</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([q0, q1])</span>
<span class="sd">            &gt;&gt;&gt; q0 &lt;&lt; q1</span>
<span class="sd">            &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; q = q0 &lt; q1</span>
<span class="sd">            &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; q.qubit_id == q0.qubit_id</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="n">QubitNode</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot disconnect itself.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;QubitNode&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QubitNode&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect with other qubit node and return rhs.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (:class:`~.device.QubitNode`): qubit node you want to connect with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`~.device.QubitNode`, the right hand side qubit.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology</span>
<span class="sd">            &gt;&gt;&gt; q0 = QubitNode(0)</span>
<span class="sd">            &gt;&gt;&gt; q1 = QubitNode(1)</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([q0, q1])</span>
<span class="sd">            &gt;&gt;&gt; q = q0 &gt;&gt; q1</span>
<span class="sd">            &gt;&gt;&gt; q.qubit_id == q1.qubit_id</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="n">QubitNode</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot disconnect itself.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">other</span>

<div class="viewcode-block" id="QubitNode.set_color"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitNode.html#mindquantum.device.QubitNode.set_color">[docs]</a>    <span class="k">def</span> <span class="nf">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the color of this qubit.</span>

<span class="sd">        Args:</span>
<span class="sd">            color (str): The new color.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">            &gt;&gt;&gt; q0 = QubitNode(1)</span>
<span class="sd">            &gt;&gt;&gt; q0.set_color(&#39;#ababab&#39;)</span>
<span class="sd">            &gt;&gt;&gt; q0.color</span>
<span class="sd">            &#39;#ababab&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_</span> <span class="o">=</span> <span class="n">color</span></div>

<div class="viewcode-block" id="QubitNode.set_poi"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitNode.html#mindquantum.device.QubitNode.set_poi">[docs]</a>    <span class="k">def</span> <span class="nf">set_poi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poi_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">poi_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the position of this qubit.</span>

<span class="sd">        Args:</span>
<span class="sd">            poi_x (float): x position of qubit in canvas.</span>
<span class="sd">            poi_y (float): y position of qubit in canvas.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">            &gt;&gt;&gt; q0 = QubitNode(1, poi_x=0, poi_y=1)</span>
<span class="sd">            &gt;&gt;&gt; q0.set_poi(1, 0)</span>
<span class="sd">            &gt;&gt;&gt; print(q0.poi_x, q0.poi_y)</span>
<span class="sd">            1 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;poi_x&quot;</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">poi_x</span><span class="p">)</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;poi_y&quot;</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">poi_y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poi_x_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">poi_y_</span> <span class="o">=</span> <span class="n">poi_x</span><span class="p">,</span> <span class="n">poi_y</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the color of this qubit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str, the color of qubit node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qubit_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the id of this qubit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int, the id of this qubit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">poi_x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        X position of this qubit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float, the x position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">poi_x_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">poi_y</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Y position of this qubit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float, the y position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">poi_y_</span></div>


<div class="viewcode-block" id="QubitsTopology"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology">[docs]</a><span class="k">class</span> <span class="nc">QubitsTopology</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Topology of qubit in physical device.</span>

<span class="sd">    Topology is construct by different :class:`~.device.QubitNode`, and you</span>
<span class="sd">    can set the property of each qubit node directly.</span>

<span class="sd">    Args:</span>
<span class="sd">        qubits (List[:class:`~.device.QubitNode`]): All qubit nodes in this topology.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindquantum.device import QubitsTopology</span>
<span class="sd">        &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">        &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">        &gt;&gt;&gt; topology[0] &gt;&gt; topology[1]</span>
<span class="sd">        &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; topology.set_color(0, &quot;#121212&quot;)</span>
<span class="sd">        &gt;&gt;&gt; topology[0].color</span>
<span class="sd">        &#39;#121212&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">QubitNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a physical qubit topology.&quot;&quot;&quot;</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;qubits&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
            <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;Element of qubits&quot;</span><span class="p">,</span> <span class="n">QubitNode</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">QubitNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">qubit_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Qubit with id </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">qubit_id</span><span class="si">}</span><span class="s2"> already exists.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QubitNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get qubit node base on qubit id.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit_id (int), the identity number of qubit you want.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`~.device.QubitNode`, the qubit node with given id.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology[2].qubit_id</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;qubit_id&quot;</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">[</span><span class="n">qubit_id</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__get_cpp_obj__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get cpp object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QubitsTopology_</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">__get_cpp_obj__</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

<div class="viewcode-block" id="QubitsTopology.add_qubit_node"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.add_qubit_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_qubit_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit</span><span class="p">:</span> <span class="n">QubitNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a qubit node into this topology.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit (:class:`~.device.QubitNode`): the qubit you want to add into this topology.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(2)])</span>
<span class="sd">            &gt;&gt;&gt; topology.add_qubit_node(QubitNode(2));</span>
<span class="sd">            &gt;&gt;&gt; topology.all_qubit_id()</span>
<span class="sd">            {0, 1, 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;qubit&quot;</span><span class="p">,</span> <span class="n">QubitNode</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qubit</span><span class="o">.</span><span class="n">qubit_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Qubit with id </span><span class="si">{</span><span class="n">qubit</span><span class="o">.</span><span class="n">qubit_id</span><span class="si">}</span><span class="s2"> already exists.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">[</span><span class="n">qubit</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">qubit</span></div>

<div class="viewcode-block" id="QubitsTopology.all_qubit_id"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.all_qubit_id">[docs]</a>    <span class="k">def</span> <span class="nf">all_qubit_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all qubit id.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Set[int], all qubit id in this qubit topology.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(2)])</span>
<span class="sd">            &gt;&gt;&gt; topology.add_qubit_node(QubitNode(2));</span>
<span class="sd">            &gt;&gt;&gt; topology.all_qubit_id()</span>
<span class="sd">            {0, 1, 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="QubitsTopology.compress"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.compress">[docs]</a>    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;QubitsTopology&quot;</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Relabeling the qubit id so that the qubit id in new topology will start from 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[QubitsTopology, Dict[int, int]], the first element of return is the new compressed topology,</span>
<span class="sd">                and the second element of return is the qubit id map with key be the qubit id in old topology and</span>
<span class="sd">                value be the qubit id in new topology.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import LinearQubits</span>
<span class="sd">            &gt;&gt;&gt; topo1 = LinearQubits(5)</span>
<span class="sd">            &gt;&gt;&gt; topo1.remove_qubit_node(0)</span>
<span class="sd">            &gt;&gt;&gt; topo1.remove_qubit_node(2)</span>
<span class="sd">            &gt;&gt;&gt; topo2, qubit_map = topo1.compress()</span>
<span class="sd">            &gt;&gt;&gt; print(topo2.edges_with_id())</span>
<span class="sd">            {(1, 2)}</span>
<span class="sd">            &gt;&gt;&gt; print(qubit_map)</span>
<span class="sd">            {1: 0, 3: 1, 4: 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">topo_dup</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">old_id</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_qubit_id</span><span class="p">())</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">topo_dup</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">old_id</span><span class="p">)</span>
        <span class="n">old_new_id_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">old_id</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">qid</span> <span class="ow">in</span> <span class="n">old_id</span><span class="p">:</span>
            <span class="n">topo_dup</span><span class="o">.</span><span class="n">isolate_with_near</span><span class="p">(</span><span class="n">qid</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">id_</span> <span class="o">=</span> <span class="n">old_new_id_dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id_</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">QubitsTopology</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_with_id</span><span class="p">():</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">old_new_id_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;&gt;</span> <span class="n">out</span><span class="p">[</span><span class="n">old_new_id_dict</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">old_new_id_dict</span></div>

<div class="viewcode-block" id="QubitsTopology.edges_with_id"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.edges_with_id">[docs]</a>    <span class="k">def</span> <span class="nf">edges_with_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get edges with id of two connected qubits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Set[Tuple[int, int]], all connected edges in this qubit topology.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(2)])</span>
<span class="sd">            &gt;&gt;&gt; topology[0] &lt;&lt; topology[1]</span>
<span class="sd">            &gt;&gt;&gt; topology.edges_with_id()</span>
<span class="sd">            {(0, 1)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">qubit1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">qid_2</span> <span class="ow">in</span> <span class="n">qubit1</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">qubit1</span><span class="o">.</span><span class="n">qubit_id</span> <span class="o">&gt;</span> <span class="n">qid_2</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">qid_2</span><span class="p">,</span> <span class="n">qubit1</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">qubit1</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">,</span> <span class="n">qid_2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="QubitsTopology.edges_with_poi"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.edges_with_poi">[docs]</a>    <span class="k">def</span> <span class="nf">edges_with_poi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get edges with position of two connected qubits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Set[Tuple[Tuple[float, float], Tuple[float, float]]], the x and y position of two connected qubits.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitNode, QubitsTopology</span>
<span class="sd">            &gt;&gt;&gt; q0 = QubitNode(0, poi_x=0, poi_y=0)</span>
<span class="sd">            &gt;&gt;&gt; q1 = QubitNode(1, poi_x=1, poi_y=0)</span>
<span class="sd">            &gt;&gt;&gt; q0 &gt;&gt; q1</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([q0, q1])</span>
<span class="sd">            &gt;&gt;&gt; topology.edges_with_poi()</span>
<span class="sd">            {((0, 0), (1, 0))}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">q_id_1</span><span class="p">,</span> <span class="n">q_id_2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_with_id</span><span class="p">():</span>
            <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">[</span><span class="n">q_id_1</span><span class="p">]</span>
            <span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">[</span><span class="n">q_id_2</span><span class="p">]</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">(((</span><span class="n">q1</span><span class="o">.</span><span class="n">poi_x</span><span class="p">,</span> <span class="n">q1</span><span class="o">.</span><span class="n">poi_y</span><span class="p">),</span> <span class="p">(</span><span class="n">q2</span><span class="o">.</span><span class="n">poi_x</span><span class="p">,</span> <span class="n">q2</span><span class="o">.</span><span class="n">poi_y</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="QubitsTopology.has_qubit_node"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.has_qubit_node">[docs]</a>    <span class="k">def</span> <span class="nf">has_qubit_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether a qubit is in this topology.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit_id (int): the id of qubit you want to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool, whether this topology has qubit node with given id.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(2)])</span>
<span class="sd">            &gt;&gt;&gt; topology.has_qubit_node(0)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;qubit_id&quot;</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qubit_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span></div>

<div class="viewcode-block" id="QubitsTopology.is_coupled_with"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.is_coupled_with">[docs]</a>    <span class="k">def</span> <span class="nf">is_coupled_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">id2</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether two qubit nodes are coupled.</span>

<span class="sd">        Args:</span>
<span class="sd">            id1 (int): the id of one qubit you want to check.</span>
<span class="sd">            id2 (int): the id of the other qubit you want to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool, whether two qubits node with given ids coupled.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(2)])</span>
<span class="sd">            &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; topology[0] &gt;&gt; topology[1]</span>
<span class="sd">            &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;id1&quot;</span><span class="p">,</span> <span class="n">id1</span><span class="p">)</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;id2&quot;</span><span class="p">,</span> <span class="n">id2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">id2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">[</span><span class="n">id1</span><span class="p">]</span><span class="o">.</span><span class="n">neighbor</span></div>

<div class="viewcode-block" id="QubitsTopology.isolate_with_near"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.isolate_with_near">[docs]</a>    <span class="k">def</span> <span class="nf">isolate_with_near</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnect with all coupling qubits.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit_id (int): the id of qubit you want to disconnect with all nearby qubits.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology[0] &gt;&gt; topology[1] &gt;&gt; topology[2]</span>
<span class="sd">            &gt;&gt;&gt; topology.edges_with_id()</span>
<span class="sd">            {(0, 1), (1, 2)}</span>
<span class="sd">            &gt;&gt;&gt; topology.isolate_with_near(1)</span>
<span class="sd">            &gt;&gt;&gt; topology.edges_with_id()</span>
<span class="sd">            set()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;qubit_id&quot;</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">)</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">qubit_id</span><span class="p">]</span>
        <span class="n">other_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">current_node</span><span class="o">.</span><span class="n">neighbor</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">other_nodes</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">node</span> <span class="o">&gt;</span> <span class="n">current_node</span></div>

<div class="viewcode-block" id="QubitsTopology.n_edges"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.n_edges">[docs]</a>    <span class="k">def</span> <span class="nf">n_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get total connected edge number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int, the edge number of this qubit topology.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology[0] &gt;&gt; topology[1] &gt;&gt; topology[2]</span>
<span class="sd">            &gt;&gt;&gt; topology.n_edges()</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="QubitsTopology.choose"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.choose">[docs]</a>    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">QubitNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Choose qubit nodes based on given qubit id.</span>

<span class="sd">        Args:</span>
<span class="sd">            ids (List[int]): A list of qubit node id.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[:class:`~.device.QubitNode`], a list of qubit node based on given qubit node id.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology[0] &gt;&gt; topology[1] &gt;&gt; topology[2]</span>
<span class="sd">            &gt;&gt;&gt; nodes = topology.choose([0, 1])</span>
<span class="sd">            &gt;&gt;&gt; print(nodes[0].qubit_id, nodes[1].qubit_id)</span>
<span class="sd">            0 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;ids&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qubit_id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;Element of ids&quot;</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">]</span></div>

<div class="viewcode-block" id="QubitsTopology.remove_isolate_node"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.remove_isolate_node">[docs]</a>    <span class="k">def</span> <span class="nf">remove_isolate_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove qubit node that do not connect with any other qubits.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology[0] &gt;&gt; topology[1] &gt;&gt; topology[2]</span>
<span class="sd">            &gt;&gt;&gt; topology.edges_with_id()</span>
<span class="sd">            {(0, 1), (1, 2)}</span>
<span class="sd">            &gt;&gt;&gt; topology.isolate_with_near(1)</span>
<span class="sd">            &gt;&gt;&gt; topology.all_qubit_id()</span>
<span class="sd">            {0, 1, 2}</span>
<span class="sd">            &gt;&gt;&gt; topology.remove_isolate_node()</span>
<span class="sd">            &gt;&gt;&gt; topology.all_qubit_id()</span>
<span class="sd">            set()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">will_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">neighbor</span><span class="p">:</span>
                <span class="n">will_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">qubit_id</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qubit_id</span> <span class="ow">in</span> <span class="n">will_remove</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">qubit_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="QubitsTopology.remove_qubit_node"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.remove_qubit_node">[docs]</a>    <span class="k">def</span> <span class="nf">remove_qubit_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a qubit node out of this topology.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit_id (int): the id of qubit you want to remove.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology.remove_qubit_node(1)</span>
<span class="sd">            &gt;&gt;&gt; topology.all_qubit_id()</span>
<span class="sd">            {0, 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;qubit_id&quot;</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">)</span>
        <span class="n">will_remove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">[</span><span class="n">qubit_id</span><span class="p">]</span>
        <span class="n">near_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">will_remove</span><span class="o">.</span><span class="n">neighbor</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">near_qubits</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">node</span> <span class="o">&gt;</span> <span class="n">will_remove</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">qubit_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="QubitsTopology.select"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;QubitsTopology&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select certain qubit nodes to generate a new topology.</span>

<span class="sd">        Args:</span>
<span class="sd">            ids (List[int]): A list of qubit node id.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`~.device.QubitsTopology`, a new topology while keeping the connection property.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import LinearQubits</span>
<span class="sd">            &gt;&gt;&gt; t1 = LinearQubits(4)</span>
<span class="sd">            &gt;&gt;&gt; t2 = t1.select([0, 1, 2])</span>
<span class="sd">            &gt;&gt;&gt; t2.edges_with_id()</span>
<span class="sd">            {(0, 1), (1, 2)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">ids</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">neighbor</span> <span class="o">&amp;=</span> <span class="n">ids_set</span>
        <span class="k">return</span> <span class="n">QubitsTopology</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="QubitsTopology.set_color"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.set_color">[docs]</a>    <span class="k">def</span> <span class="nf">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set color of certain qubit.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit_id (int): the id of qubit you want to change color.</span>
<span class="sd">            color (str): the new color.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology.set_color(0, &quot;#ababab&quot;)</span>
<span class="sd">            &gt;&gt;&gt; topology[0].color</span>
<span class="sd">            &#39;#ababab&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;qubit_id&quot;</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">)</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">qubit_id</span><span class="p">]</span><span class="o">.</span><span class="n">color_</span> <span class="o">=</span> <span class="n">color</span></div>

<div class="viewcode-block" id="QubitsTopology.set_position"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.set_position">[docs]</a>    <span class="k">def</span> <span class="nf">set_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">poi_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">poi_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set position of a certain qubit.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit_id (int): the id of qubit you want to change position.</span>
<span class="sd">            poi_x (float): new x position.</span>
<span class="sd">            poi_y (float): new y position.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology.set_position(0, 1, 1)</span>
<span class="sd">            &gt;&gt;&gt; topology[0].poi_x, topology[0].poi_y</span>
<span class="sd">            (1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;qubit_id&quot;</span><span class="p">,</span> <span class="n">qubit_id</span><span class="p">)</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;poi_x&quot;</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">poi_x</span><span class="p">)</span>
        <span class="n">_check_input_type</span><span class="p">(</span><span class="s2">&quot;poi_y&quot;</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">poi_y</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">qubit_id</span><span class="p">]</span><span class="o">.</span><span class="n">set_poi</span><span class="p">(</span><span class="n">poi_x</span><span class="p">,</span> <span class="n">poi_y</span><span class="p">)</span></div>

<div class="viewcode-block" id="QubitsTopology.size"><a class="viewcode-back" href="../../../device/mindquantum.device.QubitsTopology.html#mindquantum.device.QubitsTopology.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get total qubit number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int, the total qubit number.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import QubitsTopology, QubitNode</span>
<span class="sd">            &gt;&gt;&gt; topology = QubitsTopology([QubitNode(i) for i in range(3)])</span>
<span class="sd">            &gt;&gt;&gt; topology.size()</span>
<span class="sd">            3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LinearQubits"><a class="viewcode-back" href="../../../device/mindquantum.device.LinearQubits.html#mindquantum.device.LinearQubits">[docs]</a><span class="k">class</span> <span class="nc">LinearQubits</span><span class="p">(</span><span class="n">QubitsTopology</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear qubit topology.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_qubits (int): total qubit size.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindquantum.device import LinearQubits</span>
<span class="sd">        &gt;&gt;&gt; topology = LinearQubits(5)</span>
<span class="sd">        &gt;&gt;&gt; topology.is_coupled_with(0, 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; topology.is_coupled_with(0, 2)</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a linear topology.&quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;n_qubits&quot;</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">QubitNode</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">poi_x</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)]</span>
        <span class="n">left_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">left_node</span> <span class="o">=</span> <span class="n">left_node</span> <span class="o">&gt;&gt;</span> <span class="n">node</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="GridQubits"><a class="viewcode-back" href="../../../device/mindquantum.device.GridQubits.html#mindquantum.device.GridQubits">[docs]</a><span class="k">class</span> <span class="nc">GridQubits</span><span class="p">(</span><span class="n">QubitsTopology</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Grid qubit topology.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_row (int): how many rows of your grid qubits.</span>
<span class="sd">        n_col (int): how many columns of your grid quits.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindquantum.device import GridQubits</span>
<span class="sd">        &gt;&gt;&gt; topology = GridQubits(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; topology.n_row()</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_row</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_col</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a grid topology with row and col number.&quot;&quot;&quot;</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;n_row&quot;</span><span class="p">,</span> <span class="n">n_row</span><span class="p">)</span>
        <span class="n">_check_int_type</span><span class="p">(</span><span class="s2">&quot;n_col&quot;</span><span class="p">,</span> <span class="n">n_col</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_row_</span> <span class="o">=</span> <span class="n">n_row</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_col_</span> <span class="o">=</span> <span class="n">n_col</span>
        <span class="n">qubits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_row</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_col</span><span class="p">):</span>
                <span class="n">qubits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">QubitNode</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">n_col</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">poi_x</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">poi_y</span><span class="o">=</span><span class="n">r</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_row</span><span class="p">):</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">qubits</span><span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">n_col</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">next_node</span> <span class="o">=</span> <span class="n">next_node</span> <span class="o">&gt;&gt;</span> <span class="n">qubits</span><span class="p">[</span><span class="n">next_node</span><span class="o">.</span><span class="n">qubit_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_col</span><span class="p">):</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">qubits</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">next_node</span> <span class="o">=</span> <span class="n">next_node</span> <span class="o">&gt;&gt;</span> <span class="n">qubits</span><span class="p">[</span><span class="n">next_node</span><span class="o">.</span><span class="n">qubit_id</span> <span class="o">+</span> <span class="n">n_col</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<div class="viewcode-block" id="GridQubits.n_col"><a class="viewcode-back" href="../../../device/mindquantum.device.GridQubits.html#mindquantum.device.GridQubits.n_col">[docs]</a>    <span class="k">def</span> <span class="nf">n_col</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get column number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int, the column number.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import GridQubits</span>
<span class="sd">            &gt;&gt;&gt; topology = GridQubits(2, 3)</span>
<span class="sd">            &gt;&gt;&gt; topology.n_col()</span>
<span class="sd">            3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_col_</span></div>

<div class="viewcode-block" id="GridQubits.n_row"><a class="viewcode-back" href="../../../device/mindquantum.device.GridQubits.html#mindquantum.device.GridQubits.n_row">[docs]</a>    <span class="k">def</span> <span class="nf">n_row</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get row number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int, the row number.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from mindquantum.device import GridQubits</span>
<span class="sd">            &gt;&gt;&gt; topology = GridQubits(2, 3)</span>
<span class="sd">            &gt;&gt;&gt; topology.n_row()</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_row_</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>