<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>通过量子神经网络对鸢尾花进行分类 &mdash; MindSpore master 文档</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script><script src="_static/jquery.js"></script>
        <script src="_static/js/theme.js"></script><script src="_static/underscore.js"></script><script src="_static/doctools.js"></script><script src="_static/translations.js"></script><script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script><script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="量子近似优化算法" href="quantum_approximate_optimization_algorithm.html" />
    <link rel="prev" title="布洛赫球" href="bloch_sphere.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">安装部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">安装MindSpore Quantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">基础使用指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">变分量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_simulator.html">量子模拟器</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">量子神经网络初体验</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">变分量子线路梯度计算进阶</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_operations_of_quantum_circuit.html">量子线路高阶操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_measurement.html">量子测量</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">含噪声量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_simulator.html">噪声模拟器</a></li>
<li class="toctree-l1"><a class="reference internal" href="qubit_mapping.html">比特映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="bloch_sphere.html">布洛赫球</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">变分量子算法</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">通过量子神经网络对鸢尾花进行分类</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#概述">概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#环境准备">环境准备</a></li>
<li class="toctree-l2"><a class="reference internal" href="#数据图像化">数据图像化</a></li>
<li class="toctree-l2"><a class="reference internal" href="#数据预处理">数据预处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="#搭建encoder">搭建Encoder</a></li>
<li class="toctree-l2"><a class="reference internal" href="#搭建ansatz">搭建Ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="#构建哈密顿量">构建哈密顿量</a></li>
<li class="toctree-l2"><a class="reference internal" href="#搭建量子神经网络">搭建量子神经网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="#训练">训练</a></li>
<li class="toctree-l2"><a class="reference internal" href="#训练过程中的准确率">训练过程中的准确率</a></li>
<li class="toctree-l2"><a class="reference internal" href="#预测">预测</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">量子近似优化算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">量子神经网络在自然语言处理中的应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">在量子化学计算中应用量子变分求解器</a></li>
<li class="toctree-l1"><a class="reference internal" href="equivalence_checking_of_PQC.html">含参量子线路的等价性检查</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">通用量子算法</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">量子相位估计算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">基于MindSpore Quantum的Grover搜索算法和龙算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">基于MindSpore Quantum的Shor算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="hhl_algorithm.html">HHL 算法</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">总览</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.dtype.html">mindquantum.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.device.html">mindquantum.device</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>通过量子神经网络对鸢尾花进行分类</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/classification_of_iris_by_qnn.ipynb.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="通过量子神经网络对鸢尾花进行分类">
<h1>通过量子神经网络对鸢尾花进行分类<a class="headerlink" href="#通过量子神经网络对鸢尾花进行分类" title="永久链接至标题"></a></h1>
<p><a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/zh_cn/mindspore_classification_of_iris_by_qnn.ipynb"><img alt="下载Notebook" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_notebook.png" /></a>  <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/zh_cn/mindspore_classification_of_iris_by_qnn.py"><img alt="下载样例代码" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_download_code.png" /></a>  <a class="reference external" href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_zh_cn/classification_of_iris_by_qnn.ipynb"><img alt="查看源文件" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source.png" /></a></p>
<section id="概述">
<h2>概述<a class="headerlink" href="#概述" title="永久链接至标题"></a></h2>
<p>在之前的案例中，我们介绍了什么是变分量子线路，并通过一个简单的例子体验了如何搭建量子神经网络来解决一个小问题。在本文档中，我们将体验升级，将会介绍如何通过搭建量子神经网络来解决经典机器学习中的问题。我们选取的问题是：监督学习中的鸢尾花分类问题。</p>
<p>问题描述：鸢尾花（iris）数据集是经典机器学习中常用的数据集，该数据集总共包含150个样本（分为3种不同的亚属：山鸢尾（setosa）、杂色鸢尾（versicolor）和维吉尼亚鸢尾（virginica），每个亚属各有50个样本），每个样本包含4个特征，分别为花萼长度（sepal length）、花萼宽度（sepal width）和花瓣长度（petal length）、花瓣宽度（petal width）。</p>
<p>我们选取前100个样本（山鸢尾（setosa）和杂色鸢尾（versicolor）），并随机抽取80个样本作为训练集，通过搭建量子神经网络对量子分类器（Ansatz）进行训练，学习完成后，对剩余的20个样本进行分类测试，期望预测的准确率尽可能高。</p>
<p>思路：我们需要将100个样本进行划分，分成80个训练样本和20个测试样本，根据训练样本的经典数据计算搭建Encoder所需的参数，然后，搭建Encoder，将训练样本的经典数据编码到量子态上，接着，搭建Ansatz，通过搭建的量子神经网络层和MindSpore的算子对Ansatz中的参数进行训练，进而得到最终的分类器，最后，对剩余的20个测试样本进行分类测试，得到预测的准确率。</p>
</section>
<section id="环境准备">
<h2>环境准备<a class="headerlink" href="#环境准备" title="永久链接至标题"></a></h2>
<p>首先，我们需要导入鸢尾花的数据集，而在导入该数据集前，我们需要使用sklearn库中的datasets模块，因此读者需要检查是否安装了sklearn库，可执行如下代码进行安装。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>show<span class="w"> </span>scikit-learn
</pre></div>
</div>
<p>若无报错，则表明已安装。简单说明一下，sklearn是scikit-learn的简称，是一个基于Python的第三方模块。sklearn库集成了一些常用的机器学习方法，在进行机器学习任务时，并不需要实现算法，只需要简单的调用sklearn库中提供的模块就能完成大多数的机器学习任务。</p>
<p>若未安装sklearn库，则可通过运行如下代码来安装。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>scikit-learn
</pre></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>                                        <span class="c1"># 导入numpy库并简写为np</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>                              <span class="c1"># 导入datasets模块，用于加载鸢尾花的数据集</span>

<span class="n">iris_dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>                       <span class="c1"># 加载鸢尾花的数据集，并存在iris_dataset</span>

<span class="nb">print</span><span class="p">(</span><span class="n">iris_dataset</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                            <span class="c1"># 打印iris_dataset的样本的数据维度</span>
<span class="nb">print</span><span class="p">(</span><span class="n">iris_dataset</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>                         <span class="c1"># 打印iris_dataset的样本的特征名称</span>
<span class="nb">print</span><span class="p">(</span><span class="n">iris_dataset</span><span class="o">.</span><span class="n">target_names</span><span class="p">)</span>                          <span class="c1"># 打印iris_dataset的样本包含的亚属名称</span>
<span class="nb">print</span><span class="p">(</span><span class="n">iris_dataset</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>                                <span class="c1"># 打印iris_dataset的样本的标签的数组</span>
<span class="nb">print</span><span class="p">(</span><span class="n">iris_dataset</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                          <span class="c1"># 打印iris_dataset的样本的标签的数据维度</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(150, 4)
[&#39;sepal length (cm)&#39;, &#39;sepal width (cm)&#39;, &#39;petal length (cm)&#39;, &#39;petal width (cm)&#39;]
[&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]
(150,)
</pre></div></div>
</div>
<p>从上述打印可以看到，该数据集共有150个样本，每个样本均有4个特征，分别为花萼长度（sepal length）、花萼宽度（sepal width）和花瓣长度（petal length）、花瓣宽度（petal width）。同时样本包含3种不同的亚属：山鸢尾（setosa）、杂色鸢尾（versicolor）和维吉尼亚鸢尾（virginica），每个样本有对应的分类编号，0表示样本属于setosa，1表示样本属于versicolor，2表示样本属于virginica，因此有一个由150个数字组成的数组来表示样本的亚属类型。</p>
<p>由于我们只选取前100个样本，因此执行如下命令。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">iris_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="mi">100</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>         <span class="c1"># 选取iris_dataset的data的前100个数据，将其数据类型转换为float32，并储存在X中</span>
<span class="n">X_feature_names</span> <span class="o">=</span> <span class="n">iris_dataset</span><span class="o">.</span><span class="n">feature_names</span>              <span class="c1"># 将iris_dataset的特征名称储存在X_feature_names中</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">iris_dataset</span><span class="o">.</span><span class="n">target</span><span class="p">[:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>                 <span class="c1"># 选取iris_dataset的target的前100个数据，将其数据类型转换为int，并储存在y中</span>
<span class="n">y_target_names</span> <span class="o">=</span> <span class="n">iris_dataset</span><span class="o">.</span><span class="n">target_names</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>            <span class="c1"># 选取iris_dataset的target_names的前2个数据，并储存在y_target_names中</span>

<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                                            <span class="c1"># 打印样本的数据维度</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_feature_names</span><span class="p">)</span>                                    <span class="c1"># 打印样本的特征名称</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y_target_names</span><span class="p">)</span>                                     <span class="c1"># 打印样本包含的亚属名称</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>                                                  <span class="c1"># 打印样本的标签的数组</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                                            <span class="c1"># 打印样本的标签的数据维度</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(100, 4)
[&#39;sepal length (cm)&#39;, &#39;sepal width (cm)&#39;, &#39;petal length (cm)&#39;, &#39;petal width (cm)&#39;]
[&#39;setosa&#39; &#39;versicolor&#39;]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
(100,)
</pre></div></div>
</div>
<p>从上述打印可以看到，此时的数据集<code class="docutils literal notranslate"><span class="pre">X</span></code>中只有100个样本，每个样本依然有4个特征，仍为花萼长度（sepal length）、花萼宽度（sepal width）和花瓣长度（petal length）、花瓣宽度（petal width）。此时只有2种不同的亚属：山鸢尾（setosa）和杂色鸢尾（versicolor），并且每一个样本有对应的分类编号，0表示它属于setosa，1表示它属于versicolor，因此有一个由100个数字组成的数组来表示样本的亚属类型。</p>
</section>
<section id="数据图像化">
<h2>数据图像化<a class="headerlink" href="#数据图像化" title="永久链接至标题"></a></h2>
<p>为了更加直观地了解这100个样本组成的数据集，我们画出所有样本不同特征之间组成的散点图，执行如下命令。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>                                                           <span class="c1"># 导入matplotlib.pyplot模块并简写为plt</span>

<span class="n">feature_name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;sepal length&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;sepal width&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;petal length&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;petal width&#39;</span><span class="p">}</span> <span class="c1"># 将不同的特征名称分别标记为0,1,2,3</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>                                        <span class="c1"># 画出一个大小为23*23的图，包含4*4=16个子图</span>

<span class="n">colormap</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;g&#39;</span><span class="p">}</span>                                                               <span class="c1"># 将标签为0的样本设为红色，标签为1的样本设为绿色</span>
<span class="n">cvalue</span> <span class="o">=</span> <span class="p">[</span><span class="n">colormap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>                                                         <span class="c1"># 将100个样本对应的标签设置相应的颜色</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>                                                               <span class="c1"># 在[i][j]的子图上开始画图</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">cvalue</span><span class="p">)</span>                                        <span class="c1"># 画出第[i]个特征和第[j]个特征组成的散点图</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">feature_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span>                                   <span class="c1"># 设置X轴的名称为第[i]个特征名称，字体大小为22</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">feature_name</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span>                                   <span class="c1"># 设置Y轴的名称为第[j]个特征名称，字体大小为22</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                                                                                <span class="c1"># 渲染图像，即呈现图像</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/classification_of_iris_by_qnn_8_0.png" src="_images/classification_of_iris_by_qnn_8_0.png" />
</div>
</div>
<p>从上述呈现的图像可以看到，红色的点表示标签为“0”的样本，绿色的点表示标签为“1”的样本，另外，我们发现，这两类样本的不同特征还是比较容易区分的。</p>
</section>
<section id="数据预处理">
<h2>数据预处理<a class="headerlink" href="#数据预处理" title="永久链接至标题"></a></h2>
<p>接下来，我们需要计算生成搭建Encoder时所要用到的参数，然后将数据集划分为训练集和测试集，执行如下命令。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>           <span class="c1"># 每一个样本中，利用相邻两个特征值计算出一个参数，即每一个样本会多出3个参数（因为有4个特征值），并储存在alpha中</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># 在axis=1的维度上，将alpha的数据值添加到X的特征值中</span>

<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                        <span class="c1"># 打印此时X的样本的数据维度</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(100, 7)
</pre></div></div>
</div>
<p>从上述打印可以看到，此时的数据集<code class="docutils literal notranslate"><span class="pre">X</span></code>中仍有100个样本，但此时每个样本却有7个特征，前4个特征值就是原来的特征值，后3个特征值就是通过上述预处理计算得到的特征值，其具体计算公式如下：</p>
<div class="math notranslate nohighlight">
\[X_{i+4}^{j} = X_{i}^{j} * X_{i+1}^{j}, i=0,1,2,j=1,2,...,100.\]</div>
<p>最后，我们将此时的数据集分为训练集和测试集，执行如下命令。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>                                                   <span class="c1"># 导入train_test_split函数，用于对数据集进行划分</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># 将数据集划分为训练集和测试集</span>

<span class="nb">print</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                                                                                   <span class="c1"># 打印训练集中样本的数据类型</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                                                                                    <span class="c1"># 打印测试集中样本的数据类型</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(80, 7)
(20, 7)
</pre></div></div>
</div>
<p>从上述打印可以看到，此时的训练集有80个样本，测试集有20个样本，每个样本均有7个特征。</p>
<p>说明：</p>
<p>（1）append主要用于为原始数组添加一些值，一般格式如下：np.append(arr, values, axis=None)，arr是需要被添加值的数组，values就是添加到数组arr中的值，axis表示沿着哪个方向；</p>
<p>（2）shuffle=True表示将数据集打乱，每次都会以不同的顺序返回， shuffle就是为了避免数据投入的顺序对网络训练造成影响。增加随机性，提高网络的泛化性能，避免因为有规律的数据出现，导致权重更新时的梯度过于极端，避免最终模型过拟合或欠拟合。</p>
<p>（3）train_test_split是交叉验证中常用的函数，主要用于是从样本中随机地按比例选取训练数据集和测试数据集，一般格式如下： X_train, X_test, y_train, y_test = train_test_split(X, y, test_size, random_state, shuffle=True)，其中test_size表示测试样本的比例，random_state表示产生随机数的种子，shuffle=True表示将数据集打乱。</p>
</section>
<section id="搭建encoder">
<h2>搭建Encoder<a class="headerlink" href="#搭建encoder" title="永久链接至标题"></a></h2>
<p>根据图示的量子线路图，我们可以在MindSpore Quantum中搭建Encoder，将经典数据编码到量子态上。</p>
<p><img alt="encoder classification of iris by qnn" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_zh_cn/images/encoder_classification_of_iris_by_qnn.png" /></p>
<p>在这里，我们采用的编码方式是IQP编码（Instantaneous Quantum Polynomial encoding），一般来说Encoder的编码方式不固定，可根据问题需要选择不同的编码方式，有时也会根据最后的性能对Encoder进行调整。</p>
<p>Encoder中的参数<span class="math notranslate nohighlight">\(\alpha_0,\alpha_1,...,\alpha_6\)</span>​​的值，就是用上述数据预处理中得到的7个特征值代入。​</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>         <span class="c1"># 导入Circuit模块，用于搭建量子线路</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">UN</span>              <span class="c1"># 导入UN模块</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">RZ</span>          <span class="c1"># 导入量子门H, X, RZ</span>

<span class="n">encoder</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                                  <span class="c1"># 初始化量子线路</span>

<span class="n">encoder</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>                                  <span class="c1"># H门作用在每1位量子比特</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>                                   <span class="c1"># i = 0, 1, 2, 3</span>
    <span class="n">encoder</span> <span class="o">+=</span> <span class="n">RZ</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;alpha</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>                 <span class="c1"># RZ(alpha_i)门作用在第i位量子比特</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>                                   <span class="c1"># j = 0, 1, 2</span>
    <span class="n">encoder</span> <span class="o">+=</span> <span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>                          <span class="c1"># X门作用在第j+1位量子比特，受第j位量子比特控制</span>
    <span class="n">encoder</span> <span class="o">+=</span> <span class="n">RZ</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;alpha</span><span class="si">{</span><span class="n">j</span><span class="o">+</span><span class="mi">4</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>             <span class="c1"># RZ(alpha_{j+4})门作用在第0位量子比特</span>
    <span class="n">encoder</span> <span class="o">+=</span> <span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>                          <span class="c1"># X门作用在第j+1位量子比特，受第j位量子比特控制</span>

<span class="n">encoder</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>                          <span class="c1"># Encoder作为整个量子神经网络的第一层，不用对编码线路中的梯度求导数，因此加入no_grad()</span>
<span class="n">encoder</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>                                    <span class="c1"># 总结Encoder</span>
<span class="n">encoder</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
=================================Circuit Summary=================================
|Total number of gates  : 17.                                                   |
|Parameter gates        : 7.                                                    |
|with 7 parameters are  :                                                       |
|alpha0, alpha1, alpha2, alpha3, alpha4, alpha5, alpha6                        .|
|Number qubit of circuit: 4                                                     |
=================================================================================
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/classification_of_iris_by_qnn_14_1.svg" src="_images/classification_of_iris_by_qnn_14_1.svg" /></div>
</div>
<p>从对Encoder的Summary中可以看到，该量子线路由17个量子门组成，其中有7个含参量子门且参数为<span class="math notranslate nohighlight">\(\alpha_0,\alpha_1,...,\alpha_6\)</span>，该量子线路调控的量子比特数为4。</p>
<p>说明：</p>
<p>UN模块用于将量子门映射到不同的目标量子比特和控制量子比特，一般格式如下：mindquantum.circuit.UN(gate, maps_obj, maps_ctrl=None)，括号中的gate是我们需要执行的量子门，maps_obj是需要执行该量子门的目标量子比特，maps_ctrl是控制量子比特，若为None即无控制量子位。若每个量子比特位执行同一个非参数量子门，则可以直接写出UN(gate, N)，N表示量子比特个数。</p>
</section>
<section id="搭建ansatz">
<h2>搭建Ansatz<a class="headerlink" href="#搭建ansatz" title="永久链接至标题"></a></h2>
<p>根据图示的量子线路图，我们可以在MindSpore Quantum中搭建Ansatz。</p>
<p><img alt="ansatz classification of iris by qnn" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/docs/mindquantum/docs/source_zh_cn/images/ansatz_classification_of_iris_by_qnn.png" /></p>
<p>与Encoder一样，Ansatz的编码方式也不固定，我们可以尝试不同的编码方式来测试最后的结果。</p>
<p>在这里，我们采用的是HardwareEfficientAnsatz，即上述量子线路图所示的编码方式。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">HardwareEfficientAnsatz</span>                                      <span class="c1"># 导入HardwareEfficientAnsatz</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">RY</span>                                                               <span class="c1"># 导入量子门RY</span>

<span class="n">ansatz</span> <span class="o">=</span> <span class="n">HardwareEfficientAnsatz</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">single_rot_gate_seq</span><span class="o">=</span><span class="p">[</span><span class="n">RY</span><span class="p">],</span> <span class="n">entangle_gate</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">circuit</span>     <span class="c1"># 通过HardwareEfficientAnsatz搭建Ansatz</span>
<span class="n">ansatz</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>                                                                                    <span class="c1"># 总结Ansatz</span>
<span class="n">ansatz</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
===================================================Circuit Summary===================================================
|Total number of gates  : 25.                                                                                       |
|Parameter gates        : 16.                                                                                       |
|with 16 parameters are :                                                                                           |
|d0_n0_0, d0_n1_0, d0_n2_0, d0_n3_0, d1_n0_0, d1_n1_0, d1_n2_0, d1_n3_0, d2_n0_0, d2_n1_0..                        .|
|Number qubit of circuit: 4                                                                                         |
=====================================================================================================================
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/classification_of_iris_by_qnn_16_1.svg" src="_images/classification_of_iris_by_qnn_16_1.svg" /></div>
</div>
<p>从对Ansatz的Summary中可以看到，该量子线路由25个量子门组成，其中有16个含参量子门且参数为d2_n3_0, d1_n1_0, d0_n2_0, d1_n0_0, d3_n2_0, d2_n2_0, d0_n1_0, d3_n1_0, d2_n0_0, d3_n0_0…，该量子线路调控的量子比特数为4。</p>
<p>说明：</p>
<p>HardwareEfficientAnsatz是一种容易在量子芯片上实现的Ansatz，其量子线路图由红色虚线框内的量子门组成，一般格式如下：mindquantum.ansatz.HardwareEfficientAnsatz(n_qubits, single_rot_gate_seq, entangle_gate=X, entangle_mapping=“linear”,
depth=1)，括号中的n_qubits表示ansatz需要作用的量子比特总数，single_rot_gate_seq表示一开始每一位量子比特执行的参数门，同时后面需要执行的参数门也固定了，只是参数不同，entangle_gate=X表示执行的纠缠门为X，entangle_mapping=“linear”表示纠缠门将作用于每对相邻量子比特，depth表示黑色虚线框内的量子门需要重复的次数。</p>
<p>那么完整的量子线路就是Encoder加上Ansatz。这里我们调用量子线路的<code class="docutils literal notranslate"><span class="pre">as_encoder</span></code>将量子线路中的所有参数设置为编码参数，调用<code class="docutils literal notranslate"><span class="pre">as_ansatz</span></code>将量子线路中的所有参数设置为待训练参数。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">as_encoder</span><span class="p">()</span> <span class="o">+</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">as_ansatz</span><span class="p">()</span>                  <span class="c1"># 完整的量子线路由Encoder和Ansatz组成</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
================================================Circuit Summary================================================
|Total number of gates  : 42.                                                                                 |
|Parameter gates        : 23.                                                                                 |
|with 23 parameters are :                                                                                     |
|alpha0, alpha1, alpha2, alpha3, alpha4, alpha5, alpha6, d0_n0_0, d0_n1_0, d0_n2_0..                        . |
|Number qubit of circuit: 4                                                                                   |
===============================================================================================================
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/classification_of_iris_by_qnn_18_1.svg" src="_images/classification_of_iris_by_qnn_18_1.svg" /></div>
</div>
<p>从对完整的量子线路的Summary中可以看到，该量子线路由42个量子门组成，其中有23个含参量子门且参数为<span class="math notranslate nohighlight">\(\alpha_0,\alpha_1,...,\alpha_6\)</span>和d2_n3_0, d1_n1_0, d0_n2_0, d1_n0_0, d3_n2_0, d2_n2_0, d0_n1_0, d3_n1_0, d2_n0_0, d3_n0_0…，该量子线路调控的量子比特数为4。</p>
</section>
<section id="构建哈密顿量">
<h2>构建哈密顿量<a class="headerlink" href="#构建哈密顿量" title="永久链接至标题"></a></h2>
<p>我们分别对第2位和第3位量子比特执行泡利<code class="docutils literal notranslate"><span class="pre">Z</span></code>算符测量，构建对应的哈密顿量。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">QubitOperator</span>           <span class="c1"># 导入QubitOperator模块，用于构造泡利算符</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">Hamiltonian</span>             <span class="c1"># 导入Hamiltonian模块，用于构建哈密顿量</span>

<span class="n">hams</span> <span class="o">=</span> <span class="p">[</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="n">QubitOperator</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Z</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>   <span class="c1"># 分别对第2位和第3位量子比特执行泡利Z算符测量，且将系数都设为1，构建对应的哈密顿量</span>
<span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hams</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
1 [Z2]
1 [Z3]
</pre></div></div>
</div>
<p>从上述打印可以看到，此时构建的哈密顿量有2个，分别为对第2位和第3位量子比特执行泡利<code class="docutils literal notranslate"><span class="pre">Z</span></code>算符，且将系数都设为1。通过泡利<code class="docutils literal notranslate"><span class="pre">Z</span></code>算符测量，我们可以得到2个哈密顿量测量值，若第1个测量值更大，则会将此样本归类到标签为“0”的类，同理，若第2个测量值更大，则会将此样本归类到标签为“1”的类。通过神经网络的训练，期望训练样本中标签为“0”的样本的第1个测量值更大，而标签为“1”的样本的第2个测量值更大，最后应用此模型来预测新样本的分类。</p>
</section>
<section id="搭建量子神经网络">
<h2>搭建量子神经网络<a class="headerlink" href="#搭建量子神经网络" title="永久链接至标题"></a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>                                                                         <span class="c1"># 导入mindspore库并简写为ms</span>
<span class="kn">from</span> <span class="nn">mindquantum.framework</span> <span class="kn">import</span> <span class="n">MQLayer</span>                                                      <span class="c1"># 导入MQLayer</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>
<span class="n">ms</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                                                                                 <span class="c1"># 设置生成随机数的种子</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>
<span class="n">grad_ops</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">hams</span><span class="p">,</span>
                                         <span class="n">circuit</span><span class="p">,</span>
                                         <span class="n">parallel_worker</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">QuantumNet</span> <span class="o">=</span> <span class="n">MQLayer</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">)</span>          <span class="c1"># 搭建量子神经网络</span>
<span class="n">QuantumNet</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
MQLayer&lt;
  (evolution): MQOps&lt;4 qubits mqvector VQA Operator&gt;
  &gt;
</pre></div></div>
</div>
<p>从上述打印可以看到，我们已经成功搭建了量子机器学习层，其可以无缝地跟MindSpore中其它的算子构成一张更大的机器学习网络。</p>
<p>说明：</p>
<p>MindSpore是一个全场景深度学习框架，旨在实现易开发、高效执行、全场景覆盖三大目标，提供支持异构加速的张量可微编程能力，支持云、服务器、边和端多种硬件平台.</p>
</section>
<section id="训练">
<h2>训练<a class="headerlink" href="#训练" title="永久链接至标题"></a></h2>
<p>接下来，我们需要定义损失函数，设定需要优化的参数，然后将搭建好的量子机器学习层和MindSpore的算子组合，构成一张更大的机器学习网络，最后对该模型进行训练。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore.nn</span> <span class="kn">import</span> <span class="n">SoftmaxCrossEntropyWithLogits</span>                         <span class="c1"># 导入SoftmaxCrossEntropyWithLogits模块，用于定义损失函数</span>
<span class="kn">from</span> <span class="nn">mindspore.nn</span> <span class="kn">import</span> <span class="n">Adam</span>                                                  <span class="c1"># 导入Adam模块用于定义优化参数</span>
<span class="kn">from</span> <span class="nn">mindspore.train</span> <span class="kn">import</span> <span class="n">Accuracy</span><span class="p">,</span> <span class="n">Model</span><span class="p">,</span> <span class="n">LossMonitor</span>                       <span class="c1"># 导入Accuracy模块，用于评估预测准确率</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">from</span> <span class="nn">mindspore.dataset</span> <span class="kn">import</span> <span class="n">NumpySlicesDataset</span>                               <span class="c1"># 导入NumpySlicesDataset模块，用于创建模型可以识别的数据集</span>

<span class="n">loss</span> <span class="o">=</span> <span class="n">SoftmaxCrossEntropyWithLogits</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>            <span class="c1"># 通过SoftmaxCrossEntropyWithLogits定义损失函数，sparse=True表示指定标签使用稀疏格式，reduction=&#39;mean&#39;表示损失函数的降维方法为求平均值</span>
<span class="n">opti</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">QuantumNet</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>                  <span class="c1"># 通过Adam优化器优化Ansatz中的参数，需要优化的是Quantumnet中可训练的参数，学习率设为0.1</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">QuantumNet</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">opti</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Acc&#39;</span><span class="p">:</span> <span class="n">Accuracy</span><span class="p">()})</span>             <span class="c1"># 建立模型：将MindSpore Quantum构建的量子机器学习层和MindSpore的算子组合，构成一张更大的机器学习网络</span>

<span class="n">train_loader</span> <span class="o">=</span> <span class="n">NumpySlicesDataset</span><span class="p">({</span><span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="n">X_train</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">y_train</span><span class="p">},</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># 通过NumpySlicesDataset创建训练样本的数据集，shuffle=False表示不打乱数据，batch(5)表示训练集每批次样本点有5个</span>
<span class="n">test_loader</span> <span class="o">=</span> <span class="n">NumpySlicesDataset</span><span class="p">({</span><span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="n">X_test</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">y_test</span><span class="p">})</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                   <span class="c1"># 通过NumpySlicesDataset创建测试样本的数据集，batch(5)表示测试集每批次样本点有5个</span>


<span class="k">class</span> <span class="nc">StepAcc</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">Callback</span><span class="p">):</span>                                                      <span class="c1"># 定义一个关于每一步准确率的回调函数</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">test_loader</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_loader</span> <span class="o">=</span> <span class="n">test_loader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">step_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_context</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_loader</span><span class="p">,</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="s1">&#39;Acc&#39;</span><span class="p">])</span>


<span class="n">monitor</span> <span class="o">=</span> <span class="n">LossMonitor</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>                                                       <span class="c1"># 监控训练中的损失，每16步打印一次损失值</span>

<span class="n">acc</span> <span class="o">=</span> <span class="n">StepAcc</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">test_loader</span><span class="p">)</span>                                               <span class="c1"># 使用建立的模型和测试样本计算预测的准确率</span>

<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">train_loader</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">monitor</span><span class="p">,</span> <span class="n">acc</span><span class="p">],</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="c1"># 将上述建立好的模型训练20次</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
epoch: 1 step: 16, loss is 0.6140301823616028
epoch: 2 step: 16, loss is 0.48262983560562134
epoch: 3 step: 16, loss is 0.43457236886024475
epoch: 4 step: 16, loss is 0.4101267457008362
epoch: 5 step: 16, loss is 0.4027639925479889
epoch: 6 step: 16, loss is 0.39859312772750854
epoch: 7 step: 16, loss is 0.39496558904647827
epoch: 8 step: 16, loss is 0.3970319926738739
epoch: 9 step: 16, loss is 0.3954522907733917
epoch: 10 step: 16, loss is 0.39520972967147827
epoch: 11 step: 16, loss is 0.3955090641975403
epoch: 12 step: 16, loss is 0.3953099250793457
epoch: 13 step: 16, loss is 0.39525243639945984
epoch: 14 step: 16, loss is 0.3952508568763733
epoch: 15 step: 16, loss is 0.39521533250808716
epoch: 16 step: 16, loss is 0.39519912004470825
epoch: 17 step: 16, loss is 0.39518338441848755
epoch: 18 step: 16, loss is 0.395169198513031
epoch: 19 step: 16, loss is 0.39515653252601624
epoch: 20 step: 16, loss is 0.3951443135738373
</pre></div></div>
</div>
<p>从上述打印可以看到，20次迭代后，损失值不断下降并趋于稳定，最后收敛于约0.395。</p>
<p>说明：</p>
<p>（1）nn.SoftmaxCrossEntropyWithLogits可以计算数据和标签之间的softmax交叉熵。使用交叉熵损失测量输入（使用softmax函数计算）的概率和目标之间的分布误差，其中类是互斥的（只有一个类是正的），一般格式如下：mindspore.nn.SoftmaxCrossEntropyWithLogits(sparse=False, reduction=“none”)，sparse=False表示指定标签是否使用稀疏格式，默认值:False；reduction=“none”表示适用于损失的减少类型。可选值为mean、sum和none。如果为none，则不执行减少，默认值:“没有”。</p>
<p>（2）Adam模块通过自适应矩估计算法更新梯度，可以优化Ansazt中的参数，输入的是神经网络中可训练的参数；一般格式如下：nn.Adam(net.trainable_params(), learning_rate=0.1)，学习率可以自己调节；</p>
<p>（3）mindspore.train.Model是用于训练或测试的高级API，模型将层分组到具有训练和推理特征的对象中，一般格式如下：mindspore.train.Model(network, loss_fn=None, optimizer=None, metrics=None, eval_network=None, eval_indexes=None, amp_level=“O0”, acc_level=“O0”)，其中network就是我们要训练的网络即Quantumnet；loss_fn即目标函数，在这里就是定义的loss函数；optimizer即优化器，用于更新权重，在这里就是定义的opti；metrics就是模型在训练和测试期间需要评估的字典或一组度量，在这里就是评估准确率；</p>
<p>（4）Accuracy用于计算分类和多标签数据的准确率，一般格式如下：mindspore.train.Accuracy(eval_type=“classification”)，用于分类（单标签）和多标签（多标签分类)）的数据集上计算准确率的度量，默认值：“分类”；</p>
<p>（5）NumpySlicesDataset使用给定的数据切片创建数据集，主要用于将Python数据加载到数据集中，一般格式如下：mindspore.dataset.NumpySlicesDataset(data, column_names=None, num_samples=None, num_parallel_workers=1, shuffle=None, sampler=None, num_shards=None, shard_id=None)；</p>
<p>（6）Callback用于构建回调类的抽象基类，回调是上下文管理器，在传递到模型时将输入和输出。你可以使用此机制自动初始化和释放资源。回调函数将执行当前步骤或数据轮回中的一些操作；</p>
<p>（7）LossMonitor主要用于监控训练中的损失，如果损失是NAN或INF，它将终止训练，一般格式如下：mindspore.train.LossMonitor(per_print_times=1)，per_print_times=1表示每秒钟打印一次损失，默认值：1；</p>
<p>（8）train模块用于训练模型，其中迭代由Python前端控制；当设置PyNative模式或CPU时，训练过程将在数据集不接收的情况下执行，一般格式如下：train(epoch, train_dataset, callbacks=None, dataset_sink_mode=True, sink_size=-1)，其中epoch表示在数据上的总迭代次数；train_dataset就是我们定义的train_loader；callbacks就是我们需要回调的损失值和准确率；dataset_sink_mode表示确定是否通过数据集通道传递数据，文档中为否。</p>
</section>
<section id="训练过程中的准确率">
<h2>训练过程中的准确率<a class="headerlink" href="#训练过程中的准确率" title="永久链接至标题"></a></h2>
<p>我们已经看到损失值趋于稳定，那么我们还可以将模型在训练过程中的预测的准确率呈现出来，执行如下代码。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">acc</span><span class="o">.</span><span class="n">acc</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Statistics of accuracy&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Steps&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Accuracy&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0, 0.5, &#39;Accuracy&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/classification_of_iris_by_qnn_26_1.png" src="_images/classification_of_iris_by_qnn_26_1.png" />
</div>
</div>
<p>从上述打印的图像可以看到，在大约50步后，预测的准确率收敛于1，也就是说预测的准确率已经可以达到100%。</p>
</section>
<section id="预测">
<h2>预测<a class="headerlink" href="#预测" title="永久链接至标题"></a></h2>
<p>最后，我们测试一下训练好的模型，将其应用在测试集上。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">ops</span>                                         <span class="c1"># 导入ops模块</span>

<span class="n">predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">Softmax</span><span class="p">()(</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">X_test</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># 使用建立的模型和测试样本，得到测试样本预测的分类</span>
<span class="n">correct</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">test_loader</span><span class="p">,</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>                   <span class="c1"># 计算测试样本应用训练好的模型的预测准确率</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;预测分类结果：&quot;</span><span class="p">,</span> <span class="n">predict</span><span class="p">)</span>                                              <span class="c1"># 对于测试样本，打印预测分类结果</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;实际分类结果：&quot;</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>                                               <span class="c1"># 对于测试样本，打印实际分类结果</span>

<span class="nb">print</span><span class="p">(</span><span class="n">correct</span><span class="p">)</span>                                                               <span class="c1"># 打印模型预测的准确率</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
预测分类结果： [0 1 0 1 1 1 0 1 1 1 1 1 1 0 0 0 0 0 0 0]
实际分类结果： [0 1 0 1 1 1 0 1 1 1 1 1 1 0 0 0 0 0 0 0]
{&#39;Acc&#39;: 1.0}
</pre></div></div>
</div>
<p>从上述打印的可以看到，预测分类结果和实际分类结果完全一致，模型预测的准确率达到了100%。</p>
<p>至此，我们体验了如何通过搭建量子神经网络来解决经典机器学习中的经典问题——鸢尾花分类问题。相信大家也对使用MindSpore Quantum有了更进一步的了解！期待大家挖掘更多的问题，充分发挥MindSpore Quantum强大的功能！</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="bloch_sphere.html" class="btn btn-neutral float-left" title="布洛赫球" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="quantum_approximate_optimization_algorithm.html" class="btn btn-neutral float-right" title="量子近似优化算法" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, MindSpore.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>