

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>在量子化学计算中应用量子变分求解器 &mdash; MindSpore master 文档</title>
  

  
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
  <link rel="stylesheet" href="_static/nbsphinx-code-cells.css" type="text/css" />
   
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
        
        
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="含参量子线路的等价性检查" href="equivalence_checking_of_PQC.html" />
    <link rel="prev" title="量子神经网络在自然语言处理中的应用" href="qnn_for_nlp.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">安装部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">安装MindSpore Quantum</a></li>
</ul>
<p class="caption"><span class="caption-text">基础使用指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">变分量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_simulator.html">量子模拟器</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">量子神经网络初体验</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">变分量子线路梯度计算进阶</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_operations_of_quantum_circuit.html">量子线路高阶操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_measurement.html">量子测量</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">含噪声量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="bloch_sphere.html">布洛赫球</a></li>
</ul>
<p class="caption"><span class="caption-text">变分量子算法</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">通过量子神经网络对鸢尾花进行分类</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">量子近似优化算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">量子神经网络在自然语言处理中的应用</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">在量子化学计算中应用量子变分求解器</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#概述">概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#环境准备">环境准备</a></li>
<li class="toctree-l2"><a class="reference internal" href="#导入依赖">导入依赖</a></li>
<li class="toctree-l2"><a class="reference internal" href="#量子化学计算方法">量子化学计算方法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#波函数方法">波函数方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#二次量子化">二次量子化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#量子变分求解器">量子变分求解器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#变分原理">变分原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#初态制备">初态制备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#波函数拟设">波函数拟设</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vqe的一般流程">VQE的一般流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#分步构造幺正耦合簇拟设">分步构造幺正耦合簇拟设</a></li>
<li class="toctree-l2"><a class="reference internal" href="#总结">总结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="equivalence_checking_of_PQC.html">含参量子线路的等价性检查</a></li>
</ul>
<p class="caption"><span class="caption-text">通用量子算法</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">量子相位估计算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">基于MindSpore Quantum的Grover搜索算法和龙算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">基于MindSpore Quantum的Shor算法</a></li>
</ul>
<p class="caption"><span class="caption-text">API参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">总览</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>在量子化学计算中应用量子变分求解器</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/vqe_for_quantum_chemistry.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="在量子化学计算中应用量子变分求解器">
<h1>在量子化学计算中应用量子变分求解器<a class="headerlink" href="#在量子化学计算中应用量子变分求解器" title="永久链接至标题">¶</a></h1>
<p><a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/zh_cn/mindspore_vqe_for_quantum_chemistry.ipynb"><img alt="下载Notebook" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_notebook.png" /></a> <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/master/mindquantum/zh_cn/mindspore_vqe_for_quantum_chemistry.py"><img alt="下载样例代码" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_download_code.png" /></a> <a class="reference external" href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_zh_cn/vqe_for_quantum_chemistry.ipynb"><img alt="查看源文件" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source.png" /></a></p>
<div class="section" id="概述">
<h2>概述<a class="headerlink" href="#概述" title="永久链接至标题">¶</a></h2>
<p>量子化学，指的是运用量子力学的基本理论及方法，求解含时或定态薛定谔方程的数值解。在高性能计算机上进行量子化学模拟已成为研究材料的物理、化学性质的重要手段。然而，精确求解薛定谔方程具有指数级的复杂度，可模拟的化学体系规模严重受制于此。近年量子计算的发展为解决这个问题提供了一条可行的路，有望在量子计算机上实现多项式复杂度下对薛定谔方程的高精度求解。</p>
<p><a class="reference external" href="https://doi.org/10.1038/ncomms5213">Peruzzo等人</a>在2014年首次将量子变分求解器(Variational quantum eigensolver, VQE)结合<a class="reference external" href="https://linkinghub.elsevier.com/retrieve/pii/S0009261489873725">幺正耦合簇理论</a>用于量子化学的模拟中，实现了He-H+基态能量的求解。量子变分求解器是一个量子–经典混合算法，在基于量子算法的化学模拟中应用广泛，本教程将介绍使用量子变分求解器求解分子体系基态能量的方法。</p>
<p>本教程的主要内容包括如下几个部分：</p>
<ol class="arabic simple">
<li><p>量子化学原理简介。</p></li>
<li><p>量子变分求解器的应用。</p></li>
<li><p>使用MindSpore Quantum实现高效自动求导的VQE模拟。</p></li>
</ol>
<blockquote>
<div><p>本文档适用于CPU环境。</p>
</div></blockquote>
</div>
<div class="section" id="环境准备">
<h2>环境准备<a class="headerlink" href="#环境准备" title="永久链接至标题">¶</a></h2>
<p>本教程需要安装以下环境：</p>
<ul class="simple">
<li><p>NumPy</p></li>
<li><p>SciPy</p></li>
<li><p><a class="reference external" href="https://gitee.com/mindspore/mindquantum">mindquantum</a></p></li>
<li><p><a class="reference external" href="https://gitee.com/mindspore/mindspore">mindspore</a></p></li>
<li><p>PySCF</p></li>
<li><p>openfermion</p></li>
<li><p>openfermionpyscf</p></li>
</ul>
<blockquote>
<div><p>以上依赖都可通过<code class="docutils literal notranslate"><span class="pre">pip</span></code>命令来安装。</p>
</div></blockquote>
</div>
<div class="section" id="导入依赖">
<h2>导入依赖<a class="headerlink" href="#导入依赖" title="永久链接至标题">¶</a></h2>
<p>导入本教程所依赖模块</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openfermion.chem</span> <span class="kn">import</span> <span class="n">MolecularData</span>
<span class="kn">from</span> <span class="nn">openfermionpyscf</span> <span class="kn">import</span> <span class="n">run_pyscf</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">X</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">Hamiltonian</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">generate_uccsd</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="量子化学计算方法">
<h2>量子化学计算方法<a class="headerlink" href="#量子化学计算方法" title="永久链接至标题">¶</a></h2>
<p>量子化学的核心问题在于求解薛定谔方程（Schrödinger Equation）。一般来说，求解含时薛定谔方程（Time-dependent Schrödinger Equation）较为复杂，故引入玻恩-奥本海默近似（Born-Oppenheimer approximation, BO approximation）。BO近似认为，原子核质量远大于电子、运动速度远低于电子，故可以将两者进行分离变量，单独讨论原子核或电子的运动，于是可得到如下不含时的电子运动方程，也称为定态薛定谔方程：</p>
<div class="math notranslate nohighlight">
\[\hat{H} |\Psi\rangle = E |\Psi\rangle\]</div>
<p>其中<span class="math notranslate nohighlight">\(\hat{H}\)</span>包含以下三项：</p>
<div class="math notranslate nohighlight">
\[\hat{H} = \hat{K} _{e} + \hat{V} _{ee} + \hat{V} _{Ne}\]</div>
<p>分别为电子动能、电子-电子势能和电子-核势能。</p>
<p>有多种数值算法可以求解定态薛定谔方程。本教程将介绍其中的一类：波函数方法。波函数方法直接求解给定分子哈密顿量的本征波函数和本征能量，目前有大量的开源软件包可实现，如<a class="reference external" href="http://pyscf.org/">PySCF</a>等。此处从一个简单的例子：氢化锂分子开始，使用openfermion结合openfermionpyscf插件进行。首先定义分子结构：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;Li&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">dist</span><span class="p">]],</span>
    <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">dist</span><span class="p">]],</span>
<span class="p">]</span>
<span class="n">basis</span> <span class="o">=</span> <span class="s2">&quot;sto3g&quot;</span>
<span class="n">spin</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Geometry: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Geometry:
 [[&#39;Li&#39;, [0.0, 0.0, 0.0]], [&#39;H&#39;, [0.0, 0.0, 1.5]]]
</pre></div></div>
</div>
<p>上面的代码定义了一个Li-H键长为1.5Å分子。使用STO-3G基组进行计算。接下来使用openfermionpyscf，调用PySCF进行HF、CCSD和FCI计算。这三种方法属于波函数方法，开始计算之前，先对这些方法作一个简单的介绍。</p>
<div class="section" id="波函数方法">
<h3>波函数方法<a class="headerlink" href="#波函数方法" title="永久链接至标题">¶</a></h3>
<p>求解定态薛定谔方程的方法之一是<a class="reference external" href="https://doi.org/10.1098/rspa.1935.0085">Hartree-Fock（HF）</a>方法，该方法在二十世纪三十年代左右由Hartree等人提出，是量子化学计算中的基本方法。HF方法引入了单行列式近似，即 <span class="math notranslate nohighlight">\(N\)</span> 电子体系的波函数由一个行列式形式的波函数表示：</p>
<div class="math notranslate nohighlight">
\[| \Psi \rangle = | \psi_{1} \psi_{2} \psi_{3} \dots \psi_{N} \rangle\]</div>
<p>其中 <span class="math notranslate nohighlight">\(| \psi_{1} \psi_{2} \psi_{3} \dots \rangle\)</span> 代表由一组自旋轨道波函数 <span class="math notranslate nohighlight">\(\{ \pi_{i} \}\)</span> 构成的N阶行列式。 自旋轨道波函数 <span class="math notranslate nohighlight">\(\psi_{i}\)</span> 可进一步用一组形式已知的基函数展开：</p>
<div class="math notranslate nohighlight">
\[\psi_{i} = \phi_{i} \eta_{i}\]</div>
<div class="math notranslate nohighlight">
\[\phi_{i} = \sum_{\mu}{C_{\mu i} \chi_{\mu}}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\{\chi_{\mu}\}\)</span> 被称为基函数，可以是高斯函数等。 该近似考虑了电子间的交换作用，但是忽略了电子间的关联作用，故无法正确计算如解离能等性质。</p>
<p>HF方法的改进可以从波函数展开定理出发。波函数展开定理可以表述为，若 <span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span> 是一组完备的自旋轨道波函数，则 <span class="math notranslate nohighlight">\(N\)</span> 电子体系波函数可以由 <span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span> 构成的行列式波函数精确展开：</p>
<div class="math notranslate nohighlight">
\[| \Psi \rangle = \sum^{\infty} _ {i_{1} &lt; i_{2} &lt; \dots &lt; i_{N}} {C_{i_{1} i_{2} \dots i_{N}} | \psi_{i_{1}} \psi_{i_{2}} \dots \psi_{i_{N}} \rangle}\]</div>
<p>由此可得到Configuration Interaction（CI）方法：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{CI} \rangle = C_{0} | \Psi_{HF} \rangle + \sum^{a\rightarrow\infty} _{i\in occ, a\not\in occ}{C^{a} _{i} | \Psi^{a} _{i} \rangle } + \sum^{ab\rightarrow\infty} _{ij\in occ, ab\not\in occ}{C^{ab} _{ij} | \Psi^{ab} _{ij} \rangle }\]</div>
<p>上式中的 <span class="math notranslate nohighlight">\(| \Psi^{a}_{i} \rangle + \dots\)</span> 代表电子由轨道 <span class="math notranslate nohighlight">\(i\)</span> 激发到轨道 <span class="math notranslate nohighlight">\(a\)</span> 的单激发波函数，以此类推。只考虑单激发和双激发的CI被称为CISD，即Configuration Interaction with singles and doubles。将基态HF波函数一直到N激发波函数全部考虑在内的Configuration Interaction被称为Full Configuration Interaction（FCI），FCI波函数是定态薛定谔方程在给定基函数下的精确解。</p>
</div>
<div class="section" id="二次量子化">
<h3>二次量子化<a class="headerlink" href="#二次量子化" title="永久链接至标题">¶</a></h3>
<p>在二次量子化表述下，体系的哈密顿量具有如下形式：</p>
<div class="math notranslate nohighlight">
\[\hat{H} = \sum_{p, q}{h^p_q E^p_q} + \sum_{p, q, r, s}{\frac{1}{2} g^{pq} _ {rs} E^{pq}_{rs}}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(E^p_q\)</span> 和 <span class="math notranslate nohighlight">\(E^{pq}_{rs}\)</span> 分别为：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
E^{pq} _{rs} &amp;= a^{\dagger} _{p} a^{\dagger} _{q} a _ {r} a _ {s}\\
E^p_q &amp;= a^{\dagger}_pa_q
\end{align*}\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(a^{\dagger}_p\)</span> 和 <span class="math notranslate nohighlight">\(a_q\)</span> 分别为产生算符（Creation Operator）和湮灭算符（Annihilation Operator）。</p>
<p>使用二次量子化的表述方法，可以非常方便地表示激发态波函数：</p>
<div class="math notranslate nohighlight">
\[| \Psi^{abc\dots} _ {ijk\dots} \rangle = a^{\dagger} _ {a} a^{\dagger} _ {b} a^{\dagger} _ {c} \dots a _ {i} a_{j} a_{k} \dots | \Psi \rangle\]</div>
<p>CI方法的一个改进是耦合簇理论（Coupled-Cluster theory, CC）。CC引入指数化算符：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{CC} \rangle = \exp{(\hat{T})} | \Psi_{HF} \rangle\]</div>
<p>其中耦合簇算符 <span class="math notranslate nohighlight">\(\hat{T}\)</span> 为对激发算符的求和：</p>
<div class="math notranslate nohighlight">
\[\hat{T} = \sum_{p\not\in occ, q\in occ}{\theta^{p} _ {q} E^{p} _ {q}} + \sum_{pq\not\in occ, rs\in occ}{\theta^{pq} _ {rs} E^{pq} _ {rs}} + \dots\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\theta\)</span> 和CI方法中的 <span class="math notranslate nohighlight">\(C\)</span> 类似，是待求解的参数。由指数的泰勒展开易知，即使耦合簇算符 <span class="math notranslate nohighlight">\(\hat{T}\)</span> 中只包含低阶激发项，<span class="math notranslate nohighlight">\(\exp{(\hat{T})}\)</span> 也可以隐含部分高阶激发，这也使得CC方法向FCI波函数收敛的速度要远快于CI，同样截断到K激发，如K=2，CCSD的精度会超过CISD。</p>
<!--
一般而言，若一个方法可以达到化学精度，即由此方法计算的能量和FCI能量之间的差值小于1 kcal/mol，则认为这个方法具有良好的精度，截断到三激发的CCSD(T)在大部分情况下都能符合这个标准
--><p>电子关联作用的效果是使得总能量降低，故HF得到的基态能量会略高于CCSD和FCI。另外，从上述理论不难发现，FCI的计算量远大于CCSD和HF。我们使用openfermion封装的<code class="docutils literal notranslate"><span class="pre">MolecularData</span></code>和openfermionpyscf封装的<code class="docutils literal notranslate"><span class="pre">run_pyscf</span></code>函数来进行演示：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_of</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">,</span>
    <span class="n">multiplicity</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">)</span>
<span class="n">molecule_of</span> <span class="o">=</span> <span class="n">run_pyscf</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="p">,</span>
    <span class="n">run_scf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">run_ccsd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">run_fci</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hartree-Fock energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">hf_energy</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CCSD energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_energy</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FCI energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">fci_energy</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Hartree-Fock energy:  -7.8633576215351129 Ha
CCSD energy:  -7.8823529091526972 Ha
FCI energy:  -7.8823622867987213 Ha
</pre></div></div>
</div>
<p>在上面的例子中，我们运行了Hartree-Fock（HF）、CCSD、FCI进行总能量的计算。若对运行时间进行统计，会发现<span class="math notranslate nohighlight">\(T_{HF}&lt;T_{CCSD}\ll T_{FCI}\)</span>，换成计算量更大的体系如乙烯分子等会更明显一些。此外，对于计算得到的总能量，有<span class="math notranslate nohighlight">\(E_{HF}&gt;E_{CCSD}&gt;E_{FCI}\)</span>。计算完成后，我们将结果保存到<code class="docutils literal notranslate"><span class="pre">molecule_file</span></code>文件（即<code class="docutils literal notranslate"><span class="pre">molecule_of.filename</span></code>）中：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_of</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">molecule_file</span> <span class="o">=</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">filename</span>
<span class="nb">print</span><span class="p">(</span><span class="n">molecule_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
H1-Li1_sto3g_singlet
</pre></div></div>
</div>
<p>量子化学计算的一大阻碍是计算量。随着体系大小（电子数、原子数）的增加，求解FCI波函数和基态能量的时间消耗大约以<span class="math notranslate nohighlight">\(2^{N}\)</span>增长，即使是较小的分子如乙烯分子等，进行FCI计算也并不容易。量子计算机的出现为此提供了一条可能的解决途径，已有的研究表明，量子计算机可以多项式的时间复杂度模拟哈密顿量的含时演化，在量子处理器上进行化学模拟相较于经典计算机有指数级的加速。本教程将介绍其中一类量子算法：量子变分求解器。</p>
</div>
</div>
<div class="section" id="量子变分求解器">
<h2>量子变分求解器<a class="headerlink" href="#量子变分求解器" title="永久链接至标题">¶</a></h2>
<p>量子变分求解器（Variational Quantum Eigensolver, VQE）是一类量子-经典混合（Hybrid quantum-classical）算法，应用变分原理实现对基态波函数的求解。其中，变分参数的优化步在经典计算机上进行。</p>
<div class="section" id="变分原理">
<h3>变分原理<a class="headerlink" href="#变分原理" title="永久链接至标题">¶</a></h3>
<p>变分原理可使用如下形式表述：</p>
<div class="math notranslate nohighlight">
\[E_{0} \le \frac{\langle \Psi_{t} | \hat{H} | \Psi_{t} \rangle}{\langle \Psi_{t} | \Psi_{t} \rangle}\]</div>
<p>上式中的<span class="math notranslate nohighlight">\(| \Psi_{t} \rangle\)</span>代表试探波函数。变分原理表明，在满足一定的条件下，任意试探波函数得到的基态能量总是大于等于真实的基态能量。变分原理为求解分子基态薛定谔方程提供了一种方法：使用一个参数化的函数<span class="math notranslate nohighlight">\(f(\theta)\)</span>作为精确基态波函数的近似，通过优化参数<span class="math notranslate nohighlight">\(\theta\)</span>来逼近精确的基态能量。</p>
</div>
<div class="section" id="初态制备">
<h3>初态制备<a class="headerlink" href="#初态制备" title="永久链接至标题">¶</a></h3>
<p>在二次量子化表述下，<span class="math notranslate nohighlight">\(N\)</span>-电子HF波函数也具有非常简洁的形式：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{HF} \rangle = \prod^{i=0} _{N-1}{a^{\dagger} _{i}| 0 \rangle}\]</div>
<p>上式搭建了一个由量子化学波函数到量子计算的桥梁：用<span class="math notranslate nohighlight">\(|0\rangle\)</span>代表非占据轨道，用<span class="math notranslate nohighlight">\(|1\rangle\)</span>代表电子占据的轨道，由此可以将<span class="math notranslate nohighlight">\(N\)</span>-电子HF波函数映射为由一串<span class="math notranslate nohighlight">\(M+N\)</span>个量子比特<span class="math notranslate nohighlight">\(| 00\dots 11\dots \rangle\)</span>，<span class="math notranslate nohighlight">\(M\)</span>代表非占据轨道的数量。</p>
<p>以下代码构造了对应于LiH分子的HF初态波函数。在Jordan-Wigner变换下，相当于将<span class="math notranslate nohighlight">\(N\)</span>个<span class="math notranslate nohighlight">\(\text{X}\)</span>门作用于<span class="math notranslate nohighlight">\(|000\dots\rangle\)</span>上。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hartreefock_wfn_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">([</span><span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hartreefock_wfn_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
q0: ──X──

q1: ──X──

q2: ──X──

q3: ──X──
</pre></div></div>
</div>
<p>基于此，我们可以构造如下形式的试探波函数：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{t} \rangle = U(\theta) | \Psi_{HF} \rangle\]</div>
<p>其中<span class="math notranslate nohighlight">\(U(\theta)\)</span>代表一个可通过量子线路模拟的幺正变换，<span class="math notranslate nohighlight">\(| \Psi_{HF} \rangle\)</span>作为初态，可通过多个单比特<span class="math notranslate nohighlight">\(\text{X}\)</span>门来方便地制备。<span class="math notranslate nohighlight">\(U(\theta) | \Psi_{HF} \rangle\)</span>的具体形式也被称为波函数拟设。</p>
</div>
<div class="section" id="波函数拟设">
<h3>波函数拟设<a class="headerlink" href="#波函数拟设" title="永久链接至标题">¶</a></h3>
<p>前文提到的耦合簇理论是一个非常高效的波函数拟设。在量子计算机上使用，需要作一些修改：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{UCC} \rangle = \exp{(\hat{T} - \hat{T}^{\dagger})} | \Psi_{HF} \rangle\]</div>
<p>UCC即幺正耦合簇(Unitary Coupled-Cluster theory)，<span class="math notranslate nohighlight">\(\hat{T}^{\dagger}\)</span>代表<span class="math notranslate nohighlight">\(\hat{T}\)</span>的厄米共轭。如此，<span class="math notranslate nohighlight">\(\exp{(\hat{T} - \hat{T}^{\dagger})}\)</span>即为幺正算符。<a class="reference external" href="https://doi.org/10.1038/ncomms5213">Peruzzo等人</a>在2014年首次使用VQE结合UCCSD(Unitary coupled-cluster with singles and
doubles)拟设进行了量子计算机上的化学模拟实验。值得注意的是幺正耦合簇默认了耦合簇算符中的参数<span class="math notranslate nohighlight">\(\{\theta\}\)</span>是实数。在分子体系中该假设不会有问题；在周期性体系中，<a class="reference external" href="https://doi.org/10.1021/acs.jctc.0c00881">刘杰等人</a>的研究表明幺正耦合簇会因为忽略复数部分而造成误差。本教程暂时不讨论幺正耦合簇在周期性体系中的应用。</p>
<p>使用mindquantum的circuit模块中的<code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>函数可读取先前保存在<code class="docutils literal notranslate"><span class="pre">molecule_file</span></code>的计算结果，“一键”构造UCCSD波函数拟设，以及其对应的量子线路：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ansatz_circuit</span><span class="p">,</span> \
<span class="n">init_amplitudes</span><span class="p">,</span> \
<span class="n">ansatz_parameter_names</span><span class="p">,</span> \
<span class="n">hamiltonian_QubitOp</span><span class="p">,</span> \
<span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">generate_uccsd</span><span class="p">(</span><span class="n">molecule_file</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ccsd:-7.882352909152697.
fci:-7.882362286798721.
</pre></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>将幺正耦合簇相关的函数打包了起来，包括导出分子哈密度量、构造幺正耦合簇拟设算符、提取CCSD计算的耦合簇系数等多个步骤。该函数通过输入分子的文件路径来读取该分子，参数<code class="docutils literal notranslate"><span class="pre">th</span></code>是表示量子线路中哪些参数需要更新梯度的阈值。在<a class="reference internal" href="#分步构造幺正耦合簇拟设"><span class="std std-ref">分步构造幺正耦合簇拟设</span></a>章节，我们会演示如何使用mindquantum的相关接口分步完成其中包含的步骤。完整的量子线路包含HF初态+UCCSD拟设，如下代码所示：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">total_circuit</span> <span class="o">=</span> <span class="n">hartreefock_wfn_circuit</span> <span class="o">+</span> <span class="n">ansatz_circuit</span>
<span class="n">total_circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of parameters: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ansatz_parameter_names</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
============================Circuit Summary============================
|Total number of gates  : 15172.                                      |
|Parameter gates        : 640.                                        |
|with 44 parameters are :                                             |
|p0, p8, p1, p9, p2, p10, p3, p11, p4, p12..                        . |
|Number qubit of circuit: 12                                          |
=======================================================================
Number of parameters: 44
</pre></div></div>
</div>
<p>对于LiH分子而言，其UCCSD波函数拟设中包含44个变分参数。该线路总共的量子比特门数量为12612，总共需要12个量子比特进行模拟。</p>
</div>
<div class="section" id="vqe的一般流程">
<h3>VQE的一般流程<a class="headerlink" href="#vqe的一般流程" title="永久链接至标题">¶</a></h3>
<p>使用VQE进行分子基态求解的一般流程如下：</p>
<ol class="arabic simple">
<li><p>制备HF初态：<span class="math notranslate nohighlight">\(| 00\dots11\dots \rangle\)</span>；</p></li>
<li><p>定义波函数拟设，如UCCSD等；</p></li>
<li><p>将波函数拟设转化为参数化的量子线路；</p></li>
<li><p>初始化变分参数，如全设为0等；</p></li>
<li><p>在量子计算机上多次测量得到分子哈密顿量在该套变分参数下的能量<span class="math notranslate nohighlight">\(E(\theta)\)</span>以及能量关于参数的导数<span class="math notranslate nohighlight">\(\{ {\partial E} / {\partial \theta_{i}} \}\)</span></p></li>
<li><p>在经典计算机上使用优化算法，如梯度下降、BFGS等更新变分参数；</p></li>
<li><p>将新的变分参数传入量子线路中进行更新；</p></li>
<li><p>重复步骤(5)到(7)，直到满足收敛标准；</p></li>
<li><p>结束</p></li>
</ol>
<p>在第5步中，求取能量关于参数的导数<span class="math notranslate nohighlight">\(\{ {\partial E} / {\partial \theta_{i}} \}\)</span>在量子计算机上可通过parameter-shift rule来进行，在模拟器中也可通过模拟parameter-shift rule或者有限差分法来计算，是个较为耗时的过程。mindquantum基于mindspore框架，提供了类似于机器学习的自动求导功能，可以在模拟中可以高效计算变分量子线路的导数。以下使用mindquantum构造带自动求导功能的参数化UCCSD量子线路：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">total_circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>
<span class="n">molecule_pqc</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="n">hamiltonian_QubitOp</span><span class="p">),</span> <span class="n">total_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>通过将参数的具体数值传入<code class="docutils literal notranslate"><span class="pre">molecule_pqc</span></code>，即可得到对应于此变分参数的能量<span class="math notranslate nohighlight">\(E(\theta)=\langle \Psi_{UCC}(\theta) | \hat{H} | \Psi_{UCC}(\theta) \rangle\)</span>以及关于每个变分参数的导数。</p>
<p>例如，我们可以利用下面的代码计算当变分量子线路中所有参数都为零时，哈密顿量的期望值和期望值关于梯度的导数。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_circuit</span><span class="o">.</span><span class="n">params_name</span><span class="p">)</span>
<span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_params</span><span class="p">)</span>
<span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">molecule_pqc</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energy: &quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">shape: &quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gradient: &quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">shape: &quot;</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Energy:  [[-7.86335762+0.j]]
shape:  (1, 1)

Gradient:  [[[-1.17000470e-10+0.j -8.60518140e-02+0.j  7.34841121e-09+0.j
   -4.85545093e-02+0.j -4.27880918e-16+0.j -3.92769093e-02+0.j
   -2.03178123e-14+0.j -9.59481736e-02+0.j -2.19963362e-15+0.j
   -3.92769093e-02+0.j  2.01070916e-15+0.j -9.59481736e-02+0.j
   -1.36457968e-10+0.j -2.89649669e-02+0.j  4.02404639e-10+0.j
   -4.91813235e-01+0.j -9.35292655e-04+0.j -1.66209006e-16+0.j
   -3.46620125e-17+0.j  1.54862629e-17+0.j  1.54555976e-16+0.j
    2.53664212e-17+0.j -2.06994596e-17+0.j  5.06813144e-03+0.j
    1.08542342e-02+0.j -1.28614257e-02+0.j -4.90653894e-17+0.j
    1.10397120e-17+0.j  1.33973783e-01+0.j -3.03063678e-02+0.j
    6.13317367e-19+0.j  6.13317367e-19+0.j  7.90297720e-29+0.j
    5.24386349e-17+0.j -3.70848761e-17+0.j  3.33490478e-17+0.j
    1.29095036e-28+0.j  1.15391966e-16+0.j -3.03063678e-02+0.j
   -5.24386349e-17+0.j  4.89887785e-17+0.j -4.22508287e-17+0.j
   -2.44510201e-17+0.j -1.68035030e-03+0.j]]]
shape:  (1, 1, 44)
</pre></div></div>
</div>
<p>通过上述计算，我们获得了能量值和梯度值，用户可以根据实际应用需求来提取这些值。 接下来需要进行VQE优化的(5)~(7)步，即对变分量子线路进行优化。我们可以借助scipy中的优化器来对线路参数进行优化。首先我们构造适用与scipy优化器的优化函数：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">molecule_pqc</span><span class="p">,</span> <span class="n">energy_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">molecule_pqc</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">g</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">energy_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">energy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_list</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">energy_list</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="se">\t</span><span class="s2">energy: </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span>

<span class="n">fun</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">molecule_pqc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(-7.863357621536957,
 array([-1.17000470e-10, -8.60518140e-02,  7.34841121e-09, -4.85545093e-02,
        -4.27880918e-16, -3.92769093e-02, -2.03178123e-14, -9.59481736e-02,
        -2.19963362e-15, -3.92769093e-02,  2.01070916e-15, -9.59481736e-02,
        -1.36457968e-10, -2.89649669e-02,  4.02404639e-10, -4.91813235e-01,
        -9.35292655e-04, -1.66209006e-16, -3.46620125e-17,  1.54862629e-17,
         1.54555976e-16,  2.53664212e-17, -2.06994596e-17,  5.06813144e-03,
         1.08542342e-02, -1.28614257e-02, -4.90653894e-17,  1.10397120e-17,
         1.33973783e-01, -3.03063678e-02,  6.13317367e-19,  6.13317367e-19,
         7.90297720e-29,  5.24386349e-17, -3.70848761e-17,  3.33490478e-17,
         1.29095036e-28,  1.15391966e-16, -3.03063678e-02, -5.24386349e-17,
         4.89887785e-17, -4.22508287e-17, -2.44510201e-17, -1.68035030e-03]))
</pre></div></div>
</div>
<p>此时，我们定义出来的 <code class="docutils literal notranslate"><span class="pre">fun</span></code> 函数能够正确返回符合要求的数据类型：一个实数格式的能量值，一个跟参数长度一直的梯度数组。接下来，我们利用 scipy 中的 <code class="docutils literal notranslate"><span class="pre">bfgs</span></code> 二阶优化器来进行优化。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>

<span class="n">energy_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">molecule_pqc</span><span class="p">,</span> <span class="n">energy_list</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Step: 5,        energy: -7.880227726053225
Step: 10,       energy: -7.881817123969861
Step: 15,       energy: -7.882213242986122
Step: 20,       energy: -7.882345337008459
Step: 25,       energy: -7.882352494991635
Step: 30,       energy: -7.882352691272213
Step: 35,       energy: -7.882352707864624
Step: 40,       energy: -7.882352708256735
Step: 45,       energy: -7.882352708339958
</pre></div></div>
</div>
<p>如上，我们便完成了变分量子线路的梯度优化。在这里 <code class="docutils literal notranslate"><span class="pre">energy_list</span></code> 用于存储收敛过程中的能量。这里我们对 <code class="docutils literal notranslate"><span class="pre">minimize</span></code> 函数做一个简单介绍：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fun</span></code>: 第一个参数表示想要优化的函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p0</span></code>：第二个参数表示变量的初始值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code>：<code class="docutils literal notranslate"><span class="pre">fun</span></code> 函数中除了第一个参数以外的其他参数，根据我们的 <code class="docutils literal notranslate"><span class="pre">fun</span></code> 函数的定义，这里选择 <code class="docutils literal notranslate"><span class="pre">args=(molecule_pqc,</span> <span class="pre">energy_list)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>：所使用的优化算法，我们这里选择二阶优化算法 <code class="docutils literal notranslate"><span class="pre">bfgs</span></code>。更多优化算法请参考 <code class="docutils literal notranslate"><span class="pre">`scipy</span></code> 官方文档 &lt;<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a>&gt;`__</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jac</span></code>：<code class="docutils literal notranslate"><span class="pre">fun</span></code> 函数是否返回导数值，这里我们选择 <code class="docutils literal notranslate"><span class="pre">True</span></code>，因为 MindSpore Quantum 框架能够算出变分量子线路中参数的精确梯度值。如选 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则 <code class="docutils literal notranslate"><span class="pre">minimize</span></code> 框架将在内部利用差分方法计算近似梯度值。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">res</span></code> 为 <code class="docutils literal notranslate"><span class="pre">scipy</span></code> 中优化算法得到的优化结果，包括优化得到的参数，最优化函数值和迭代次数等。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ground state: </span><span class="se">\n</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">fun</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FCI: </span><span class="se">\n</span><span class="s2">-7.882362286798721</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimized amplitudes: </span><span class="se">\n</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Ground state:
-7.882352708347493

FCI:
-7.882362286798721

Optimized amplitudes:
[ 2.38712434e-04  1.89072212e-03  3.52371962e-02  1.60368062e-02
  4.58341956e-09  9.09417397e-04  8.87731878e-10  1.41638572e-02
  8.70408136e-10  9.08690861e-04  1.01871578e-09  1.41700430e-02
 -5.47655818e-04  4.26823250e-04  2.87179882e-03  5.38109243e-02
  2.34704374e-04 -1.53416806e-08  8.33679682e-08 -8.59399531e-08
 -1.09241359e-08  8.69631759e-08 -8.85803852e-08  1.33003007e-05
 -1.04125728e-04  7.99021032e-04 -6.16712752e-10 -5.09574759e-10
 -5.50005269e-02  3.09114892e-03 -4.78658817e-11 -1.05874198e-07
  1.05877675e-07  4.10043904e-07  2.63845620e-07 -2.76942779e-07
 -1.69080845e-13  2.10388157e-09  3.09108797e-03  1.90755827e-08
  1.86729203e-07 -1.76508410e-07  6.07581905e-10  3.72843789e-04]
</pre></div></div>
</div>
<p>可以看到，幺正耦合簇给出的计算结果和FCI非常接近，具有良好的精度。</p>
</div>
</div>
<div class="section" id="分步构造幺正耦合簇拟设">
<h2>分步构造幺正耦合簇拟设<a class="headerlink" href="#分步构造幺正耦合簇拟设" title="永久链接至标题">¶</a></h2>
<p>在上文中，我们使用了<code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>一步构造出了幺正耦合簇拟设所需要的所有内容，此处我们将步骤拆分，分别得到我们需要的耦合簇算符、对应的量子线路以及取自于经典CCSD计算结果的变分参数初猜值。 首先，导入部分额外依赖，主要包含mindquantum中hiqfermion模块的相关函数：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">get_qubit_hamiltonian</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">uccsd_singlet_generator</span><span class="p">,</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">TimeEvolution</span>
<br/></pre></div>
</div>
</div>
<p>分子哈密顿量使用<code class="docutils literal notranslate"><span class="pre">get_qubit_hamiltonian</span></code>，读取之前的计算结果得到：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_QubitOp</span> <span class="o">=</span> <span class="n">get_qubit_hamiltonian</span><span class="p">(</span><span class="n">molecule_of</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>对于幺正耦合簇算符 <span class="math notranslate nohighlight">\(\hat{T} - \hat{T}^{\dagger}\)</span> ，可以使用<code class="docutils literal notranslate"><span class="pre">uccsd_singlet_generator</span></code>进行构造。提供总量子比特数（总自旋轨道数）和总电子数，并设置参数<code class="docutils literal notranslate"><span class="pre">anti_hermitian=True</span></code>：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ucc_fermion_ops</span> <span class="o">=</span> <span class="n">uccsd_singlet_generator</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span> <span class="n">anti_hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>上一步构造的<code class="docutils literal notranslate"><span class="pre">ucc_fermion_ops</span></code>是参数化的。使用Jordan-Wigner变换将费米子激发算符映射为Pauli算符：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ucc_qubit_ops</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="n">ucc_fermion_ops</span><span class="p">)</span><span class="o">.</span><span class="n">jordan_wigner</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>接下来，我们需要得到幺正算符 <span class="math notranslate nohighlight">\(\exp \left(\hat{T}-\hat{T}^{\dagger}\right)\)</span> 所对应的量子线路。<code class="docutils literal notranslate"><span class="pre">TimeEvolution</span></code>可生成 <span class="math notranslate nohighlight">\(\exp (-i \hat{H} t)\)</span> 所对应的线路，其中 <span class="math notranslate nohighlight">\(\hat{H}\)</span> 是一个厄米算符， <span class="math notranslate nohighlight">\(t\)</span> 是实数。需要注意的是，使用<code class="docutils literal notranslate"><span class="pre">TimeEvolution</span></code>时，<code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code>中已经包含了复数因子 <span class="math notranslate nohighlight">\(i\)</span> ，所以我们需要将<code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code>除以 <span class="math notranslate nohighlight">\(i\)</span> ，或者提取其虚部：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">TimeEvolution</span><span class="p">(</span><span class="n">ucc_qubit_ops</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">circuit</span>
<span class="n">ansatz_parameter_names</span> <span class="o">=</span> <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">params_name</span>
</pre></div>
</div>
</div>
<p>我们使用<code class="docutils literal notranslate"><span class="pre">ansatz_parameter_names</span></code>记录该线路中的参数名。到目前为止，我们已经得到了VQE量子线路所需要内容，包括哈密顿量<code class="docutils literal notranslate"><span class="pre">hamiltonian_QubitOp</span></code>、参数化的波函数拟设线路<code class="docutils literal notranslate"><span class="pre">ansatz_circuit</span></code>，故可仿照前文，得到完整的态制备线路。其中Hartree-Fock参考态复用之前的<code class="docutils literal notranslate"><span class="pre">hartreefock_wfn_circuit</span></code>：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">total_circuit</span> <span class="o">=</span> <span class="n">hartreefock_wfn_circuit</span> <span class="o">+</span> <span class="n">ansatz_circuit</span>
<span class="n">total_circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
==================================Circuit Summary==================================
|Total number of gates  : 15172.                                                  |
|Parameter gates        : 640.                                                    |
|with 44 parameters are :                                                         |
|s_0, d1_0, s_1, d1_1, s_2, d1_2, s_3, d1_3, s_4, d1_4..                        . |
|Number qubit of circuit: 12                                                      |
===================================================================================
</pre></div></div>
</div>
<p>下一步，需要为变分参数提供一个合理的初始值。前文构造的优化器默认使用0作为初猜，在大多数情况下是可行的。不过，使用CCSD的计算数据作为UCC的出发点，可能会有更好的结果。使用<code class="docutils literal notranslate"><span class="pre">uccsd_singlet_get_packed_amplitudes</span></code>函数从<code class="docutils literal notranslate"><span class="pre">molecule_of</span></code>提取CCSD的参数：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">init_amplitudes_ccsd</span> <span class="o">=</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_single_amps</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_double_amps</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)</span>
<span class="n">init_amplitudes_ccsd</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_amplitudes_ccsd</span><span class="p">[</span><span class="n">param_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">param_i</span> <span class="ow">in</span> <span class="n">ansatz_parameter_names</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>根据之前类似的方式，我们可以利用 MindSpore Quantum 来得到梯度算子，并利用 scipy 来进行优化。</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grad_ops</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">total_circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span>
    <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">hamiltonian_QubitOp</span><span class="o">.</span><span class="n">real</span><span class="p">),</span>
    <span class="n">total_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>使用<code class="docutils literal notranslate"><span class="pre">init_amplitudes_ccsd</span></code>（即CCSD计算的耦合簇系数）作为初始变分参数：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">energy_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">init_amplitudes_ccsd</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">,</span> <span class="n">energy_list</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Step: 5,        energy: -7.878223282730547
Step: 10,       energy: -7.880288481438961
Step: 15,       energy: -7.882035668304055
Step: 20,       energy: -7.882302370885741
Step: 25,       energy: -7.882349803534313
Step: 30,       energy: -7.882352702053751
Step: 35,       energy: -7.8823527077335065
Step: 40,       energy: -7.882352708347106
</pre></div></div>
</div>
<p>最后，我们可以得到优化的结果如下：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ground state: </span><span class="se">\n</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">fun</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FCI: </span><span class="se">\n</span><span class="s2">-7.882362286798721</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimized amplitudes: </span><span class="se">\n</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Ground state:
-7.882352708347106

FCI:
-7.882362286798721

Optimized amplitudes:
[-2.38716797e-04  1.89072948e-03 -3.52373113e-02  1.60368505e-02
 -1.65211897e-08  9.09419406e-04  6.97535496e-10  1.41633024e-02
 -6.40543396e-09  9.08685812e-04  3.62517408e-10  1.41706530e-02
  5.47788025e-04  4.26824061e-04 -2.87153659e-03  5.38109309e-02
  2.34736444e-04 -2.07143981e-07  1.78941118e-07 -1.62503048e-07
 -8.80911165e-08  4.07521713e-08 -3.40755199e-08  1.32909026e-05
  7.99087755e-04 -1.04066519e-04 -1.07974132e-09 -3.40797600e-10
 -5.50004943e-02  3.09140289e-03 -2.51213790e-09 -2.71345445e-11
  1.93711194e-10 -1.81505812e-07 -1.08665216e-07  1.19335275e-07
 -7.25358274e-12 -9.25316075e-10  3.09081391e-03 -4.66785554e-08
 -5.15818095e-08  5.28564624e-08 -3.02691203e-10  3.72803168e-04]
</pre></div></div>
</div>
</div>
<div class="section" id="总结">
<h2>总结<a class="headerlink" href="#总结" title="永久链接至标题">¶</a></h2>
<p>在本案例中，我们通过两种方法，利用 <code class="docutils literal notranslate"><span class="pre">scipy</span></code> 中的优化器，得到了LiH分子的基态能量。在第一种方法中，我们利用MindSpore Quantum打包好的<code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>函数生成了能够解决该问题的量子神经网络，而在第二种方法中，我们一步一步的构造出了类似的梯度算子。最终得到的结果是一致的。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="equivalence_checking_of_PQC.html" class="btn btn-neutral float-right" title="含参量子线路的等价性检查" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="qnn_for_nlp.html" class="btn btn-neutral float-left" title="量子神经网络在自然语言处理中的应用" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2022, MindSpore.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>