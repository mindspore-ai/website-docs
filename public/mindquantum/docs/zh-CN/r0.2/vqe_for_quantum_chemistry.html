<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>在量子化学计算中应用量子变分求解器 &mdash; MindSpore master documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="量子近似优化算法" href="quantum_approximate_optimization_algorithm.html" />
    <link rel="prev" title="量子神经网络在自然语言处理中的应用" href="qnn_for_nlp.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">安装部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">安装MindQuantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">使用指南</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">参数化量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">量子神经网络在自然语言处理中的应用</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">在量子化学计算中应用量子变分求解器</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#概述">概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#环境准备">环境准备</a></li>
<li class="toctree-l2"><a class="reference internal" href="#导入依赖">导入依赖</a></li>
<li class="toctree-l2"><a class="reference internal" href="#量子化学计算方法">量子化学计算方法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#波函数方法">波函数方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#二次量子化">二次量子化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#量子变分求解器">量子变分求解器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#变分原理">变分原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#初态制备">初态制备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#波函数拟设">波函数拟设</a></li>
<li class="toctree-l3"><a class="reference internal" href="#VQE的一般流程">VQE的一般流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#分步构造幺正耦合簇拟设">分步构造幺正耦合簇拟设</a></li>
<li class="toctree-l2"><a class="reference internal" href="#总结">总结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">量子近似优化算法</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>在量子化学计算中应用量子变分求解器</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/vqe_for_quantum_chemistry.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="在量子化学计算中应用量子变分求解器">
<h1>在量子化学计算中应用量子变分求解器<a class="headerlink" href="#在量子化学计算中应用量子变分求解器" title="Permalink to this headline"></a></h1>
<p><code class="docutils literal notranslate"><span class="pre">Linux</span></code> <code class="docutils literal notranslate"><span class="pre">CPU</span></code> <code class="docutils literal notranslate"><span class="pre">全流程</span></code> <code class="docutils literal notranslate"><span class="pre">初级</span></code> <code class="docutils literal notranslate"><span class="pre">中级</span></code> <code class="docutils literal notranslate"><span class="pre">高级</span></code></p>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/blob/r1.3/docs/mindquantum/docs/source_zh_cn/vqe_for_quantum_chemistry.ipynb"><img alt="image0" src="https://gitee.com/mindspore/docs/raw/r1.3/resource/_static/logo_source.png" /></a> <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/r1.3/mindquantum/zh_cn/mindspore_vqe_for_quantum_chemistry.ipynb"><img alt="image1" src="https://gitee.com/mindspore/docs/raw/r1.3/resource/_static/logo_notebook.png" /></a> <a class="reference external" href="https://authoring-modelarts-cnnorth4.huaweicloud.com/console/lab?share-url-b64=aHR0cHM6Ly9taW5kc3BvcmUtd2Vic2l0ZS5vYnMuY24tbm9ydGgtNC5teWh1YXdlaWNsb3VkLmNvbS9ub3RlYm9vay9tb2RlbGFydHMvbWluZHNwb3JlX3ZxZV9mb3JfcXVhbnR1bV9jaGVtaXN0cnkuaXB5bmI=&amp;imageid=65f636a0-56cf-49df-b941-7d2a07ba8c8c"><img alt="image2" src="https://gitee.com/mindspore/docs/raw/r1.3/resource/_static/logo_modelarts.png" /></a></p>
<section id="概述">
<h2>概述<a class="headerlink" href="#概述" title="Permalink to this headline"></a></h2>
<p>量子化学，指的是运用量子力学的基本理论及方法，求解含时或定态薛定谔方程的数值解。在高性能计算机上进行量子化学模拟已成为研究材料的物理、化学性质的重要手段。然而，精确求解薛定谔方程具有指数级的复杂度，可模拟的化学体系规模严重受制于此。近年量子计算的发展为解决这个问题提供了一条可行的路，有望在量子计算机上实现多项式复杂度下对薛定谔方程的高精度求解。</p>
<p><a class="reference external" href="https://doi.org/10.1038/ncomms5213">Peruzzo等人</a>在2014年首次将量子变分求解器(Variational quantum eigensolver, VQE)结合<a class="reference external" href="https://linkinghub.elsevier.com/retrieve/pii/S0009261489873725">幺正耦合簇理论</a>用于量子化学的模拟中，实现了He-H+基态能量的求解。量子变分求解器是一个量子–经典混合算法，在基于量子算法的化学模拟中应用广泛，本教程将介绍使用量子变分求解器求解分子体系基态能量的方法。</p>
<p>本教程的主要内容包括如下几个部分：</p>
<ol class="arabic simple">
<li><p>量子化学原理简介。</p></li>
<li><p>量子变分求解器的应用。</p></li>
<li><p>使用MindQuantum实现高效自动求导的VQE模拟。</p></li>
</ol>
<blockquote>
<div><div class="line-block">
<div class="line">本文档适用于CPU环境。</div>
<div class="line">你可以在这里找到完整的可运行的样例代码：<a class="reference external" href="https://gitee.com/mindspore/mindquantum/blob/master/tutorials/source/vqe_for_quantum_chemistry.py">https://gitee.com/mindspore/mindquantum/blob/master/tutorials/source/vqe_for_quantum_chemistry.py</a>。</div>
</div>
</div></blockquote>
</section>
<section id="环境准备">
<h2>环境准备<a class="headerlink" href="#环境准备" title="Permalink to this headline"></a></h2>
<p>本教程需要安装以下环境：</p>
<ul class="simple">
<li><p>NumPy</p></li>
<li><p>SciPy</p></li>
<li><p><a class="reference external" href="https://gitee.com/mindspore/mindquantum">mindquantum</a></p></li>
<li><p><a class="reference external" href="https://gitee.com/mindspore/mindspore">mindspore</a></p></li>
<li><p>PySCF</p></li>
<li><p>openfermion</p></li>
<li><p>openfermionpyscf</p></li>
</ul>
<blockquote>
<div><p>以上依赖都可通过<code class="docutils literal notranslate"><span class="pre">pip</span></code>命令来安装。</p>
</div></blockquote>
</section>
<section id="导入依赖">
<h2>导入依赖<a class="headerlink" href="#导入依赖" title="Permalink to this headline"></a></h2>
<p>导入本教程所依赖模块</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">openfermion.chem</span> <span class="kn">import</span> <span class="n">MolecularData</span>
<span class="kn">from</span> <span class="nn">openfermionpyscf</span> <span class="kn">import</span> <span class="n">run_pyscf</span>
<span class="kn">import</span> <span class="nn">mindquantum</span> <span class="k">as</span> <span class="nn">mq</span>
<span class="kn">from</span> <span class="nn">mindquantum</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">RX</span><span class="p">,</span> <span class="n">Hamiltonian</span>
<span class="kn">from</span> <span class="nn">mindquantum.circuit</span> <span class="kn">import</span> <span class="n">generate_uccsd</span>
<span class="kn">from</span> <span class="nn">mindquantum.nn</span> <span class="kn">import</span> <span class="n">generate_pqc_operator</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">import</span> <span class="nn">mindspore.context</span> <span class="k">as</span> <span class="nn">context</span>
<span class="kn">from</span> <span class="nn">mindspore.common.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">mindspore.common.initializer</span> <span class="kn">import</span> <span class="n">initializer</span>

<span class="n">context</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">GRAPH_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="量子化学计算方法">
<h2>量子化学计算方法<a class="headerlink" href="#量子化学计算方法" title="Permalink to this headline"></a></h2>
<p>量子化学的核心问题在于求解薛定谔方程（Schrödinger Equation）。一般来说，求解含时薛定谔方程（Time-dependent Schrödinger Equation)较为复杂，故引入玻恩-奥本海默近似（Born-Oppenheimer approximation, BO approximation）。BO近似认为，原子核质量远大于电子、运动速度远低于电子，故可以将两者进行分离变量，单独讨论原子核或电子的运动，于是可得到如下不含时的电子运动方程，也称为定态薛定谔方程：</p>
<div class="math notranslate nohighlight">
\[\hat{H} |\Psi\rangle = E |\Psi\rangle\]</div>
<p>其中<span class="math notranslate nohighlight">\(\hat{H}\)</span>包含以下三项：</p>
<div class="math notranslate nohighlight">
\[\hat{H} = \hat{K} _{e} + \hat{V} _{ee} + \hat{V} _{Ne}\]</div>
<p>分别为电子动能、电子-电子势能和电子-核势能。</p>
<p>有多种数值算法可以求解定态薛定谔方程。本教程将介绍其中的一类：波函数方法。波函数方法直接求解给定分子哈密顿量的本征函数和本征能量，目前有大量的开源软件包可实现，如<a class="reference external" href="http://pyscf.org/">PySCF</a>等。此处从一个简单的例子：氢化锂分子开始，使用openfermion结合openfermionpyscf插件进行。首先定义分子结构：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;Li&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">dist</span><span class="p">]],</span>
    <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span>  <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">dist</span><span class="p">]],</span>
<span class="p">]</span>
<span class="n">basis</span> <span class="o">=</span> <span class="s2">&quot;sto3g&quot;</span>
<span class="n">spin</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Geometry: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Geometry:
 [[&#39;Li&#39;, [0.0, 0.0, 0.0]], [&#39;H&#39;, [0.0, 0.0, 1.5]]]
</pre></div></div>
</div>
<p>上面的代码定义了一个Li-H键长为1.5Å分子。使用STO-3G基组进行计算。接下来使用openfermionpyscf，调用PySCF进行HF、CCSD和FCI计算。这三种方法属于波函数方法，开始计算之前，先对这些方法作一个简单的介绍。</p>
<section id="波函数方法">
<h3>波函数方法<a class="headerlink" href="#波函数方法" title="Permalink to this headline"></a></h3>
<p>求解定态薛定谔方程的方法之一是<a class="reference external" href="https://doi.org/10.1098/rspa.1935.0085">Hartree-Fock（HF）</a>方法，该方法在二十世纪三十年代左右由Hartree等人提出，是量子化学计算中的基本方法。HF方法引入了单行列式近似，即<span class="math notranslate nohighlight">\(N\)</span>-电子体系的波函数由一个行列式形式的波函数表示：</p>
<div class="math notranslate nohighlight">
\[| \Psi \rangle = | \psi_{1} \psi_{2} \psi_{3} \dots \psi_{N} \rangle\]</div>
<p>其中<span class="math notranslate nohighlight">\(| \psi_{1} \psi_{2} \psi_{3} \dots \rangle\)</span>代表由一组自旋轨道波函数<span class="math notranslate nohighlight">\(\{ \pi_{i} \}\)</span>构成的N阶行列式。 自旋轨道波函数<span class="math notranslate nohighlight">\(\psi_{i}\)</span>可进一步用一组形式已知的基函数展开：</p>
<div class="math notranslate nohighlight">
\[\psi_{i} = \phi_{i} \eta_{i}\]</div>
<div class="math notranslate nohighlight">
\[\phi_{i} = \sum_{\mu}{C_{\mu i} \chi_{\mu}}\]</div>
<p>其中<span class="math notranslate nohighlight">\(\{\chi_{\mu}\}\)</span>被称为基函数，可以是高斯函数等。 该近似考虑了电子间的交换作用，但是忽略了电子间的关联作用，故无法正确计算如解离能等性质。</p>
<p>HF方法的改进可以从波函数展开定理出发。波函数展开定理可以表述为，若<span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span>是一组完备的自旋轨道波函数，则<span class="math notranslate nohighlight">\(N\)</span>-电子体系波函数可以由<span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span>构成的行列式波函数精确展开：</p>
<div class="math notranslate nohighlight">
\[| \Psi \rangle = \sum^{\infty} _ {i_{1} &lt; i_{2} &lt; \dots &lt; i_{N}} {C_{i_{1} i_{2} \dots i_{N}} | \psi_{i_{1}} \psi_{i_{2}} \dots \psi_{i_{N}} \rangle}\]</div>
<p>由此可得到Configuration Interaction（CI）方法：</p>
<div class="math notranslate nohighlight">
\[\begin{split}| \Psi_{CI} \rangle = C_{0} | \Psi_{HF} \rangle + \sum^{a\rightarrow\infty} _{i\in occ\\\\a\not\in occ}{C^{a} _{i} | \Psi^{a} _{i} \rangle } + \sum^{ab\rightarrow\infty} _{ij\in occ\\\\ab\not\in occ}{C^{ab} _{ij} | \Psi^{ab} _{ij} \rangle }\end{split}\]</div>
<p>上式中的<span class="math notranslate nohighlight">\(| \Psi^{a}_{i} \rangle + \dots\)</span>代表电子由轨道<span class="math notranslate nohighlight">\(i\)</span>激发到轨道<span class="math notranslate nohighlight">\(a\)</span>的单激发波函数，以此类推。只考虑单激发和双激发的CI被称为CISD，即Configuration Interaction with singles and doubles。将基态HF波函数一直到N激发波函数全部考虑在内的Configuration Interaction被称为Full Configuration Interaction（FCI），FCI波函数是定态薛定谔方程在给定基函数下的精确解。</p>
</section>
<section id="二次量子化">
<h3>二次量子化<a class="headerlink" href="#二次量子化" title="Permalink to this headline"></a></h3>
<p>在二次量子化表述下，体系的哈密顿量具有如下形式：</p>
<div class="math notranslate nohighlight">
\[\hat{H} = \sum_{p, q}{h^{p} _ {q} E^{p} _ {q}} + \sum_{p, q, r, s}{\frac{1}{2} g^{pq} _ {rs} E^{pq} _ {rs} }\]</div>
<p>其中<span class="math notranslate nohighlight">\(E^{p} _ {q}\)</span>和<span class="math notranslate nohighlight">\(E^{pq} _ {rs}\)</span>分别为：</p>
<div class="math notranslate nohighlight">
\[E^{p} _ {q} = a^{\dagger} _ {p} a_{q}\]</div>
<div class="math notranslate nohighlight">
\[E^{pq} _ {rs} = a^{\dagger} _ {p} a^{\dagger} _ {q} a_{r} a_{s}\]</div>
<p><span class="math notranslate nohighlight">\(a^{\dagger} _ {p}\)</span>和<span class="math notranslate nohighlight">\(a _ {q}\)</span>分别为产生算符（Creation Operator）和湮灭算符（Annihilation Operator）。</p>
<p>使用二次量子化的表述方法，可以非常方便地表示激发态波函数：</p>
<div class="math notranslate nohighlight">
\[| \Psi^{abc\dots} _ {ijk\dots} \rangle = a^{\dagger} _ {a} a^{\dagger} _ {b} a^{\dagger} _ {c} \dots a_{i} a_{j} a_{k} \dots | \Psi \rangle\]</div>
<p>CI方法的一个改进是耦合簇理论（Coupled-Cluster theory, CC）。CC引入指数化算符：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{CC} \rangle = \exp{(\hat{T})} | \Psi_{HF} \rangle\]</div>
<p>其中耦合簇算符<span class="math notranslate nohighlight">\(\hat{T}\)</span>为对激发算符的求和：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{T} = \sum_{p\not\in occ\\\\q\in occ}{\theta^{p} _ {q} E^{p} _ {q}} + \sum_{pq\not\in occ\\\\rs\in occ}{\theta^{pq} _ {rs} E^{pq} _ {rs}} + \dots\end{split}\]</div>
<p>其中<span class="math notranslate nohighlight">\(\theta\)</span>和CI方法中的<span class="math notranslate nohighlight">\(C\)</span>类似，是待求解的参数。由指数的泰勒展开易知，即使耦合簇算符<span class="math notranslate nohighlight">\(\hat{T}\)</span>中只包含低阶激发项，<span class="math notranslate nohighlight">\(\exp{(\hat{T})}\)</span>也可以隐含部分高阶激发，这也使得CC方法向FCI波函数收敛的速度要远快于CI，同样截断到K激发，如K=2，CCSD的精度会超过CISD。</p>
<!--
一般而言，若一个方法可以达到化学精度，即由此方法计算的能量和FCI能量之间的差值小于1 kcal/mol，则认为这个方法具有良好的精度，截断到三激发的CCSD(T)在大部分情况下都能符合这个标准
--><p>电子关联作用的效果是使得总能量降低，故HF得到的基态能量会略高于CCSD和FCI。另外，从上述理论不难发现，FCI的计算量远大于CCSD和HF。我们使用openfermion封装的<code class="docutils literal notranslate"><span class="pre">MolecularData</span></code>和openfermionpyscf封装的<code class="docutils literal notranslate"><span class="pre">run_pyscf</span></code>函数来进行演示：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_of</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">,</span>
    <span class="n">multiplicity</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">)</span>
<span class="n">molecule_of</span> <span class="o">=</span> <span class="n">run_pyscf</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="p">,</span>
    <span class="n">run_scf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">run_ccsd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">run_fci</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hartree-Fock energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">hf_energy</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CCSD energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_energy</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FCI energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">fci_energy</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Hartree-Fock energy:  -7.8633576215351200 Ha
CCSD energy:  -7.8823529091527051 Ha
FCI energy:  -7.8823622867987249 Ha
</pre></div></div>
</div>
<p>在上面的例子中，我们运行了Hartree-Fock（HF）、CCSD、FCI进行总能量的计算。若对运行时间进行统计，会发现<span class="math notranslate nohighlight">\(T_{HF}&lt;T_{CCSD}\ll T_{FCI}\)</span>，换成计算量更大的体系如乙烯分子等会更明显一些。此外，对于计算得到的总能量，有<span class="math notranslate nohighlight">\(E_{HF}&gt;E_{CCSD}&gt;E_{FCI}\)</span>。计算完成后，我们将结果保存到<code class="docutils literal notranslate"><span class="pre">molecule_file</span></code>文件（即<code class="docutils literal notranslate"><span class="pre">molecule_of.filename</span></code>）中：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_of</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">molecule_file</span> <span class="o">=</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">filename</span>
<span class="nb">print</span><span class="p">(</span><span class="n">molecule_file</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
/home/xuxs/anaconda3/envs/p37/lib/python3.7/site-packages/openfermion/testing/data/H1-Li1_sto3g_singlet
</pre></div></div>
</div>
<p>量子化学计算的一大阻碍是计算量。随着体系大小（电子数、原子数）的增加，求解FCI波函数和基态能量的时间消耗大约以<span class="math notranslate nohighlight">\(2^{N}\)</span>增长，即使是较小的分子如乙烯分子等，进行FCI计算也并不容易。量子计算机的出现为此提供了一条可能的解决途径，已有的研究表明，量子计算机可以多项式的时间复杂度模拟哈密顿量的含时演化，在量子处理器上进行化学模拟相较于经典计算机有指数级的加速。本教程将介绍其中一类量子算法：量子变分求解器。</p>
</section>
</section>
<section id="量子变分求解器">
<h2>量子变分求解器<a class="headerlink" href="#量子变分求解器" title="Permalink to this headline"></a></h2>
<p>量子变分求解器（Variational Quantum Eigensolver, VQE）是一类量子-经典混合（Hybrid quantum-classical）算法，应用变分原理实现对基态波函数的求解。其中，变分参数的优化步在经典计算机上进行。</p>
<section id="变分原理">
<h3>变分原理<a class="headerlink" href="#变分原理" title="Permalink to this headline"></a></h3>
<p>变分原理可使用如下形式表述：</p>
<div class="math notranslate nohighlight">
\[E_{0} \le \frac{\langle \Psi_{t} | \hat{H} | \Psi_{t} \rangle}{\langle \Psi_{t} | \Psi_{t} \rangle}\]</div>
<p>上式中的<span class="math notranslate nohighlight">\(| \Psi_{t} \rangle\)</span>代表试探波函数。变分原理表明，在满足一定的条件下，任意试探波函数得到的基态能量总是大于等于真实的基态能量。变分原理为求解分子基态薛定谔方程提供了一种方法：使用一个参数化的函数<span class="math notranslate nohighlight">\(f(\theta)\)</span>作为精确基态波函数的近似，通过优化参数<span class="math notranslate nohighlight">\(\theta\)</span>来逼近精确的基态能量。</p>
</section>
<section id="初态制备">
<h3>初态制备<a class="headerlink" href="#初态制备" title="Permalink to this headline"></a></h3>
<p>在二次量子化表述下，<span class="math notranslate nohighlight">\(N\)</span>-电子HF波函数也具有非常简洁的形式：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{HF} \rangle = \prod^{i=0} _{N-1}{a^{\dagger} _{i}| 0 \rangle}\]</div>
<p>上式搭建了一个由量子化学波函数到量子计算的桥梁：用<span class="math notranslate nohighlight">\(|0\rangle\)</span>代表非占据轨道，用<span class="math notranslate nohighlight">\(|1\rangle\)</span>代表电子占据的轨道，由此可以将<span class="math notranslate nohighlight">\(N\)</span>-电子HF波函数映射为由一串<span class="math notranslate nohighlight">\(M+N\)</span>个量子比特<span class="math notranslate nohighlight">\(| 00\dots 11\dots \rangle\)</span>，<span class="math notranslate nohighlight">\(M\)</span>代表非占据轨道的数量。</p>
<p>以下代码构造了对应于LiH分子的HF初态波函数。在Jordan-Wigner变换下，相当于将<span class="math notranslate nohighlight">\(N\)</span>个<span class="math notranslate nohighlight">\(\text{X}\)</span>门作用于<span class="math notranslate nohighlight">\(|000\dots\rangle\)</span>上。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hartreefock_wfn_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">([</span><span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hartreefock_wfn_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
X(0)
X(1)
X(2)
X(3)
</pre></div></div>
</div>
<p>基于此，我们可以构造如下形式的试探波函数：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{t} \rangle = U(\theta) | \Psi_{HF} \rangle\]</div>
<p>其中<span class="math notranslate nohighlight">\(U(\theta)\)</span>代表一个可通过量子线路模拟的幺正变换，<span class="math notranslate nohighlight">\(| \Psi_{HF} \rangle\)</span>作为初态，可通过多个单比特<span class="math notranslate nohighlight">\(\text{X}\)</span>门来方便地制备。<span class="math notranslate nohighlight">\(U(\theta) | \Psi_{HF} \rangle\)</span>的具体形式也被称为波函数拟设。</p>
</section>
<section id="波函数拟设">
<h3>波函数拟设<a class="headerlink" href="#波函数拟设" title="Permalink to this headline"></a></h3>
<p>前文提到的耦合簇理论是一个非常高效的波函数拟设。在量子计算机上使用，需要作一些修改：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{UCC} \rangle = \exp{(\hat{T} - \hat{T}^{\dagger})} | \Psi_{HF} \rangle\]</div>
<p>UCC即幺正耦合簇(Unitary Coupled-Cluster theory)，<span class="math notranslate nohighlight">\(\hat{T}^{\dagger}\)</span>代表<span class="math notranslate nohighlight">\(\hat{T}\)</span>的厄米共轭。如此，<span class="math notranslate nohighlight">\(\exp{(\hat{T} - \hat{T}^{\dagger})}\)</span>即为幺正算符。<a class="reference external" href="https://doi.org/10.1038/ncomms5213">Peruzzo等人</a>在2014年首次使用VQE结合UCCSD(Unitary coupled-cluster with singles and
doubles)拟设进行了量子计算机上的化学模拟实验。值得注意的是幺正耦合簇默认了耦合簇算符中的参数<span class="math notranslate nohighlight">\(\{\theta\}\)</span>是实数。在分子体系中该假设不会有问题；在周期性体系中，<a class="reference external" href="https://doi.org/10.1021/acs.jctc.0c00881">刘杰等人</a>的研究表明幺正耦合簇会因为忽略复数部分而造成误差。本教程暂时不讨论幺正耦合簇在周期性体系中的应用。</p>
<p>使用mindquantum的circuit模块中的<code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>函数可读取先前保存在<code class="docutils literal notranslate"><span class="pre">molecule_file</span></code>的计算结果，“一键”构造UCCSD波函数拟设，以及其对应的量子线路：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ansatz_circuit</span><span class="p">,</span> \
<span class="n">init_amplitudes</span><span class="p">,</span> \
<span class="n">ansatz_parameter_names</span><span class="p">,</span> \
<span class="n">hamiltonian_QubitOp</span><span class="p">,</span> \
<span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">generate_uccsd</span><span class="p">(</span><span class="n">molecule_file</span><span class="p">,</span> <span class="n">th</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ccsd:-7.882352909152705.
fci:-7.882362286798725.
</pre></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>将幺正耦合簇相关的函数打包了起来，包括导出分子哈密顿量、构造幺正耦合簇拟设算符、提取CCSD计算的耦合簇系数等多个步骤。该函数通过输入分子的文件路径来读取该分子，参数<code class="docutils literal notranslate"><span class="pre">th</span></code>是表示量子线路中哪些参数需要更新梯度的阈值。在<a class="reference external" href="#step-by-step">分步构造幺正耦合簇拟设</a>章节，我们会演示如何使用mindquantum的相关接口分步完成其中包含的步骤。完整的量子线路包含HF初态+UCCSD拟设，如下代码所示：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">total_circuit</span> <span class="o">=</span> <span class="n">hartreefock_wfn_circuit</span> <span class="o">+</span> <span class="n">ansatz_circuit</span>
<span class="n">total_circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of parameters: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ansatz_parameter_names</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
==============================Circuit Summary==============================
|Total number of gates  : 12612.                                          |
|Parameter gates        : 640.                                            |
|with 44 parameters are : p40, p9, p8, p3, p32, p28, p15, p4, p18, p22... |
|Number qubit of circuit: 12                                              |
===========================================================================
Number of parameters: 44
</pre></div></div>
</div>
<p>对于LiH分子而言，其UCCSD波函数拟设中包含44个变分参数。该线路总共的量子比特门数量为12612，总共需要12个量子比特进行模拟。</p>
</section>
<section id="VQE的一般流程">
<h3>VQE的一般流程<a class="headerlink" href="#VQE的一般流程" title="Permalink to this headline"></a></h3>
<p>使用VQE进行分子基态求解的一般流程如下：</p>
<ol class="arabic simple">
<li><p>制备HF初态：<span class="math notranslate nohighlight">\(| 00\dots11\dots \rangle\)</span>；</p></li>
<li><p>定义波函数拟设，如UCCSD等；</p></li>
<li><p>将波函数拟设转化为参数化的量子线路；</p></li>
<li><p>初始化变分参数，如全设为0等；</p></li>
<li><p>在量子计算机上多次测量得到分子哈密顿量在该套变分参数下的能量<span class="math notranslate nohighlight">\(E(\theta)\)</span>以及能量关于参数的导数<span class="math notranslate nohighlight">\(\{ {\partial E} / {\partial \theta_{i}} \}\)</span></p></li>
<li><p>在经典计算机上使用优化算法，如梯度下降、BFGS等更新变分参数；</p></li>
<li><p>将新的变分参数传入量子线路中进行更新；</p></li>
<li><p>重复步骤(5)到(7)，直到满足收敛标准；</p></li>
<li><p>结束</p></li>
</ol>
<p>在第5步中，求取能量关于参数的导数<span class="math notranslate nohighlight">\(\{ {\partial E} / {\partial \theta_{i}} \}\)</span>在量子计算机上可通过parameter-shift rule来进行，在模拟器中也可通过模拟parameter-shift rule或者有限差分法来计算，是个较为耗时的过程。mindquantum基于mindspore框架，提供了类似于机器学习的自动求导功能，可以在模拟中可以高效计算参数化量子线路的导数。以下使用mindquantum构造带自动求导功能的参数化UCCSD量子线路：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_pqc</span> <span class="o">=</span> <span class="n">generate_pqc_operator</span><span class="p">(</span>
    <span class="p">[</span><span class="s2">&quot;null&quot;</span><span class="p">],</span> <span class="n">ansatz_parameter_names</span><span class="p">,</span>
    <span class="n">RX</span><span class="p">(</span><span class="s2">&quot;null&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">total_circuit</span><span class="p">,</span>
    <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">hamiltonian_QubitOp</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>由于mindquantum需要提供两套线路（以及参数）分别作为Encoding circuit和Ansatz circuit，此处我们使用<code class="docutils literal notranslate"><span class="pre">RX(&quot;null&quot;)</span></code>作为一个Encoding circuit，在之后令参数<code class="docutils literal notranslate"><span class="pre">null</span></code>等于0将其无效化。通过将参数的具体数值传入<code class="docutils literal notranslate"><span class="pre">molecule_pqc</span></code>，即可得到对应于此变分参数的能量<span class="math notranslate nohighlight">\(E(\theta)=\langle \Psi_{UCC}(\theta) | \hat{H} | \Psi_{UCC}(\theta) \rangle\)</span>以及关于每个变分参数的导数。</p>
<p>接下来需要进行VQE优化的(5)~(7)步，即对参数化量子线路进行优化。我们可以借助MindSpore框架，使用参数化量子线路算子<code class="docutils literal notranslate"><span class="pre">molecule_pqc</span></code>构造一个神经网络模型，然后通过类似于训练神经网络的方法来优化变分参数：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PQCNet</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pqc</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PQCNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pqc</span> <span class="o">=</span> <span class="n">pqc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span>  <span class="n">Parameter</span><span class="p">(</span><span class="n">initializer</span><span class="p">(</span><span class="s2">&quot;Zeros&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pqc</span><span class="o">.</span><span class="n">ansatz_params_names</span><span class="p">)),</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoder_data_dummy</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">]],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">energy</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">grads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pqc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder_data_dummy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">energy</span>

<span class="n">molecule_pqcnet</span> <span class="o">=</span> <span class="n">PQCNet</span><span class="p">(</span><span class="n">molecule_pqc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>此处我们手动构造了一个基本的<code class="docutils literal notranslate"><span class="pre">PQCNet</span></code>作为模型示例，该模型可以和常规的机器学习模型类似使用，比如优化权重、计算导数等。更好的选择是使用mindquantum中封装的<code class="docutils literal notranslate"><span class="pre">MindQuantumAnsatzOnlyLayer</span></code>，将会在后文中进行演示。</p>
<p>构造的<code class="docutils literal notranslate"><span class="pre">PQCNet</span></code>使用<code class="docutils literal notranslate"><span class="pre">&quot;Zeros&quot;</span></code>关键字，将所有的变分参数初始化为0。使用CCSD（耦合簇理论）或者MP2（二阶多体微扰论）的计算结果也可以作为幺正耦合簇变分参数的初始值。此时有<span class="math notranslate nohighlight">\(E(\vec{0})=\langle \Psi_{UCC}(\vec{0}) | \hat{H} | \Psi_{UCC}(\vec{0}) \rangle = E_{HF}\)</span>：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initial_energy</span> <span class="o">=</span> <span class="n">molecule_pqcnet</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial energy: </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">initial_energy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Initial energy:  -7.8633575439453125
</pre></div></div>
</div>
<p>最后使用mindspore的Adam优化器进行优化，学习率设置为<span class="math notranslate nohighlight">\(1\times 10^{-2}\)</span>，优化终止标准设置为<span class="math notranslate nohighlight">\(\left.|\epsilon|\right. = \left.|E^{k+1} - E^{k}|\right. \le 1\times 10^{-8}\)</span></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Adagrad</span><span class="p">(</span><span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">4e-2</span><span class="p">)</span>
<span class="n">train_pqcnet</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">TrainOneStepCell</span><span class="p">(</span><span class="n">molecule_pqcnet</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)</span>

<span class="n">eps</span> <span class="o">=</span> <span class="mf">1.e-8</span>
<span class="n">energy_diff</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="mi">1000</span>
<span class="n">energy_last</span> <span class="o">=</span> <span class="n">initial_energy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">+</span> <span class="n">energy_diff</span>
<span class="n">iter_idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">energy_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">):</span>
    <span class="n">energy_i</span> <span class="o">=</span> <span class="n">train_pqcnet</span><span class="p">()</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">iter_idx</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step </span><span class="si">%3d</span><span class="s2"> energy </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_idx</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">energy_i</span><span class="p">)))</span>
    <span class="n">energy_diff</span> <span class="o">=</span> <span class="n">energy_last</span> <span class="o">-</span> <span class="n">energy_i</span>
    <span class="n">energy_last</span> <span class="o">=</span> <span class="n">energy_i</span>
    <span class="n">iter_idx</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimization completed at step </span><span class="si">%3d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized energy: </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">energy_i</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized amplitudes: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Step   0 energy  -7.8633575439453125
Step   5 energy  -7.8726239204406738
Step  10 energy  -7.8821778297424316
Step  15 energy  -7.8822836875915527
Step  20 energy  -7.8823199272155762
Step  25 energy  -7.8823370933532715
Step  30 energy  -7.8823437690734863
Step  35 energy  -7.8618836402893066
Step  40 energy  -7.8671770095825195
Step  45 energy  -7.8751692771911621
Step  50 energy  -7.8822755813598633
Step  55 energy  -7.8812966346740723
Step  60 energy  -7.8823189735412598
Step  65 energy  -7.8823523521423340
Optimization completed at step  67
Optimized energy:  -7.8823528289794922
Optimized amplitudes:
 [ 2.3980068e-04  1.8912849e-03  3.5044324e-02  1.6005965e-02
 -1.9985158e-07  9.0940151e-04  1.6222824e-05  1.4160988e-02
 -1.1072063e-07  9.0867787e-04  1.3825165e-05  1.4166672e-02
 -5.4699212e-04  4.2679289e-04  2.8641545e-03  5.3817011e-02
  2.3320253e-04  1.7034533e-07  6.6684343e-08 -2.7686235e-07
  7.2332718e-08  1.2834757e-05 -1.0439425e-04  7.1826143e-08
  3.6483241e-06  6.1677817e-08  3.1003920e-06  7.9770159e-04
 -5.4951470e-02  3.0904056e-03 -4.4321241e-05  8.5840838e-07
 -1.9589644e-08 -4.9430941e-08  8.6163556e-07 -2.5008637e-07
  2.1493735e-08 -4.6331229e-06  3.0904033e-03  9.5311613e-08
 -4.8755901e-08  2.0483398e-08 -3.9453280e-06  3.7235476e-04]
</pre></div></div>
</div>
<p>可以看到，幺正耦合簇给出的计算结果和FCI非常接近，具有良好的精度。</p>
</section>
</section>
<section id="分步构造幺正耦合簇拟设">
<h2>分步构造幺正耦合簇拟设<a class="headerlink" href="#分步构造幺正耦合簇拟设" title="Permalink to this headline"></a></h2>
<p>在上文中，我们使用了<code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>一步构造出了幺正耦合簇拟设所需要的所有内容，此处我们将步骤拆分，分别得到我们需要的耦合簇算符、对应的量子线路以及取自于经典CCSD计算结果的变分参数初猜值。 首先，导入部分额外依赖，主要包含mindquantum中hiqfermion模块的相关函数：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.hiqfermion.transforms</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">mindquantum.hiqfermion.ucc</span> <span class="kn">import</span> <span class="n">get_qubit_hamiltonian</span>
<span class="kn">from</span> <span class="nn">mindquantum.hiqfermion.ucc</span> <span class="kn">import</span> <span class="n">uccsd_singlet_generator</span><span class="p">,</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span>
<span class="kn">from</span> <span class="nn">mindquantum.circuit</span> <span class="kn">import</span> <span class="n">TimeEvolution</span>
<span class="kn">from</span> <span class="nn">mindquantum.nn.mindquantum_ansatz_only_layer</span> <span class="kn">import</span> <span class="n">MindQuantumAnsatzOnlyLayer</span>
</pre></div>
</div>
</div>
<p>分子哈密顿量使用<code class="docutils literal notranslate"><span class="pre">get_qubit_hamiltonian</span></code>，读取之前的计算结果得到：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_QubitOp</span> <span class="o">=</span> <span class="n">get_qubit_hamiltonian</span><span class="p">(</span><span class="n">molecule_of</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>对于幺正耦合簇算符<span class="math notranslate nohighlight">\(\hat{T} - \hat{T}^{\dagger}\)</span>，可以使用<code class="docutils literal notranslate"><span class="pre">uccsd_singlet_generator</span></code>进行构造。提供总量子比特数（总自旋轨道数）和总电子数，并设置参数<code class="docutils literal notranslate"><span class="pre">anti_hermitian=True</span></code>：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ucc_fermion_ops</span> <span class="o">=</span> <span class="n">uccsd_singlet_generator</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span> <span class="n">anti_hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>上一步构造的<code class="docutils literal notranslate"><span class="pre">ucc_fermion_ops</span></code>是参数化的。使用Jordan-Wigner变换将费米子激发算符映射为Pauli算符：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ucc_qubit_ops</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="n">ucc_fermion_ops</span><span class="p">)</span><span class="o">.</span><span class="n">jordan_wigner</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>接下来，我们需要得到幺正算符<span class="math notranslate nohighlight">\(\exp{(\hat{T} - \hat{T}^{\dagger})}\)</span>所对应的量子线路。<code class="docutils literal notranslate"><span class="pre">TimeEvolution</span></code>可生成<span class="math notranslate nohighlight">\(\exp{(-i\hat{H}t)}\)</span>所对应的线路，其中<span class="math notranslate nohighlight">\(\hat{H}\)</span>是一个厄米算符，<span class="math notranslate nohighlight">\(t\)</span>是实数。需要注意的是，使用<code class="docutils literal notranslate"><span class="pre">TimeEvolution</span></code>时，<code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code>中已经包含了复数因子<span class="math notranslate nohighlight">\(i\)</span>，所以我们需要将<code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code>除以<span class="math notranslate nohighlight">\(i\)</span>，或者提取其虚部：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">TimeEvolution</span><span class="p">(</span><span class="n">ucc_qubit_ops</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">circuit</span>
<span class="n">ansatz_parameter_names</span> <span class="o">=</span> <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">para_name</span>
</pre></div>
</div>
</div>
<p>我们使用<code class="docutils literal notranslate"><span class="pre">ansatz_parameter_names</span></code>记录该线路中的参数名。到目前为止，我们已经得到了VQE量子线路所需要内容，包括哈密顿量<code class="docutils literal notranslate"><span class="pre">hamiltonian_QubitOp</span></code>、参数化的波函数拟设线路<code class="docutils literal notranslate"><span class="pre">ansatz_circuit</span></code>，故可仿照前文，得到完整的态制备线路。其中Hartree-Fock参考态复用之前的<code class="docutils literal notranslate"><span class="pre">hartreefock_wfn_circuit</span></code>：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">total_circuit</span> <span class="o">=</span> <span class="n">hartreefock_wfn_circuit</span> <span class="o">+</span> <span class="n">ansatz_circuit</span>
<span class="n">total_circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
======================================Circuit Summary======================================
|Total number of gates  : 12612.                                                          |
|Parameter gates        : 640.                                                            |
|with 44 parameters are : d1_3, d2_26, d2_6, d2_1, d2_2, d2_14, d1_1, s_1, d2_16, d2_11...|
|Number qubit of circuit: 12                                                              |
===========================================================================================
</pre></div></div>
</div>
<p>下一步，需要为变分参数提供一个合理的初始值。前文构造的<code class="docutils literal notranslate"><span class="pre">PQCNet</span></code>默认使用0作为初猜，在大多数情况下是可行的。不过，使用CCSD的计算数据作为UCC的出发点，可能会有更好的结果。使用<code class="docutils literal notranslate"><span class="pre">uccsd_singlet_get_packed_amplitudes</span></code>函数从<code class="docutils literal notranslate"><span class="pre">molecule_of</span></code>提取CCSD的参数：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">init_amplitudes_ccsd</span> <span class="o">=</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_single_amps</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_double_amps</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)</span>
<span class="n">init_amplitudes_ccsd</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_amplitudes_ccsd</span><span class="p">[</span><span class="n">param_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">param_i</span> <span class="ow">in</span> <span class="n">ansatz_parameter_names</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>使用<code class="docutils literal notranslate"><span class="pre">MindQuantumAnsatzOnlyLayer</span></code>可以方便地由参数、量子线路获得以参数化量子线路为基础的机器学习模型：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_pqcnet</span> <span class="o">=</span> <span class="n">MindQuantumAnsatzOnlyLayer</span><span class="p">(</span>
    <span class="n">ansatz_parameter_names</span><span class="p">,</span> <span class="n">total_circuit</span><span class="p">,</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">hamiltonian_QubitOp</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>使用<code class="docutils literal notranslate"><span class="pre">init_amplitudes_ccsd</span></code>（即CCSD计算的耦合簇系数）作为初始变分参数：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">init_amplitudes_ccsd</span><span class="p">,</span> <span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
<span class="n">initial_energy</span> <span class="o">=</span> <span class="n">molecule_pqcnet</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial energy: </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">initial_energy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Initial energy:  -7.8173098564147949
</pre></div></div>
</div>
<p>在这个例子中，CCSD初猜并没有提供一个更好的起点。读者可以对更多的分子、更多种类的初始值（如随机数初猜）等进行测试和探究。最后进行VQE的优化步骤，优化器依然使用Adam，收敛标准不变。优化所用的代码与前文基本一致，注意更新相应的变量即可：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Adagrad</span><span class="p">(</span><span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">4e-2</span><span class="p">)</span>
<span class="n">train_pqcnet</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">TrainOneStepCell</span><span class="p">(</span><span class="n">molecule_pqcnet</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;eps: &quot;</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
<span class="n">energy_diff</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="mi">1000</span>
<span class="n">energy_last</span> <span class="o">=</span> <span class="n">initial_energy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span> <span class="o">+</span> <span class="n">energy_diff</span>
<span class="n">iter_idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">energy_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">):</span>
    <span class="n">energy_i</span> <span class="o">=</span> <span class="n">train_pqcnet</span><span class="p">()</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">iter_idx</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step </span><span class="si">%3d</span><span class="s2"> energy </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_idx</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">energy_i</span><span class="p">)))</span>
    <span class="n">energy_diff</span> <span class="o">=</span> <span class="n">energy_last</span> <span class="o">-</span> <span class="n">energy_i</span>
    <span class="n">energy_last</span> <span class="o">=</span> <span class="n">energy_i</span>
    <span class="n">iter_idx</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimization completed at step </span><span class="si">%3d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized energy: </span><span class="si">%20.16f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">energy_i</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized amplitudes: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">molecule_pqcnet</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
eps:  1e-08
Step   0 energy  -7.8173098564147949
Step   5 energy  -7.8740763664245605
Step  10 energy  -7.8818783760070801
Step  15 energy  -7.8821649551391602
Step  20 energy  -7.8822622299194336
Step  25 energy  -7.8823084831237793
Step  30 energy  -7.8823180198669434
Step  35 energy  -7.8737111091613770
Step  40 energy  -7.8724455833435059
Step  45 energy  -7.8801403045654297
Step  50 energy  -7.8821926116943359
Step  55 energy  -7.8818311691284180
Step  60 energy  -7.8823456764221191
Optimization completed at step  64
Optimized energy:  -7.8823523521423340
Optimized amplitudes:
 [-2.4216002e-04  1.8924323e-03 -3.4653045e-02  1.5943546e-02
  3.6362690e-07  9.0936717e-04 -1.7181528e-05  1.4154296e-02
 -4.4650793e-08  9.0864423e-04 -2.6399141e-06  1.4159971e-02
  5.4558384e-04  4.2672374e-04 -2.8494308e-03  5.3833455e-02
  2.3033506e-04  1.2578158e-06  3.3855862e-08  7.3955505e-08
 -5.2005623e-07  2.9746575e-08  1.2325607e-08  1.1919828e-05
 -1.0492613e-04  7.9503102e-04  3.8478893e-06  5.9738107e-07
 -5.4855812e-02  3.0889052e-03  7.9252044e-05 -1.5384763e-06
 -1.5373821e-06 -3.0784176e-07 -3.5303248e-08  1.7360321e-08
  4.4359115e-07 -4.9067144e-06  3.0889027e-03  1.3888703e-07
 -1.6715177e-08  6.3234533e-09 -7.5149819e-07  3.7140178e-04]
</pre></div></div>
</div>
</section>
<section id="总结">
<h2>总结<a class="headerlink" href="#总结" title="Permalink to this headline"></a></h2>
<p>在本案例中，我们通过两种方法，利用量子神经网络得到了LiH分子的基态能量。在第一种方法中，我们利用MindQuantum打包好的<code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>函数生成了能够解决该问题的量子神经网络，而在第二种方法中，我们一步一步的构造出了类似的量子神经网络。最终得到的结果是一致的。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="qnn_for_nlp.html" class="btn btn-neutral float-left" title="量子神经网络在自然语言处理中的应用" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="quantum_approximate_optimization_algorithm.html" class="btn btn-neutral float-right" title="量子近似优化算法" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
        <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>