

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mindquantum.algorithm.nisq &mdash; MindSpore master documentation</title>
  

  
   
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        
        
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="mindquantum.io" href="mindquantum.io.html" />
    <link rel="prev" title="mindquantum.algorithm.library" href="mindquantum.algorithm.library.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">安装部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">安装MindQuantum</a></li>
</ul>
<p class="caption"><span class="caption-text">基础使用指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">变分量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">量子神经网络初体验</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">变分量子线路梯度计算进阶</a></li>
</ul>
<p class="caption"><span class="caption-text">变分量子算法</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">通过量子神经网络对鸢尾花进行分类</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">量子近似优化算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">量子神经网络在自然语言处理中的应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">在量子化学计算中应用量子变分求解器</a></li>
</ul>
<p class="caption"><span class="caption-text">通用量子算法</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">量子相位估计算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">基于MindQuantum的Grover搜索算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">基于MindQuantum的Shor算法</a></li>
</ul>
<p class="caption"><span class="caption-text">API参考</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="mindquantum.algorithm.library.html">mindquantum.algorithm.library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">mindquantum.algorithm.nisq</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="mindquantum.algorithm.html">mindquantum.algorithm</a> &raquo;</li>
        
      <li>mindquantum.algorithm.nisq</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/mindquantum.algorithm.nisq.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="module-mindquantum.algorithm.nisq">
<span id="module-mindquantum.algorithm.nisq"></span><span id="mindquantum-algorithm-nisq"></span><h1>mindquantum.algorithm.nisq<a class="headerlink" href="#module-mindquantum.algorithm.nisq" title="Permalink to this headline">¶</a></h1>
<p>NISQ algorithms</p>
<dl class="class">
<dt id="mindquantum.algorithm.nisq.Ansatz">
<em class="property">class </em><code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">Ansatz</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">n_qubits</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/_ansatz.html#Ansatz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Ansatz" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic class for Ansatz.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – The name of this ansatz.</p></li>
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – How many qubits this ansatz act on.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="mindquantum.algorithm.nisq.Ansatz.circuit">
<em class="property">property </em><code class="sig-name descname">circuit</code><a class="headerlink" href="#mindquantum.algorithm.nisq.Ansatz.circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the quantum circuit of this ansatz.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Circuit, the quantum circuit of this ansatz.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mindquantum.algorithm.nisq.HardwareEfficientAnsatz">
<em class="property">class </em><code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">HardwareEfficientAnsatz</code><span class="sig-paren">(</span><em class="sig-param">n_qubits</em>, <em class="sig-param">single_rot_gate_seq</em>, <em class="sig-param">entangle_gate=X</em>, <em class="sig-param">entangle_mapping=&quot;linear&quot;</em>, <em class="sig-param">depth=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/hardware_efficient_ansatz.html#HardwareEfficientAnsatz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.HardwareEfficientAnsatz" title="Permalink to this definition">¶</a></dt>
<dd><p>Hardware efficient ansatz is a kind of ansatz that can be easily implement on quantum chip.</p>
<p>The hardware efficient is constructed by a layer of single qubit rotation gate and a layer
of two qubits entanglement gate. The single qubit rotation gate layer is constructed by one
or several rotation gate that act on every qubit. The two qubits entanglement gate layer is
constructed by CNOT, CZ, XX, YY, ZZ, etc. acting on entangle_mapping. For more detail, please
refers <a class="reference external" href="https://www.nature.com/articles/nature23879">https://www.nature.com/articles/nature23879</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – number of qubit that this ansatz act on.</p></li>
<li><p><strong>single_rot_gate_seq</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>[</em><a class="reference internal" href="mindquantum.core.gates.html#mindquantum.core.gates.BasicGate" title="mindquantum.core.gates.BasicGate"><em>BasicGate</em></a><em>]</em>) – A list of parameterized rotation gate that act on
each qubit.</p></li>
<li><p><strong>entangle_gate</strong> (<a class="reference internal" href="mindquantum.core.gates.html#mindquantum.core.gates.BasicGate" title="mindquantum.core.gates.BasicGate"><em>BasicGate</em></a>) – The non parameterized entanglement gate. If it is a single qubit
gate, than the control version will be used. Default: XGate.</p></li>
<li><p><strong>entangle_mapping</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em><em>]</em>) – The entanglement mapping of entanglement gate.
‘linear’ means the entanglement gate will be act on every neighboring qubits. ‘all’ means
the entanglemtn gate will be act on any two qbuits. Besides, you can specific which two
qubits you want to do entanglement by setting the entangle_mapping to a list of two qubits
tuple. Default: “linear”.</p></li>
<li><p><strong>depth</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The depth of ansatz. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">HardwareEfficientAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum</span> <span class="kn">import</span> <span class="n">RY</span><span class="p">,</span> <span class="n">RZ</span><span class="p">,</span> <span class="n">Z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hea</span> <span class="o">=</span> <span class="n">HardwareEfficientAnsatz</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">RY</span><span class="p">,</span> <span class="n">RZ</span><span class="p">],</span> <span class="n">Z</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hea</span><span class="o">.</span><span class="n">circuit</span>
<span class="go">q0: ──RY(d0_n0_0)────RZ(d0_n0_1)────●────●────RY(d1_n0_0)────RZ(d1_n0_1)──</span>
<span class="go">                                    │    │</span>
<span class="go">q1: ──RY(d0_n1_0)────RZ(d0_n1_1)────Z────┼────RY(d1_n1_0)────RZ(d1_n1_1)──</span>
<span class="go">                                         │</span>
<span class="go">q2: ──RY(d0_n2_0)────RZ(d0_n2_1)─────────Z────RY(d1_n2_0)────RZ(d1_n2_1)──</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="mindquantum.algorithm.nisq.IQPEncoding">
<em class="property">class </em><code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">IQPEncoding</code><span class="sig-paren">(</span><em class="sig-param">n_feature</em>, <em class="sig-param">first_rotation_gate=RZ</em>, <em class="sig-param">second_rotation_gate=RZ</em>, <em class="sig-param">num_repeats=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qnn/iqp_encoding.html#IQPEncoding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.IQPEncoding" title="Permalink to this definition">¶</a></dt>
<dd><p>General IQP Encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_feature</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of feature of data you want to encode with iqp encoding.</p></li>
<li><p><strong>first_rotation_gate</strong> (<em>ParamaterGate</em>) – One of the rotation gate RX, RY or RZ.</p></li>
<li><p><strong>second_rotation_gate</strong> (<em>ParamaterGate</em>) – One of the rotation gate RX, RY or RZ.</p></li>
<li><p><strong>num_repeats</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of encoding iterations.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.library</span> <span class="kn">import</span> <span class="n">IQPEncoding</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span> <span class="o">=</span> <span class="n">IQPEncoding</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span>
<span class="go">q0: ──H────RZ(alpha0)────●───────────────────────────●───────────────────────────────────</span>
<span class="go">                         │                           │</span>
<span class="go">q1: ──H────RZ(alpha1)────X────RZ(alpha0 * alpha1)────X────●───────────────────────────●──</span>
<span class="go">                                                          │                           │</span>
<span class="go">q2: ──H────RZ(alpha2)─────────────────────────────────────X────RZ(alpha1 * alpha2)────X──</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">params_name</span>
<span class="go">[&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;alpha0 * alpha1&#39;, &#39;alpha1 * alpha2&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">params_name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 0, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iqp</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="n">iqp</span><span class="o">.</span><span class="n">data_preparation</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">array([-0.28324704-0.21159186j, -0.28324704-0.21159186j,</span>
<span class="go">        0.31027229+0.16950252j,  0.31027229+0.16950252j,</span>
<span class="go">        0.02500938+0.35266773j,  0.02500938+0.35266773j,</span>
<span class="go">        0.31027229+0.16950252j,  0.31027229+0.16950252j])</span>
</pre></div>
</div>
<dl class="method">
<dt id="mindquantum.algorithm.nisq.IQPEncoding.data_preparation">
<code class="sig-name descname">data_preparation</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qnn/iqp_encoding.html#IQPEncoding.data_preparation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.IQPEncoding.data_preparation" title="Permalink to this definition">¶</a></dt>
<dd><p>The IQPEncoding ansatz provide a ansatz to encode classical data into quantum state.
This method will prepare the classical data into suitable dimension for IQPEncoding.
Suppose the origin data has <span class="math notranslate nohighlight">\(n\)</span> features, then the output data will have <span class="math notranslate nohighlight">\(2n-1\)</span> features,
with first <span class="math notranslate nohighlight">\(n\)</span> features keep the same and for <span class="math notranslate nohighlight">\(m &gt; n\)</span>,</p>
<div class="math notranslate nohighlight">
\[\text{data}_m = \text{data}_{m - n} * \text{data}_{m - n - 1}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>, </em><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a><em>]</em>) – The classical data need to encode with IQPEncoding ansatz.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray, the prepared data that is suitable for this ansatz.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mindquantum.algorithm.nisq.Max2SATAnsatz">
<em class="property">class </em><code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">Max2SATAnsatz</code><span class="sig-paren">(</span><em class="sig-param">clauses</em>, <em class="sig-param">depth=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_2_sat_ansatz.html#Max2SATAnsatz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Max2SATAnsatz" title="Permalink to this definition">¶</a></dt>
<dd><p>The Max-2-SAT ansatz. For more detail,
please refers to <a class="reference external" href="https://arxiv.org/pdf/1906.11259.pdf">https://arxiv.org/pdf/1906.11259.pdf</a>.</p>
<div class="math notranslate nohighlight">
\[U(\beta, \gamma) = e^{-\beta_pH_b}e^{-\gamma_pH_c}
\cdots e^{-\beta_0H_b}e^{-\gamma_0H_c}H^{\otimes n}\]</div>
<p>Where,</p>
<div class="math notranslate nohighlight">
\[H_b = \sum_{i\in n}X_{i}, H_c = \sum_{l\in m}P(l)\]</div>
<p>Here <span class="math notranslate nohighlight">\(n\)</span> is the number of Boolean variables and <span class="math notranslate nohighlight">\(m\)</span> is the number
of total clauses and <span class="math notranslate nohighlight">\(P(l)\)</span> is rank-one projector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clauses</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The Max-2-SAT structure. Every element of list
is a clause represented by a tuple with length two. The element of
tuple must be non-zero integer. For example, (2, -3) stands for clause
<span class="math notranslate nohighlight">\(x_2\lor\lnot x_3\)</span>.</p></li>
<li><p><strong>depth</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The depth of Max-2-SAT ansatz. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.qaoa</span> <span class="kn">import</span> <span class="n">Max2SATAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clauses</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max2sat</span> <span class="o">=</span> <span class="n">Max2SATAnsatz</span><span class="p">(</span><span class="n">clauses</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max2sat</span><span class="o">.</span><span class="n">circuit</span>
<span class="go">q1: ──H─────RZ(0.5*beta_0)────●───────────────────────●────RX(alpha_0)──</span>
<span class="go">                              │                       │</span>
<span class="go">q2: ──H────RZ(-0.5*beta_0)────X────RZ(-0.5*beta_0)────X────RX(alpha_0)──</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">max2sat</span><span class="o">.</span><span class="n">hamiltonian</span>
<span class="go">0.25 [] +</span>
<span class="go">0.25 [Z1] +</span>
<span class="go">-0.25 [Z1 Z2] +</span>
<span class="go">-0.25 [Z2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sats</span> <span class="o">=</span> <span class="n">max2sat</span><span class="o">.</span><span class="n">get_sat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sats</span>
<span class="go">[&#39;001&#39;, &#39;000&#39;, &#39;011&#39;, &#39;010&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sats</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sat value: </span><span class="si">{</span><span class="n">max2sat</span><span class="o">.</span><span class="n">get_sat_value</span><span class="p">([</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">sat value: 1</span>
<span class="go">sat value: 0</span>
<span class="go">sat value: 2</span>
<span class="go">sat value: 1</span>
</pre></div>
</div>
<dl class="method">
<dt id="mindquantum.algorithm.nisq.Max2SATAnsatz.get_sat">
<code class="sig-name descname">get_sat</code><span class="sig-paren">(</span><em class="sig-param">max_n</em>, <em class="sig-param">weight</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_2_sat_ansatz.html#Max2SATAnsatz.get_sat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Max2SATAnsatz.get_sat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the strings of this max-2-sat problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_n</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – how many strings you want.</p></li>
<li><p><strong>weight</strong> (<em>Union</em><em>[</em><a class="reference internal" href="mindquantum.core.parameterresolver.html#mindquantum.core.parameterresolver.ParameterResolver" title="mindquantum.core.parameterresolver.ParameterResolver"><em>ParameterResolver</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a><em>, </em><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/numbers.html#numbers.Number" title="(in Python v3.8)"><em>numbers.Number</em></a><em>]</em>) – parameter
value for Max-2-SAT ansatz.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list, a list of strings.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.Max2SATAnsatz.get_sat_value">
<code class="sig-name descname">get_sat_value</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_2_sat_ansatz.html#Max2SATAnsatz.get_sat_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Max2SATAnsatz.get_sat_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sat values for given strings.
The string is a str that satisfies all the clauses of the given max-2-sat problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – a string of the max-2-sat problem consided.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>int, sat_value under the given string.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.Max2SATAnsatz.hamiltonian">
<em class="property">property </em><code class="sig-name descname">hamiltonian</code><a class="headerlink" href="#mindquantum.algorithm.nisq.Max2SATAnsatz.hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the hamiltonian of this max-2-sat problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, hamiltonian of this max-2-sat problem.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mindquantum.algorithm.nisq.MaxCutAnsatz">
<em class="property">class </em><code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">MaxCutAnsatz</code><span class="sig-paren">(</span><em class="sig-param">graph</em>, <em class="sig-param">depth=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_cut_ansatz.html#MaxCutAnsatz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.MaxCutAnsatz" title="Permalink to this definition">¶</a></dt>
<dd><p>The MaxCut ansatz. For more detail,
please refers to <a class="reference external" href="https://arxiv.org/pdf/1411.4028.pdf">https://arxiv.org/pdf/1411.4028.pdf</a>.</p>
<div class="math notranslate nohighlight">
\[U(\beta, \gamma) = e^{-\beta_pH_b}e^{-\gamma_pH_c}
\cdots e^{-\beta_0H_b}e^{-\gamma_0H_c}H^{\otimes n}\]</div>
<p>Where,</p>
<div class="math notranslate nohighlight">
\[H_b = \sum_{i\in n}X_{i}, H_c = \sum_{(i,j)\in C}Z_iZ_j\]</div>
<p>Here <span class="math notranslate nohighlight">\(n\)</span> is the set of nodes and <span class="math notranslate nohighlight">\(C\)</span> is the set of
edges of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#tuple" title="(in Python v3.8)"><em>tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The graph structure. Every element of graph
is a edge that constructed by two nodes.</p></li>
<li><p><strong>depth</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The depth of max cut ansatz. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.qaoa</span> <span class="kn">import</span> <span class="n">MaxCutAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxcut</span> <span class="o">=</span> <span class="n">MaxCutAnsatz</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxcut</span><span class="o">.</span><span class="n">circuit</span>
<span class="go">q0: ──H────ZZ(beta_0)──────────────────ZZ(beta_0)────RX(alpha_0)──</span>
<span class="go">               │                           │</span>
<span class="go">q1: ──H────ZZ(beta_0)────ZZ(beta_0)────────┼─────────RX(alpha_0)──</span>
<span class="go">                             │             │</span>
<span class="go">q2: ──H──────────────────ZZ(beta_0)────ZZ(beta_0)────RX(alpha_0)──</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maxcut</span><span class="o">.</span><span class="n">hamiltonian</span>
<span class="go">1.5 [] +</span>
<span class="go">-0.5 [Z0 Z1] +</span>
<span class="go">-0.5 [Z0 Z2] +</span>
<span class="go">-0.5 [Z1 Z2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxcut</span><span class="o">.</span><span class="n">hamiltonian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">partitions</span> <span class="o">=</span> <span class="n">maxcut</span><span class="o">.</span><span class="n">get_partition</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;partition: left: </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">, right: </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">, cut value: </span><span class="si">{</span><span class="n">maxcut</span><span class="o">.</span><span class="n">get_cut_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">partition: left: [2], right: [0, 1], cut value: 2</span>
<span class="go">partition: left: [0, 1], right: [2], cut value: 2</span>
<span class="go">partition: left: [0], right: [1, 2], cut value: 2</span>
<span class="go">partition: left: [0, 1, 2], right: [], cut value: 0</span>
<span class="go">partition: left: [], right: [0, 1, 2], cut value: 0</span>
</pre></div>
</div>
<dl class="method">
<dt id="mindquantum.algorithm.nisq.MaxCutAnsatz.get_cut_value">
<code class="sig-name descname">get_cut_value</code><span class="sig-paren">(</span><em class="sig-param">partition</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_cut_ansatz.html#MaxCutAnsatz.get_cut_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.MaxCutAnsatz.get_cut_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the cut values for given partitions. The partition is a list that contains two lists,
each list contains the nodes of the given graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>partition</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – a partition of the graph consided.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>int, cut_value under the given partition.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.MaxCutAnsatz.get_partition">
<code class="sig-name descname">get_partition</code><span class="sig-paren">(</span><em class="sig-param">max_n</em>, <em class="sig-param">weight</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/qaoa/max_cut_ansatz.html#MaxCutAnsatz.get_partition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.MaxCutAnsatz.get_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the partitions of this max-cut problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_n</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – how many partitions you want.</p></li>
<li><p><strong>weight</strong> (<em>Union</em><em>[</em><a class="reference internal" href="mindquantum.core.parameterresolver.html#mindquantum.core.parameterresolver.ParameterResolver" title="mindquantum.core.parameterresolver.ParameterResolver"><em>ParameterResolver</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a><em>, </em><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a><em>, </em><a class="reference external" href="https://docs.python.org/library/numbers.html#numbers.Number" title="(in Python v3.8)"><em>numbers.Number</em></a><em>]</em>) – parameter
value for max-cut ansatz.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list, a list of partitions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.MaxCutAnsatz.hamiltonian">
<em class="property">property </em><code class="sig-name descname">hamiltonian</code><a class="headerlink" href="#mindquantum.algorithm.nisq.MaxCutAnsatz.hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the hamiltonian of this max cut problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, hamiltonian of this max cut problem.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mindquantum.algorithm.nisq.QubitUCCAnsatz">
<em class="property">class </em><code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">QubitUCCAnsatz</code><span class="sig-paren">(</span><em class="sig-param">n_qubits=None</em>, <em class="sig-param">n_electrons=None</em>, <em class="sig-param">occ_orb=None</em>, <em class="sig-param">vir_orb=None</em>, <em class="sig-param">generalized=False</em>, <em class="sig-param">trotter_step=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/qubit_ucc_ansatz.html#QubitUCCAnsatz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.QubitUCCAnsatz" title="Permalink to this definition">¶</a></dt>
<dd><p>Qubit Unitary Coupled-Cluster (qUCC) ansatz is a variant of unitary
coupled-cluster ansatz which uses qubit excitation operators instead of
Fermion excitation operators. The Fock space spanned by qubit excitation
operators is equivalent as Fermion operators, therefore the exact
wave function can be approximated using qubit excitation operators at
the expense of a higher order of Trotterization.</p>
<p>The greatest advantange of qUCC is that the number of CNOT gates is much
smaller than the original version of UCC, even using a 3rd or 4th order
Trotterization. Also, the accuracy is greatly improved despite that the
number of variational parameters is increased.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Hartree-Fock circuit is not included.
Currently, generalized=True is not allowed since the theory needs verification.
Reference: Yordan S. Yordanov et al. Phys. Rev. A, 102, 062612 (2020)</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of qubits (spin-orbitals) in the simulation. Default: None.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of electrons of the given molecule. Default: None.</p></li>
<li><p><strong>occ_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned occupied spatial orbitals. Default: None.</p></li>
<li><p><strong>vir_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned virtual spatial orbitals. Default: None.</p></li>
<li><p><strong>generalized</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to use generalized excitations which
do not distinguish occupied or virtual orbitals (qUCCGSD). Currently,
generalized=True is not allowed since the theory needs verification. Default: False.</p></li>
<li><p><strong>trotter_step</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The number of Trotter steps. Default is one. It is
recommended to set a value larger than or equal to 2 to achieve a
good accuracy. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">QubitUCCAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QubitUCCAnsatz</span><span class="p">()</span><span class="o">.</span><span class="n">n_qubits</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc</span> <span class="o">=</span> <span class="n">QubitUCCAnsatz</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">trotter_step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc</span><span class="o">.</span><span class="n">circuit</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">q0: ──X──────────●──────────X───────────────────────────────X──────────●──────────X───────</span>
<span class="go">      │          │          │                               │          │          │</span>
<span class="go">q1: ──┼──────────┼──────────┼────X──────────●──────────X────┼──────────┼──────────┼────X──</span>
<span class="go">      │          │          │    │          │          │    │          │          │    │</span>
<span class="go">q2: ──●────RY(t_0_q_s_0)────●────●────RY(t_0_q_s_1)────●────┼──────────┼──────────┼────┼──</span>
<span class="go">                                                            │          │          │    │</span>
<span class="go">q3: ────────────────────────────────────────────────────────●────RY(t_0_q_s_2)────●────●──</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc</span><span class="o">.</span><span class="n">n_qubits</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc_2</span> <span class="o">=</span> <span class="n">QubitUCCAnsatz</span><span class="p">(</span><span class="n">occ_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vir_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qucc_2</span><span class="o">.</span><span class="n">operator_pool</span>
<span class="go">[-1.0*t_0_q_s_0 [Q0^ Q4] +</span>
<span class="go">1.0*t_0_q_s_0 [Q4^ Q0] , -1.0*t_0_q_s_1 [Q1^ Q4] +</span>
<span class="go">1.0*t_0_q_s_1 [Q4^ Q1] , -1.0*t_0_q_s_2 [Q2^ Q4] +</span>
<span class="go">1.0*t_0_q_s_2 [Q4^ Q2] , -1.0*t_0_q_s_3 [Q3^ Q4] +</span>
<span class="go">1.0*t_0_q_s_3 [Q4^ Q3] , -1.0*t_0_q_s_4 [Q0^ Q5] +</span>
<span class="go">1.0*t_0_q_s_4 [Q5^ Q0] , -1.0*t_0_q_s_5 [Q1^ Q5] +</span>
<span class="go">1.0*t_0_q_s_5 [Q5^ Q1] , -1.0*t_0_q_s_6 [Q2^ Q5] +</span>
<span class="go">1.0*t_0_q_s_6 [Q5^ Q2] , -1.0*t_0_q_s_7 [Q3^ Q5] +</span>
<span class="go">1.0*t_0_q_s_7 [Q5^ Q3] , -1.0*t_0_q_d_0 [Q1^ Q0^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_0 [Q5^ Q4^ Q1 Q0] , -1.0*t_0_q_d_1 [Q2^ Q0^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_1 [Q5^ Q4^ Q2 Q0] , -1.0*t_0_q_d_2 [Q2^ Q1^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_2 [Q5^ Q4^ Q2 Q1] , -1.0*t_0_q_d_3 [Q3^ Q0^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_3 [Q5^ Q4^ Q3 Q0] , -1.0*t_0_q_d_4 [Q3^ Q1^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_4 [Q5^ Q4^ Q3 Q1] , -1.0*t_0_q_d_5 [Q3^ Q2^ Q5 Q4] +</span>
<span class="go">1.0*t_0_q_d_5 [Q5^ Q4^ Q3 Q2] ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="mindquantum.algorithm.nisq.Transform">
<em class="property">class </em><code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">Transform</code><span class="sig-paren">(</span><em class="sig-param">operator</em>, <em class="sig-param">n_qubits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for transforms of fermionic and qubit operators.
Methods jordan_wigner, parity, bravyi_kitaev, bravyi_kitaev_tree,
bravyi_kitaev_superfast make transform of fermionic operators to
qubit ones,
they are initialized by FermionOperator, return QubitOperator.
Note method reversed_jordan_wigner makes transform of qubit operator
to fermionic one, it is initialized by QubitOperator,
returns FermionOperator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<em>Union</em><em>[</em><a class="reference internal" href="mindquantum.core.operators.html#mindquantum.core.operators.FermionOperator" title="mindquantum.core.operators.FermionOperator"><em>FermionOperator</em></a><em>, </em><a class="reference internal" href="mindquantum.core.operators.html#mindquantum.core.operators.QubitOperator" title="mindquantum.core.operators.QubitOperator"><em>QubitOperator</em></a><em>]</em>) – The input
FermionOperator or QubitOperator that need to do transform.</p></li>
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The total qubits of this operator. Default: None</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">FermionOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op1</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">(</span><span class="s1">&#39;1^&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op1</span>
<span class="go">1.0 [1^]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span><span class="o">.</span><span class="n">jordan_wigner</span><span class="p">()</span>
<span class="go">0.5 [Z0 X1] +</span>
<span class="go">-0.5j [Z0 Y1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span><span class="o">.</span><span class="n">parity</span><span class="p">()</span>
<span class="go">0.5 [Z0 X1] +</span>
<span class="go">-0.5j [Y1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span><span class="o">.</span><span class="n">bravyi_kitaev</span><span class="p">()</span>
<span class="go">0.5 [Z0 X1] +</span>
<span class="go">-0.5j [Y1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_transform</span><span class="o">.</span><span class="n">ternary_tree</span><span class="p">()</span>
<span class="go">0.5 [X0 Z1] +</span>
<span class="go">-0.5j [Y0 X2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op2</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">(</span><span class="s1">&#39;1^&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Transform</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span><span class="o">.</span><span class="n">jordan_wigner</span><span class="p">()</span>
<span class="go">0.5*a [Z0 X1] +</span>
<span class="go">-0.5*I*a [Z0 Y1]</span>
</pre></div>
</div>
<dl class="method">
<dt id="mindquantum.algorithm.nisq.Transform.bravyi_kitaev">
<code class="sig-name descname">bravyi_kitaev</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.bravyi_kitaev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.bravyi_kitaev" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Bravyi-Kitaev transform.</p>
<p>The Bravyi-Kitaev basis is a middle between Jordan-Wigner
and parity transform. That is, it balances the locality of occupation and parity information
for improved simulation efficiency. In this scheme, qubits store the parity
of a set of <span class="math notranslate nohighlight">\(2^x\)</span> orbitals, where <span class="math notranslate nohighlight">\(x \ge 0\)</span>. A qubit of index j always
stores orbital <span class="math notranslate nohighlight">\(j\)</span>.
For even values of <span class="math notranslate nohighlight">\(j\)</span>, this is the only orbital
that it stores, but for odd values of <span class="math notranslate nohighlight">\(j\)</span>, it also stores a certain
set of adjacent orbitals with index less than <span class="math notranslate nohighlight">\(j\)</span>.
For the occupation transformation, we follow the
formular:</p>
<div class="math notranslate nohighlight">
\[b_{i} = \sum{[\beta_{n}]_{i,j}} f_{j},\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta_{n}\)</span> is the <span class="math notranslate nohighlight">\(N\times N\)</span> square matrix,
<span class="math notranslate nohighlight">\(N\)</span> is the total qubit number.
The qubits index are divide into three sets,
the parity set, the update set and flip set.
The parity of this set of qubits has
the same parity as the set of orbitals with index less than <span class="math notranslate nohighlight">\(j\)</span>,
and so we will call this set of qubit indices the “parity set” of
index <span class="math notranslate nohighlight">\(j\)</span>, or <span class="math notranslate nohighlight">\(P(j)\)</span>.</p>
<p>the update set of index <span class="math notranslate nohighlight">\(j\)</span>, or <span class="math notranslate nohighlight">\(U(j)\)</span> contains the set of qubits (other than
qubit <span class="math notranslate nohighlight">\(j\)</span>) that must be updated when the occupation of orbital <span class="math notranslate nohighlight">\(j\)</span>
This is the set of qubits in the Bravyi-Kitaev basis that store a
partial sum including orbital <span class="math notranslate nohighlight">\(j\)</span>.
the flip set of index <span class="math notranslate nohighlight">\(j\)</span>, or <span class="math notranslate nohighlight">\(F(j)\)</span> contains the set of BravyiKitaev qubits determines
whether qubit <span class="math notranslate nohighlight">\(j\)</span> has the same parity or inverted parity with
respect to orbital <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>Please see some detail explanation in the paper (THE JOURNAL OF
CHEMICAL PHYSICS 137, 224109 (2012)).</p>
<p>Implementation from <a class="reference external" href="https://arxiv.org/pdf/quant-ph/0003137.pdf">https://arxiv.org/pdf/quant-ph/0003137.pdf</a> and
“A New Data Structure for Cumulative Frequency Tables”
by Peter M. Fenwick.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubit operator after bravyi_kitaev transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.Transform.bravyi_kitaev_superfast">
<code class="sig-name descname">bravyi_kitaev_superfast</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.bravyi_kitaev_superfast"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.bravyi_kitaev_superfast" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Bravyi-Kitaev Superfast transform.
Implementation from <a class="reference external" href="https://arxiv.org/pdf/1712.00446.pdf">https://arxiv.org/pdf/1712.00446.pdf</a></p>
<p>Note that only hermitian operators of form</p>
<div class="math notranslate nohighlight">
\[C + \sum_{p, q} h_{p, q} a^\dagger_p a_q +
    \sum_{p, q, r, s} h_{p, q, r, s} a^\dagger_p a^\dagger_q a_r a_s\]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is a constant, be transformed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubit operator after bravyi_kitaev_superfast.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.Transform.jordan_wigner">
<code class="sig-name descname">jordan_wigner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.jordan_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.jordan_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Jordan-Wigner transform. The Jordan-Wigner transform
holds the initial occupation number locally.
which change the formular of fermion
operator into qubit operator following the equation.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}a^\dagger_{j}\rightarrow \sigma^{-}_{j} X \prod_{i=0}^{j-1}\sigma^{Z}_{i}\\a_{j}\rightarrow \sigma^{+}_{j} X \prod_{i=0}^{j-1}\sigma^{Z}_{i},\end{aligned}\end{align} \]</div>
<p>where the <span class="math notranslate nohighlight">\(\sigma_{+}= \sigma^{X} + i \sigma^{Y}\)</span> and <span class="math notranslate nohighlight">\(\sigma_{-} = \sigma^{X} - i\sigma^{Y}\)</span> is the
Pauli spin raising and lowring operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubit operator after jordan_wigner transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.Transform.parity">
<code class="sig-name descname">parity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.parity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.parity" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply parity transform.
The parity transform
stores the initial occupation number nonlocally.
with the formular:</p>
<div class="math notranslate nohighlight">
\[\left|f_{M−1}, f_{M−2},\cdots, f_0\right&gt; → \left|q_{M−1}, q_{M−2},\cdots, q_0\right&gt;,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[q_{m} = \left|\left(\sum_{i=0}^{m-1}f_{i}\right) mod\ 2 \right&gt;\]</div>
<p>Basically, this formular could be written as this,</p>
<div class="math notranslate nohighlight">
\[p_{i} = \sum{[\pi_{n}]_{i,j}} f_{j},\]</div>
<p>where <span class="math notranslate nohighlight">\(\pi_{n}\)</span> is the <span class="math notranslate nohighlight">\(N\times N\)</span> square matrix,
<span class="math notranslate nohighlight">\(N\)</span> is the total qubit number. The operator changes follows the following equation as:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}a^\dagger_{j}\rightarrow\frac{1}{2}\left(\prod_{i=j+1}^N
\left(\sigma_i^X X\right)\right)\left( \sigma^{X}_{j}-i\sigma_j^Y\right) X \sigma^{Z}_{j-1}\\a_{j}\rightarrow\frac{1}{2}\left(\prod_{i=j+1}^N
\left(\sigma_i^X X\right)\right)\left( \sigma^{X}_{j}+i\sigma_j^Y\right) X \sigma^{Z}_{j-1}\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubits operator after parity transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.Transform.reversed_jordan_wigner">
<code class="sig-name descname">reversed_jordan_wigner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.reversed_jordan_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.reversed_jordan_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply reversed Jordan-Wigner transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>FermionOperator, fermion operator after reversed_jordan_wigner transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mindquantum.algorithm.nisq.Transform.ternary_tree">
<code class="sig-name descname">ternary_tree</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/transform.html#Transform.ternary_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.Transform.ternary_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Ternary tree transform.
Implementation from <a class="reference external" href="https://arxiv.org/pdf/1910.10746.pdf">https://arxiv.org/pdf/1910.10746.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>QubitOperator, qubit operator after ternary_tree transformation.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mindquantum.algorithm.nisq.UCCAnsatz">
<em class="property">class </em><code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">UCCAnsatz</code><span class="sig-paren">(</span><em class="sig-param">n_qubits=None</em>, <em class="sig-param">n_electrons=None</em>, <em class="sig-param">occ_orb=None</em>, <em class="sig-param">vir_orb=None</em>, <em class="sig-param">generalized=False</em>, <em class="sig-param">trotter_step=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/unitary_cc.html#UCCAnsatz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.UCCAnsatz" title="Permalink to this definition">¶</a></dt>
<dd><p>The unitary coupled-cluster ansatz for molecular simulations.</p>
<div class="math notranslate nohighlight">
\[U(\vec{\theta}) = \prod_{j=1}^{N(N\ge1)}{\prod_{i=0}^{N_{j}}{\exp{(\theta_{i}\hat{\tau}_{i})}}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\tau}\)</span> are anti-Hermitian operators.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the circuit is construncted using JW transformation.
In addition, the reference state wave function (Hartree-Fock) will NOT be
included.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of qubits (spin-orbitals). Default: None.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons (occupied spin-orbitals). Default: None.</p></li>
<li><p><strong>occ_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned occupied spatial
orbitals, for ansatz construction only. Default: None.</p></li>
<li><p><strong>vir_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned virtual spatial
orbitals, for ansatz construction only. Default: None.</p></li>
<li><p><strong>generalized</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to use generalized excitations which
do not distinguish occupied or virtual orbitals (UCCGSD). Default: False.</p></li>
<li><p><strong>trotter_step</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The order of Trotterization step. Default: 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">UCCAnsatz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ucc</span> <span class="o">=</span> <span class="n">UCCAnsatz</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">occ_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                <span class="n">vir_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                <span class="n">generalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">trotter_step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span> <span class="o">=</span> <span class="n">ucc</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">remove_barrier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
<span class="go">3624</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params_list</span> <span class="o">=</span> <span class="n">ucc</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">params_name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">params_list</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]</span>
<span class="go">q5: ──●────RX(7π/2)───────H───────●────────────────────────────●───────H──────</span>
<span class="go">      │                           │                            │</span>
<span class="go">q7: ──X───────H────────RX(π/2)────X────RZ(-0.5*t_1_d0_d_17)────X────RX(7π/2)──</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindquantum.algorithm.nisq.generate_uccsd">
<code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">generate_uccsd</code><span class="sig-paren">(</span><em class="sig-param">molecular</em>, <em class="sig-param">th=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/uccsd.html#generate_uccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.generate_uccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a uccsd quantum circuit based on a molecular data generated by
HiQfermion or openfermion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecular</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>MolecularData</em><em>]</em>) – the name of the molecular data file,
or openfermion MolecularData.</p></li>
<li><p><strong>th</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – the threshold to filt the uccsd amplitude. When th &lt; 0, we
will keep all amplitudes. When th == 0, we will keep all amplitude
that are positive. Default: 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>uccsd_circuit</strong> (Circuit), the ansatz circuit generated by uccsd method.</p></li>
<li><p><strong>initial_amplitudes</strong> (numpy.ndarray), the initial parameter values of uccsd circuit.</p></li>
<li><p><strong>parameters_name</strong> (list[str]), the name of initial parameters.</p></li>
<li><p><strong>qubit_hamiltonian</strong> (QubitOperator), the hamiltonian of the molecule.</p></li>
<li><p><strong>n_qubits</strong> (int), the number of qubits in simulation.</p></li>
<li><p><strong>n_electrons</strong>, the number of electrons of the molecule.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mindquantum.algorithm.nisq.get_qubit_hamiltonian">
<code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">get_qubit_hamiltonian</code><span class="sig-paren">(</span><em class="sig-param">mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/qubit_hamiltonian.html#get_qubit_hamiltonian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.get_qubit_hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the qubit hamiltonian of a molecular data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mol</strong> (<em>MolecularData</em>) – molecular data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>QubitOperator, qubit operator of this molecular.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mindquantum.algorithm.nisq.quccsd_generator">
<code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">quccsd_generator</code><span class="sig-paren">(</span><em class="sig-param">n_qubits=None</em>, <em class="sig-param">n_electrons=None</em>, <em class="sig-param">anti_hermitian=True</em>, <em class="sig-param">occ_orb=None</em>, <em class="sig-param">vir_orb=None</em>, <em class="sig-param">generalized=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/quccsd.html#quccsd_generator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.quccsd_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate qubit-UCCSD (qUCCSD) ansatz using qubit-excitation operators.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, unrestricted version is implemented, i.e., excitations from the
same spatial-orbital but with different spins will use distinct variational
parameters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of qubits (spin-orbitals). Default: None.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons (occupied spin-orbitals). Default: None.</p></li>
<li><p><strong>anti_hermitian</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to subtract the hermitian conjugate
to form anti-Hermitian operators. Default: True.</p></li>
<li><p><strong>occ_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned occupied spatial
orbitals. Default: None.</p></li>
<li><p><strong>vir_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned virtual spatial
orbitals. Default: None.</p></li>
<li><p><strong>generalized</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to use generalized excitations which
do not distinguish occupied or virtual orbitals (qUCCGSD). Default: False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Generator of the qUCCSD operators.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="mindquantum.core.operators.html#mindquantum.core.operators.QubitExcitationOperator" title="mindquantum.core.operators.QubitExcitationOperator">QubitExcitationOperator</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">quccsd_generator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quccsd_generator</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quccsd_generator</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-1.0*q_s_0 [Q0^ Q2] +</span>
<span class="go">-1.0*q_s_2 [Q0^ Q3] +</span>
<span class="go">-1.0*q_d_0 [Q1^ Q0^ Q3 Q2] +</span>
<span class="go">-1.0*q_s_1 [Q1^ Q2] +</span>
<span class="go">-1.0*q_s_3 [Q1^ Q3] +</span>
<span class="go">1.0*q_s_0 [Q2^ Q0] +</span>
<span class="go">1.0*q_s_1 [Q2^ Q1] +</span>
<span class="go">1.0*q_s_2 [Q3^ Q0] +</span>
<span class="go">1.0*q_s_3 [Q3^ Q1] +</span>
<span class="go">1.0*q_d_0 [Q3^ Q2^ Q1 Q0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q_op</span> <span class="o">=</span> <span class="n">quccsd_generator</span><span class="p">(</span><span class="n">occ_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vir_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">generalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q_qubit_op</span> <span class="o">=</span> <span class="n">q_op</span><span class="o">.</span><span class="n">to_qubit_operator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q_qubit_op</span><span class="p">)[:</span><span class="mi">315</span><span class="p">])</span>
<span class="go">0.125*I*q_d_4 + 0.125*I*q_d_7 + 0.125*I*q_d_9 [X0 X1 X2 Y3] +</span>
<span class="go">0.125*I*q_d_4 - 0.125*I*q_d_7 - 0.125*I*q_d_9 [X0 X1 Y2 X3] +</span>
<span class="go">0.25*I*q_d_12 + 0.25*I*q_d_5 + 0.5*I*q_s_0 - 0.5*I*q_s_3 [X0 Y1] +</span>
<span class="go">-0.125*I*q_d_4 + 0.125*I*q_d_7 - 0.125*I*q_d_9 [X0 Y1 X2 X3] +</span>
<span class="go">0.125*I*q_d_4 + 0.125*I*q_d_7 - 0.125*I*q_d_9 [X0 Y1 Y2 Y3] +</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindquantum.algorithm.nisq.uccsd0_singlet_generator">
<code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">uccsd0_singlet_generator</code><span class="sig-paren">(</span><em class="sig-param">n_qubits=None</em>, <em class="sig-param">n_electrons=None</em>, <em class="sig-param">anti_hermitian=True</em>, <em class="sig-param">occ_orb=None</em>, <em class="sig-param">vir_orb=None</em>, <em class="sig-param">generalized=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/algorithm/nisq/chem/uccsd0.html#uccsd0_singlet_generator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.uccsd0_singlet_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate UCCSD operators using CCD0 ansatz for molecular systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Manually assigned occ_orb or vir_orb are indices of spatial orbitals
instead of spin-orbitals. They will override n_electrons and
n_qubits. This is to some degree similar to the active space,
therefore can reduce the number of variational parameters. However, it
may not reduce the number of required qubits, since Fermion
excitation operators are non-local, i.e.,
<span class="math notranslate nohighlight">\(a_{7}^{\dagger} a_{0}\)</span> involves not only the 0th and 7th
qubit, but also the 1st, 2nd, … 6th qubit.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of qubits (spin-orbitals). Default: None.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons (occupied spin-orbitals). Default: None.</p></li>
<li><p><strong>anti_hermitian</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to subtract the hermitian conjugate
to form anti-Hermitian operators. Default: True.</p></li>
<li><p><strong>occ_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned occupied spatial
orbitals. Default: None.</p></li>
<li><p><strong>vir_orb</strong> (<a class="reference external" href="https://docs.python.org/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – Indices of manually assigned virtual spatial
orbitals. Default: None.</p></li>
<li><p><strong>generalized</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to use generalized excitations which
do not distinguish occupied or virtual orbitals (UCCGSD). Default: False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>FermionOperator, Generator of the UCCSD operators that uses CCD0 ansatz.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem.uccsd0</span> <span class="kn">import</span> <span class="n">uccsd0_singlet_generator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd0_singlet_generator</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-1.0*d0_s_0 [0^ 2] +</span>
<span class="go">2.0*d0_d_0 [1^ 0^ 3 2] +</span>
<span class="go">-1.0*d0_s_0 [1^ 3] +</span>
<span class="go">1.0*d0_s_0 [2^ 0] +</span>
<span class="go">1.0*d0_s_0 [3^ 1] +</span>
<span class="go">-2.0*d0_d_0 [3^ 2^ 1 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd0_singlet_generator</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">generalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">1.0*d0_s_0 - 1.0*d0_s_1 [0^ 2] +</span>
<span class="go">1.0*d0_d_0 [1^ 0^ 2 1] +</span>
<span class="go">-1.0*d0_d_0 [1^ 0^ 3 0] +</span>
<span class="go">-2.0*d0_d_1 [1^ 0^ 3 2] +</span>
<span class="go">1.0*d0_s_0 - 1.0*d0_s_1 [1^ 3] +</span>
<span class="go">-1.0*d0_s_0 + 1.0*d0_s_1 [2^ 0] +</span>
<span class="go">-1.0*d0_d_0 [2^ 1^ 1 0] +</span>
<span class="go">1.0*d0_d_2 [2^ 1^ 3 2] +</span>
<span class="go">1.0*d0_d_0 [3^ 0^ 1 0] +</span>
<span class="go">-1.0*d0_d_2 [3^ 0^ 3 2] +</span>
<span class="go">-1.0*d0_s_0 + 1.0*d0_s_1 [3^ 1] +</span>
<span class="go">2.0*d0_d_1 [3^ 2^ 1 0] +</span>
<span class="go">-1.0*d0_d_2 [3^ 2^ 2 1] +</span>
<span class="go">1.0*d0_d_2 [3^ 2^ 3 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd0_singlet_generator</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">occ_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vir_orb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">-1.0*d0_s_0 [0^ 2] +</span>
<span class="go">2.0*d0_d_0 [1^ 0^ 3 2] +</span>
<span class="go">-1.0*d0_s_0 [1^ 3] +</span>
<span class="go">1.0*d0_s_0 [2^ 0] +</span>
<span class="go">1.0*d0_s_0 [3^ 1] +</span>
<span class="go">-2.0*d0_d_0 [3^ 2^ 1 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindquantum.algorithm.nisq.uccsd_singlet_generator">
<code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">uccsd_singlet_generator</code><span class="sig-paren">(</span><em class="sig-param">n_qubits</em>, <em class="sig-param">n_electrons</em>, <em class="sig-param">anti_hermitian=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/third_party/unitary_cc.html#uccsd_singlet_generator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.uccsd_singlet_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a singlet UCCSD generator for a system with n_electrons</p>
<p>This function generates a FermionOperator for a UCCSD generator designed
to act on a single reference state consisting of n_qubits spin orbitals
and n_electrons electrons, that is a spin singlet operator, meaning it
conserves spin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of spin-orbitals used to represent the system,
which also corresponds to number of qubits in a non-compact map.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons in the physical system.</p></li>
<li><p><strong>anti_hermitian</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Flag to generate only normal CCSD operator
rather than unitary variant, primarily for testing</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>FermionOperator, Generator of the UCCSD operator that
builds the UCCSD wavefunction.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">uccsd_singlet_generator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd_singlet_generator</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-s_0 [0^ 2] +</span>
<span class="go">-d1_0 [0^ 2 1^ 3] +</span>
<span class="go">-s_0 [1^ 3] +</span>
<span class="go">-d1_0 [1^ 3 0^ 2] +</span>
<span class="go">s_0 [2^ 0] +</span>
<span class="go">d1_0 [2^ 0 3^ 1] +</span>
<span class="go">s_0 [3^ 1] +</span>
<span class="go">d1_0 [3^ 1 2^ 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindquantum.algorithm.nisq.uccsd_singlet_get_packed_amplitudes">
<code class="sig-prename descclassname">mindquantum.algorithm.nisq.</code><code class="sig-name descname">uccsd_singlet_get_packed_amplitudes</code><span class="sig-paren">(</span><em class="sig-param">single_amplitudes</em>, <em class="sig-param">double_amplitudes</em>, <em class="sig-param">n_qubits</em>, <em class="sig-param">n_electrons</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mindquantum/third_party/unitary_cc.html#uccsd_singlet_get_packed_amplitudes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mindquantum.algorithm.nisq.uccsd_singlet_get_packed_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert amplitudes for use with singlet UCCSD</p>
<p>The output list contains only those amplitudes that are relevant to
singlet UCCSD, in an order suitable for use with the function
<cite>uccsd_singlet_generator</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_amplitudes</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – <span class="math notranslate nohighlight">\(N\times N\)</span> array storing single excitation
amplitudes corresponding to <span class="math notranslate nohighlight">\(t_{i,j} * (a_i^\dagger a_j - \text{H.C.})\)</span></p></li>
<li><p><strong>double_amplitudes</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – <span class="math notranslate nohighlight">\(N\times N\times N\times N\)</span> array storing double
excitation amplitudes corresponding to
<span class="math notranslate nohighlight">\(t_{i,j,k,l} * (a_i^\dagger a_j a_k^\dagger a_l - \text{H.C.})\)</span></p></li>
<li><p><strong>n_qubits</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of spin-orbitals used to represent the system,
which also corresponds to number of qubits in a non-compact map.</p></li>
<li><p><strong>n_electrons</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of electrons in the physical system.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ParameterResolver, List storing the unique single
and double excitation amplitudes for a singlet UCCSD operator.
The ordering lists unique single excitations before double
excitations.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq.chem</span> <span class="kn">import</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_electrons</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ccsd_single_amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ccsd_double_amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uccsd_singlet_get_packed_amplitudes</span><span class="p">(</span><span class="n">ccsd_single_amps</span><span class="p">,</span> <span class="n">ccsd_double_amps</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_electrons</span><span class="p">)</span>
<span class="go">{&#39;s_0&#39;: 0.6011150117432088, &#39;d1_0&#39;: 0.7616196153287176}</span>
</pre></div>
</div>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="mindquantum.io.html" class="btn btn-neutral float-right" title="mindquantum.io" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="mindquantum.algorithm.library.html" class="btn btn-neutral float-left" title="mindquantum.algorithm.library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, MindSpore.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>