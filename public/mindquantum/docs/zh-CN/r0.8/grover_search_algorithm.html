<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>基于MindQuantum的Grover搜索算法和龙算法 &mdash; MindSpore master 文档</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/translations.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="基于MindQuantum的Shor算法" href="shor_algorithm.html" />
    <link rel="prev" title="量子相位估计算法" href="quantum_phase_estimation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">安装部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum_install.html">安装MindQuantum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">基础使用指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameterized_quantum_circuit.html">变分量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_simulator.html">量子模拟器</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_experience_of_quantum_neural_network.html">量子神经网络初体验</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_gradient_of_PQC_with_mindquantum.html">变分量子线路梯度计算进阶</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_operations_of_quantum_circuit.html">量子线路高阶操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_measurement.html">量子测量</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">含噪声量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="bloch_sphere.html">布洛赫球</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">变分量子算法</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">通过量子神经网络对鸢尾花进行分类</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">量子近似优化算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">量子神经网络在自然语言处理中的应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe_for_quantum_chemistry.html">在量子化学计算中应用量子变分求解器</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">通用量子算法</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">量子相位估计算法</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">基于MindQuantum的Grover搜索算法和龙算法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#概述">概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#问题描述">问题描述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grover搜索算法的基本原理">Grover搜索算法的基本原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="#构造翻转量子比特相位的酉算子">构造翻转量子比特相位的酉算子</a></li>
<li class="toctree-l2"><a class="reference internal" href="#利用mindquantum实现grover搜素算法实例">利用MindQuantum实现Grover搜素算法实例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#实例1-n3​\omega\rangle2\rangle单目标">实例1：<span class="math notranslate nohighlight">\(n=3\)</span>​，<span class="math notranslate nohighlight">\(|\omega\rangle=|2\rangle\)</span>（单目标）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#实例2-n5\omega\rangle5\rangle和11\rangle多目标">实例2：<span class="math notranslate nohighlight">\(n=5\)</span>，<span class="math notranslate nohighlight">\(|\omega\rangle=|5\rangle\)</span>和<span class="math notranslate nohighlight">\(|11\rangle\)</span>（多目标）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#龙算法">龙算法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#一般角度相位转动线路">一般角度相位转动线路</a></li>
<li class="toctree-l3"><a class="reference internal" href="#搭建龙算子">搭建龙算子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#完成量子精确搜索算法-龙算法">完成量子精确搜索算法：龙算法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#参考文献-"><strong>参考文献：</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">基于MindQuantum的Shor算法</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>基于MindQuantum的Grover搜索算法和龙算法</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/grover_search_algorithm.ipynb.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="基于mindquantum的grover搜索算法和龙算法">
<h1>基于MindQuantum的Grover搜索算法和龙算法<a class="headerlink" href="#基于mindquantum的grover搜索算法和龙算法" title="永久链接至标题"></a></h1>
<p><a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/r2.0.0-alpha/mindquantum/zh_cn/mindspore_grover_search_algorithm.ipynb"><img alt="下载Notebook" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.0.0-alpha/resource/_static/logo_notebook.png" /></a>  <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/r2.0.0-alpha/mindquantum/zh_cn/mindspore_grover_search_algorithm.py"><img alt="下载样例代码" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.0.0-alpha/resource/_static/logo_download_code.png" /></a>  <a class="reference external" href="https://gitee.com/mindspore/docs/blob/r2.0.0-alpha/docs/mindquantum/docs/source_zh_cn/grover_search_algorithm.ipynb"><img alt="查看源文件" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.0.0-alpha/resource/_static/logo_source.png" /></a>  <a class="reference external" href="https://authoring-modelarts-cnnorth4.huaweicloud.com/console/lab?share-url-b64=aHR0cHM6Ly9taW5kc3BvcmUtd2Vic2l0ZS5vYnMuY24tbm9ydGgtNC5teWh1YXdlaWNsb3VkLmNvbS9ub3RlYm9vay9yMi4wLjAtYWxwaGEvbWluZHF1YW50dW0vemhfY24vbWluZHNwb3JlX2dyb3Zlcl9zZWFyY2hfYWxnb3JpdGhtLmlweW5i&amp;imageid=b711ac95-db2b-45b7-ab9b-98de275dd57e"><img alt="在ModelArts平台运行" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.0.0-alpha/resource/_static/logo_modelarts.png" /></a></p>
<section id="概述">
<h2>概述<a class="headerlink" href="#概述" title="永久链接至标题"></a></h2>
<p>如果你听过量子计算，那么你一定听说过Grover搜索算法。1996年，Lov Grover [1] 提出了Grover搜索算法，它是一种利用量子状态的叠加性进行并行计算并实现加速的算法。Grover搜索算法被公认为是继Shor算法后的第二大量子算法，也是第一个被完整的实验实现的量子算法，它解决的是无序数据库搜索问题。1997年，Bennett [2] 等人证明，对于非结构化的量子搜索问题，至少需要<span class="math notranslate nohighlight">\(\Omega(\sqrt{N})\)</span>​次量子查询，因此Grover搜索算法对于该问题是渐进意义下的最优算法。</p>
<p>无序数据库搜索问题（Unordered Database Search problem）就是从一个海量元素的无序数据库中，找到某些满足要求的元素。由于数据库中元素的数量是巨大的且这些元素是无序排列的，所以，要验证给定的元素是否满足要求很容易，但反过来，要找到这些元素却不是一件容易的事。</p>
<p>求解无序数据库搜索问题（不妨假设只有一个目标搜索数据），经典算法所需的时间复杂度为<span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span>，而Grover搜索算法所需的时间复杂度仅为<span class="math notranslate nohighlight">\(\mathcal{O}(\sqrt{N})\)</span>，相比经典算法具有平方加速，展示了量子计算的强大性能。此外，Grover搜索算法中用到的振幅扩大技巧，对许多启发式的经典搜索算法可以实现加速，因而具有广泛的应用。</p>
<p>本文档将会介绍Grover搜索算法的基本原理，以及通过两个具体的小例子来展示如何利用MindQuantum实现该算法。</p>
</section>
<section id="问题描述">
<h2>问题描述<a class="headerlink" href="#问题描述" title="永久链接至标题"></a></h2>
<p>我们需要在一组无序的<span class="math notranslate nohighlight">\(N\)</span>元素集合（数据库）中进行搜索。将数据库中的元素与索引（从<span class="math notranslate nohighlight">\(0\)</span>到<span class="math notranslate nohighlight">\(N-1\)</span>之间的整数）建立一一对应，我们关注于搜索这些元素的索引。考虑将该搜索问题表示为一个关于输入<span class="math notranslate nohighlight">\(x\)</span>的函数<span class="math notranslate nohighlight">\(f(x)\)</span>，其中<span class="math notranslate nohighlight">\(x\)</span>为<span class="math notranslate nohighlight">\(0\)</span>到<span class="math notranslate nohighlight">\(N-1\)</span>之间的整数。那么，函数<span class="math notranslate nohighlight">\(f\)</span>定义为：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{equation}
f(x)=\begin{cases}0,x\neq x_{target}\\\\
1,x=x_{target}
\end{cases}
\end{equation}.\end{split}\]</div>
<p>不失一般性，假设<span class="math notranslate nohighlight">\(N=2^n\)</span>​，那么在量子系统中，索引以量子态<span class="math notranslate nohighlight">\(|0\rangle,|1\rangle,...,|N-1\rangle\)</span>​（或<span class="math notranslate nohighlight">\(|00...0\rangle,|00...1\rangle,...,|11...1\rangle\)</span>​）表示，也即我们可以使用<span class="math notranslate nohighlight">\(n\)</span>​个量子比特存储这些索引。</p>
<p>同时假设搜索问题只有一个目标态<span class="math notranslate nohighlight">\(|\omega\rangle\)</span>。Grover搜索算法的目标就是以极大的概率将<span class="math notranslate nohighlight">\(|\omega\rangle\)</span>搜索出来。</p>
</section>
<section id="grover搜索算法的基本原理">
<h2>Grover搜索算法的基本原理<a class="headerlink" href="#grover搜索算法的基本原理" title="永久链接至标题"></a></h2>
<p>Grover搜索算法的基本原理：首先通过<code class="docutils literal notranslate"><span class="pre">Hadamard</span></code>门产生均匀叠加态，然后反复调用Grover迭代（或称为<span class="math notranslate nohighlight">\(G\)</span>算子），以放大目标项的概率振幅同时抑制非目标项的概率振幅（该方法称之为振幅放大），最后对末态进行测量，那么就能以极大的概率得到目标态<span class="math notranslate nohighlight">\(|\omega\rangle\)</span>​​。</p>
<p>Grover搜索算法主要包括以下步骤：</p>
<ul>
<li><p>Step 1：数据库初始化</p>
<p>对<span class="math notranslate nohighlight">\(|0\rangle^{\otimes n}\)</span>​​​​执行<span class="math notranslate nohighlight">\(H^{\otimes n}\)</span>​​​​​操作，使得数据库被初始为一个均匀叠加态，即</p>
<div class="math notranslate nohighlight">
\[|\psi_0\rangle=H^{\otimes n}|0\rangle^{\otimes n}=\frac{1}{\sqrt{N}}\sum_{i=0}^{N-1}|i\rangle.\]</div>
</li>
<li><p>Step 2：Grover迭代</p>
<p>Grover迭代又可以分解为四步：</p>
<ol class="arabic simple">
<li><p>执行Oracle算子<span class="math notranslate nohighlight">\(U_{\omega}\)</span>​，翻转目标态<span class="math notranslate nohighlight">\(|\omega \rangle\)</span>​​​​​的相位</p></li>
</ol>
<p>为了将需要寻找的数据和其它的数据区别开，最简单的方法就是翻转目标态的相位（增加一个负号），此时我们需要构造一个Oracle算子<span class="math notranslate nohighlight">\(U_{\omega}\)</span>，其作用如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{equation}
U_{\omega}|x\rangle=\begin{cases}
&amp;|x\rangle,x\neq \omega&amp;\\\\
-&amp;|x\rangle,x=\omega&amp;
\end{cases}
\end{equation}.\end{split}\]</div>
<p>由于当<span class="math notranslate nohighlight">\(x=\omega\)</span>​时，<span class="math notranslate nohighlight">\(f(\omega)=1\)</span>​，那么<span class="math notranslate nohighlight">\(U_{\omega}\)</span>​​的作用还可以表示成：</p>
<div class="math notranslate nohighlight">
\[U_{\omega}|x\rangle=(-1)^{f(x)}|x\rangle,\]</div>
<p>其矩阵表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{equation}
U_{\omega}=
\left[
\begin{array}{ccc}
     (-1)^{f(0)} &amp; 0           &amp; \dots  &amp; 0            \\\\
     0           &amp; (-1)^{f(1)} &amp; \dots  &amp; 0            \\\\
     \vdots      &amp; \vdots      &amp; \ddots &amp; \vdots       \\\\
     0           &amp; 0           &amp; \dots  &amp; (-1)^{f(N-1)}
\end{array}
\right]
\end{equation}.\end{split}\]</div>
<ol class="arabic simple" start="2">
<li><p>执行<span class="math notranslate nohighlight">\(H^{\otimes n}\)</span>操作</p></li>
</ol>
<p>对<span class="math notranslate nohighlight">\(n\)</span>位量子比特执行<span class="math notranslate nohighlight">\(H^{\otimes n}\)</span>操作。</p>
<ol class="arabic simple" start="3">
<li><p>执行条件相移算子<span class="math notranslate nohighlight">\(P\)</span></p></li>
</ol>
<p>条件相移算子<span class="math notranslate nohighlight">\(P\)</span>能使<span class="math notranslate nohighlight">\(|0\rangle\)</span>​态以外的每个态的相位都翻转，其作用如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{equation}
P|x\rangle=\begin{cases}&amp;|0\rangle,x= 0&amp;\\\\
-&amp;|x\rangle,x\neq0&amp;
\end{cases}
\end{equation}.\end{split}\]</div>
<p>其矩阵表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{equation}
P = 2(|0\rangle\langle0|)^{\otimes n} - I_n =
\left[
\begin{array}{ccc}
     1      &amp; 0      &amp; \dots  &amp; 0            \\\\
     0      &amp; -1     &amp; \dots  &amp; 0            \\\\
     \vdots &amp; \vdots &amp; \ddots &amp; \vdots       \\\\
     0      &amp; 0      &amp; \dots  &amp; -1
\end{array}
\right]
\end{equation}.\end{split}\]</div>
<ol class="arabic simple" start="4">
<li><p>再次执行<span class="math notranslate nohighlight">\(H^{\otimes n}\)</span>操作</p></li>
</ol>
<p>至此，完整的<span class="math notranslate nohighlight">\(G\)</span>算子可以表示为</p>
<div class="math notranslate nohighlight">
\[G = H^{\otimes n} [2(|0\rangle\langle0|)^{\otimes n} - I_n] H^{\otimes n} U_{\omega}.\]</div>
<p>注意：<span class="math notranslate nohighlight">\(G\)</span>算子需要迭代的次数为</p>
<div class="math notranslate nohighlight">
\[r = \left[ \frac{\pi}{4} \sqrt{\frac{N}{M}} \right] \sim O(\sqrt{N}),\]</div>
<p>其中，M表示目标态的个数。</p>
</li>
<li><p>Step 3：测量</p>
<p>对末态进行<span class="math notranslate nohighlight">\(\\{|0\rangle,|1\rangle\\}\)</span>基测量，就能以极大的概率得到目标态<span class="math notranslate nohighlight">\(|\omega \rangle\)</span>。</p>
</li>
</ul>
<p>Grover搜索算法的完整量子线路模型如下所示：</p>
<p><img alt="grover algorithm circuit" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.0.0-alpha/docs/mindquantum/docs/source_zh_cn/images/grover_algorithm_circuit.png" /></p>
</section>
<section id="构造翻转量子比特相位的酉算子">
<h2>构造翻转量子比特相位的酉算子<a class="headerlink" href="#构造翻转量子比特相位的酉算子" title="永久链接至标题"></a></h2>
<p>通过上述介绍，我们发现，Grover搜索算法中最关键的部分就是存在可以翻转量子比特相位的酉算子，Oracle算子<span class="math notranslate nohighlight">\(U_{\omega}\)</span>可以翻转目标态的相位，条件相移算子<span class="math notranslate nohighlight">\(P\)</span>可以翻转<span class="math notranslate nohighlight">\(|0\rangle\)</span>态以外的每个态的相位。</p>
<p>接下来，我们将构造可以翻转某一位量子比特相位的酉算子，定义如下：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">Z</span>

<span class="k">def</span> <span class="nf">bitphaseflip_operator</span><span class="p">(</span><span class="n">phase_inversion_qubit</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">):</span>   <span class="c1"># 定义可以翻转某一位量子比特相位的函数</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n_qubits</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phase_inversion_qubit</span><span class="p">:</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">cz</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">cz</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">current</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cz</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">circuit</span> <span class="o">+=</span> <span class="n">Z</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">circuit</span> <span class="o">+=</span> <span class="n">Z</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">circuit</span>
</pre></div>
</div>
</div>
<p>现在， <code class="docutils literal notranslate"><span class="pre">bitphaseflip_operator()</span></code> 函数就可以实现翻转某一位量子比特的相位，只需要输入需要翻转相位的目标量子态和量子比特总数即可。</p>
<p>举个例子，我们现在生成3​​量子比特的均匀叠加态，运行如下代码：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">H</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">UN</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>

<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">3</span>                                 <span class="c1"># 设定量子比特数为3</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>        <span class="c1"># 使用mqvector模拟器，命名为sim</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                          <span class="c1"># 初始化量子线路，命名为circuit</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>                   <span class="c1"># 每位量子比特上执行H门操作</span>

<span class="n">sim</span><span class="o">.</span><span class="n">apply_circuit</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>                   <span class="c1"># 通过模拟器sim运行搭建好的量子线路circuit</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>                                <span class="c1"># 打印此时的量子线路circuit</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_3_0.svg" src="_images/grover_search_algorithm_3_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>                      <span class="c1"># 打印模拟器sim中运行量子线路circuit后的末态</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
√2/4¦000⟩
√2/4¦001⟩
√2/4¦010⟩
√2/4¦011⟩
√2/4¦100⟩
√2/4¦101⟩
√2/4¦110⟩
√2/4¦111⟩
</pre></div></div>
</div>
<p>从运行的结果看到此时的量子线路，以及我们成功生成了3量子比特的均匀叠加态。</p>
<p>假设我们需要翻转<span class="math notranslate nohighlight">\(|4\rangle\)</span>态的相位，只需调用我们定义好的<code class="docutils literal notranslate"><span class="pre">bitphaseflip_operator()</span></code>函数即可，运行如下代码：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">sim</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>                                                      <span class="c1"># 重置模拟器sim维护好的量子态，使得初始化的量子态为|000&gt;</span>

<span class="n">phase_inversion_qubit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>                                      <span class="c1"># 翻转|4&gt;态的相位</span>
<span class="n">operator</span> <span class="o">=</span> <span class="n">bitphaseflip_operator</span><span class="p">(</span><span class="n">phase_inversion_qubit</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span><span class="c1"># 调用我们定义好的bitphaseflip_operator()函数</span>

<span class="n">circuit</span> <span class="o">+=</span> <span class="n">operator</span>                                              <span class="c1"># 在量子线路circuit中添加翻转|4&gt;态的相位所需的量子门</span>

<span class="n">sim</span><span class="o">.</span><span class="n">apply_circuit</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>                                       <span class="c1"># 通过模拟器sim再次运行搭建好的量子线路circuit</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>                                                    <span class="c1"># 打印此时的量子线路circuit</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_6_0.svg" src="_images/grover_search_algorithm_6_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>                                          <span class="c1"># 打印模拟器sim中运行量子线路circuit后的末态</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
√2/4¦000⟩
√2/4¦001⟩
√2/4¦010⟩
√2/4¦011⟩
-√2/4¦100⟩
√2/4¦101⟩
√2/4¦110⟩
√2/4¦111⟩
</pre></div></div>
</div>
<p>从运行的结果看到此时的量子线路，以及<span class="math notranslate nohighlight">\(|100\rangle\)</span>​​的相位翻转为-1，运行如下代码：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;100&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
4
</pre></div></div>
</div>
<p>从运行的结果看到，发生相位翻转的<span class="math notranslate nohighlight">\(|100\rangle\)</span>态即为我们希望相位翻转的<span class="math notranslate nohighlight">\(|4\rangle\)</span>态。</p>
<p>假设我们需要翻转除<span class="math notranslate nohighlight">\(|0\rangle\)</span>态以外的每个态的相位，运行如下代码：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">3</span>                                                     <span class="c1"># 设定量子比特数为3</span>
<span class="n">sim1</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>                           <span class="c1"># 使用mqvector模拟器，命名为sim1</span>

<span class="n">operator1</span> <span class="o">=</span> <span class="n">bitphaseflip_operator</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">))],</span> <span class="n">n_qubits</span><span class="p">)</span> <span class="c1"># 调用我们定义好的bitphaseflip_operator()函数，翻转除|0&gt;态以外的每个态的相位，命名为operator1</span>

<span class="n">circuit1</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                                             <span class="c1"># 初始化量子线路，命名为circuit1</span>
<span class="n">circuit1</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>                                      <span class="c1"># 每位量子比特上执行H门操作</span>
<span class="n">circuit1</span> <span class="o">+=</span> <span class="n">operator1</span>                                            <span class="c1"># 在量子线路circuit1中添加翻转除|0&gt;态以外的每个态的相位所需的量子门</span>

<span class="n">sim1</span><span class="o">.</span><span class="n">apply_circuit</span><span class="p">(</span><span class="n">circuit1</span><span class="p">)</span>                                     <span class="c1"># 通过模拟器sim1运行搭建好的量子线路circuit1</span>

<span class="n">circuit1</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>                                                         <span class="c1"># 打印此时的量子线路circuit1</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_11_0.svg" src="_images/grover_search_algorithm_11_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sim1</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>                                         <span class="c1"># 打印模拟器sim1中运行量子线路circuit1后的末态</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
√2/4¦000⟩
-√2/4¦001⟩
-√2/4¦010⟩
-√2/4¦011⟩
-√2/4¦100⟩
-√2/4¦101⟩
-√2/4¦110⟩
-√2/4¦111⟩
</pre></div></div>
</div>
<p>从运行的结果看到此时的量子线路，以及我们成功翻转除<span class="math notranslate nohighlight">\(|0\rangle\)</span>态以外的每个态的相位。</p>
<p>也就是说，我们定义的函数<code class="docutils literal notranslate"><span class="pre">bitphaseflip_operator()</span></code>可以实现Grover搜素算法中的Oracle算子<span class="math notranslate nohighlight">\(U_{\omega}\)</span>和条件相移算子<span class="math notranslate nohighlight">\(P\)</span>。</p>
</section>
<section id="利用mindquantum实现grover搜素算法实例">
<h2>利用MindQuantum实现Grover搜素算法实例<a class="headerlink" href="#利用mindquantum实现grover搜素算法实例" title="永久链接至标题"></a></h2>
<section id="实例1-n3​\omega\rangle2\rangle单目标">
<h3>实例1：<span class="math notranslate nohighlight">\(n=3\)</span>​，<span class="math notranslate nohighlight">\(|\omega\rangle=|2\rangle\)</span>（单目标）<a class="headerlink" href="#实例1-n3​\omega\rangle2\rangle单目标" title="永久链接至标题"></a></h3>
<p>首先，我们需要定义<span class="math notranslate nohighlight">\(G\)</span>算子，运行如下代码：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">G</span><span class="p">(</span><span class="n">phase_inversion_qubit</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">):</span>           <span class="c1"># 定义Grover搜索算法中的G算子</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">bitphaseflip_operator</span><span class="p">(</span><span class="n">phase_inversion_qubit</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
    <span class="n">operator</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
    <span class="n">operator</span> <span class="o">+=</span> <span class="n">bitphaseflip_operator</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">))],</span> <span class="n">n_qubits</span><span class="p">)</span>
    <span class="n">operator</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operator</span>
</pre></div>
</div>
</div>
<p>然后，我们根据Grover搜索算法的量子线路模型在MindQuantum中搭建对应的量子线路：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span>

<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">3</span>                                      <span class="c1"># 设定量子比特数为3</span>
<span class="n">phase_inversion_qubit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>                       <span class="c1"># 设定需要翻转相位的目标态，在这里翻转|2&gt;态的相位</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>                               <span class="c1"># 计算出数据库中元素的总个数</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_inversion_qubit</span><span class="p">)</span>                    <span class="c1"># 计算出目标态的总个数</span>

<span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="n">M</span><span class="p">))</span>                     <span class="c1"># 设定G算子迭代次数为r</span>

<span class="n">sim2</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>            <span class="c1"># 使用mqvector模拟器，命名为sim2</span>

<span class="n">circuit2</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                              <span class="c1"># 初始化量子线路，命名为circuit2</span>
<span class="n">circuit2</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>                       <span class="c1"># 每位量子比特上执行H门操作</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>                                <span class="c1"># 循环执行G算子r次</span>
    <span class="n">circuit2</span> <span class="o">+=</span> <span class="n">G</span><span class="p">(</span><span class="n">phase_inversion_qubit</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>

<span class="n">sim2</span><span class="o">.</span><span class="n">apply_circuit</span><span class="p">(</span><span class="n">circuit2</span><span class="p">)</span>                      <span class="c1"># 通过模拟器sim2运行搭建好的量子线路circuit2</span>

<span class="n">circuit2</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>                                    <span class="c1"># 打印此时的量子线路circuit2</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_16_0.svg" src="_images/grover_search_algorithm_16_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sim2</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>                          <span class="c1"># 打印模拟器sim2中运行量子线路circuit2后的末态</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
-√2/16¦000⟩
-√2/16¦001⟩
0.9722718241315036¦010⟩
-√2/16¦011⟩
-√2/16¦100⟩
-√2/16¦101⟩
-√2/16¦110⟩
-√2/16¦111⟩
</pre></div></div>
</div>
<p>从运行的结果看到，<span class="math notranslate nohighlight">\(|010\rangle\)</span>态的振幅为0.9722718241315036，相比于其它的量子态，这是极大的振幅，也就是说，若我们测量此时的状态，将会以极大的概率得到目标态<span class="math notranslate nohighlight">\(|010\rangle\)</span>​，运行如下代码进行测量：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">Measure</span>

<span class="n">sim2</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>                                      <span class="c1"># 重置模拟器sim2维护好的量子态，使得初始化的量子态为|000&gt;</span>

<span class="n">circuit2</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">Measure</span><span class="p">(),</span> <span class="n">circuit2</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>      <span class="c1"># 对量子线路circuit2中的每一位量子比特添加测量门</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">sim2</span><span class="o">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">circuit2</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>      <span class="c1"># 通过模拟器sim2对量子线路circuit2进行1000次的采样</span>
<span class="n">result</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>                                      <span class="c1"># 打印采样结果</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_19_0.svg" src="_images/grover_search_algorithm_19_0.svg" /></div>
</div>
<p>从运行的结果看到，1000次采样中有947次的采样结果为<code class="docutils literal notranslate"><span class="pre">010</span></code>，将其转化为10进制数，运行如下代码：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;010&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
2
</pre></div></div>
</div>
<p>从运行的结果看到，我们成功地搜索出<span class="math notranslate nohighlight">\(|2\rangle\)</span>态。</p>
</section>
<section id="实例2-n5\omega\rangle5\rangle和11\rangle多目标">
<h3>实例2：<span class="math notranslate nohighlight">\(n=5\)</span>，<span class="math notranslate nohighlight">\(|\omega\rangle=|5\rangle\)</span>和<span class="math notranslate nohighlight">\(|11\rangle\)</span>（多目标）<a class="headerlink" href="#实例2-n5\omega\rangle5\rangle和11\rangle多目标" title="永久链接至标题"></a></h3>
<p>实例1中实现的是单目标搜索，现在我们尝试实现多目标搜索。首先，<span class="math notranslate nohighlight">\(G\)</span>算子已经定义好了，我们只需设定量子比特数和需要翻转相位的目标态，然后搭建对应的量子线路即可，运行如下代码：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">5</span>                                      <span class="c1"># 设定量子比特数为5</span>
<span class="n">phase_inversion_qubit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>                   <span class="c1"># 设定需要翻转相位的目标态，在这里翻转|5&gt;态和|11&gt;态的相位</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>                               <span class="c1"># 计算出数据库中元素的总个数</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_inversion_qubit</span><span class="p">)</span>                    <span class="c1"># 计算出目标态的总个数</span>

<span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="n">M</span><span class="p">))</span>                     <span class="c1"># 设定G算子迭代次数为r</span>

<span class="n">sim3</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>            <span class="c1"># 使用mqvector模拟器，命名为sim3</span>

<span class="n">circuit3</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>                              <span class="c1"># 初始化量子线路，命名为circuit3</span>
<span class="n">circuit3</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>                       <span class="c1"># 每位量子比特上执行H门操作</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>                                <span class="c1"># 循环执行G算子r次</span>
    <span class="n">circuit3</span> <span class="o">+=</span> <span class="n">G</span><span class="p">(</span><span class="n">phase_inversion_qubit</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>

<span class="n">sim3</span><span class="o">.</span><span class="n">apply_circuit</span><span class="p">(</span><span class="n">circuit3</span><span class="p">)</span>                      <span class="c1"># 通过模拟器sim3运行搭建好的量子线路circuit3</span>

<span class="n">circuit3</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>                                          <span class="c1"># 打印此时的量子线路circuit3</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_23_0.svg" src="_images/grover_search_algorithm_23_0.svg" /></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sim3</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>                          <span class="c1"># 打印模拟器sim3中运行量子线路circuit3后的末态</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
-0.035907766232129455¦00000⟩
-0.035907766232129365¦00001⟩
-0.03590776623212947¦00010⟩
-0.035907766232129254¦00011⟩
-0.03590776623212947¦00100⟩
0.6932961018664989¦00101⟩
-0.035907766232129455¦00110⟩
-0.035907766232129365¦00111⟩
-0.035907766232129455¦01000⟩
-0.035907766232129365¦01001⟩
-0.03590776623212947¦01010⟩
0.6932961018664989¦01011⟩
-0.03590776623212947¦01100⟩
-0.035907766232129254¦01101⟩
-0.035907766232129455¦01110⟩
-0.035907766232129365¦01111⟩
-0.0359077662321294¦10000⟩
-0.03590776623212939¦10001⟩
-0.03590776623212936¦10010⟩
-0.03590776623212949¦10011⟩
-0.03590776623212936¦10100⟩
-0.03590776623212949¦10101⟩
-0.0359077662321294¦10110⟩
-0.03590776623212939¦10111⟩
-0.0359077662321294¦11000⟩
-0.03590776623212939¦11001⟩
-0.03590776623212936¦11010⟩
-0.03590776623212949¦11011⟩
-0.03590776623212936¦11100⟩
-0.03590776623212949¦11101⟩
-0.0359077662321294¦11110⟩
-0.03590776623212939¦11111⟩
</pre></div></div>
</div>
<p>从运行的结果看到，<span class="math notranslate nohighlight">\(|00101\rangle\)</span>​​和<span class="math notranslate nohighlight">\(|01011\rangle\)</span>​​态的振幅均为0.6932961018664989，相比于其它的量子态，这是极大的振幅，也就是说，若我们测量此时的状态，将会以极大的概率得到目标态<span class="math notranslate nohighlight">\(|00101\rangle\)</span>​​和<span class="math notranslate nohighlight">\(|01011\rangle\)</span>​​态，运行如下代码进行测量：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># pylint: disable=W0104</span>
<span class="n">sim3</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>                                      <span class="c1"># 重置模拟器sim3维护好的量子态，使得初始化的量子态为|00000&gt;</span>

<span class="n">circuit3</span> <span class="o">+=</span> <span class="n">UN</span><span class="p">(</span><span class="n">Measure</span><span class="p">(),</span> <span class="n">circuit3</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>      <span class="c1"># 对量子线路circuit3中的每一位量子比特添加测量门</span>

<span class="n">result1</span> <span class="o">=</span> <span class="n">sim3</span><span class="o">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">circuit3</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>     <span class="c1"># 通过模拟器sim3对量子线路circuit3进行1000次的采样</span>
<span class="n">result1</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>                                     <span class="c1"># 打印采样结果</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_26_0.svg" src="_images/grover_search_algorithm_26_0.svg" /></div>
</div>
<p>从运行的结果看到，1000次采样中有463次的采样结果为<code class="docutils literal notranslate"><span class="pre">00101</span></code>和503次的采样结果为<code class="docutils literal notranslate"><span class="pre">01011</span></code>，将其转化为10进制数，运行如下代码：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;00101&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;01011&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
5
11
</pre></div></div>
</div>
<p>从运行的结果看到，我们成功地搜索出<span class="math notranslate nohighlight">\(|5\rangle\)</span>​​和<span class="math notranslate nohighlight">\(|11\rangle\)</span>​​​​​态。</p>
<p>至此，我们介绍了Grover搜索算法的基本原理，以及通过两个具体的小例子来展示如何利用MindQuantum实现该算法！赶紧动手体验一下量子编程的乐趣吧！</p>
</section>
</section>
<section id="龙算法">
<h2>龙算法<a class="headerlink" href="#龙算法" title="永久链接至标题"></a></h2>
<p>除了在规模为4的数据库中找1个数据的场景，Grover算法不能够精确的搜索出所标记态。清华大学龙桂鲁教授在Grover算法基础之上提出量子精确搜索算法龙算法[3]，能够以准确率为1的概率在所有场景中搜索出目标态。其主要思想是将Grover算子改写为如下的算子，</p>
<div class="math notranslate nohighlight">
\[L = -H^{\otimes n} R_0 H^{\otimes n} R_\tau\]</div>
<p>其中：<span class="math notranslate nohighlight">\(R_0 = (I+(e^{i\theta}-1)\left|0\right&gt;\left&lt;0\right|)\)</span>，<span class="math notranslate nohighlight">\(R_\tau = (I+(e^{i\theta}-1)\left|\tau\right&gt;\left&lt;\tau\right|)\)</span>。在满足相位匹配条件时，</p>
<div class="math notranslate nohighlight">
\[\theta = 2\arcsin\left(\sin\beta\sin\left(\frac{\pi}{4J_s+6}\right)\right)\]</div>
<p>我们只需作用<span class="math notranslate nohighlight">\(J_s+1\)</span>次龙算子，就可以以概率1找到目标态，这里<span class="math notranslate nohighlight">\(\beta=\arcsin{\sqrt{M/N}}\)</span>，<span class="math notranslate nohighlight">\(M\)</span>为标记态个数，<span class="math notranslate nohighlight">\(N\)</span>为数据库大小，<span class="math notranslate nohighlight">\(J_s&gt;=[((\pi/2)-\beta)/\beta]\)</span>。下面我们用MindQuantum来实现。</p>
<section id="一般角度相位转动线路">
<h3>一般角度相位转动线路<a class="headerlink" href="#一般角度相位转动线路" title="永久链接至标题"></a></h3>
<p>借助于辅助比特，我们搭建某个计算基矢一般角度相位转动线路。</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">X</span><span class="p">,</span> <span class="n">PhaseShift</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="k">def</span> <span class="nf">change_phase_with_anclia</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="n">which_bit</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">which</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">polarity_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">which_bit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="n">polarity_circ</span> <span class="o">+=</span> <span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">+=</span> <span class="n">polarity_circ</span>
    <span class="n">c</span> <span class="o">+=</span> <span class="n">PhaseShift</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)))</span>
    <span class="n">c</span> <span class="o">+=</span> <span class="n">polarity_circ</span>
    <span class="k">return</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</section>
<section id="搭建龙算子">
<h3>搭建龙算子<a class="headerlink" href="#搭建龙算子" title="永久链接至标题"></a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">BARRIER</span><span class="p">,</span> <span class="n">Z</span>

<span class="k">def</span> <span class="nf">L</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
    <span class="n">R0</span> <span class="o">=</span> <span class="n">change_phase_with_anclia</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">R_t</span> <span class="o">=</span> <span class="n">change_phase_with_anclia</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
    <span class="n">g_ops</span> <span class="o">=</span> <span class="n">R_t</span> <span class="o">+</span> <span class="n">BARRIER</span> <span class="o">+</span> <span class="n">U</span> <span class="o">+</span> <span class="n">BARRIER</span> <span class="o">+</span> <span class="n">R0</span> <span class="o">+</span> <span class="n">BARRIER</span> <span class="o">+</span> <span class="n">U</span> <span class="o">+</span> <span class="n">BARRIER</span>
    <span class="n">g_ops</span> <span class="o">+=</span> <span class="n">Z</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g_ops</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="完成量子精确搜索算法-龙算法">
<h2>完成量子精确搜索算法：龙算法<a class="headerlink" href="#完成量子精确搜索算法-龙算法" title="永久链接至标题"></a></h2>
<p>这里我们以3比特数据库中搜索<span class="math notranslate nohighlight">\(\left|2\right&gt;\)</span>态为例，完成龙算法。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">H</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">UN</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">will_find</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">n_qubits</span><span class="p">))</span>
<span class="n">Js</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">beta</span><span class="p">)</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">Js</span> <span class="o">+</span> <span class="mi">6</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">theta</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">will_find</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>            <span class="c1"># 构建用于精确搜索的龙算子</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">UN</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Js</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">circ</span> <span class="o">+=</span> <span class="n">g</span>
<span class="n">circ</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_34_0.svg" src="_images/grover_search_algorithm_34_0.svg" /></div>
</div>
<p>接下来，我们计算线路的量子态。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_qs</span><span class="p">(</span><span class="n">ket</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(0.048708136684586345-0.9988130542902997j)¦1010⟩
</pre></div></div>
</div>
<p>发现，除去相位，我们可以精确的得到目标态。通过采样，我们也可以得到如下类似的结果。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">Measure</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">circ</span> <span class="o">+</span> <span class="n">UN</span><span class="p">(</span><span class="n">Measure</span><span class="p">(),</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">),</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">res</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/grover_search_algorithm_38_0.svg" src="_images/grover_search_algorithm_38_0.svg" /></div>
</div>
<p>若想查询更多关于MindQuantum的API，请点击：<a class="reference external" href="https://mindspore.cn/mindquantum/">https://mindspore.cn/mindquantum/</a>。</p>
<section id="参考文献-">
<h3><strong>参考文献：</strong><a class="headerlink" href="#参考文献-" title="永久链接至标题"></a></h3>
<p>[1] L. K. Grover, A fast quantum mechanical algorithm for database search[C]// Proceedings of the twenty-eighth annual ACM symposium on Theory of computing. ACM, 1996: 212-219.</p>
<p>[2] G. Brassard, P. Hoyer, M. Mosca, et al. Quantum amplitude amplification and estimation[J]. Contemporary Mathematics, 2002, 305: 53-74.</p>
<p>[3] Long G L. Grover algorithm with zero theoretical failure rate. Physical Rev A, 2001, 64: 022307.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="quantum_phase_estimation.html" class="btn btn-neutral float-left" title="量子相位估计算法" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="shor_algorithm.html" class="btn btn-neutral float-right" title="基于MindQuantum的Shor算法" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, MindSpore.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
        <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>