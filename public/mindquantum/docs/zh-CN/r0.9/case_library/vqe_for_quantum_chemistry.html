<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>在量子化学计算中应用量子变分求解器 &mdash; MindSpore master 文档</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script><script src="../_static/jquery.js"></script>
        <script src="../_static/js/theme.js"></script><script src="../_static/underscore.js"></script><script src="../_static/doctools.js"></script><script src="../_static/translations.js"></script><script crossorigin="anonymous" integrity="sha256-1fEPhSsRKlFKGfK3eO710tEweHh1fwokU5wFGDHO+vg=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/mathjax/MathJax-3.2.2/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="量子神经网络在自然语言处理中的应用" href="qnn_for_nlp.html" />
    <link rel="prev" title="通过量子神经网络对鸢尾花进行分类" href="classification_of_iris_by_qnn.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">初级使用教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/beginner.html">初级使用教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/parameterized_quantum_circuit.html">变分量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/quantum_simulator.html">量子模拟器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/quantum_measurement.html">量子测量</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/advanced_operations_of_quantum_circuit.html">量子线路高阶操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/bloch_sphere.html">布洛赫球</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">中级使用教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../middle_level/middle_level.html">中级使用教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../middle_level/noise.html">含噪声量子线路</a></li>
<li class="toctree-l1"><a class="reference internal" href="../middle_level/noise_simulator.html">噪声模拟器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../middle_level/qubit_mapping.html">比特映射</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">高级使用教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../advanced/advanced.html">高级使用教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/get_gradient_of_PQC_with_mindquantum.html">变分量子线路梯度计算进阶</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/initial_experience_of_quantum_neural_network.html">量子神经网络初体验</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/equivalence_checking_of_PQC.html">含参量子线路的等价性检查</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">案例库</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="case_library.html">案例库</a></li>
<li class="toctree-l1"><a class="reference internal" href="grover_search_algorithm.html">基于MindSpore Quantum的Grover搜索算法和龙算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="shor_algorithm.html">基于MindSpore Quantum的Shor算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="hhl_algorithm.html">HHL 算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_phase_estimation.html">量子相位估计算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_approximate_optimization_algorithm.html">量子近似优化算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="classification_of_iris_by_qnn.html">通过量子神经网络对鸢尾花进行分类</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">在量子化学计算中应用量子变分求解器</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#概述">概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#环境准备">环境准备</a></li>
<li class="toctree-l2"><a class="reference internal" href="#导入依赖">导入依赖</a></li>
<li class="toctree-l2"><a class="reference internal" href="#量子化学计算方法">量子化学计算方法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#波函数方法">波函数方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#二次量子化">二次量子化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#量子变分求解器">量子变分求解器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#变分原理">变分原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#初态制备">初态制备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#波函数拟设">波函数拟设</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vqe的一般流程">VQE的一般流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#分步构造幺正耦合簇拟设">分步构造幺正耦合簇拟设</a></li>
<li class="toctree-l2"><a class="reference internal" href="#总结">总结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="qnn_for_nlp.html">量子神经网络在自然语言处理中的应用</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">总览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.dtype.html">mindquantum.dtype</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.core.html">mindquantum.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.simulator.html">mindquantum.simulator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.framework.html">mindquantum.framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.algorithm.html">mindquantum.algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.device.html">mindquantum.device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.io.html">mindquantum.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.engine.html">mindquantum.engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum.utils.html">mindquantum.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">论文复现代码</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../paper_with_code.html">论文复现代码</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE.html">Release Notes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">安装指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mindquantum_install.html">安装MindSpore Quantum</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>在量子化学计算中应用量子变分求解器</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/case_library/vqe_for_quantum_chemistry.ipynb.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="在量子化学计算中应用量子变分求解器">
<h1>在量子化学计算中应用量子变分求解器<a class="headerlink" href="#在量子化学计算中应用量子变分求解器" title="永久链接至标题"></a></h1>
<p><a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/r2.2/mindquantum/zh_cn/case_library/mindspore_vqe_for_quantum_chemistry.ipynb"><img alt="下载Notebook" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.2/resource/_static/logo_notebook.svg" /></a> <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/r2.2/mindquantum/zh_cn/case_library/mindspore_vqe_for_quantum_chemistry.py"><img alt="下载样例代码" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.2/resource/_static/logo_download_code.svg" /></a> <a class="reference external" href="https://gitee.com/mindspore/docs/blob/r2.2/docs/mindquantum/docs/source_zh_cn/case_library/vqe_for_quantum_chemistry.ipynb"><img alt="查看源文件" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.2/resource/_static/logo_source.svg" /></a> <a class="reference external" href="https://authoring-modelarts-cnnorth4.huaweicloud.com/console/lab?share-url-b64=aHR0cHM6Ly9taW5kc3BvcmUtd2Vic2l0ZS5vYnMuY24tbm9ydGgtNC5teWh1YXdlaWNsb3VkLmNvbS9ub3RlYm9vay9yMi4yL21pbmRxdWFudHVtL3poX2NuL2Nhc2VfbGlicmFyeS9taW5kc3BvcmVfdnFlX2Zvcl9xdWFudHVtX2NoZW1pc3RyeS5pcHluYg%3D%3D&amp;imageid=73522c7f-6d98-43d8-b306-8ff374c7d3a7"><img alt="在ModelArts平台运行" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.2/resource/_static/logo_modelarts.svg" /></a></p>
<section id="概述">
<h2>概述<a class="headerlink" href="#概述" title="永久链接至标题"></a></h2>
<p>量子化学，指的是运用量子力学的基本理论及方法，求解含时或定态薛定谔方程的数值解。在高性能计算机上进行量子化学模拟已成为研究材料的物理、化学性质的重要手段。然而，精确求解薛定谔方程具有指数级的复杂度，可模拟的化学体系规模严重受制于此。近年量子计算的发展为解决这个问题提供了一条可行的路，有望在量子计算机上实现多项式复杂度下对薛定谔方程的高精度求解。</p>
<p><a class="reference external" href="https://doi.org/10.1038/ncomms5213">Peruzzo等人</a>在2014年首次将量子变分求解器(Variational quantum eigensolver, VQE)结合<a class="reference external" href="https://linkinghub.elsevier.com/retrieve/pii/S0009261489873725">幺正耦合簇理论</a>用于量子化学的模拟中，实现了He-H+基态能量的求解。量子变分求解器是一个量子–经典混合算法，在基于量子算法的化学模拟中应用广泛，本教程将介绍使用量子变分求解器求解分子体系基态能量的方法。</p>
<p>本教程的主要内容包括如下几个部分：</p>
<ol class="arabic simple">
<li><p>量子化学原理简介。</p></li>
<li><p>量子变分求解器的应用。</p></li>
<li><p>使用MindSpore Quantum实现高效自动求导的VQE模拟。</p></li>
</ol>
<blockquote>
<div><p>本文档适用于CPU环境。</p>
</div></blockquote>
</section>
<section id="环境准备">
<h2>环境准备<a class="headerlink" href="#环境准备" title="永久链接至标题"></a></h2>
<p>本教程需要安装以下环境：</p>
<ul class="simple">
<li><p>NumPy</p></li>
<li><p>SciPy</p></li>
<li><p><a class="reference external" href="https://gitee.com/mindspore/mindquantum">mindquantum</a></p></li>
<li><p><a class="reference external" href="https://gitee.com/mindspore/mindspore">mindspore</a></p></li>
<li><p>PySCF</p></li>
<li><p>openfermion</p></li>
<li><p>openfermionpyscf</p></li>
</ul>
<blockquote>
<div><p>以上依赖都可通过<code class="docutils literal notranslate"><span class="pre">pip</span></code>命令来安装。</p>
</div></blockquote>
</section>
<section id="导入依赖">
<h2>导入依赖<a class="headerlink" href="#导入依赖" title="永久链接至标题"></a></h2>
<p>导入本教程所依赖模块</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openfermion.chem</span> <span class="kn">import</span> <span class="n">MolecularData</span>
<span class="kn">from</span> <span class="nn">openfermionpyscf</span> <span class="kn">import</span> <span class="n">run_pyscf</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.gates</span> <span class="kn">import</span> <span class="n">X</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">Hamiltonian</span>
<span class="kn">from</span> <span class="nn">mindquantum.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">generate_uccsd</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">PYNATIVE_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="量子化学计算方法">
<h2>量子化学计算方法<a class="headerlink" href="#量子化学计算方法" title="永久链接至标题"></a></h2>
<p>量子化学的核心问题在于求解薛定谔方程（Schrödinger Equation）。一般来说，求解含时薛定谔方程（Time-dependent Schrödinger Equation）较为复杂，故引入玻恩-奥本海默近似（Born-Oppenheimer approximation, BO approximation）。BO近似认为，原子核质量远大于电子、运动速度远低于电子，故可以将两者进行分离变量，单独讨论原子核或电子的运动，于是可得到如下不含时的电子运动方程，也称为定态薛定谔方程：</p>
<div class="math notranslate nohighlight">
\[\hat{H} |\Psi\rangle = E |\Psi\rangle\]</div>
<p>其中<span class="math notranslate nohighlight">\(\hat{H}\)</span>包含以下三项：</p>
<div class="math notranslate nohighlight">
\[\hat{H} = \hat{K} _{e} + \hat{V} _{ee} + \hat{V} _{Ne}\]</div>
<p>分别为电子动能、电子-电子势能和电子-核势能。</p>
<p>有多种数值算法可以求解定态薛定谔方程。本教程将介绍其中的一类：波函数方法。波函数方法直接求解给定分子哈密顿量的本征波函数和本征能量，目前有大量的开源软件包可实现，如<a class="reference external" href="http://pyscf.org/">PySCF</a>等。此处从一个简单的例子：氢化锂分子开始，使用openfermion结合openfermionpyscf插件进行。首先定义分子结构：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;Li&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">dist</span><span class="p">]],</span>
    <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">dist</span><span class="p">]],</span>
<span class="p">]</span>
<span class="n">basis</span> <span class="o">=</span> <span class="s2">&quot;sto3g&quot;</span>
<span class="n">spin</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Geometry: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Geometry:
 [[&#39;Li&#39;, [0.0, 0.0, 0.0]], [&#39;H&#39;, [0.0, 0.0, 1.5]]]
</pre></div></div>
</div>
<p>上面的代码定义了一个Li-H键长为1.5Å分子。使用STO-3G基组进行计算。接下来使用openfermionpyscf，调用PySCF进行HF、CCSD和FCI计算。这三种方法属于波函数方法，开始计算之前，先对这些方法作一个简单的介绍。</p>
<section id="波函数方法">
<h3>波函数方法<a class="headerlink" href="#波函数方法" title="永久链接至标题"></a></h3>
<p>求解定态薛定谔方程的方法之一是<a class="reference external" href="https://doi.org/10.1098/rspa.1935.0085">Hartree-Fock（HF）</a>方法，该方法在二十世纪三十年代左右由Hartree等人提出，是量子化学计算中的基本方法。HF方法引入了单行列式近似，即 <span class="math notranslate nohighlight">\(N\)</span> 电子体系的波函数由一个行列式形式的波函数表示：</p>
<div class="math notranslate nohighlight">
\[| \Psi \rangle = | \psi_{1} \psi_{2} \psi_{3} \dots \psi_{N} \rangle\]</div>
<p>其中 <span class="math notranslate nohighlight">\(| \psi_{1} \psi_{2} \psi_{3} \dots \rangle\)</span> 代表由一组自旋轨道波函数 <span class="math notranslate nohighlight">\(\{ \pi_{i} \}\)</span> 构成的N阶行列式。 自旋轨道波函数 <span class="math notranslate nohighlight">\(\psi_{i}\)</span> 可进一步用一组形式已知的基函数展开：</p>
<div class="math notranslate nohighlight">
\[\psi_{i} = \phi_{i} \eta_{i}\]</div>
<div class="math notranslate nohighlight">
\[\phi_{i} = \sum_{\mu}{C_{\mu i} \chi_{\mu}}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\{\chi_{\mu}\}\)</span> 被称为基函数，可以是高斯函数等。 该近似考虑了电子间的交换作用，但是忽略了电子间的关联作用，故无法正确计算如解离能等性质。</p>
<p>HF方法的改进可以从波函数展开定理出发。波函数展开定理可以表述为，若 <span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span> 是一组完备的自旋轨道波函数，则 <span class="math notranslate nohighlight">\(N\)</span> 电子体系波函数可以由 <span class="math notranslate nohighlight">\(\{ \psi_{i} \}\)</span> 构成的行列式波函数精确展开：</p>
<div class="math notranslate nohighlight">
\[| \Psi \rangle = \sum^{\infty} _ {i_{1} &lt; i_{2} &lt; \dots &lt; i_{N}} {C_{i_{1} i_{2} \dots i_{N}} | \psi_{i_{1}} \psi_{i_{2}} \dots \psi_{i_{N}} \rangle}\]</div>
<p>由此可得到Configuration Interaction（CI）方法：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{CI} \rangle = C_{0} | \Psi_{HF} \rangle + \sum^{a\rightarrow\infty} _{i\in occ, a\not\in occ}{C^{a} _{i} | \Psi^{a} _{i} \rangle } + \sum^{ab\rightarrow\infty} _{ij\in occ, ab\not\in occ}{C^{ab} _{ij} | \Psi^{ab} _{ij} \rangle }\]</div>
<p>上式中的 <span class="math notranslate nohighlight">\(| \Psi^{a}_{i} \rangle + \dots\)</span> 代表电子由轨道 <span class="math notranslate nohighlight">\(i\)</span> 激发到轨道 <span class="math notranslate nohighlight">\(a\)</span> 的单激发波函数，以此类推。只考虑单激发和双激发的CI被称为CISD，即Configuration Interaction with singles and doubles。将基态HF波函数一直到N激发波函数全部考虑在内的Configuration Interaction被称为Full Configuration Interaction（FCI），FCI波函数是定态薛定谔方程在给定基函数下的精确解。</p>
</section>
<section id="二次量子化">
<h3>二次量子化<a class="headerlink" href="#二次量子化" title="永久链接至标题"></a></h3>
<p>在二次量子化表述下，体系的哈密顿量具有如下形式：</p>
<div class="math notranslate nohighlight">
\[\hat{H} = \sum_{p, q}{h^p_q E^p_q} + \sum_{p, q, r, s}{\frac{1}{2} g^{pq} _ {rs} E^{pq}_{rs}}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(E^p_q\)</span> 和 <span class="math notranslate nohighlight">\(E^{pq}_{rs}\)</span> 分别为：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
E^{pq} _{rs} &amp;= a^{\dagger} _{p} a^{\dagger} _{q} a _ {r} a _ {s}\\
E^p_q &amp;= a^{\dagger}_pa_q
\end{align*}\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(a^{\dagger}_p\)</span> 和 <span class="math notranslate nohighlight">\(a_q\)</span> 分别为产生算符（Creation Operator）和湮灭算符（Annihilation Operator）。</p>
<p>使用二次量子化的表述方法，可以非常方便地表示激发态波函数：</p>
<div class="math notranslate nohighlight">
\[| \Psi^{abc\dots} _ {ijk\dots} \rangle = a^{\dagger} _ {a} a^{\dagger} _ {b} a^{\dagger} _ {c} \dots a _ {i} a_{j} a_{k} \dots | \Psi \rangle\]</div>
<p>CI方法的一个改进是耦合簇理论（Coupled-Cluster theory, CC）。CC引入指数化算符：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{CC} \rangle = \exp{(\hat{T})} | \Psi_{HF} \rangle\]</div>
<p>其中耦合簇算符 <span class="math notranslate nohighlight">\(\hat{T}\)</span> 为对激发算符的求和：</p>
<div class="math notranslate nohighlight">
\[\hat{T} = \sum_{p\not\in occ, q\in occ}{\theta^{p} _ {q} E^{p} _ {q}} + \sum_{pq\not\in occ, rs\in occ}{\theta^{pq} _ {rs} E^{pq} _ {rs}} + \dots\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\theta\)</span> 和CI方法中的 <span class="math notranslate nohighlight">\(C\)</span> 类似，是待求解的参数。由指数的泰勒展开易知，即使耦合簇算符 <span class="math notranslate nohighlight">\(\hat{T}\)</span> 中只包含低阶激发项，<span class="math notranslate nohighlight">\(\exp{(\hat{T})}\)</span> 也可以隐含部分高阶激发，这也使得CC方法向FCI波函数收敛的速度要远快于CI，同样截断到K激发，如K=2，CCSD的精度会超过CISD。</p>
<!--
一般而言，若一个方法可以达到化学精度，即由此方法计算的能量和FCI能量之间的差值小于1 kcal/mol，则认为这个方法具有良好的精度，截断到三激发的CCSD(T)在大部分情况下都能符合这个标准
--><p>电子关联作用的效果是使得总能量降低，故HF得到的基态能量会略高于CCSD和FCI。另外，从上述理论不难发现，FCI的计算量远大于CCSD和HF。我们使用openfermion封装的<code class="docutils literal notranslate"><span class="pre">MolecularData</span></code>和openfermionpyscf封装的<code class="docutils literal notranslate"><span class="pre">run_pyscf</span></code>函数来进行演示：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_of</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">,</span>
    <span class="n">multiplicity</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">)</span>
<span class="n">molecule_of</span> <span class="o">=</span> <span class="n">run_pyscf</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="p">,</span>
    <span class="n">run_scf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">run_ccsd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">run_fci</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hartree-Fock energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">hf_energy</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CCSD energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_energy</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FCI energy: </span><span class="si">%20.16f</span><span class="s2"> Ha&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">fci_energy</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Hartree-Fock energy:  -7.8633576215351200 Ha
CCSD energy:  -7.8823529091526812 Ha
FCI energy:  -7.8823622867987284 Ha
</pre></div></div>
</div>
<p>在上面的例子中，我们运行了Hartree-Fock（HF）、CCSD、FCI进行总能量的计算。若对运行时间进行统计，会发现<span class="math notranslate nohighlight">\(T_{HF}&lt;T_{CCSD}\ll T_{FCI}\)</span>，换成计算量更大的体系如乙烯分子等会更明显一些。此外，对于计算得到的总能量，有<span class="math notranslate nohighlight">\(E_{HF}&gt;E_{CCSD}&gt;E_{FCI}\)</span>。计算完成后，我们将结果保存到<code class="docutils literal notranslate"><span class="pre">molecule_file</span></code>文件（即<code class="docutils literal notranslate"><span class="pre">molecule_of.filename</span></code>）中：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">molecule_of</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">molecule_file</span> <span class="o">=</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">filename</span>
<span class="nb">print</span><span class="p">(</span><span class="n">molecule_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
H1-Li1_sto3g_singlet
</pre></div></div>
</div>
<p>量子化学计算的一大阻碍是计算量。随着体系大小（电子数、原子数）的增加，求解FCI波函数和基态能量的时间消耗大约以<span class="math notranslate nohighlight">\(2^{N}\)</span>增长，即使是较小的分子如乙烯分子等，进行FCI计算也并不容易。量子计算机的出现为此提供了一条可能的解决途径，已有的研究表明，量子计算机可以多项式的时间复杂度模拟哈密顿量的含时演化，在量子处理器上进行化学模拟相较于经典计算机有指数级的加速。本教程将介绍其中一类量子算法：量子变分求解器。</p>
</section>
</section>
<section id="量子变分求解器">
<h2>量子变分求解器<a class="headerlink" href="#量子变分求解器" title="永久链接至标题"></a></h2>
<p>量子变分求解器（Variational Quantum Eigensolver, VQE）是一类量子-经典混合（Hybrid quantum-classical）算法，应用变分原理实现对基态波函数的求解。其中，变分参数的优化步在经典计算机上进行。</p>
<section id="变分原理">
<h3>变分原理<a class="headerlink" href="#变分原理" title="永久链接至标题"></a></h3>
<p>变分原理可使用如下形式表述：</p>
<div class="math notranslate nohighlight">
\[E_{0} \le \frac{\langle \Psi_{t} | \hat{H} | \Psi_{t} \rangle}{\langle \Psi_{t} | \Psi_{t} \rangle}\]</div>
<p>上式中的<span class="math notranslate nohighlight">\(| \Psi_{t} \rangle\)</span>代表试探波函数。变分原理表明，在满足一定的条件下，任意试探波函数得到的基态能量总是大于等于真实的基态能量。变分原理为求解分子基态薛定谔方程提供了一种方法：使用一个参数化的函数<span class="math notranslate nohighlight">\(f(\theta)\)</span>作为精确基态波函数的近似，通过优化参数<span class="math notranslate nohighlight">\(\theta\)</span>来逼近精确的基态能量。</p>
</section>
<section id="初态制备">
<h3>初态制备<a class="headerlink" href="#初态制备" title="永久链接至标题"></a></h3>
<p>在二次量子化表述下，<span class="math notranslate nohighlight">\(N\)</span>-电子HF波函数也具有非常简洁的形式：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{HF} \rangle = \prod^{i=0} _{N-1}{a^{\dagger} _{i}| 0 \rangle}\]</div>
<p>上式搭建了一个由量子化学波函数到量子计算的桥梁：用<span class="math notranslate nohighlight">\(|0\rangle\)</span>代表非占据轨道，用<span class="math notranslate nohighlight">\(|1\rangle\)</span>代表电子占据的轨道，由此可以将<span class="math notranslate nohighlight">\(N\)</span>-电子HF波函数映射为由一串<span class="math notranslate nohighlight">\(M+N\)</span>个量子比特<span class="math notranslate nohighlight">\(| 00\dots 11\dots \rangle\)</span>，<span class="math notranslate nohighlight">\(M\)</span>代表非占据轨道的数量。</p>
<p>以下代码构造了对应于LiH分子的HF初态波函数。在Jordan-Wigner变换下，相当于将<span class="math notranslate nohighlight">\(N\)</span>个<span class="math notranslate nohighlight">\(\text{X}\)</span>门作用于<span class="math notranslate nohighlight">\(|000\dots\rangle\)</span>上。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hartreefock_wfn_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">([</span><span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hartreefock_wfn_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
      ┏━━━┓
q0: ──┨╺╋╸┠───
      ┗━━━┛
      ┏━━━┓
q1: ──┨╺╋╸┠───
      ┗━━━┛
      ┏━━━┓
q2: ──┨╺╋╸┠───
      ┗━━━┛
      ┏━━━┓
q3: ──┨╺╋╸┠───
      ┗━━━┛
</pre></div></div>
</div>
<p>基于此，我们可以构造如下形式的试探波函数：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{t} \rangle = U(\theta) | \Psi_{HF} \rangle\]</div>
<p>其中<span class="math notranslate nohighlight">\(U(\theta)\)</span>代表一个可通过量子线路模拟的幺正变换，<span class="math notranslate nohighlight">\(| \Psi_{HF} \rangle\)</span>作为初态，可通过多个单比特<span class="math notranslate nohighlight">\(\text{X}\)</span>门来方便地制备。<span class="math notranslate nohighlight">\(U(\theta) | \Psi_{HF} \rangle\)</span>的具体形式也被称为波函数拟设。</p>
</section>
<section id="波函数拟设">
<h3>波函数拟设<a class="headerlink" href="#波函数拟设" title="永久链接至标题"></a></h3>
<p>前文提到的耦合簇理论是一个非常高效的波函数拟设。在量子计算机上使用，需要作一些修改：</p>
<div class="math notranslate nohighlight">
\[| \Psi_{UCC} \rangle = \exp{(\hat{T} - \hat{T}^{\dagger})} | \Psi_{HF} \rangle\]</div>
<p>UCC即幺正耦合簇(Unitary Coupled-Cluster theory)，<span class="math notranslate nohighlight">\(\hat{T}^{\dagger}\)</span>代表<span class="math notranslate nohighlight">\(\hat{T}\)</span>的厄米共轭。如此，<span class="math notranslate nohighlight">\(\exp{(\hat{T} - \hat{T}^{\dagger})}\)</span>即为幺正算符。<a class="reference external" href="https://doi.org/10.1038/ncomms5213">Peruzzo等人</a>在2014年首次使用VQE结合UCCSD(Unitary coupled-cluster with singles and
doubles)拟设进行了量子计算机上的化学模拟实验。值得注意的是幺正耦合簇默认了耦合簇算符中的参数<span class="math notranslate nohighlight">\(\{\theta\}\)</span>是实数。在分子体系中该假设不会有问题；在周期性体系中，<a class="reference external" href="https://doi.org/10.1021/acs.jctc.0c00881">刘杰等人</a>的研究表明幺正耦合簇会因为忽略复数部分而造成误差。本教程暂时不讨论幺正耦合簇在周期性体系中的应用。</p>
<p>使用mindquantum的circuit模块中的<code class="docutils literal notranslate"><span class="pre">generate_uccsd</span></code>函数可读取先前保存在<code class="docutils literal notranslate"><span class="pre">molecule_file</span></code>的计算结果，“一键”构造UCCSD波函数拟设，以及其对应的量子线路：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ansatz_circuit</span><span class="p">,</span> \
<span class="n">init_amplitudes</span><span class="p">,</span> \
<span class="n">ansatz_parameter_names</span><span class="p">,</span> \
<span class="n">hamiltonian_QubitOp</span><span class="p">,</span> \
<span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">generate_uccsd</span><span class="p">(</span><span class="n">molecule_file</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ccsd:-7.882352909152681.
fci:-7.882362286798728.
</pre></div></div>
</div>
<p><a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/zh-CN/r0.9/algorithm/nisq/mindquantum.algorithm.nisq.generate_uccsd.html">generate_uccsd</a>
将幺正耦合簇相关的函数打包了起来，包括导出分子哈密度量、构造幺正耦合簇拟设算符、提取CCSD计算的耦合簇系数等多个步骤。该函数通过输入分子的文件路径来读取该分子，参数<code class="docutils literal notranslate"><span class="pre">th</span></code>是表示量子线路中哪些参数需要更新梯度的阈值。在<a class="reference external" href="#分步构造幺正耦合簇拟设">分步构造幺正耦合簇拟设</a>章节，我们会演示如何使用mindquantum的相关接口分步完成其中包含的步骤。完整的量子线路包含HF初态+UCCSD拟设，如下代码所示：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">total_circuit</span> <span class="o">=</span> <span class="n">hartreefock_wfn_circuit</span> <span class="o">+</span> <span class="n">ansatz_circuit</span>
<span class="n">total_circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of parameters: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ansatz_parameter_names</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="color: #ff0000; text-decoration-color: #ff0000; font-weight: bold">                            Circuit Summary                            </span>
╭──────────────────────┬──────────────────────────────────────────────╮
│<span style="font-weight: bold"> </span><span style="color: #3b3b95; text-decoration-color: #3b3b95; font-weight: bold">Info</span><span style="font-weight: bold">                 </span>│<span style="font-weight: bold"> </span><span style="color: #3b3b95; text-decoration-color: #3b3b95; font-weight: bold">value</span><span style="font-weight: bold">                                        </span>│
├──────────────────────┼──────────────────────────────────────────────┤
│ <span style="font-weight: bold">Number of qubit</span>      │ 12                                           │
├──────────────────────┼──────────────────────────────────────────────┤
│ <span style="font-weight: bold">Total number of gate</span> │ 12612                                        │
│ Barrier              │ 2560                                         │
│ Noise Channel        │ 0                                            │
│ Measurement          │ 0                                            │
├──────────────────────┼──────────────────────────────────────────────┤
│ <span style="font-weight: bold">Parameter gate</span>       │ 640                                          │
│ 44 ansatz parameters │ <span style="color: #48c9b0; text-decoration-color: #48c9b0">p0, p8, p1, p9, p2, p10, p3, p11, p4, p12...</span> │
╰──────────────────────┴──────────────────────────────────────────────╯
</pre></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Number of parameters: 44
</pre></div></div>
</div>
<p>对于LiH分子而言，其UCCSD波函数拟设中包含44个变分参数。该线路总共的量子比特门数量为12612，总共需要12个量子比特进行模拟。</p>
</section>
<section id="vqe的一般流程">
<h3>VQE的一般流程<a class="headerlink" href="#vqe的一般流程" title="永久链接至标题"></a></h3>
<p>使用VQE进行分子基态求解的一般流程如下：</p>
<ol class="arabic simple">
<li><p>制备HF初态：<span class="math notranslate nohighlight">\(| 00\dots11\dots \rangle\)</span>；</p></li>
<li><p>定义波函数拟设，如UCCSD等；</p></li>
<li><p>将波函数拟设转化为参数化的量子线路；</p></li>
<li><p>初始化变分参数，如全设为0等；</p></li>
<li><p>在量子计算机上多次测量得到分子哈密顿量在该套变分参数下的能量<span class="math notranslate nohighlight">\(E(\theta)\)</span>以及能量关于参数的导数<span class="math notranslate nohighlight">\(\{ {\partial E} / {\partial \theta_{i}} \}\)</span></p></li>
<li><p>在经典计算机上使用优化算法，如梯度下降、BFGS等更新变分参数；</p></li>
<li><p>将新的变分参数传入量子线路中进行更新；</p></li>
<li><p>重复步骤(5)到(7)，直到满足收敛标准；</p></li>
<li><p>结束</p></li>
</ol>
<p>在第5步中，求取能量关于参数的导数<span class="math notranslate nohighlight">\(\{ {\partial E} / {\partial \theta_{i}} \}\)</span>在量子计算机上可通过parameter-shift rule来进行，在模拟器中也可通过模拟parameter-shift rule或者有限差分法来计算，是个较为耗时的过程。mindquantum基于mindspore框架，提供了类似于机器学习的自动求导功能，可以在模拟中可以高效计算变分量子线路的导数。以下使用mindquantum构造带自动求导功能的参数化UCCSD量子线路：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">total_circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span>
<span class="n">molecule_pqc</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="n">hamiltonian_QubitOp</span><span class="p">),</span> <span class="n">total_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>通过将参数的具体数值传入<code class="docutils literal notranslate"><span class="pre">molecule_pqc</span></code>，即可得到对应于此变分参数的能量<span class="math notranslate nohighlight">\(E(\theta)=\langle \Psi_{UCC}(\theta) | \hat{H} | \Psi_{UCC}(\theta) \rangle\)</span>以及关于每个变分参数的导数。</p>
<p>例如，我们可以利用下面的代码计算当变分量子线路中所有参数都为零时，哈密顿量的期望值和期望值关于梯度的导数。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_circuit</span><span class="o">.</span><span class="n">params_name</span><span class="p">)</span>
<span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_params</span><span class="p">)</span>
<span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">molecule_pqc</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energy: &quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">shape: &quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gradient: &quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">shape: &quot;</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Energy:  [[-7.86335762+0.j]]
shape:  (1, 1)

Gradient:  [[[-5.76513698e-11+0.j -8.60518134e-02+0.j  1.19273071e-08+0.j
   -4.85545124e-02+0.j -6.07652177e-15+0.j -3.92769093e-02+0.j
   -1.00082540e-14+0.j -9.59481745e-02+0.j  3.21896998e-15+0.j
   -3.92769093e-02+0.j -2.06907796e-15+0.j -9.59481745e-02+0.j
   -8.59782560e-11+0.j -2.89649669e-02+0.j  2.97637789e-10+0.j
   -4.91813233e-01+0.j -9.35293242e-04+0.j -1.69582252e-16+0.j
   -3.24387386e-17+0.j  1.60229175e-17+0.j  1.54862635e-16+0.j
    2.66601400e-17+0.j -2.14277745e-17+0.j  5.06813117e-03+0.j
    1.08542346e-02+0.j -1.28614265e-02+0.j -5.51985604e-17+0.j
    9.81307914e-18+0.j  1.33973787e-01+0.j -3.03063680e-02+0.j
    1.83995210e-18+0.j -1.83995210e-18+0.j -2.21362064e-29+0.j
    5.61185390e-17+0.j -3.80815167e-17+0.j  3.33490478e-17+0.j
    1.14905747e-28+0.j  1.15391965e-16+0.j -3.03063680e-02+0.j
   -5.51985630e-17+0.j  4.93146033e-17+0.j -4.22508287e-17+0.j
   -2.44510199e-17+0.j -1.68035039e-03+0.j]]]
shape:  (1, 1, 44)
</pre></div></div>
</div>
<p>通过上述计算，我们获得了能量值和梯度值，用户可以根据实际应用需求来提取这些值。 接下来需要进行VQE优化的(5)~(7)步，即对变分量子线路进行优化。我们可以借助scipy中的优化器来对线路参数进行优化。首先我们构造适用与scipy优化器的优化函数：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">molecule_pqc</span><span class="p">,</span> <span class="n">energy_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">molecule_pqc</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">g</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">energy_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">energy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_list</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">energy_list</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="se">\t</span><span class="s2">energy: </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span>

<span class="n">fun</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">molecule_pqc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(-7.86335762153696,
 array([-5.76513698e-11, -8.60518134e-02,  1.19273071e-08, -4.85545124e-02,
        -6.07652177e-15, -3.92769093e-02, -1.00082540e-14, -9.59481745e-02,
         3.21896998e-15, -3.92769093e-02, -2.06907796e-15, -9.59481745e-02,
        -8.59782560e-11, -2.89649669e-02,  2.97637789e-10, -4.91813233e-01,
        -9.35293242e-04, -1.69582252e-16, -3.24387386e-17,  1.60229175e-17,
         1.54862635e-16,  2.66601400e-17, -2.14277745e-17,  5.06813117e-03,
         1.08542346e-02, -1.28614265e-02, -5.51985604e-17,  9.81307914e-18,
         1.33973787e-01, -3.03063680e-02,  1.83995210e-18, -1.83995210e-18,
        -2.21362064e-29,  5.61185390e-17, -3.80815167e-17,  3.33490478e-17,
         1.14905747e-28,  1.15391965e-16, -3.03063680e-02, -5.51985630e-17,
         4.93146033e-17, -4.22508287e-17, -2.44510199e-17, -1.68035039e-03]))
</pre></div></div>
</div>
<p>此时，我们定义出来的 <code class="docutils literal notranslate"><span class="pre">fun</span></code> 函数能够正确返回符合要求的数据类型：一个实数格式的能量值，一个跟参数长度一直的梯度数组。接下来，我们利用 scipy 中的 <code class="docutils literal notranslate"><span class="pre">bfgs</span></code> 二阶优化器来进行优化。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>

<span class="n">energy_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">molecule_pqc</span><span class="p">,</span> <span class="n">energy_list</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Step: 5,        energy: -7.880227726111784
Step: 10,       energy: -7.88181712406493
Step: 15,       energy: -7.882213242904179
Step: 20,       energy: -7.882345336993505
Step: 25,       energy: -7.882352494990301
Step: 30,       energy: -7.882352691272338
Step: 35,       energy: -7.882352706023384
</pre></div></div>
</div>
<p>如上，我们便完成了变分量子线路的梯度优化。在这里 <code class="docutils literal notranslate"><span class="pre">energy_list</span></code> 用于存储收敛过程中的能量。这里我们对 <code class="docutils literal notranslate"><span class="pre">minimize</span></code> 函数做一个简单介绍：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fun</span></code>: 第一个参数表示想要优化的函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p0</span></code>：第二个参数表示变量的初始值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code>：<code class="docutils literal notranslate"><span class="pre">fun</span></code> 函数中除了第一个参数以外的其他参数，根据我们的 <code class="docutils literal notranslate"><span class="pre">fun</span></code> 函数的定义，这里选择 <code class="docutils literal notranslate"><span class="pre">args=(molecule_pqc,</span> <span class="pre">energy_list)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>：所使用的优化算法，我们这里选择二阶优化算法 <code class="docutils literal notranslate"><span class="pre">bfgs</span></code>。更多优化算法请参考 <code class="docutils literal notranslate"><span class="pre">`scipy</span></code> 官方文档 &lt;<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a>&gt;`__</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jac</span></code>：<code class="docutils literal notranslate"><span class="pre">fun</span></code> 函数是否返回导数值，这里我们选择 <code class="docutils literal notranslate"><span class="pre">True</span></code>，因为 MindSpore Quantum 框架能够算出变分量子线路中参数的精确梯度值。如选 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则 <code class="docutils literal notranslate"><span class="pre">minimize</span></code> 框架将在内部利用差分方法计算近似梯度值。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">res</span></code> 为 <code class="docutils literal notranslate"><span class="pre">scipy</span></code> 中优化算法得到的优化结果，包括优化得到的参数，最优化函数值和迭代次数等。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ground state: </span><span class="se">\n</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">fun</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FCI: </span><span class="se">\n</span><span class="s2">-7.882362286798721</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimized amplitudes: </span><span class="se">\n</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Ground state:
-7.8823527083497105

FCI:
-7.882362286798721

Optimized amplitudes:
[ 2.38544548e-04  1.89071786e-03  3.52375725e-02  1.60369224e-02
 -5.38925036e-09  9.09472571e-04 -1.56807151e-10  1.41642144e-02
  1.51399639e-08  9.08742805e-04 -1.74968590e-10  1.41698985e-02
 -5.47895177e-04  4.26807722e-04  2.87128385e-03  5.38110483e-02
  2.34823599e-04  1.08613207e-08 -1.31353895e-07  1.29567542e-07
 -3.56002770e-08  3.17328351e-07 -3.10806922e-07  1.32372340e-05
 -1.04187318e-04  7.98992314e-04  4.80948977e-10 -1.09620509e-09
 -5.50006189e-02  3.09112335e-03  2.82662610e-10  1.68729874e-09
 -1.70596920e-09 -1.22679172e-08 -1.60711122e-08  1.29352307e-08
  8.29267936e-13 -5.33349675e-11  3.09111737e-03  4.61835836e-08
 -5.41032067e-08  5.57952993e-08 -9.64149879e-11  3.72726345e-04]
</pre></div></div>
</div>
<p>可以看到，幺正耦合簇给出的计算结果和FCI非常接近，具有良好的精度。</p>
</section>
</section>
<section id="分步构造幺正耦合簇拟设">
<h2>分步构造幺正耦合簇拟设<a class="headerlink" href="#分步构造幺正耦合簇拟设" title="永久链接至标题"></a></h2>
<p>在上文中，我们使用了 <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/zh-CN/r0.9/algorithm/nisq/mindquantum.algorithm.nisq.generate_uccsd.html">generate_uccsd</a> 一步构造出了幺正耦合簇拟设所需要的所有内容，此处我们将步骤拆分，分别得到我们需要的耦合簇算符、对应的量子线路以及取自于经典CCSD计算结果的变分参数初猜值。 首先，导入部分额外依赖，主要包含mindquantum中hiqfermion模块的相关函数：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">get_qubit_hamiltonian</span>
<span class="kn">from</span> <span class="nn">mindquantum.algorithm.nisq</span> <span class="kn">import</span> <span class="n">uccsd_singlet_generator</span><span class="p">,</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span>
<span class="kn">from</span> <span class="nn">mindquantum.core.operators</span> <span class="kn">import</span> <span class="n">TimeEvolution</span>
<br/></pre></div>
</div>
</div>
<p>分子哈密顿量使用 <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/zh-CN/r0.9/algorithm/nisq/mindquantum.algorithm.nisq.get_qubit_hamiltonian.html">get_qubit_hamiltonian</a> ，读取之前的计算结果得到：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_QubitOp</span> <span class="o">=</span> <span class="n">get_qubit_hamiltonian</span><span class="p">(</span><span class="n">molecule_of</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>对于幺正耦合簇算符 <span class="math notranslate nohighlight">\(\hat{T} - \hat{T}^{\dagger}\)</span> ，可以使用 <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/zh-CN/r0.9/algorithm/nisq/mindquantum.algorithm.nisq.uccsd_singlet_generator.html">uccsd_singlet_generator</a> 进行构造。提供总量子比特数（总自旋轨道数）和总电子数，并设置参数<code class="docutils literal notranslate"><span class="pre">anti_hermitian=True</span></code>：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ucc_fermion_ops</span> <span class="o">=</span> <span class="n">uccsd_singlet_generator</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span> <span class="n">anti_hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>上一步构造的<code class="docutils literal notranslate"><span class="pre">ucc_fermion_ops</span></code>是参数化的。使用Jordan-Wigner变换将费米子激发算符映射为Pauli算符：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ucc_qubit_ops</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="n">ucc_fermion_ops</span><span class="p">)</span><span class="o">.</span><span class="n">jordan_wigner</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>接下来，我们需要得到幺正算符 <span class="math notranslate nohighlight">\(\exp \left(\hat{T}-\hat{T}^{\dagger}\right)\)</span> 所对应的量子线路。<a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/zh-CN/r0.9/core/operators/mindquantum.core.operators.TimeEvolution.html">TimeEvolution</a> 可生成 <span class="math notranslate nohighlight">\(\exp (-i \hat{H} t)\)</span> 所对应的线路，其中 <span class="math notranslate nohighlight">\(\hat{H}\)</span> 是一个厄米算符， <span class="math notranslate nohighlight">\(t\)</span> 是实数。需要注意的是，使用<a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/zh-CN/r0.9/core/operators/mindquantum.core.operators.TimeEvolution.html">TimeEvolution</a>
时，<code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code>中已经包含了复数因子 <span class="math notranslate nohighlight">\(i\)</span> ，所以我们需要将<code class="docutils literal notranslate"><span class="pre">ucc_qubit_ops</span></code>除以 <span class="math notranslate nohighlight">\(i\)</span> ，或者提取其虚部：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">TimeEvolution</span><span class="p">(</span><span class="n">ucc_qubit_ops</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">circuit</span>
<span class="n">ansatz_parameter_names</span> <span class="o">=</span> <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">params_name</span>
</pre></div>
</div>
</div>
<p>我们使用<code class="docutils literal notranslate"><span class="pre">ansatz_parameter_names</span></code>记录该线路中的参数名。到目前为止，我们已经得到了VQE量子线路所需要内容，包括哈密顿量<code class="docutils literal notranslate"><span class="pre">hamiltonian_QubitOp</span></code>、参数化的波函数拟设线路<code class="docutils literal notranslate"><span class="pre">ansatz_circuit</span></code>，故可仿照前文，得到完整的态制备线路。其中Hartree-Fock参考态复用之前的<code class="docutils literal notranslate"><span class="pre">hartreefock_wfn_circuit</span></code>：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">total_circuit</span> <span class="o">=</span> <span class="n">hartreefock_wfn_circuit</span> <span class="o">+</span> <span class="n">ansatz_circuit</span>
<span class="n">total_circuit</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="color: #ff0000; text-decoration-color: #ff0000; font-weight: bold">                                  Circuit Summary                                  </span>
╭──────────────────────┬──────────────────────────────────────────────────────────╮
│<span style="font-weight: bold"> </span><span style="color: #3b3b95; text-decoration-color: #3b3b95; font-weight: bold">Info</span><span style="font-weight: bold">                 </span>│<span style="font-weight: bold"> </span><span style="color: #3b3b95; text-decoration-color: #3b3b95; font-weight: bold">value</span><span style="font-weight: bold">                                                    </span>│
├──────────────────────┼──────────────────────────────────────────────────────────┤
│ <span style="font-weight: bold">Number of qubit</span>      │ 12                                                       │
├──────────────────────┼──────────────────────────────────────────────────────────┤
│ <span style="font-weight: bold">Total number of gate</span> │ 12612                                                    │
│ Barrier              │ 2560                                                     │
│ Noise Channel        │ 0                                                        │
│ Measurement          │ 0                                                        │
├──────────────────────┼──────────────────────────────────────────────────────────┤
│ <span style="font-weight: bold">Parameter gate</span>       │ 640                                                      │
│ 44 ansatz parameters │ <span style="color: #48c9b0; text-decoration-color: #48c9b0">s_0, d1_0, s_1, d1_1, s_2, d1_2, s_3, d1_3, s_4, d1_4...</span> │
╰──────────────────────┴──────────────────────────────────────────────────────────╯
</pre></div>
</div>
<p>下一步，需要为变分参数提供一个合理的初始值。前文构造的优化器默认使用0作为初猜，在大多数情况下是可行的。不过，使用CCSD的计算数据作为UCC的出发点，可能会有更好的结果。使用 <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/zh-CN/r0.9/algorithm/nisq/mindquantum.algorithm.nisq.uccsd_singlet_get_packed_amplitudes.html">uccsd_singlet_get_packed_amplitudes</a> 函数从<code class="docutils literal notranslate"><span class="pre">molecule_of</span></code>提取CCSD的参数：</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">init_amplitudes_ccsd</span> <span class="o">=</span> <span class="n">uccsd_singlet_get_packed_amplitudes</span><span class="p">(</span>
    <span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_single_amps</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">ccsd_double_amps</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">molecule_of</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)</span>
<span class="n">init_amplitudes_ccsd</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_amplitudes_ccsd</span><span class="p">[</span><span class="n">param_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">param_i</span> <span class="ow">in</span> <span class="n">ansatz_parameter_names</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>根据之前类似的方式，我们可以利用 MindSpore Quantum 来得到梯度算子，并利用 scipy 来进行优化。</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grad_ops</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="s1">&#39;mqvector&#39;</span><span class="p">,</span> <span class="n">total_circuit</span><span class="o">.</span><span class="n">n_qubits</span><span class="p">)</span><span class="o">.</span><span class="n">get_expectation_with_grad</span><span class="p">(</span>
    <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">hamiltonian_QubitOp</span><span class="o">.</span><span class="n">real</span><span class="p">),</span>
    <span class="n">total_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>使用<code class="docutils literal notranslate"><span class="pre">init_amplitudes_ccsd</span></code>（即CCSD计算的耦合簇系数）作为初始变分参数：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">energy_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">init_amplitudes_ccsd</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">grad_ops</span><span class="p">,</span> <span class="n">energy_list</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Step: 5,        energy: -7.87822328311087
Step: 10,       energy: -7.880288481802379
Step: 15,       energy: -7.882035668318941
Step: 20,       energy: -7.882302370884022
Step: 25,       energy: -7.882349803535785
Step: 30,       energy: -7.882352702053598
Step: 35,       energy: -7.882352707882877
Step: 40,       energy: -7.882352708334483
</pre></div></div>
</div>
<p>最后，我们可以得到优化的结果如下：</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ground state: </span><span class="se">\n</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">fun</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FCI: </span><span class="se">\n</span><span class="s2">-7.882362286798721</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimized amplitudes: </span><span class="se">\n</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Ground state:
-7.882352708353205

FCI:
-7.882362286798721

Optimized amplitudes:
[-2.38523911e-04  1.89069822e-03 -3.52373476e-02  1.60367877e-02
  1.01252245e-09  9.09441478e-04 -3.44110570e-10  1.41641951e-02
 -3.55437460e-09  9.08694499e-04  1.51899574e-10  1.41696901e-02
  5.47582129e-04  4.26818549e-04 -2.87197044e-03  5.38109082e-02
  2.34573340e-04  9.61091660e-11  3.26047168e-08 -3.28565811e-08
 -3.01353861e-08  2.57229375e-08 -2.35406397e-08  1.32955992e-05
  7.98917451e-04 -1.04228796e-04 -1.41632464e-10 -1.72636257e-10
 -5.50006376e-02  3.09132360e-03 -4.33208163e-10  5.56668226e-09
 -5.53725165e-09 -9.18193176e-08  3.36714462e-08 -2.47305566e-08
 -1.26595719e-12 -1.96392557e-10  3.09104547e-03  8.41723416e-08
 -3.28071662e-09 -2.20592853e-09  2.57550150e-10  3.72870642e-04]
</pre></div></div>
</div>
</section>
<section id="总结">
<h2>总结<a class="headerlink" href="#总结" title="永久链接至标题"></a></h2>
<p>在本案例中，我们通过两种方法，利用 <code class="docutils literal notranslate"><span class="pre">scipy</span></code> 中的优化器，得到了LiH分子的基态能量。在第一种方法中，我们利用MindSpore Quantum打包好的 <a class="reference external" href="https://www.mindspore.cn/mindquantum/docs/zh-CN/r0.9/algorithm/nisq/mindquantum.algorithm.nisq.generate_uccsd.html">generate_uccsd</a> 函数生成了能够解决该问题的量子神经网络，而在第二种方法中，我们一步一步的构造出了类似的梯度算子。最终得到的结果是一致的。</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindquantum.utils.show_info</span> <span class="kn">import</span> <span class="n">InfoTable</span>

<span class="n">InfoTable</span><span class="p">(</span><span class="s1">&#39;mindquantum&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<table border="1">
  <tr>
    <th>Software</th>
    <th>Version</th>
  </tr>
<tr><td>mindquantum</td><td>0.9.11</td></tr>
<tr><td>scipy</td><td>1.9.3</td></tr>
<tr><td>numpy</td><td>1.23.5</td></tr>
<tr>
    <th>System</th>
    <th>Info</th>
</tr>
<tr><td>Python</td><td>3.8.17</td></tr><tr><td>OS</td><td>Linux x86_64</td></tr><tr><td>Memory</td><td>16.62 GB</td></tr><tr><td>CPU Max Thread</td><td>16</td></tr><tr><td>Date</td><td>Tue Jan  2 17:03:00 2024</td></tr>
</table></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="classification_of_iris_by_qnn.html" class="btn btn-neutral float-left" title="通过量子神经网络对鸢尾花进行分类" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="qnn_for_nlp.html" class="btn btn-neutral float-right" title="量子神经网络在自然语言处理中的应用" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 MindSpore.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>