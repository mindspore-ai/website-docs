

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Incremental Training for Solving a Family of Maxwell’s Equation &mdash; MindSpore master documentation</title>
  

  
   
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        
        
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Data Driven Deep Learning Method for Electromagnetic Simulation" href="data_driven.html" />
    <link rel="prev" title="AI Method for Solving Point Source Maxwell’s Equations" href="time_domain_maxwell.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">MindSPONGE</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mindsponge/intro_and_install.html">MindSPONGE Introduction and Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mindsponge/ala.html">MindSPONGE Molecular Simulation Practice</a></li>
</ul>
<p class="caption"><span class="caption-text">MindElec</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro_and_install.html">MindElec Introduction and Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="physics_driven.html">Physics Informed Deep Learning Method for Electromagnetic Simulation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="time_domain_maxwell.html">AI Method for Solving Point Source Maxwell’s Equations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Incremental Training for Solving a Family of Maxwell’s Equation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#problem-description">Problem Description</a></li>
<li class="toctree-l3"><a class="reference internal" href="#physics-informed-auto-decoder">Physics-Informed Auto-Decoder</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#importing-dependency">Importing dependency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-dataset">Creating a Dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-the-control-equation-and-initial-boundary-condition">Defining the Control Equation and Initial &amp; Boundary Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#building-a-neural-network">Building a Neural Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adaptive-weighted-loss-function-for-accelerating-convergence">Adaptive Weighted Loss Function for Accelerating Convergence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-evaluation">Model Evaluation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-pre-training">Model Pre-training</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-fine-tuning">Model Fine-tuning</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_driven.html">Data Driven Deep Learning Method for Electromagnetic Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualizing Electromagnetic Simulation Results</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="physics_driven.html">Physics Informed Deep Learning Method for Electromagnetic Simulation</a> &raquo;</li>
        
      <li>Incremental Training for Solving a Family of Maxwell’s Equation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/mindelec/incremental_learning.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="incremental-training-for-solving-a-family-of-maxwell-s-equation">
<h1>Incremental Training for Solving a Family of Maxwell’s Equation<a class="headerlink" href="#incremental-training-for-solving-a-family-of-maxwell-s-equation" title="Permalink to this headline">¶</a></h1>
<p><a href="https://gitee.com/mindspore/docs/blob/r1.5/docs/mindscience/docs/source_en/mindelec/incremental_learning.md" target="_blank"><img src="https://gitee.com/mindspore/docs/raw/r1.5/resource/_static/logo_source_en.png"></a>  </p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The Physics-Informed Neural Networks (PINNs) is unable to solve parametric Partial Differential Equations (PDEs). When the parameters of PDEs (dielectric constants) change, the PINNs method needs to retrain a new neural network and it increases the total solving time.</p>
<p>This tutorial focuses on how to use Physics-Informed Auto-Decoder (PIAD) based on the MindElec toolkit to solve the parametric Maxwell’s equations with incremental training, which reduces the training time significantly.</p>
<blockquote>
<div><p>This current sample is for Ascend 910 AI processor. You can find the complete executable code at
<a class="reference external" href="https://gitee.com/mindspore/mindscience/tree/r0.1/MindElec/examples/physics_driven/incremental_learning">https://gitee.com/mindspore/mindscience/tree/r0.1/MindElec/examples/physics_driven/incremental_learning</a></p>
</div></blockquote>
</div>
<div class="section" id="problem-description">
<h2>Problem Description<a class="headerlink" href="#problem-description" title="Permalink to this headline">¶</a></h2>
<p>This tutorial deals with the generalization of the medium parameters for the point source Maxwell’s equations. For the specific form of the governing equation, the domain and the configuration of the excitation source, please refer to the <a class="reference external" href="https://www.mindspore.cn/mindscience/docs/en/r0.1/mindelec/time_domain_maxwell.html">tutorial of the point source Maxwell problem</a>.</p>
</div>
<div class="section" id="physics-informed-auto-decoder">
<h2>Physics-Informed Auto-Decoder<a class="headerlink" href="#physics-informed-auto-decoder" title="Permalink to this headline">¶</a></h2>
<p>In general, the distribution of variable parameter <span class="math notranslate nohighlight">\(\lambda\)</span> forms a high-dimensional space. To reduce the model complexity and training costs, we first map the high-dimensional variable parameter space onto a low-dimensional manifold represented by a low-dimensional vector (Z). Then the characteristic parameter (Z) of the manifold and the input (X) of the equation are fused into the training of PINNs as the inputs of the point source problem solving network. The pre-trained model can be obtained. For the newly given variable parameter problem, the solution of the new equation can be obtained by fine-tuning the pre-trained model.</p>
<p>The process for MindElec to solve the problem based on Physics-Informed Auto-Decoder is as follows:</p>
<ul>
<li><p>Pre-train a series of equations based on the combination of latent vector and neural network. Different from solving a single PDE, the input of the neural network is the fusion of the sampling point (X) and the implicit vector (Z) in the pre-training step, as shown in the following figure.</p>
<p><img alt="TE_for_Maxwell" src="../_images/pretrain_model.png" /></p>
</li>
<li><p>For the new equations, incrementally train latent vector and neural network to solve the new problems quickly. We provide two incremental training modes:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\textit{finetune_latent_with_model}\)</span>: this mode updates the latent vector and network structure simultaneously and only needs to load the pre-trained model for incremental training.</p></li>
<li><p><span class="math notranslate nohighlight">\(\textit{finetune_latent_only}\)</span>: as shown in the following figure, this mode freezes the network structure and updates the latent vector only.</p></li>
</ul>
<p><img alt="TE_for_Maxwell" src="../_images/finetune_latent.png" /></p>
</li>
</ul>
<div class="section" id="importing-dependency">
<h3>Importing dependency<a class="headerlink" href="#importing-dependency" title="Permalink to this headline">¶</a></h3>
<p>Import the modules on which this tutorial depends.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindelec.data</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">mindelec.geometry</span> <span class="kn">import</span> <span class="n">Disk</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">,</span> <span class="n">TimeDomain</span><span class="p">,</span> <span class="n">GeometryWithTime</span>
<span class="kn">from</span> <span class="nn">mindelec.loss</span> <span class="kn">import</span> <span class="n">Constraints</span>
<span class="kn">from</span> <span class="nn">mindelec.solver</span> <span class="kn">import</span> <span class="n">Solver</span><span class="p">,</span> <span class="n">LossAndTimeMonitor</span>
<span class="kn">from</span> <span class="nn">mindelec.common</span> <span class="kn">import</span> <span class="n">L2</span>
<span class="kn">from</span> <span class="nn">mindelec.architecture</span> <span class="kn">import</span> <span class="n">MultiScaleFCCell</span><span class="p">,</span> <span class="n">MTLWeightedLossCell</span>

<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">get_test_data</span><span class="p">,</span> <span class="n">create_random_dataset</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">MultiStepLR</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">Maxwell2DMur</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">PredictCallback</span>
<span class="kn">from</span> <span class="nn">src</span> <span class="kn">import</span> <span class="n">visual_result</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-a-dataset">
<h3>Creating a Dataset<a class="headerlink" href="#creating-a-dataset" title="Permalink to this headline">¶</a></h3>
<p>Consistent with the point source Maxwell’s problem, five uniform samplings need to be implemented inside the rectangular computational domain: samplings on the rectangular domain constrained by the control equation and on internal points near the source region; samplings on the rectangular domain constrained by the initial condition and on internal points near the source region; boundary sampling on rectangular domain controlled by boundary conditions. The integration of spatial and temporal sampling data constitutes a training sample.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># src region</span>
<span class="n">disk</span> <span class="o">=</span> <span class="n">Disk</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="n">disk_origin</span><span class="p">,</span> <span class="n">disk_radius</span><span class="p">)</span>
<span class="c1"># no src region</span>
<span class="n">rectangle</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="s2">&quot;rect&quot;</span><span class="p">,</span> <span class="n">coord_min</span><span class="p">,</span> <span class="n">coord_max</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">rectangle</span> <span class="o">-</span> <span class="n">disk</span>

<span class="c1"># time info</span>
<span class="n">time_interval</span> <span class="o">=</span> <span class="n">TimeDomain</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;range_t&quot;</span><span class="p">])</span>

<span class="c1"># geometry merge with time</span>
<span class="n">no_src_region</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">no_src_region</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;no_src&quot;</span><span class="p">)</span>
<span class="n">no_src_region</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">no_src_sampling_config</span><span class="p">))</span>
<span class="n">src_region</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">src_region</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span>
<span class="n">src_region</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">src_sampling_config</span><span class="p">))</span>
<span class="n">boundary</span> <span class="o">=</span> <span class="n">GeometryWithTime</span><span class="p">(</span><span class="n">rectangle</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<span class="n">boundary</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;bc&quot;</span><span class="p">)</span>
<span class="n">boundary</span><span class="o">.</span><span class="n">set_sampling_config</span><span class="p">(</span><span class="n">create_config_from_edict</span><span class="p">(</span><span class="n">bc_sampling_config</span><span class="p">))</span>

<span class="c1"># final sampling fields</span>
<span class="n">geom_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">src_region</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;IC&quot;</span><span class="p">],</span>
                 <span class="n">no_src_region</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;IC&quot;</span><span class="p">],</span>
                 <span class="n">boundary</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BC&quot;</span><span class="p">]}</span>
</pre></div>
</div>
<p>The MindElec Dataset API combines different sampled data into a unified training dataset.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># create dataset for train</span>
<span class="n">elec_train_dataset</span> <span class="o">=</span> <span class="n">create_random_dataset</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;batch_size&quot;</span><span class="p">],</span>
                                                  <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">prebatched_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-the-control-equation-and-initial-boundary-condition">
<h3>Defining the Control Equation and Initial &amp; Boundary Condition<a class="headerlink" href="#defining-the-control-equation-and-initial-boundary-condition" title="Permalink to this headline">¶</a></h3>
<p>Inherit the Problem class provided by MindElec, the core code of the PDE problem is defined as follows. Different from solving one specific PDE problem, we transfer parameters <code class="docutils literal notranslate"><span class="pre">eps_candidates</span></code> and <code class="docutils literal notranslate"><span class="pre">mu_candidates</span></code> to represent the relative dielectric constant and relative magnetic permeability of the medium. In this tutorial, the pre-trained model selects the following parameter settings: <span class="math notranslate nohighlight">\((\epsilon_r, \mu_r)\in [1,3,5]*[1,3,5]\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Maxwell2DMur</span><span class="p">(</span><span class="n">Problem</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">domain_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bc_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ic_column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Maxwell2DMur</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain_column</span> <span class="o">=</span> <span class="n">domain_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc_column</span> <span class="o">=</span> <span class="n">bc_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ic_column</span> <span class="o">=</span> <span class="n">ic_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>

        <span class="c1"># operations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span> <span class="o">=</span> <span class="n">Grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cast</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Cast</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">()</span>

        <span class="c1"># gauss-type pulse source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">PI</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_frq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;src_frq&quot;</span><span class="p">,</span> <span class="mf">1e+9</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">((</span><span class="mf">2.3</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">PI</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_frq</span><span class="p">),</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">3.65</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># src space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_x0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_pos&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_y0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_pos&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_sigma</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;src_radius&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_coord_min</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;coord_min&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_coord_max</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;coord_max&quot;</span><span class="p">]</span>

        <span class="n">input_scales</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;input_scales&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5e+8</span><span class="p">])</span>
        <span class="n">output_scales</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_scales&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">37.67303</span><span class="p">,</span> <span class="mf">37.67303</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scales</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">input_scales</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scales</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">output_scales</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># set up eps, mu candidates</span>
        <span class="n">eps_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;eps_list&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">EPS</span>
        <span class="n">mu_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;mu_list&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">MU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">eps_candidates</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_y</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">eps_candidates</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">mu_candidates</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">ops</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">()(</span><span class="n">ops</span><span class="o">.</span><span class="n">Mul</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">))</span>

    <span class="c1"># gaussian pulse with gaussian smooth technology</span>
    <span class="k">def</span> <span class="nf">smooth_src</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp</span> <span class="o">*</span> <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">((</span><span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">gauss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">gauss</span><span class="p">)</span>

    <span class="nd">@ms_function</span>
    <span class="k">def</span> <span class="nf">governing_equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;maxwell equation of TE mode wave&quot;&quot;&quot;</span>
        <span class="c1"># net output and sampling input</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_column</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># get gradients</span>
        <span class="n">dex_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dex_dy</span><span class="p">,</span> <span class="n">dex_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dex_dxyt</span><span class="p">)</span>
        <span class="n">dey_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">dey_dx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dey_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dey_dxyt</span><span class="p">)</span>
        <span class="n">dhz_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">dhz_dx</span><span class="p">,</span> <span class="n">dhz_dy</span><span class="p">,</span> <span class="n">dhz_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dhz_dxyt</span><span class="p">)</span>

        <span class="c1"># get equation residual</span>
        <span class="n">loss_a1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="n">dhz_dy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span><span class="p">)</span>
        <span class="n">loss_a2</span> <span class="o">=</span> <span class="n">dex_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">loss_b1</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="n">dhz_dx</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_y</span><span class="p">)</span>
        <span class="n">loss_b2</span> <span class="o">=</span> <span class="n">dey_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">loss_c1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="n">dey_dx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="n">dex_dy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">)</span>
        <span class="n">loss_c2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span>

        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_src</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_z</span><span class="p">)</span>

        <span class="n">pde_res1</span> <span class="o">=</span> <span class="n">loss_a1</span> <span class="o">-</span> <span class="n">loss_a2</span>
        <span class="n">pde_res2</span> <span class="o">=</span> <span class="n">loss_b1</span> <span class="o">-</span> <span class="n">loss_b2</span>
        <span class="n">pde_res3</span> <span class="o">=</span> <span class="n">loss_c1</span> <span class="o">-</span> <span class="n">loss_c2</span> <span class="o">-</span> <span class="n">source</span>
        <span class="n">pde_r</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="mi">1</span><span class="p">)((</span><span class="n">pde_res1</span><span class="p">,</span> <span class="n">pde_res2</span><span class="p">,</span> <span class="n">pde_res3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pde_r</span>

    <span class="nd">@ms_function</span>
    <span class="k">def</span> <span class="nf">boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;2nd-order mur boundary condition&quot;&quot;&quot;</span>
        <span class="c1"># get net output and inputs</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc_column</span><span class="p">]</span>

        <span class="c1"># specify each boundary</span>
        <span class="n">coord_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_coord_min</span>
        <span class="n">coord_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_coord_max</span>
        <span class="n">batch_size</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">bc_attr</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">bc_attr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coord_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">bc_attr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coord_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">bc_attr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coord_min</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">bc_attr</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ms_np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coord_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="n">dex_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dex_dy</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dex_dxyt</span><span class="p">)</span>
        <span class="n">dey_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dey_dx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dey_dxyt</span><span class="p">)</span>
        <span class="n">dhz_dxyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">dhz_dx</span><span class="p">,</span> <span class="n">dhz_dy</span><span class="p">,</span> <span class="n">dhz_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dhz_dxyt</span><span class="p">)</span>

        <span class="n">bc_r1</span> <span class="o">=</span> <span class="n">dhz_dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dex_dy</span>  <span class="c1"># left boundary</span>
        <span class="n">bc_r2</span> <span class="o">=</span> <span class="n">dhz_dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span> <span class="o">+</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ex</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dex_dy</span>  <span class="c1"># right boundary</span>
        <span class="n">bc_r3</span> <span class="o">=</span> <span class="n">dhz_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">-</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dey_dx</span>  <span class="c1"># bottom boundary</span>
        <span class="n">bc_r4</span> <span class="o">=</span> <span class="n">dhz_dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span> <span class="o">+</span> <span class="n">dhz_dt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">s_ey</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_speed</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_hz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dey_dx</span>  <span class="c1"># top boundary</span>

        <span class="n">bc_r_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">bc_r1</span><span class="p">,</span> <span class="n">bc_r2</span><span class="p">,</span> <span class="n">bc_r3</span><span class="p">,</span> <span class="n">bc_r4</span><span class="p">))</span>
        <span class="n">bc_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">bc_r_all</span><span class="p">,</span> <span class="n">bc_attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bc_r</span>

    <span class="nd">@ms_function</span>
    <span class="k">def</span> <span class="nf">initial_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initial condition: u = 0&quot;&quot;&quot;</span>
        <span class="n">net_out</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">net_out</span>
</pre></div>
</div>
<p>The problem constraints are defined as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># define constraints</span>
<span class="n">train_prob</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">all_datasets</span><span class="p">:</span>
    <span class="n">train_prob</span><span class="p">[</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Maxwell2DMur</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
                                            <span class="n">domain_column</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">,</span>
                                            <span class="n">ic_column</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">,</span>
                                            <span class="n">bc_column</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_points&quot;</span><span class="p">)</span>
<span class="n">train_constraints</span> <span class="o">=</span> <span class="n">Constraints</span><span class="p">(</span><span class="n">elec_train_dataset</span><span class="p">,</span> <span class="n">train_prob</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="building-a-neural-network">
<h3>Building a Neural Network<a class="headerlink" href="#building-a-neural-network" title="Permalink to this headline">¶</a></h3>
<p>In the Physics-Informed Auto-Decoder, the input of the neural network is the fusion of sampling points (X) and latent vector (Z) in the pre-training step, and the main structure of the neural network is multi-channel residual network combined with the Sin activation function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># initialize latent vector</span>
<span class="n">num_scenarios</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_scenarios&quot;</span><span class="p">]</span>
<span class="n">latent_size</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;latent_vector_size&quot;</span><span class="p">]</span>
<span class="n">latent_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_scenarios</span><span class="p">,</span> <span class="n">latent_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">latent_size</span><span class="p">)</span>
<span class="n">latent_vector</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">latent_init</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">network</span> <span class="o">=</span> <span class="n">MultiScaleFCCell</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_size&quot;</span><span class="p">],</span>
                           <span class="n">config</span><span class="p">[</span><span class="s2">&quot;output_size&quot;</span><span class="p">],</span>
                           <span class="n">layers</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;layers&quot;</span><span class="p">],</span>
                           <span class="n">neurons</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;neurons&quot;</span><span class="p">],</span>
                           <span class="n">residual</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;residual&quot;</span><span class="p">],</span>
                           <span class="n">weight_init</span><span class="o">=</span><span class="n">HeUniform</span><span class="p">(</span><span class="n">negative_slope</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span>
                           <span class="n">act</span><span class="o">=</span><span class="s2">&quot;sin&quot;</span><span class="p">,</span>
                           <span class="n">num_scales</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_scales&quot;</span><span class="p">],</span>
                           <span class="n">amp_factor</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;amp_factor&quot;</span><span class="p">],</span>
                           <span class="n">scale_factor</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">],</span>
                           <span class="n">input_scale</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_scale&quot;</span><span class="p">],</span>
                           <span class="n">input_center</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;input_center&quot;</span><span class="p">],</span>
                           <span class="n">latent_vector</span><span class="o">=</span><span class="n">latent_vector</span>
                           <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="adaptive-weighted-loss-function-for-accelerating-convergence">
<h3>Adaptive Weighted Loss Function for Accelerating Convergence<a class="headerlink" href="#adaptive-weighted-loss-function-for-accelerating-convergence" title="Permalink to this headline">¶</a></h3>
<p>In this case, because the encrypted sampling near the source region is performed as an independent subdataset for network training, the composition of the loss function includes the following five items: a control equation and an initial condition of the source region, a control equation and an initial condition of the source-free region, and a boundary condition. Experiments show that the five items in the loss function differ greatly in magnitude, so the simple summation of the loss functions will lead to the failure of network training, and the manual adjustment of the weight information of each loss function is very cumbersome. MindElec develops a weighting algorithm based on uncertainty estimation of multi-task learning. By introducing trainable parameters and adaptively adjusting the weight of each loss function, MindElec can significantly improve the training speed and accuracy. The algorithm is implemented as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MTLWeightedLossCell</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_losses</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MTLWeightedLossCell</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">auto_prefix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_losses</span> <span class="o">=</span> <span class="n">num_losses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_losses</span><span class="p">),</span> <span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pow</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Pow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Log</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">div</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">RealDiv</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">losses</span><span class="p">):</span>
        <span class="n">loss_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_losses</span><span class="p">):</span>
            <span class="n">weighted_loss</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">loss_sum</span> <span class="o">=</span> <span class="n">loss_sum</span> <span class="o">+</span> <span class="n">weighted_loss</span>
        <span class="k">return</span> <span class="n">loss_sum</span>

<span class="c1"># self-adaptive weighting</span>
<span class="n">mtl</span> <span class="o">=</span> <span class="n">MTLWeightedLossCell</span><span class="p">(</span><span class="n">num_losses</span><span class="o">=</span><span class="n">elec_train_dataset</span><span class="o">.</span><span class="n">num_dataset</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="model-evaluation">
<h3>Model Evaluation<a class="headerlink" href="#model-evaluation" title="Permalink to this headline">¶</a></h3>
<p>MindElec can use the user-defined callback function to implement training and inference at the same time. You can directly load the test dataset and set corresponding callback functions to implement inference and analyze the result.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">LossAndTimeMonitor</span><span class="p">(</span><span class="n">epoch_steps</span><span class="p">)]</span>
<span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;train_with_eval&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">input_data</span><span class="p">,</span> <span class="n">label_data</span> <span class="o">=</span> <span class="n">get_test_data</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;test_data_path&quot;</span><span class="p">])</span>
    <span class="n">eval_callback</span> <span class="o">=</span> <span class="n">PredictCallback</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">label_data</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span> <span class="n">visual_fn</span><span class="o">=</span><span class="n">visual_result</span><span class="p">)</span>
    <span class="n">callbacks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">eval_callback</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="model-pre-training">
<h3>Model Pre-training<a class="headerlink" href="#model-pre-training" title="Permalink to this headline">¶</a></h3>
<p>The Solver class provided by MindElec is an API for model training and inference. You can enter the optimizer, network model, PDE constraints (train_constraints), and optional parameters such as the adaptive weighting algorithm module to define the solver object. In this tutorial, the MindSpore + Ascend mixed precision mode is used to train the network to solve the Maxwell’s equations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># mixed precision</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">input_scale</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">mstype</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># optimizer</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span> <span class="o">+</span> <span class="n">mtl</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
<span class="n">lr_scheduler</span> <span class="o">=</span> <span class="n">MultiStepLR</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;milestones&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr_gamma&quot;</span><span class="p">],</span>
                           <span class="n">epoch_steps</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">])</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="n">Tensor</span><span class="p">(</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">get_lr</span><span class="p">()))</span>

<span class="c1"># problem solver</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">network</span><span class="p">,</span>
                <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;PINNs&quot;</span><span class="p">,</span>
                <span class="n">train_constraints</span><span class="o">=</span><span class="n">train_constraints</span><span class="p">,</span>
                <span class="n">test_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">metrics</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;l2&#39;</span><span class="p">:</span> <span class="n">L2</span><span class="p">(),</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">MAE</span><span class="p">()},</span>
                <span class="n">loss_fn</span><span class="o">=</span><span class="s1">&#39;smooth_l1_loss&#39;</span><span class="p">,</span>
                <span class="n">loss_scale_manager</span><span class="o">=</span><span class="n">DynamicLossScaleManager</span><span class="p">(),</span>
                <span class="n">mtl_weighted_cell</span><span class="o">=</span><span class="n">mtl_cell</span><span class="p">,</span>
                <span class="n">latent_vector</span><span class="o">=</span><span class="n">latent_vector</span><span class="p">,</span>
                <span class="n">latent_reg</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;latent_reg&quot;</span><span class="p">]</span>
                <span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">],</span> <span class="n">train_dataset</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="model-fine-tuning">
<h3>Model Fine-tuning<a class="headerlink" href="#model-fine-tuning" title="Permalink to this headline">¶</a></h3>
<p>Given the new PDE parameter, for example, <span class="math notranslate nohighlight">\((\epsilon_r, \mu_r)=(2,2)\)</span>, we need to load the pre-trained network weights and initialize a new latent vector (Z).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># load pretrained ckpt</span>
<span class="n">param_dict</span> <span class="o">=</span> <span class="n">load_checkpoint</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;load_ckpt_path&quot;</span><span class="p">])</span>
<span class="n">loaded_ckpt_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">latent_vector_ckpt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;model.latent_vector&quot;</span><span class="p">:</span>
        <span class="n">latent_vector_ckpt</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="s2">&quot;network&quot;</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="s2">&quot;moment&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">loaded_ckpt_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

<span class="c1"># initialize the new latent vector</span>
<span class="n">num_scenarios</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;num_scenarios&quot;</span><span class="p">]</span>
<span class="n">latent_size</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;latent_vector_size&quot;</span><span class="p">]</span>
<span class="n">latent_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">latent_vector_ckpt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">latent_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_scenarios</span><span class="p">,</span> <span class="n">latent_size</span><span class="p">))</span>
<span class="n">latent_vector</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">latent_init</span><span class="p">,</span> <span class="n">ms_type</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># optimizer</span>
<span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;finetune_model&quot;</span><span class="p">):</span>
    <span class="n">model_params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">model_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;bias&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span>

<span class="n">params</span> <span class="o">=</span> <span class="n">model_params</span> <span class="o">+</span> <span class="n">mtl</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
<span class="n">lr_scheduler</span> <span class="o">=</span> <span class="n">MultiStepLR</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;milestones&quot;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;lr_gamma&quot;</span><span class="p">],</span>
                            <span class="n">steps_per_epoch</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;train_epoch&quot;</span><span class="p">])</span>
<span class="n">lr</span> <span class="o">=</span> <span class="n">lr_scheduler</span><span class="o">.</span><span class="n">get_lr</span><span class="p">()</span>
<span class="n">optim</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="n">Tensor</span><span class="p">(</span><span class="n">lr</span><span class="p">))</span>
</pre></div>
</div>
<p>In this tutorial, we select the <span class="math notranslate nohighlight">\(\textit{finetune_latent_with_model}\)</span> mode, namely, updating the latent vector and network weights simultaneously. The instantaneous electromagnetic fields compared with the reference labels are depicted in the following figure. Compared with solving a single PDE with the PINNs method, the PIAD method achieves a 10x speed-up at the same accuracy (6% relative error).</p>
<p><img alt="TE_for_Maxwell" src="../_images/piad_result.png" /></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="data_driven.html" class="btn btn-neutral float-right" title="Data Driven Deep Learning Method for Electromagnetic Simulation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="time_domain_maxwell.html" class="btn btn-neutral float-left" title="AI Method for Solving Point Source Maxwell’s Equations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, MindSpore.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>