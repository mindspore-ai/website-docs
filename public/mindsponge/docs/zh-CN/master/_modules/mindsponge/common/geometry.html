<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindsponge.common.geometry &mdash; MindSpore master 文档</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script><script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/js/theme.js"></script><script src="../../../_static/underscore.js"></script><script src="../../../_static/doctools.js"></script><script src="../../../_static/translations.js"></script><script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">分子模拟简介</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/physics_driven.html">物理驱动</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/data_driven.html">数据驱动</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/physics_plus_data_driven.html">融合驱动</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">使用者指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user/simulation.html">分子模拟</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/structure_prediction.html">分子结构预测</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/property_prediction.html">分子性质预测</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/design.html">分子设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/basic.html">分子基础模型</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mindsponge.cell.html">mindsponge.cell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindsponge.common.html">mindsponge.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindsponge.data_transform.html">mindsponge.data_transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindsponge.metrics.html">mindsponge.metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sponge.control.html">sponge.control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sponge.core.html">sponge.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sponge.function.html">sponge.function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sponge.optimizer.html">sponge.optimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sponge.potential.html">mindsponge.potential</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sponge.system.html">sponge.system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../constant.html">Constants</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">RELEASE NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../RELEASE.html">Release Notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">模块代码</a> &raquo;</li>
      <li>mindsponge.common.geometry</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>mindsponge.common.geometry 源代码</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021 The AIMM Group at Shenzhen Bay Laboratory &amp; Peking University &amp; Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>
<span class="sd">&quot;&quot;&quot;Geometry&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">mindspore.numpy</span> <span class="k">as</span> <span class="nn">mnp</span>
<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">mindspore.ops</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">P</span>

<span class="n">QUAT_MULTIPLY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">QUAT_MULTIPLY</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

<span class="n">QUAT_MULTIPLY</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">QUAT_MULTIPLY</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">QUAT_MULTIPLY</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">QUAT_MULTIPLY_BY_VEC</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">QUAT_MULTIPLY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>

<span class="n">QUAT_TO_ROT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>  <span class="c1"># rr</span>
<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># ii</span>
<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># jj</span>
<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>  <span class="c1"># kk</span>

<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># ij</span>
<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># ik</span>
<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># jk</span>

<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># ir</span>
<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># jr</span>
<span class="n">QUAT_TO_ROT</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># kr</span>

<span class="n">QUAT_TO_ROT</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">QUAT_TO_ROT</span><span class="p">)</span>


<div class="viewcode-block" id="vecs_scale"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_scale.html#mindsponge.common.vecs_scale">[文档]</a><span class="k">def</span> <span class="nf">vecs_scale</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale the vector.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;v=(x1,x2,x3) \\</span>
<span class="sd">        &amp;scaled\_{vecs} = (scale*x1,scale*x2,scale*x3) \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        v(Tuple):       Vector will be scaled, :math:`(x,y,z)`. x, y, z are scalars or Tensor with same shape.</span>
<span class="sd">        scale(float):   Value of scale.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple with length of 3, vector after scaled with the same shape as input v.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import vecs_scale</span>
<span class="sd">        &gt;&gt;&gt; x= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; y= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; z= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; scale=10</span>
<span class="sd">        &gt;&gt;&gt; result=vecs_scale((x,y,z),scale)</span>
<span class="sd">        &gt;&gt;&gt; print(len(result))</span>
<span class="sd">        &gt;&gt;&gt; print(result[0].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[1].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[2].shape)</span>
<span class="sd">        3</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scaled_vecs</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scaled_vecs</span></div>


<div class="viewcode-block" id="rots_scale"><a class="viewcode-back" href="../../../common/mindsponge.common.rots_scale.html#mindsponge.common.rots_scale">[文档]</a><span class="k">def</span> <span class="nf">rots_scale</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scaling of rotation matrixs.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;rot=(xx,xy,xz,yx,yy,yz,zx,zy,zz) \\</span>
<span class="sd">        &amp;scaled\_{rots} = (scale*xx,scale*xy,scale*xz,scale*yx,scale*yy,scale*yz,scale*zx,scale*zy,scale*zz)</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        rot(Tuple):     Rots, length is 9, :math:`(xx,xy,xz,yx,yy,yz,zx,zy,zz)` . Data type is scalar or</span>
<span class="sd">                        Tensor with the same shape.</span>
<span class="sd">        scale(float):   Value of scale.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, scaled rotation matrixs. Length is 9, shape is the same as the input rots&#39; shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import rots_scale</span>
<span class="sd">        &gt;&gt;&gt; x = Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; result = rots_scale((x, x, x, x, x, x, x, x, x),10)</span>
<span class="sd">        &gt;&gt;&gt; print(len(result))</span>
<span class="sd">        &gt;&gt;&gt; print(result[0].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[1].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[2].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[3].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[4].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[5].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[6].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[7].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[8].shape)</span>
<span class="sd">        3</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scaled_rots</span> <span class="o">=</span> <span class="p">(</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span>
                   <span class="n">rot</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">rot</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">rot</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span>
                   <span class="n">rot</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">rot</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">rot</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scaled_rots</span></div>


<div class="viewcode-block" id="vecs_sub"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_sub.html#mindsponge.common.vecs_sub">[文档]</a><span class="k">def</span> <span class="nf">vecs_sub</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subtract two vectors.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;v1=(x1,x2,x3) \\</span>
<span class="sd">        &amp;v2=(x1&#39;,x2&#39;,x3&#39;) \\</span>
<span class="sd">        &amp;result=(x1-x1&#39;,x2-x2&#39;,x3-x3&#39;) \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        v1(Tuple):  input vector 1 :math:`(x, y, z)`, data type is scalar or Tensor with same shape.</span>
<span class="sd">        v2(Tuple):  input vector 2 :math:`(x, y, z)`, data type is scalar or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple. Length is 3, :math:`(x&#39;, y&#39;, z&#39;)` , data type is scalar or Tensor with same shape as v1.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import vecs_sub</span>
<span class="sd">        &gt;&gt;&gt; x= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; y= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; z= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; result=vecs_sub((x,y,z),(x,y,z))</span>
<span class="sd">        &gt;&gt;&gt; print(len(result))</span>
<span class="sd">        &gt;&gt;&gt; print(result[0].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[1].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[2].shape)</span>
<span class="sd">        3</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="vecs_robust_norm"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_robust_norm.html#mindsponge.common.vecs_robust_norm">[文档]</a><span class="k">def</span> <span class="nf">vecs_robust_norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the l2-norm of a vector.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;v=(x1,x2,x3) \\</span>
<span class="sd">        &amp;l2\_norm=\sqrt{x1*x1+x2*x2+x3*x3+epsilon} \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        v(Tuple):       Input vector :math:`(x,y,z)` . Data type is scalar or Tensor with same shape.</span>
<span class="sd">        epsilon(float): A very small number to prevent the result from being 0. Default: 1e-8.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor, 2-Norm calculated by vector v. Shape is the same as v.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import vecs_robust_norm</span>
<span class="sd">        &gt;&gt;&gt; x= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; y= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; z= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; result=vecs_robust_norm((x,y,z))</span>
<span class="sd">        &gt;&gt;&gt; print(result.shape)</span>
<span class="sd">        (256)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_l2_norm</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">epsilon</span>
    <span class="n">v_norm</span> <span class="o">=</span> <span class="n">v_l2_norm</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="k">return</span> <span class="n">v_norm</span></div>


<div class="viewcode-block" id="vecs_robust_normalize"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_robust_normalize.html#mindsponge.common.vecs_robust_normalize">[文档]</a><span class="k">def</span> <span class="nf">vecs_robust_normalize</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use l2-norm normalization vectors</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;v=(x1,x2,x3) \\</span>
<span class="sd">        &amp;l2\_norm=\sqrt{x1*x1+x2*x2+x3*x3+epsilon} \\</span>
<span class="sd">        &amp;result=(x1/l2\_norm, x2/l2\_norm, x3/l2\_norm) \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        v(Tuple):       Input vector :math:`(x,y,z)` . Data type is scalar or Tensor with same shape.</span>
<span class="sd">        epsilon(float): Minimal value, prevent the result from being 0. Default: 1e-8.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple with length of 3, normalized 2-Norm calculated by vector v. Shape is the same as v.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import vecs_robust_normalize</span>
<span class="sd">        &gt;&gt;&gt; x= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; y= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; z= Tensor(np.ones(256), mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; result=vecs_robust_normalize((x,y,z))</span>
<span class="sd">        &gt;&gt;&gt; print(len(result))</span>
<span class="sd">        &gt;&gt;&gt; print(result[0].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[1].shape)</span>
<span class="sd">        &gt;&gt;&gt; print(result[2].shape)</span>
<span class="sd">            3</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">        (256,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="n">vecs_robust_norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">norms</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">norms</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">norms</span><span class="p">)</span></div>


<div class="viewcode-block" id="vecs_dot_vecs"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_dot_vecs.html#mindsponge.common.vecs_dot_vecs">[文档]</a><span class="k">def</span> <span class="nf">vecs_dot_vecs</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dot product of vectors :math:`v_1 = (x_1, x_2, x_3)` and :math:`v_2 = (y_1, y_2, y_3)`.</span>

<span class="sd">    .. math::</span>
<span class="sd">        res = x_1 * y_1 + x_2 * y_2 + x_3 * y_3</span>

<span class="sd">    Args:</span>
<span class="sd">        v1 (tuple): vectors :math:`\vec v_1` , length is 3.</span>
<span class="sd">                    Data type is constant or Tensor with same shape.</span>
<span class="sd">        v2 (tuple): vectors :math:`\vec v_2` , length is 3.</span>
<span class="sd">                    Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float or Tensor with the same shape as the Tensor in input, dot product result of two vectors .</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; v1 = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; v2 = (3, 4, 5)</span>
<span class="sd">        &gt;&gt;&gt; ans = mindsponge.common.vecs_dot_vecs(v1, v2)</span>
<span class="sd">        &gt;&gt;&gt; print(ans)</span>
<span class="sd">        26</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="vecs_cross_vecs"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_cross_vecs.html#mindsponge.common.vecs_cross_vecs">[文档]</a><span class="k">def</span> <span class="nf">vecs_cross_vecs</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cross product of vectors :math:`v_1 = (x_1, x_2, x_3)` and :math:`v_2 = (y_1, y_2, y_3)`.</span>

<span class="sd">    .. math::</span>
<span class="sd">        cross_{res} = (x_2 * y_3 - x_3 * y_2, x_3 * y_1 - x_1 * y_3, x_1 * y_2 - x_2 * y_1)</span>

<span class="sd">    Args:</span>
<span class="sd">        v1 (tuple): vectors :math:`\vec v_1` , length is 3.</span>
<span class="sd">                    Data type is constant or Tensor with same shape.</span>
<span class="sd">        v2 (tuple): vectors :math:`\vec v_2` , length is 3.</span>
<span class="sd">                    Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple, cross product result of two vectors, length is 3.</span>
<span class="sd">            Data type is constant or Tensor with same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; v1 = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; v2 = (3, 4, 5)</span>
<span class="sd">        &gt;&gt;&gt; ans = mindsponge.common.vecs_cross_vecs(v1, v2)</span>
<span class="sd">        &gt;&gt;&gt; print(ans)</span>
<span class="sd">        (-2, 4, -2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cross_res</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                 <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                 <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">cross_res</span></div>


<div class="viewcode-block" id="rots_from_two_vecs"><a class="viewcode-back" href="../../../common/mindsponge.common.rots_from_two_vecs.html#mindsponge.common.rots_from_two_vecs">[文档]</a><span class="k">def</span> <span class="nf">rots_from_two_vecs</span><span class="p">(</span><span class="n">e0_unnormalized</span><span class="p">,</span> <span class="n">e1_unnormalized</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Put in two vectors :math:`\vec a = (a_x, a_y, a_z)` and :math:`\vec b = (b_x, b_y, b_z)`.</span>
<span class="sd">    Calculate the rotation matrix between local coordinate system, in which the x-y plane</span>
<span class="sd">    consists of two input vectors and global coordinate system.</span>

<span class="sd">    Calculate the unit vector :math:`\vec e_0 = \frac{\vec a}{|\vec a|}`</span>
<span class="sd">    as the unit vector of x axis.</span>

<span class="sd">    Then calculate the projected length of :math:`\vec b` on a axis.</span>
<span class="sd">    :math:`c = |\vec b| \cos\theta = \vec b \cdot \frac{\vec a}{|\vec a|}` .</span>

<span class="sd">    So the projected vector of :math:`\vec b` on a axis is :math:`c\vec e_0`.</span>
<span class="sd">    The vector perpendicular to e0 is :math:`\vec e_1&#39; = \vec b - c\vec e_0` .</span>

<span class="sd">    The unit vector of :math:`\vec e_1&#39;` is :math:`\vec e_1 = \frac{\vec e_1&#39;}{|\vec e_1&#39;|}`,</span>
<span class="sd">    which is the y axis of the local coordinate system.</span>

<span class="sd">    Finally get the unit vector of z axis :math:`\vec e_2` by calculating cross product of</span>
<span class="sd">    :math:`\vec e_1` and :math:`\vec e_0`.</span>

<span class="sd">    The final rots is :math:`(e_{0x}, e_{1x}, e_{2x}, e_{0y}, e_{1y}, e_{2y}, e_{0z}, e_{1z}, e_{2z})`.</span>

<span class="sd">    Args:</span>
<span class="sd">        e0_unnormalized (tuple):    vectors :math:`\vec a` as x-axis of x-y plane,</span>
<span class="sd">                                    length is 3. Data type is constant or Tensor with same shape.</span>
<span class="sd">        e1_unnormalized (tuple):    vectors :math:`\vec b` forming x-y plane,</span>
<span class="sd">                                    length is 3. Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple, rotation matrix :math:`(e_{0x}, e_{1x}, e_{2x}, e_{0y}, e_{1y}, e_{2y}, e_{0z}, e_{1z}, e_{2z})` .</span>
<span class="sd">            Data type is constant or Tensor with same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; v1 = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; v2 = (3, 4, 5)</span>
<span class="sd">        &gt;&gt;&gt; ans = mindsponge.common.rots_from_two_vecs(v1, v2)</span>
<span class="sd">        &gt;&gt;&gt; print(ans)</span>
<span class="sd">        (0.4242640686695021, -0.808290367995452, 0.40824828617045156, 0.5656854248926695,</span>
<span class="sd">         -0.1154700520346678, -0.8164965723409039, 0.7071067811158369, 0.5773502639261153,</span>
<span class="sd">         0.4082482861704521)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Normalize the unit vector for the x-axis, e0.</span>
    <span class="n">e0</span> <span class="o">=</span> <span class="n">vecs_robust_normalize</span><span class="p">(</span><span class="n">e0_unnormalized</span><span class="p">)</span>

    <span class="c1"># make e1 perpendicular to e0.</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">vecs_dot_vecs</span><span class="p">(</span><span class="n">e1_unnormalized</span><span class="p">,</span> <span class="n">e0</span><span class="p">)</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">vecs_sub</span><span class="p">(</span><span class="n">e1_unnormalized</span><span class="p">,</span> <span class="n">vecs_scale</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">vecs_robust_normalize</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>

    <span class="c1"># Compute e2 as cross product of e0 and e1.</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">vecs_cross_vecs</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
    <span class="n">rots</span> <span class="o">=</span> <span class="p">(</span><span class="n">e0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">e0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">e2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">e0</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">rots</span></div>


<div class="viewcode-block" id="rigids_from_3_points"><a class="viewcode-back" href="../../../common/mindsponge.common.rigids_from_3_points.html#mindsponge.common.rigids_from_3_points">[文档]</a><span class="k">def</span> <span class="nf">rigids_from_3_points</span><span class="p">(</span><span class="n">point_on_neg_x_axis</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">point_on_xy_plane</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gram-Schmidt process. Create rigids representation of 3 points local coordination system,</span>
<span class="sd">    point on negative x axis A, origin point O and point on x-y plane P.</span>

<span class="sd">    First calculate the coordinations of vector :math:`\vec AO` and :math:`\vec OP`. Then</span>
<span class="sd">    use `rots_from_two_vecs` get the rotation matrix.</span>

<span class="sd">    Distance between origin point O and the origin point of global coordinate system is</span>
<span class="sd">    the translations of rigid.</span>

<span class="sd">    Finally return the rotations and translations of rigid.</span>

<span class="sd">    Reference:</span>
<span class="sd">        `Jumper et al. (2021) Suppl. Alg. 21 &#39;Gram-Schmidt process&#39;</span>
<span class="sd">        &lt;https://www.nature.com/articles/s41586-021-03819-2&gt;`_.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;\vec v_1 = \vec x_3 - \vec x_2 \\</span>
<span class="sd">        &amp;\vec v_2 = \vec x_1 - \vec x_2 \\</span>
<span class="sd">        &amp;\vec e_1 = \vec v_1 / ||\vec v_1|| \\</span>
<span class="sd">        &amp;\vec u_2 = \vec v_2 - \vec  e_1(\vec e_1^T\vec v_2) \\</span>
<span class="sd">        &amp;\vec e_2 = \vec u_2 / ||\vec u_2|| \\</span>
<span class="sd">        &amp;\vec e_3 = \vec e_1 \times \vec e_2 \\</span>
<span class="sd">        &amp;rotation = (\vec e_1, \vec e_2, \vec e_3) \\</span>
<span class="sd">        &amp;translation = (\vec x_2) \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        point_on_neg_x_axis (tuple):    point on negative x axis A, length is 3.</span>
<span class="sd">                                        Data type is constant or Tensor with same shape.</span>
<span class="sd">        origin (tuple):                 origin point O, length is 3.</span>
<span class="sd">                                        Data type is constant or Tensor with same shape.</span>
<span class="sd">        point_on_xy_plane (tuple):      point on x-y plane P, length is 3.</span>
<span class="sd">                                        Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple(rots, trans), rigid, length is 2. Include rots :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`</span>
<span class="sd">            and trans :math:`(x, y, z)` . Data type is constant or Tensor with same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; A = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; O = (4, 6, 8)</span>
<span class="sd">        &gt;&gt;&gt; P = (5, 8, 11)</span>
<span class="sd">        &gt;&gt;&gt; ans = mindsponge.common.rigids_from_3_points(A, O, P)</span>
<span class="sd">        &gt;&gt;&gt; print(ans)</span>
<span class="sd">        ((0.4242640686695021, -0.808290367995452, 0.40824828617045156, 0.5656854248926695,</span>
<span class="sd">         -0.1154700520346678, -0.8164965723409039, 0.7071067811158369, 0.5773502639261153,</span>
<span class="sd">         0.4082482861704521), (4,6,8))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">rots_from_two_vecs</span><span class="p">(</span>
        <span class="n">e0_unnormalized</span><span class="o">=</span><span class="n">vecs_sub</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">point_on_neg_x_axis</span><span class="p">),</span>
        <span class="n">e1_unnormalized</span><span class="o">=</span><span class="n">vecs_sub</span><span class="p">(</span><span class="n">point_on_xy_plane</span><span class="p">,</span> <span class="n">origin</span><span class="p">))</span>
    <span class="n">rigid</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rigid</span></div>


<div class="viewcode-block" id="invert_rots"><a class="viewcode-back" href="../../../common/mindsponge.common.invert_rots.html#mindsponge.common.invert_rots">[文档]</a><span class="k">def</span> <span class="nf">invert_rots</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes inverse of rotations :math:`m`.</span>

<span class="sd">    rotations :math:`m = (xx, xy, xz, yx, yy, yz, zx, zy, zz)` and</span>
<span class="sd">    inverse of :math:`m` is :math:`m^{T} = (xx, yx, zx, xy, yy, zy, xz, yz, zz)` .</span>

<span class="sd">    Args:</span>
<span class="sd">        m (tuple):  rotations :math:`m` , length is 9.</span>
<span class="sd">                    Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple, inverse of rotations :math:`m` , length is 9. Data type is constant or Tensor with same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; m = (1, 2, 3, 4, 5, 6, 7, 8, 9)</span>
<span class="sd">        &gt;&gt;&gt; inv_m = mindsponge.common.invert_rots(m)</span>
<span class="sd">        &gt;&gt;&gt; print(inv_m)</span>
<span class="sd">        (1, 4, 7, 2, 5, 8, 3, 6, 9)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
              <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
              <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">invert</span></div>


<div class="viewcode-block" id="rots_mul_vecs"><a class="viewcode-back" href="../../../common/mindsponge.common.rots_mul_vecs.html#mindsponge.common.rots_mul_vecs">[文档]</a><span class="k">def</span> <span class="nf">rots_mul_vecs</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply rotations :math:`\vec m = (m_0, m_1, m_2, m_3, m_4, m_5, m_6, m_7, m_8)`</span>
<span class="sd">    to vectors :math:`\vec v = (v_0, v_1, v_2)`.</span>

<span class="sd">    .. math::</span>
<span class="sd">        out = m \cdot v^T = (m_0 \times v_0 + m_1 \times v_1 + m_2 \times v_2,</span>
<span class="sd">                             m_3 \times v_0 + m_4 \times v_1 + m_5 \times v_2,</span>
<span class="sd">                             m_6 \times v_0 + m_7 \times v_1 + m_8 \times v_2)</span>

<span class="sd">    Args:</span>
<span class="sd">        m (tuple):  rotations :math:`\vec m` , length is 9.</span>
<span class="sd">                    Data type is constant or Tensor with same shape.</span>
<span class="sd">        v (tuple):  vectors :math:`\vec v` , length is 3.</span>
<span class="sd">                    Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple, vectors after rotations.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; m = (1, 2, 3, 4, 5, 6, 7, 8, 9)</span>
<span class="sd">        &gt;&gt;&gt; v = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; v1 = mindsponge.common.rots_mul_vecs(m, v)</span>
<span class="sd">        &gt;&gt;&gt; print(v1)</span>
<span class="sd">        (14, 32, 50)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
           <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
           <span class="n">m</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="invert_rigids"><a class="viewcode-back" href="../../../common/mindsponge.common.invert_rigids.html#mindsponge.common.invert_rigids">[文档]</a><span class="k">def</span> <span class="nf">invert_rigids</span><span class="p">(</span><span class="n">rigids</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes group inverse of rigid transformations. Change rigid from</span>
<span class="sd">    local coordinate system to global coordinate system.</span>

<span class="sd">    Use `invert_rots` to calculate the invert rotations of rigid. Then use</span>
<span class="sd">    `rots_mul_vecs` to rotate the translations of rigid. The opposite of the</span>
<span class="sd">    result is the translations of invert rigid.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;inv\_rots = r_r^T = (r_0, r_3, r_6, r_1, r_4, r_7, r_2, r_5, r_8) \\</span>
<span class="sd">        &amp;inv\_trans = -r_r^T \cdot r_t^T = (- (r_0 \times t_0 + r_3 \times t_0 + r_6 \times t_0),</span>
<span class="sd">                                           - (r_1 \times t_1 + r_4 \times t_1 + r_7 \times t_1),</span>
<span class="sd">                                           - (r_2 \times t_2 + r_5 \times t_2 + r_8 \times t_2)) \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        rigids (tuple): rigids, including the rots and trans changing rigids</span>
<span class="sd">                        from global coordinate system to local coordinate system.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple(rots, trans), group inverse of rigid transformations, length is 2. Include rots</span>
<span class="sd">            :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)` and trans :math:`(x, y, z)` .</span>
<span class="sd">            Data type is constant or Tensor with same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; a = ((1, 2, 3, 4, 5, 6, 7, 8, 9), (3, 4, 5))</span>
<span class="sd">        &gt;&gt;&gt; inv_a = mindsponge.common.invert_rigids(a)</span>
<span class="sd">        &gt;&gt;&gt; print(inv_a)</span>
<span class="sd">        ((1, 4, 7, 2, 5, 8, 3, 6, 9), (-54.0, -66.0, -78.0))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot</span><span class="p">,</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">rigids</span>
    <span class="n">inv_rots</span> <span class="o">=</span> <span class="n">invert_rots</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">inv_rots</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
    <span class="n">inv_trans</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">inv_rigids</span> <span class="o">=</span> <span class="p">(</span><span class="n">inv_rots</span><span class="p">,</span> <span class="n">inv_trans</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inv_rigids</span></div>


<span class="k">def</span> <span class="nf">vecs_add</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add two vectors &#39;v1&#39; and &#39;v2&#39;.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<div class="viewcode-block" id="rigids_mul_vecs"><a class="viewcode-back" href="../../../common/mindsponge.common.rigids_mul_vecs.html#mindsponge.common.rigids_mul_vecs">[文档]</a><span class="k">def</span> <span class="nf">rigids_mul_vecs</span><span class="p">(</span><span class="n">rigids</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform vector :math:`\vec v` to rigid&#39; local coordinate system.</span>

<span class="sd">    Multiply vector :math:`\vec v` and the rotations of rigid together</span>
<span class="sd">    and add the translations of rigid. The result is the output vector.</span>

<span class="sd">    .. math::</span>
<span class="sd">        v = r_rv+r_t</span>

<span class="sd">    Args:</span>
<span class="sd">        rigids (tuple): rigid.</span>
<span class="sd">        v (tuple):      vector :math:`\vec v` , length is 3. Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple, changed vector, length is 3. Data type is constant or Tensor with same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; a = ((1, 2, 3, 4, 5, 6, 7, 8, 9), (3, 4, 5))</span>
<span class="sd">        &gt;&gt;&gt; b = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; b1 = mindsponge.common.rigids_mul_vecs(a,b)</span>
<span class="sd">        &gt;&gt;&gt; print(b1)</span>
<span class="sd">        (17, 36, 55)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vecs_add</span><span class="p">(</span><span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">rigids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">),</span> <span class="n">rigids</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="rigids_mul_rots"><a class="viewcode-back" href="../../../common/mindsponge.common.rigids_mul_rots.html#mindsponge.common.rigids_mul_rots">[文档]</a><span class="k">def</span> <span class="nf">rigids_mul_rots</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpy version of getting results rigid :math:`x` multiply rotations :math:`\vec y` .</span>

<span class="sd">    Multiply rotations of rigid :math:`x[0]` with rotations :math:`\vec y`,</span>
<span class="sd">    the result is rigids new rotations. Translations of rigid will not changed.</span>

<span class="sd">    .. math::</span>
<span class="sd">        (r, t) = (x_ry, x_t)</span>

<span class="sd">    Args:</span>
<span class="sd">        x (tuple):  rigid :math:`x` . Length is 2. Include rots :math:`x_r = (xx, xy, xz, yx, yy, yz, zx, zy, zz)`</span>
<span class="sd">                    and trans :math:`x_t = (x, y, z)` . Data type is constant or Tensor with same shape.</span>
<span class="sd">        y (tuple):  rotations :math:`\vec y` , length is 9. Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple(rots, trans), length is 2, rigid whose rotations are changed.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; a = ((1, 2, 3, 4, 5, 6, 7, 8, 9), (3, 4, 5))</span>
<span class="sd">        &gt;&gt;&gt; b = (2, 3, 4, 1, 5, 6, 3, 8, 7)</span>
<span class="sd">        &gt;&gt;&gt; b1 = mindsponge.common.rigids_mul_rots(a,b)</span>
<span class="sd">        &gt;&gt;&gt; print(b1)</span>
<span class="sd">        ((13, 37, 37, 31, 85, 88, 49, 133, 139), (3, 4, 5))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rigids</span> <span class="o">=</span> <span class="p">(</span><span class="n">rots_mul_rots</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">rigids</span></div>


<div class="viewcode-block" id="rigids_mul_rigids"><a class="viewcode-back" href="../../../common/mindsponge.common.rigids_mul_rigids.html#mindsponge.common.rigids_mul_rigids">[文档]</a><span class="k">def</span> <span class="nf">rigids_mul_rigids</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change rigid :math:`b` from its local coordinate system to rigid :math:`a`</span>
<span class="sd">    local coordinate system, using rigid rotations and translations.</span>

<span class="sd">    Use the rotations calculated by multiplying rotations of rigid :math:`b`</span>
<span class="sd">    and rigid :math:`a` as new rotations of rigid :math:`b` .</span>

<span class="sd">    Multiply the translations of rigid :math:`b` with rotations of rigid :math:`a` ,</span>
<span class="sd">    then add translations of rigid :math:`a` . The translations got is new translations</span>
<span class="sd">    of rigid :math:`b`.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;r = a_rb_r \\</span>
<span class="sd">        &amp;t = a_rb_t +a_t \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        a (tuple):  rigid :math:`a` . Length is 2. Include rots :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`</span>
<span class="sd">                    and trans :math:`(x, y, z)` . Data type is constant or Tensor with same shape.</span>
<span class="sd">        b (tuple):  rigid :math:`b` . Length is 2. Include rots :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`</span>
<span class="sd">                    and trans :math:`(x, y, z)` . Data type is constant or Tensor with same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple(rots, trans), rigid :math:`b` changed. Length is 2.</span>
<span class="sd">            Include rots :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`</span>
<span class="sd">            and trans :math:`(x, y, z)` . Data type is constant or Tensor with same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import mindsponge</span>
<span class="sd">        &gt;&gt;&gt; a = ((1, 2, 3, 4, 5, 6, 7, 8, 9), (3, 4, 5))</span>
<span class="sd">        &gt;&gt;&gt; b = ((2, 3, 4, 1, 5, 6, 3, 8, 7), (1, 2, 3))</span>
<span class="sd">        &gt;&gt;&gt; b1 = mindsponge.common.rigids_mul_rigids(a,b)</span>
<span class="sd">        &gt;&gt;&gt; print(b1)</span>
<span class="sd">        ((13, 37, 37, 31, 85, 88, 49, 133, 139), (17, 36, 55))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">rots_mul_rots</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">vecs_add</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span></div>


<div class="viewcode-block" id="rots_mul_rots"><a class="viewcode-back" href="../../../common/mindsponge.common.rots_mul_rots.html#mindsponge.common.rots_mul_rots">[文档]</a><span class="k">def</span> <span class="nf">rots_mul_rots</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get result of rotation matrix x multiply rotation matrix y.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;xx = xx1*xx2 + xy1*yx2 + xz1*zx2 \\</span>
<span class="sd">        &amp;xy = xx1*xy2 + xy1*yy2 + xz1*zy2 \\</span>
<span class="sd">        &amp;xz = xx1*xz2 + xy1*yz2 + xz1*zz2 \\</span>
<span class="sd">        &amp;yx = yx1*xx2 + yy1*yx2 + yz1*zx2 \\</span>
<span class="sd">        &amp;yy = yx1*xy2 + yy1*yy2 + yz1*zy2 \\</span>
<span class="sd">        &amp;yz = yx1*xz2 + yy1*yz2 + yz1*zz2 \\</span>
<span class="sd">        &amp;zx = zx1*xx2 + zy1*yx2 + zz1*zx2 \\</span>
<span class="sd">        &amp;zy = zx1*xy2 + zy1*yy2 + zz1*zy2 \\</span>
<span class="sd">        &amp;zz = zx1*xz2 + zy1*yz2 + zz1*zz2 \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        x(tuple):   rots x, :math:`(xx1, xy1, xz1, yx1, yy1, yz1, zx1, zy1, zz1)`.</span>
<span class="sd">        y(tuple):   rots y, :math:`(xx2, xy2, xz2, yx2, yy2, yz2, zx2, zy2, zz2)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple, the result of rots x multiplying rots y. The result is :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import rots_mul_rots</span>
<span class="sd">        &gt;&gt;&gt; rtos_0 = (1, 1, 1, 1, 1, 1, 1)</span>
<span class="sd">        &gt;&gt;&gt; rtos_1 = (1, 1, 1, 1, 1, 1, 1)</span>
<span class="sd">        &gt;&gt;&gt; result = rots_mul_rots(rots_0, rots_1)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        (3, 3, 3, 3, 3, 3, 3, 3, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vecs0</span> <span class="o">=</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span>
    <span class="n">vecs1</span> <span class="o">=</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span>
    <span class="n">vecs2</span> <span class="o">=</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span>
    <span class="n">rots</span> <span class="o">=</span> <span class="p">(</span><span class="n">vecs0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vecs1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vecs2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vecs0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vecs1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vecs2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vecs0</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vecs1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vecs2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">rots</span></div>


<div class="viewcode-block" id="vecs_from_tensor"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_from_tensor.html#mindsponge.common.vecs_from_tensor">[文档]</a><span class="k">def</span> <span class="nf">vecs_from_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get vectors from the last axis of input tensor.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs(Tensor): Atom position information. Shape is :math:`(..., 3)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple :math:`(x, y, z)` with three tensors,</span>
<span class="sd">        including the coordinate information of x, y and z.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import vecs_from_tensor</span>
<span class="sd">        &gt;&gt;&gt; input_0 = Tensor(np.ones((4, 256, 3)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; output = vecs_from_tensor(input_0)</span>
<span class="sd">        &gt;&gt;&gt; print(len(output), output[0].shape)</span>
<span class="sd">        3, (4,256)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_components</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">num_components</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="vecs_to_tensor"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_to_tensor.html#mindsponge.common.vecs_to_tensor">[文档]</a><span class="k">def</span> <span class="nf">vecs_to_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts &#39;v&#39; to tensor with last dim shape 3, inverse of &#39;vecs_from_tensor&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        v(tuple):   Input tuple v :math:`(x, y, z)` with three tensors, including</span>
<span class="sd">                    the coordinate information of x, y and z.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tensor, concat the tensor in last dims, shape :math:`(..., 3)` .</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import vecs_to_tensor</span>
<span class="sd">        &gt;&gt;&gt; input_0 = Tensor(np.ones((4, 256)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; input_1 = Tensor(np.ones((4, 256)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; input_2 = Tensor(np.ones((4, 256)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; inputs = (input_0, input_1, input_2)</span>
<span class="sd">        &gt;&gt;&gt; output = vecs_to_tensor(inputs)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (4, 256, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mnp</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="make_transform_from_reference"><a class="viewcode-back" href="../../../common/mindsponge.common.make_transform_from_reference.html#mindsponge.common.make_transform_from_reference">[文档]</a><span class="k">def</span> <span class="nf">make_transform_from_reference</span><span class="p">(</span><span class="n">point_a</span><span class="p">,</span> <span class="n">point_b</span><span class="p">,</span> <span class="n">point_c</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Using GramSchmidt process to construct rotation and translation from given points.</span>

<span class="sd">    Calculate the rotation matrix and translation meets</span>

<span class="sd">    a) point_b is the original point.</span>

<span class="sd">    b) point_c is on the x_axis.</span>

<span class="sd">    c) the plane a-b-c is on the x-y plane.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;\vec v_1 = \vec x_3 - \vec x_2 \\</span>
<span class="sd">        &amp;\vec v_2 = \vec x_1 - \vec x_2 \\</span>
<span class="sd">        &amp;\vec e_1 = \vec v_1 / ||\vec v_1|| \\</span>
<span class="sd">        &amp;\vec u_2 = \vec v_2 - \vec  e_1(\vec e_1^T\vec v_2) \\</span>
<span class="sd">        &amp;\vec e_2 = \vec u_2 / ||\vec u_2|| \\</span>
<span class="sd">        &amp;\vec e_3 = \vec e_1 \times \vec e_2 \\</span>
<span class="sd">        &amp;rotation = (\vec e_1, \vec e_2, \vec e_3) \\</span>
<span class="sd">        &amp;translation = (\vec x_2) \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        point_a(float, tensor) -&gt; (tensor): Spatial location information of atom &#39;N&#39;,</span>
<span class="sd">                                            shape is :math:`[..., N_{res}, 3]` .</span>
<span class="sd">        point_b(float, tensor) -&gt; (tensor): Spatial location information of atom &#39;CA&#39;,</span>
<span class="sd">                                            shape is :math:`[..., N_{res}, 3]` .</span>
<span class="sd">        point_c(float, tensor) -&gt; (tensor): Spatial location information of atom &#39;C&#39;,</span>
<span class="sd">                                            shape is :math:`[..., N_{res}, 3]` .</span>

<span class="sd">    Returns:</span>
<span class="sd">        - Tuple, rots :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)` ,</span>
<span class="sd">          the shape of every element is :math:`(..., N_{res})` .</span>
<span class="sd">        - Tuple, trans :math:`(x, y, z)` , the shape of every element is :math:`(..., N_{res})` .</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import make_transform_from_reference</span>
<span class="sd">        &gt;&gt;&gt; input_0 = Tensor(np.ones((4, 256, 3)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; input_1 = Tensor(np.ones((4, 256, 3)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; input_2 = Tensor(np.ones((4, 256, 3)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; rots, trans = make_transform_from_reference(input_0, input_1, input_2)</span>
<span class="sd">        &gt;&gt;&gt; print(len(rots), rots[0].shape, len(trans), trans[0].shape)</span>
<span class="sd">        9, (4, 256), 3, (4, 256)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># step 1 : shift the crd system by -point_b (point_b is the origin)</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="o">-</span><span class="n">point_b</span>
    <span class="n">point_c</span> <span class="o">=</span> <span class="n">point_c</span> <span class="o">+</span> <span class="n">translation</span>
    <span class="n">point_a</span> <span class="o">=</span> <span class="n">point_a</span> <span class="o">+</span> <span class="n">translation</span>
    <span class="c1"># step 2: rotate the crd system around z-axis to put point_c on x-z plane</span>
    <span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span><span class="p">,</span> <span class="n">c_z</span> <span class="o">=</span> <span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">point_c</span><span class="p">)</span>
    <span class="n">sin_c1</span> <span class="o">=</span> <span class="o">-</span><span class="n">c_y</span> <span class="o">/</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-20</span> <span class="o">+</span> <span class="n">c_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cos_c1</span> <span class="o">=</span> <span class="n">c_x</span> <span class="o">/</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-20</span> <span class="o">+</span> <span class="n">c_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">zeros</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sin_c1</span><span class="p">)</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">sin_c1</span><span class="p">)</span>
    <span class="n">c1_rot_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_c1</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_c1</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span>
                     <span class="n">sin_c1</span><span class="p">,</span> <span class="n">cos_c1</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span>
                     <span class="n">zeros</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">ones</span><span class="p">)</span>
    <span class="c1"># step 2 : rotate the crd system around y_axis to put point_c on x-axis</span>
    <span class="n">sin_c2</span> <span class="o">=</span> <span class="n">c_z</span> <span class="o">/</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-20</span> <span class="o">+</span> <span class="n">c_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c_y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c_z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cos_c2</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-20</span> <span class="o">+</span> <span class="n">c_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c_y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c_z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">c2_rot_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_c2</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">sin_c2</span><span class="p">,</span>
                     <span class="n">zeros</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span>
                     <span class="o">-</span><span class="n">sin_c2</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">cos_c2</span><span class="p">)</span>
    <span class="n">c_rot_matrix</span> <span class="o">=</span> <span class="n">rots_mul_rots</span><span class="p">(</span><span class="n">c2_rot_matrix</span><span class="p">,</span> <span class="n">c1_rot_matrix</span><span class="p">)</span>
    <span class="c1"># step 3: rotate the crd system in y-z plane to put point_a in x-y plane</span>
    <span class="n">vec_a</span> <span class="o">=</span> <span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">point_a</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">rotated_a_y</span><span class="p">,</span> <span class="n">rotated_a_z</span> <span class="o">=</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">c_rot_matrix</span><span class="p">,</span> <span class="n">vec_a</span><span class="p">)</span>

    <span class="n">sin_n</span> <span class="o">=</span> <span class="o">-</span><span class="n">rotated_a_z</span> <span class="o">/</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-20</span> <span class="o">+</span> <span class="n">rotated_a_y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rotated_a_z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cos_n</span> <span class="o">=</span> <span class="n">rotated_a_y</span> <span class="o">/</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-20</span> <span class="o">+</span> <span class="n">rotated_a_y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rotated_a_z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">a_rot_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span>
                    <span class="n">zeros</span><span class="p">,</span> <span class="n">cos_n</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_n</span><span class="p">,</span>
                    <span class="n">zeros</span><span class="p">,</span> <span class="n">sin_n</span><span class="p">,</span> <span class="n">cos_n</span><span class="p">)</span>
    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">rots_mul_rots</span><span class="p">(</span><span class="n">a_rot_matrix</span><span class="p">,</span> <span class="n">c_rot_matrix</span><span class="p">)</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="n">point_b</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">translation</span></div>


<div class="viewcode-block" id="rots_from_tensor"><a class="viewcode-back" href="../../../common/mindsponge.common.rots_from_tensor.html#mindsponge.common.rots_from_tensor">[文档]</a><span class="k">def</span> <span class="nf">rots_from_tensor</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Amortize and split the 3*3 rotation matrix corresponding to the last two axes of input Tensor</span>
<span class="sd">      to obtain each component of the rotation matrix, inverse of &#39;rots_to_tensor&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        rots(Tensor):       Represent the rotation matrix, shape is :math:`(..., 3, 3)` .</span>
<span class="sd">        use_numpy(bool):    Whether to use numpy to calculate. Default: ``False``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, rots represented by vectors, rots is :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import rots_from_tensor</span>
<span class="sd">        &gt;&gt;&gt; input_0 = Tensor(np.ones((256, 3, 3)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; output = rots_from_tensor(input_0)</span>
<span class="sd">        &gt;&gt;&gt; print(len(output), output[0].shape)</span>
<span class="sd">        9, (256,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_numpy</span><span class="p">:</span>
        <span class="n">rots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">rots</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">9</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rots</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Reshape</span><span class="p">()(</span><span class="n">rots</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">Shape</span><span class="p">()(</span><span class="n">rots</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">9</span><span class="p">,))</span>
    <span class="n">rotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                <span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">rots</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">rotation</span></div>


<div class="viewcode-block" id="rots_to_tensor"><a class="viewcode-back" href="../../../common/mindsponge.common.rots_to_tensor.html#mindsponge.common.rots_to_tensor">[文档]</a><span class="k">def</span> <span class="nf">rots_to_tensor</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate rots represented by vectors to tensor, inverse of &#39;rots_from_tensor&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        rots(Tuple):        Rots represented by vectors, shape is :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)` .</span>
<span class="sd">        use_numpy(bool):    Whether to use numpy to calculate. Default: ``False``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor, concat the tensor in last dims, shape :math:`(N_{res}, 3, 3)`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import rots_to_tensor</span>
<span class="sd">        &gt;&gt;&gt; inputs = [Tensor(np.ones((256,)), ms.float32) for i in range(9)]</span>
<span class="sd">        &gt;&gt;&gt; output = rots_to_tensor(inputs)</span>
<span class="sd">        &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">        (256, 3, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rots</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">9</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">use_numpy</span><span class="p">:</span>
        <span class="n">rots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">rots</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rots</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rots</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">rots</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rots</span></div>


<div class="viewcode-block" id="quat_affine"><a class="viewcode-back" href="../../../common/mindsponge.common.quat_affine.html#mindsponge.common.quat_affine">[文档]</a><span class="k">def</span> <span class="nf">quat_affine</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unstack_inputs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create quat affine representations based on rots and trans.</span>

<span class="sd">    Args:</span>
<span class="sd">        quaternion(tensor):     Shape is :math:`(N_{res}, 4)`.</span>
<span class="sd">        translation(tensor):    Shape is :math:`(N_{res}, 3)`.</span>
<span class="sd">        rotation(tensor):       Rots, shape is :math:`(N_{res}, 9)`. Default: ``None``.</span>
<span class="sd">        normalize(bool):        Whether to use normalization. Default: ``True``.</span>
<span class="sd">        unstack_inputs(bool):   Whether input is vector(True) of Tensor(False). Default: ``False``.</span>
<span class="sd">        use_numpy(bool):        Whether to use numpy. Default: ``False``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        result after quat affine.</span>

<span class="sd">        - quaternion, tensor, shape is :math:`(N_{res}, 4)` .</span>
<span class="sd">        - rotation, tuple, :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`,</span>
<span class="sd">          shape of every element is :math:`(N_{res},)` .</span>
<span class="sd">        - translation, tensor, shape is :math:`(N_{res}, 3)` .</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import quat_affine</span>
<span class="sd">        &gt;&gt;&gt; input_0 = Tensor(np.ones((256, 4)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; input_1 = Tensor(np.ones((256, 3)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; qua, rot, trans = quat_affine(input_0, input_1)</span>
<span class="sd">        &gt;&gt;&gt; print(qua.shape, len(rot), rot[0].shape, trans.shape)</span>
<span class="sd">        (256, 4), 9, (256,), (256, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">unstack_inputs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">rots_from_tensor</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">use_numpy</span><span class="p">)</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize</span> <span class="ow">and</span> <span class="n">quaternion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">quaternion</span> <span class="o">=</span> <span class="n">quaternion</span> <span class="o">/</span> <span class="n">mnp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">quat_to_rot</span><span class="p">(</span><span class="n">quaternion</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quaternion</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span></div>


<div class="viewcode-block" id="quat_to_rot"><a class="viewcode-back" href="../../../common/mindsponge.common.quat_to_rot.html#mindsponge.common.quat_to_rot">[文档]</a><span class="k">def</span> <span class="nf">quat_to_rot</span><span class="p">(</span><span class="n">normalized_quat</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a normalized quaternion to a rotation matrix.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;xx = 1 - 2 * y * y - 2 * z * z \\</span>
<span class="sd">        &amp;xy = 2 * x * y + 2 * w * z \\</span>
<span class="sd">        &amp;xz = 2 * x * z - 2 * w * y \\</span>
<span class="sd">        &amp;yx = 2 * x * y - 2 * w * z \\</span>
<span class="sd">        &amp;yy = 1 - 2 * x * x - 2 * z * z \\</span>
<span class="sd">        &amp;yz = 2 * z * y + 2 * w * x \\</span>
<span class="sd">        &amp;zx = 2 * x * z + 2 * w * y \\</span>
<span class="sd">        &amp;zy = 2 * y * z - 2 * w * x \\</span>
<span class="sd">        &amp;zz = 1 - 2 * x * x - 2 * y * y \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        normalized_quat (tensor): normalized quaternion, shape :math:`(N_{res}, 4)`.</span>
<span class="sd">        use_numpy (bool): use numpy or not, Default: &quot;False&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple, rotation :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`, every element shape :math:`(N_{res}, )`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import quat_to_rot</span>
<span class="sd">        &gt;&gt;&gt; input_0 = Tensor(np.ones((256, 4)), ms.float32)</span>
<span class="sd">        &gt;&gt;&gt; output = quat_to_rot(input_0)</span>
<span class="sd">        &gt;&gt;&gt; print(len(output), output[0].shape)</span>
<span class="sd">        9, (256,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_numpy</span><span class="p">:</span>
        <span class="n">rot_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">QUAT_TO_ROT</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="o">*</span> <span class="n">normalized_quat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> \
                            <span class="o">*</span> <span class="n">normalized_quat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">rot_tensor</span> <span class="o">=</span> <span class="n">rots_from_tensor</span><span class="p">(</span><span class="n">rot_tensor</span><span class="p">,</span> <span class="n">use_numpy</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rot_tensor</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">QUAT_TO_ROT</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="o">*</span> <span class="n">normalized_quat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
                             <span class="n">normalized_quat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">rot_tensor</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)(</span><span class="n">rot_tensor</span><span class="p">)</span>
        <span class="n">rot_tensor</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                      <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
                      <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">6</span><span class="p">]),</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">7</span><span class="p">]),</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">rot_tensor</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">rot_tensor</span></div>


<div class="viewcode-block" id="initial_affine"><a class="viewcode-back" href="../../../common/mindsponge.common.initial_affine.html#mindsponge.common.initial_affine">[文档]</a><span class="k">def</span> <span class="nf">initial_affine</span><span class="p">(</span><span class="n">num_residues</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize quaternion, rotation, translation of affine.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_residues(int):  Number of residues.</span>
<span class="sd">        use_numpy(bool):    Whether to use numpy. Default: ``False``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        result after quat affine.</span>
<span class="sd">        - quaternion, tensor, shape is :math:`(N_{res}, 4)` .</span>
<span class="sd">        - rotation, tuple, :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`, shape of every element is :math:`(N_{res}, )` .</span>
<span class="sd">        - translation, tuple, :math:`(x, y, z)` shape of every element tensor is :math:`(N_{res}, )` .</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import mindspore as ms</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import initial_affine</span>
<span class="sd">        &gt;&gt;&gt; output = initial_affine(256)</span>
<span class="sd">        &gt;&gt;&gt; print(len(output), output[0].shape, len(output[1]), len(output[1][0]), len(output[2]), len(output[2][0]))</span>
<span class="sd">        &gt;&gt;&gt; print(output[0])</span>
<span class="sd">        &gt;&gt;&gt; print(output[1])</span>
<span class="sd">        &gt;&gt;&gt; print(output[2])</span>
<span class="sd">        3, (1, 4), 9, 1, 3, 1</span>
<span class="sd">        [[1.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00]]</span>
<span class="sd">        (1, 0, 0, 0, 1, 0, 0, 0, 1)</span>
<span class="sd">        ([0.00000000e+00], [0.00000000e+00], [0.00000000e+00])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_numpy</span><span class="p">:</span>
        <span class="n">quaternion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="n">num_residues</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_residues</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quaternion</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="n">num_residues</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_residues</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">quat_affine</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">unstack_inputs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="n">use_numpy</span><span class="p">)</span></div>


<div class="viewcode-block" id="vecs_expand_dims"><a class="viewcode-back" href="../../../common/mindsponge.common.vecs_expand_dims.html#mindsponge.common.vecs_expand_dims">[文档]</a><span class="k">def</span> <span class="nf">vecs_expand_dims</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add an extra dimension to the input `v` at the given axis.</span>

<span class="sd">    Args:</span>
<span class="sd">        v(Tuple):   Input vector. Length is 3, :math:`(xx, xy, xz)` .</span>
<span class="sd">        axis(int):  Specifies the dimension index at which to expand the shape of `v`. Only constant value is allowed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, if the axis is 0, and the shape of :math:`xx` is :math:`(..., X_R)`, where X_R is any number.</span>
<span class="sd">          The expanded shape is :math:`(1, ..., X_R)`. If the axis is other value, then expand in the other</span>
<span class="sd">          direction. And return expanded :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)` .</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import vecs_expand_dims</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; v = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; axis = 0</span>
<span class="sd">        &gt;&gt;&gt; output= vecs_expand_dims(v, axis)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        (Tensor(shape=[1], dtype=Int64, value=[1]),Tensor(shape=[1], dtype=Int64, value=[2]),</span>
<span class="sd">         Tensor(shape=[1], dtype=Int64, value=[3]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">v</span></div>


<div class="viewcode-block" id="rots_expand_dims"><a class="viewcode-back" href="../../../common/mindsponge.common.rots_expand_dims.html#mindsponge.common.rots_expand_dims">[文档]</a><span class="k">def</span> <span class="nf">rots_expand_dims</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds an additional dimension to `rots` at the given axis.</span>

<span class="sd">    Args:</span>
<span class="sd">        rots (Tuple):   The rotation matrix is :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`,</span>
<span class="sd">                        and xx and xy have the same shape</span>
<span class="sd">        axis (Int):     Specifies the dimension index at which to expand the shape of v.</span>
<span class="sd">                        Only constant value is allowed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, rots. If the value of axis is 0, and the shape of xx is :math:`(..., X_R)`,</span>
<span class="sd">          where :math:`X_R` is any number, and the expanded shape is :math:`(1, ..., X_R)`.</span>
<span class="sd">          Return expanded :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import rots_expand_dims</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; rots = (1, 2, 3, 4, 5, 6, 7, 8, 9)</span>
<span class="sd">        &gt;&gt;&gt; axis = 0</span>
<span class="sd">        &gt;&gt;&gt; rots_expand_dims(rots, axis)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        (Tensor(shape=[1], dtype=Int64, value=[1]), Tensor(shape=[1], dtype=Int64, value=[2]),</span>
<span class="sd">        Tensor(shape=[1], dtype=Int64, value=[3]), Tensor(shape=[1], dtype=Int64, value=[4]),</span>
<span class="sd">        Tensor(shape=[1], dtype=Int64, value=[5]), Tensor(shape=[1], dtype=Int64, value=[6]),</span>
<span class="sd">        Tensor(shape=[1], dtype=Int64, value=[7]), Tensor(shape=[1], dtype=Int64, value=[8]),</span>
<span class="sd">        Tensor(shape=[1], dtype=Int64, value=[9]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rots</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span>
            <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span>
            <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">axis</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">rots</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">axis</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rots</span></div>


<div class="viewcode-block" id="invert_point"><a class="viewcode-back" href="../../../common/mindsponge.common.invert_point.html#mindsponge.common.invert_point">[文档]</a><span class="k">def</span> <span class="nf">invert_point</span><span class="p">(</span><span class="n">transformed_point</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">extra_dims</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The inverse transformation of a rigid body group transformation with respect to a point coordinate,</span>
<span class="sd">    that is, the inverse transformation of apply to point Make rotational translation changes on coordinates</span>
<span class="sd">    with the transpose of the rotation</span>
<span class="sd">    matrix :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)` and the translation vector :math:`(x, y, z)` translation.</span>

<span class="sd">    First, the initial coordinates are translated, and then the transpose of the rotation matrix is multiplied</span>
<span class="sd">    by rot_point to get the final coordinates.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;rot\_point = transformed\_point - translation \\</span>
<span class="sd">        &amp;result = rotation^T * rot\_point \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    The specific procedures of vector subtraction, transpose and multiplication can be referred to the</span>
<span class="sd">    api of vecs_sub, invert_rots, rots_mul_vecs etc.</span>

<span class="sd">    Args:</span>
<span class="sd">        transformed_point (Tuple):  The initial coordinates of the input have shape :math:`(x, y, z)`,</span>
<span class="sd">                                    where x, y and z are Tensor and have the same shape.</span>
<span class="sd">        rotation (Tuple):           The rotation matrix. shape is :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`,</span>
<span class="sd">                                    and xx and xy have the same shape.</span>
<span class="sd">        translation (Tuple):        The translation vector shape is :math:`(x, y, z)`,</span>
<span class="sd">                                    where x, y and z are Tensor and have the same shape.</span>
<span class="sd">        extra_dims (int):           Control whether to expand dims. Default: 0.</span>
<span class="sd">        stack (bool):               Control whether to transform to tuple. Default: ``False``.</span>
<span class="sd">        use_numpy(bool):            Control whether to use numpy. Default: ``False``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, the transformed coordinate of invert point.Length is 3.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import invert_point</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; transformed_point = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; rotation = (1, 2, 3, 4, 5, 6, 7, 8, 9)</span>
<span class="sd">        &gt;&gt;&gt; translation = (1, 0.5, -1)</span>
<span class="sd">        &gt;&gt;&gt; output= invert_point(transformed_point, rotation, translation)</span>
<span class="sd">        &gt;&gt;&gt; print(output)</span>
<span class="sd">        (Tensor(shape=[], dtype=Float32, value = 34), Tensor(shape=[], dtype=Float32, value = 39.5),</span>
<span class="sd">         Tensor(shape=[], dtype=Float32, value = 45))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">rots_from_tensor</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">use_numpy</span><span class="p">)</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">extra_dims</span><span class="p">):</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">rots_expand_dims</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">vecs_expand_dims</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rot_point</span> <span class="o">=</span> <span class="n">vecs_sub</span><span class="p">(</span><span class="n">transformed_point</span><span class="p">,</span> <span class="n">translation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">invert_rots</span><span class="p">(</span><span class="n">rotation</span><span class="p">),</span> <span class="n">rot_point</span><span class="p">)</span></div>


<div class="viewcode-block" id="quat_multiply_by_vec"><a class="viewcode-back" href="../../../common/mindsponge.common.quat_multiply_by_vec.html#mindsponge.common.quat_multiply_by_vec">[文档]</a><span class="k">def</span> <span class="nf">quat_multiply_by_vec</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiply a quaternion by a pure-vector quaternion.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;temp =  QUAT\_MULTIPLY\_BY\_VEC * quat[..., :, None, None] * vec[..., None, :, None] \\</span>
<span class="sd">        &amp;result = sum(temp,axis=(-3, -2)) \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        quat (Tensor):  Quaternion.Tensor of shape :math:`(..., 4)`.</span>
<span class="sd">        vec (Tensor):   A pure-vector quaternion, :math:`(b, c, d)` not normalized quaternion.</span>
<span class="sd">                        Quaternion can be expressed as :math:`(1, b, c, d)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor, the product of a quaternion with a pure vector quaternion. Shape is :math:`(..., 4)`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import quat_multiply_by_vec</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">        &gt;&gt;&gt; quat = Tensor(np.random.rand(4),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; vec = Tensor(np.random.rand(3),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; out = quat_multiply_by_vec(quat, vec)</span>
<span class="sd">        &gt;&gt;&gt; print(out)</span>
<span class="sd">        [-0.16203496,  0.03330477, -0.05129148,  0.14417158]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">mnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">QUAT_MULTIPLY_BY_VEC</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span>
                   <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="pre_compose"><a class="viewcode-back" href="../../../common/mindsponge.common.pre_compose.html#mindsponge.common.pre_compose">[文档]</a><span class="k">def</span> <span class="nf">pre_compose</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">update</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new QuatAffine which applies the transformation update first.</span>

<span class="sd">    The process of obtaining the updated translation vector and rotation matrix is as follows:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;update = (xx, xy, xz, yx, yy, yz) \\</span>
<span class="sd">        &amp;vector\_quaternion\_update = (xx, xy, xz) \\</span>
<span class="sd">        &amp;x = (yx) \\</span>
<span class="sd">        &amp;y = (yy) \\</span>
<span class="sd">        &amp;z = (yz) \\</span>
<span class="sd">        &amp;trans\_update = (x, y, z) \\</span>
<span class="sd">        &amp;new\_quaternion = quaternion + vector\_quaternion\_update * quaternion \\</span>
<span class="sd">        &amp;rotated\_trans\_update = rotation * trans\_update \\</span>
<span class="sd">        &amp;new\_translation = translation + rotated\_trans\_update \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    vector_quaternion_update and quaternion are multiplied by the quat_multiply_by_vec function,</span>
<span class="sd">    Affine transformation is performed using the generated new_quaternion and new_translation.</span>
<span class="sd">    The process of affine transformation is referred to the quat_affine api.</span>

<span class="sd">    Args:</span>
<span class="sd">        quaternion (Tensor):    The initial quaternion to be updated, shape :math:`[(..., 4)]`.</span>
<span class="sd">        rotation (Tuple):       Rotation matrix, :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`,</span>
<span class="sd">                                and xx and xy are Tensor and have the same shape.</span>
<span class="sd">        translation (Tuple):    Translation vector :math:`(x, y, z)`,</span>
<span class="sd">                                where x, y and z are Tensor and have the same shape.</span>
<span class="sd">        update (Tensor):        The update-assisted matrix has shape :math:`[(..., 6)]`.</span>
<span class="sd">                                3-vector of x, y, and z such that the quaternion</span>
<span class="sd">                                update is :math:`(1, x, y, z)` and zero for the 3-vector is the identity</span>
<span class="sd">                                quaternion. 3-vector for translation concatenated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        - Tensor, new quaternion.The updated Tensor tuple has shape :math:`[(..., 4)]`.</span>
<span class="sd">        - Tuple, the updated rotation matrix :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`,</span>
<span class="sd">          and xx and xy are Tensor and have the same shape.</span>
<span class="sd">        - Tuple, the updated translation vector :math:`(x, y, z)`,</span>
<span class="sd">          where x, y and z are Tensor and have the same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import pre_compose</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">        &gt;&gt;&gt; quaternion = Tensor(np.random.rand(4),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; update = Tensor(np.random.rand(6),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; rotation = Tensor(np.random.rand(9),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; translation = Tensor(np.random.rand(3),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; quaternion, rotation, translation = pre_compose(quaternion,rotation,translation,update)</span>
<span class="sd">        &gt;&gt;&gt; print(quaternion)</span>
<span class="sd">        [ 0.27905196  0.82475466 -0.05600705  0.48864394]</span>
<span class="sd">        &gt;&gt;&gt; print(rotation)</span>
<span class="sd">        (Tensor(shape=[], dtype=Float32, value= 0.516181), Tensor(shape=[], dtype=Float32, value= -0.365098),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= 0.774765), Tensor(shape=[], dtype=Float32, value= 0.18033),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= -0.837986), Tensor(shape=[], dtype=Float32, value= -0.515034),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= 0.837281), Tensor(shape=[], dtype=Float32, value= 0.405564),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= -0.366714))</span>
<span class="sd">        &gt;&gt;&gt; print(translation)</span>
<span class="sd">        (Tensor(shape=[], dtype=Float32, value= 0.724994), Tensor(shape=[], dtype=Float32, value= 1.47631),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= 1.40978))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">vector_quaternion_update</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">trans_update</span> <span class="o">=</span> <span class="p">[</span><span class="n">mnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">mnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">mnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">new_quaternion</span> <span class="o">=</span> <span class="p">(</span><span class="n">quaternion</span> <span class="o">+</span> <span class="n">quat_multiply_by_vec</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">vector_quaternion_update</span><span class="p">))</span>
    <span class="n">rotated_trans_update</span> <span class="o">=</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">trans_update</span><span class="p">)</span>
    <span class="n">new_translation</span> <span class="o">=</span> <span class="n">vecs_add</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">rotated_trans_update</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quat_affine</span><span class="p">(</span><span class="n">new_quaternion</span><span class="p">,</span> <span class="n">new_translation</span><span class="p">)</span></div>


<div class="viewcode-block" id="quaternion_to_tensor"><a class="viewcode-back" href="../../../common/mindsponge.common.quaternion_to_tensor.html#mindsponge.common.quaternion_to_tensor">[文档]</a><span class="k">def</span> <span class="nf">quaternion_to_tensor</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">translation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change quaternion to tensor.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;quaternion = [(x_1, y_1, z_1, m_1)] \\</span>
<span class="sd">        &amp;translation = [(x_2, y_2, z_2)] \\</span>
<span class="sd">        &amp;result = [(x_1, y_1, z_1, m_1, x_2, y_2, z_2)] \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Args:</span>
<span class="sd">        quaternion (Tensor):    Inputs quaternion. Tensor of shape :math:`(..., 4)`.</span>
<span class="sd">        translation (Tensor):    Inputs translation. Tensor of shape :math:`(..., 3)`</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor, The result of the concatenation between translation and translation. Tensor of shape :math:`(..., 7)`.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import quaternion_to_tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">        &gt;&gt;&gt; quaternion = Tensor(np.random.rand(4),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; translation = Tensor(np.random.rand(3),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; out = quaternion_to_tensor(quaternion, translation)</span>
<span class="sd">        &gt;&gt;&gt; print(out)</span>
<span class="sd">        [0.6631489  0.44137922 0.97213906 0.7425225  0.3549025  0.6535310.5426164 ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">translation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">translation</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                   <span class="n">P</span><span class="o">.</span><span class="n">ExpandDims</span><span class="p">()(</span><span class="n">translation</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),)</span>
    <span class="k">return</span> <span class="n">mnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">quaternion</span><span class="p">,)</span> <span class="o">+</span> <span class="n">translation</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="quaternion_from_tensor"><a class="viewcode-back" href="../../../common/mindsponge.common.quaternion_from_tensor.html#mindsponge.common.quaternion_from_tensor">[文档]</a><span class="k">def</span> <span class="nf">quaternion_from_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take the input &#39;tensor&#39; :math:`[(xx, xy, xz, yx, yy, yz, zz)]` to get the new</span>
<span class="sd">    &#39;quaternion&#39;, &#39;rotation&#39;, &#39;translation&#39;.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;tensor = [(xx, xy, xz, yx, yy, yz, zz)] \\</span>
<span class="sd">        &amp;quaternion = (xx, xy, xz, yx) \\</span>
<span class="sd">        &amp;translation = (yy, yz, zz) \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    Affine transformation is performed using the generated quaternion and translation.</span>
<span class="sd">    The process of affine transformation is referred to the quat_affine api.</span>

<span class="sd">    Args:</span>
<span class="sd">        tensor(Tensor):     An initial Tensor :math:`[(xx, xy, xz, yx, yy, yz, zz)]` .</span>
<span class="sd">                            :math:`[(xx, xy, xz, yx)]` is the same with `quaternion`.</span>
<span class="sd">                            :math:`(yy, yz, zz)` is the same with `translation`.</span>
<span class="sd">        normalize(bool):    Control whether to find the norm during quat_affine. Default: ``False``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        - Tensor, new quaternion.Tensor of shape :math:`(..., 4)` .</span>
<span class="sd">        - Tuple, new rotation, :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`,</span>
<span class="sd">          and xx and xy are Tensor and have the same shape.</span>
<span class="sd">        - Tuple, translation vector :math:`[(x, y, z)]`, where x, y and z are Tensor and have the same shape.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import quaternion_from_tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common import Tensor</span>
<span class="sd">        &gt;&gt;&gt; tensor = Tensor(np.random.rand(7),dtype=mstype.float32)</span>
<span class="sd">        &gt;&gt;&gt; quaternion, rotation, translation = quaternion_from_tensor(tensor)</span>
<span class="sd">        &gt;&gt;&gt; print(quaternion)</span>
<span class="sd">        [4.17021990e-01,  7.20324516e-01,  1.14374816e-04,  3.02332580e-01]</span>
<span class="sd">        &gt;&gt;&gt; print(rotation)</span>
<span class="sd">        (Tensor(shape=[], dtype=Float32, value= 0.60137), Tensor(shape=[], dtype=Float32, value= -0.251994),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= 0.435651), Tensor(shape=[], dtype=Float32, value= 0.252323),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= -0.436365), Tensor(shape=[], dtype=Float32, value= -0.600713),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= 0.43546), Tensor(shape=[], dtype=Float32, value= 0.600851),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= -0.253555))</span>
<span class="sd">        &gt;&gt;&gt; print(translation)</span>
<span class="sd">        (Tensor(shape=[], dtype=Float32, value= 0.146756),Tensor(shape=[], dtype=Float32, value= 0.0923386),</span>
<span class="sd">        Tensor(shape=[], dtype=Float32, value= 0.18626))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quaternion</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span> <span class="o">=</span> <span class="n">mnp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">tx</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">ty</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">Squeeze</span><span class="p">()(</span><span class="n">tz</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">quat_affine</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span></div>


<div class="viewcode-block" id="apply_to_point"><a class="viewcode-back" href="../../../common/mindsponge.common.apply_to_point.html#mindsponge.common.apply_to_point">[文档]</a><span class="k">def</span> <span class="nf">apply_to_point</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">extra_dims</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate and translate the input coordinates.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        &amp;rot_point = rotation \cdot point \\</span>
<span class="sd">        &amp;result = rot_point + translation \\</span>
<span class="sd">        \end{split}</span>

<span class="sd">    For specific multiplication and addition procedures, refer to the rots_mul_vecs and vecs_add apis.</span>

<span class="sd">    Args:</span>
<span class="sd">        rotation(Tuple):    The rotation matrix :math:`(xx, xy, xz, yx, yy, yz, zx, zy, zz)`,</span>
<span class="sd">                            and :math:`xx, xy` are Tensor and have the same shape.</span>
<span class="sd">        translation(Tuple): Translation vector :math:`[(x, y, z)]`,</span>
<span class="sd">                            where :math:`x, y, z` are Tensor and have the same shape.</span>
<span class="sd">        point(Tensor):      Initial coordinate values :math:`[(x, y, z)]`,</span>
<span class="sd">                            where :math:`x, y, z` are Tensor and have the same shape.</span>
<span class="sd">        extra_dims(int):    Control whether to expand dims. default:0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple, the result of the coordinate transformation. Length is 3.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.common.geometry import apply_to_point</span>
<span class="sd">        &gt;&gt;&gt; from mindspore.common import Tensor</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">        &gt;&gt;&gt; rotation = []</span>
<span class="sd">        &gt;&gt;&gt; for i in range(9):</span>
<span class="sd">        ...     rotation.append(Tensor(np.random.rand(4),dtype=mstype.float32))</span>
<span class="sd">        &gt;&gt;&gt; translation = []</span>
<span class="sd">        &gt;&gt;&gt; for i in range(3):</span>
<span class="sd">        ...     translation.append(Tensor(np.random.rand(4),dtype=mstype.float32))</span>
<span class="sd">        &gt;&gt;&gt; point = []</span>
<span class="sd">        &gt;&gt;&gt; for i in range(3):</span>
<span class="sd">        ...     point.append(Tensor(np.random.rand(4),dtype=mstype.float32))</span>
<span class="sd">        &gt;&gt;&gt; out = apply_to_point(rotation, translation, point)</span>
<span class="sd">        &gt;&gt;&gt; print(out)</span>
<span class="sd">        (Tensor(shape=[4], dtype=Float32, value= [ 1.02389336e+00,  1.12493467e+00,  2.54357845e-01,  1.25249946e+00]),</span>
<span class="sd">        Tensor(shape=[4], dtype=Float32, value= [ 9.84841168e-01,  5.20081401e-01,  6.43978953e-01,  6.15328550e-01]),</span>
<span class="sd">        Tensor(shape=[4], dtype=Float32, value= [ 8.62860143e-01,  9.11733627e-01,  1.09284782e+00,  1.44202101e+00]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">extra_dims</span><span class="p">):</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">rots_expand_dims</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">vecs_expand_dims</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rot_point</span> <span class="o">=</span> <span class="n">rots_mul_vecs</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">vecs_add</span><span class="p">(</span><span class="n">rot_point</span><span class="p">,</span> <span class="n">translation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, MindSpore.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>