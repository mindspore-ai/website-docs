

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mindsponge.data.data_transform &mdash; MindSpore master 文档</title>
  

  
   
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/translations.js"></script>
        
        
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">分子模拟简介</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/physics_driven.html">物理驱动</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/data_driven.html">数据驱动</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/physics_plus_data_driven.html">融合驱动</a></li>
</ul>
<p class="caption"><span class="caption-text">使用者指南</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user/simulation.html">分子模拟</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/structure_prediction.html">分子结构预测</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/property_prediction.html">分子性质预测</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/design.html">分子设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/basic.html">分子基础模型</a></li>
</ul>
<p class="caption"><span class="caption-text">API参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mindsponge.cell.html">mindsponge.cell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindsponge.common.html">mindsponge.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindsponge.data.html">mindsponge.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mindsponge.metrics.html">mindsponge.metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../constant.html">Constants</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">模块代码</a> &raquo;</li>
        
      <li>mindsponge.data.data_transform</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>mindsponge.data.data_transform 源代码</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021 The AIMM Group at Shenzhen Bay Laboratory &amp; Peking University &amp; Huawei Technologies Co., Ltd</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>
<span class="sd">&quot;&quot;&quot;data transform MSA TEMPLATE&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">softmax</span>
<span class="kn">import</span> <span class="nn">mindsponge.common.geometry</span> <span class="k">as</span> <span class="nn">geometry</span>
<span class="kn">from</span> <span class="nn">mindsponge.common.residue_constants</span> <span class="kn">import</span> <span class="n">chi_angles_mask</span><span class="p">,</span> <span class="n">chi_pi_periodic</span><span class="p">,</span> <span class="n">restype_1to3</span><span class="p">,</span> <span class="n">chi_angles_atoms</span><span class="p">,</span> \
    <span class="n">atom_order</span><span class="p">,</span> <span class="n">residue_atom_renaming_swaps</span><span class="p">,</span> <span class="n">restype_3to1</span><span class="p">,</span> <span class="n">MAP_HHBLITS_AATYPE_TO_OUR_AATYPE</span><span class="p">,</span> <span class="n">restype_order</span><span class="p">,</span> \
    <span class="n">restypes</span><span class="p">,</span> <span class="n">restype_name_to_atom14_names</span><span class="p">,</span> <span class="n">atom_types</span><span class="p">,</span> <span class="n">residue_atoms</span><span class="p">,</span> <span class="n">STANDARD_ATOM_MASK</span><span class="p">,</span> <span class="n">restypes_with_x_and_gap</span><span class="p">,</span> \
    <span class="n">MSA_PAD_VALUES</span>

<span class="n">MS_MIN32</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483648</span>
<span class="n">MS_MAX32</span> <span class="o">=</span> <span class="mi">2147483647</span>


<span class="k">def</span> <span class="nf">one_hot</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;one hot compute&quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">depth</span><span class="p">)[</span><span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">depth</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">correct_msa_restypes</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">deletion_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_evogen</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Correct MSA restype to have the same order as residue_constants.&quot;&quot;&quot;</span>
    <span class="n">new_order_list</span> <span class="o">=</span> <span class="n">MAP_HHBLITS_AATYPE_TO_OUR_AATYPE</span>
    <span class="n">new_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_order_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">msa</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">msa</span> <span class="o">=</span> <span class="n">new_order</span><span class="p">[</span><span class="n">msa</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">is_evogen</span><span class="p">:</span>
        <span class="n">msa_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">msa</span><span class="p">,</span> <span class="n">deletion_matrix</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">msa</span><span class="p">,</span> <span class="n">msa_input</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">msa</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">randomly_replace_msa_with_unknown</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">aatype</span><span class="p">,</span> <span class="n">replace_proportion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace a proportion of the MSA with &#39;X&#39;.&quot;&quot;&quot;</span>
    <span class="n">msa_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">replace_proportion</span>
    <span class="n">x_idx</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">gap_idx</span> <span class="o">=</span> <span class="mi">21</span>
    <span class="n">msa_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">msa_mask</span><span class="p">,</span> <span class="n">msa</span> <span class="o">!=</span> <span class="n">gap_idx</span><span class="p">)</span>
    <span class="n">msa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">msa_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_idx</span><span class="p">,</span> <span class="n">msa</span><span class="p">)</span>
    <span class="n">aatype_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">aatype</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">replace_proportion</span>
    <span class="n">aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aatype_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">aatype</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_idx</span><span class="p">,</span> <span class="n">aatype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">msa</span><span class="p">,</span> <span class="n">aatype</span>


<span class="k">def</span> <span class="nf">fix_templates_aatype</span><span class="p">(</span><span class="n">template_aatype</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fixes aatype encoding of templates.&quot;&quot;&quot;</span>
    <span class="c1"># Map one-hot to indices.</span>
    <span class="n">template_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">template_aatype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="c1"># Map hhsearch-aatype to our aatype.</span>
    <span class="n">new_order_list</span> <span class="o">=</span> <span class="n">MAP_HHBLITS_AATYPE_TO_OUR_AATYPE</span>
    <span class="n">new_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_order_list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">template_aatype</span> <span class="o">=</span> <span class="n">new_order</span><span class="p">[</span><span class="n">template_aatype</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">template_aatype</span>


<span class="k">def</span> <span class="nf">pseudo_beta_fn</span><span class="p">(</span><span class="n">aatype</span><span class="p">,</span> <span class="n">all_atom_positions</span><span class="p">,</span> <span class="n">all_atom_masks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;compute pseudo beta features from atom positions&quot;&quot;&quot;</span>
    <span class="n">is_gly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aatype</span><span class="p">,</span> <span class="n">restype_order</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">])</span>
    <span class="n">ca_idx</span> <span class="o">=</span> <span class="n">atom_order</span><span class="p">[</span><span class="s1">&#39;CA&#39;</span><span class="p">]</span>
    <span class="n">cb_idx</span> <span class="o">=</span> <span class="n">atom_order</span><span class="p">[</span><span class="s1">&#39;CB&#39;</span><span class="p">]</span>
    <span class="n">pseudo_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">is_gly</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_gly</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span>
        <span class="n">all_atom_positions</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ca_idx</span><span class="p">,</span> <span class="p">:],</span>
        <span class="n">all_atom_positions</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cb_idx</span><span class="p">,</span> <span class="p">:])</span>
    <span class="k">if</span> <span class="n">all_atom_masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pseudo_beta_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_gly</span><span class="p">,</span> <span class="n">all_atom_masks</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ca_idx</span><span class="p">],</span> <span class="n">all_atom_masks</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cb_idx</span><span class="p">])</span>
        <span class="n">pseudo_beta_mask</span> <span class="o">=</span> <span class="n">pseudo_beta_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_beta</span><span class="p">,</span> <span class="n">pseudo_beta_mask</span>
    <span class="k">return</span> <span class="n">pseudo_beta</span>


<span class="k">def</span> <span class="nf">make_atom14_masks</span><span class="p">(</span><span class="n">aatype</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;create atom 14 position features from aatype&quot;&quot;&quot;</span>
    <span class="n">rt_atom14_to_atom37</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rt_atom37_to_atom14</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rt_atom14_mask</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">restype</span> <span class="ow">in</span> <span class="n">restypes</span><span class="p">:</span>
        <span class="n">atom_names</span> <span class="o">=</span> <span class="n">restype_name_to_atom14_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">restype_1to3</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">restype</span><span class="p">))</span>

        <span class="n">rt_atom14_to_atom37</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">atom_order</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">atom_names</span><span class="p">])</span>

        <span class="n">atom_name_to_idx14</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_names</span><span class="p">)}</span>
        <span class="n">rt_atom37_to_atom14</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">atom_name_to_idx14</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">atom_name_to_idx14</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">atom_types</span><span class="p">])</span>

        <span class="n">rt_atom14_mask</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="mf">0.</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">atom_names</span><span class="p">])</span>

    <span class="c1"># Add dummy mapping for restype &#39;UNK&#39;</span>
    <span class="n">rt_atom14_to_atom37</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">14</span><span class="p">)</span>
    <span class="n">rt_atom37_to_atom14</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">37</span><span class="p">)</span>
    <span class="n">rt_atom14_mask</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="mi">14</span><span class="p">)</span>

    <span class="n">rt_atom14_to_atom37</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rt_atom14_to_atom37</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">rt_atom37_to_atom14</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rt_atom37_to_atom14</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">rt_atom14_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rt_atom14_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">ri_atom14_to_atom37</span> <span class="o">=</span> <span class="n">rt_atom14_to_atom37</span><span class="p">[</span><span class="n">aatype</span><span class="p">]</span>
    <span class="n">ri_atom14_mask</span> <span class="o">=</span> <span class="n">rt_atom14_mask</span><span class="p">[</span><span class="n">aatype</span><span class="p">]</span>

    <span class="n">atom14_atom_exists</span> <span class="o">=</span> <span class="n">ri_atom14_mask</span>
    <span class="n">ri_atom14_to_atom37</span> <span class="o">=</span> <span class="n">ri_atom14_to_atom37</span>

    <span class="c1"># create the gather indices for mapping back</span>
    <span class="n">ri_atom37_to_atom14</span> <span class="o">=</span> <span class="n">rt_atom37_to_atom14</span><span class="p">[</span><span class="n">aatype</span><span class="p">]</span>
    <span class="n">ri_atom37_to_atom14</span> <span class="o">=</span> <span class="n">ri_atom37_to_atom14</span>

    <span class="c1"># create the corresponding mask</span>
    <span class="n">restype_atom37_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">21</span><span class="p">,</span> <span class="mi">37</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">restype</span><span class="p">,</span> <span class="n">restype_letter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">restypes</span><span class="p">):</span>
        <span class="n">restype_name</span> <span class="o">=</span> <span class="n">restype_1to3</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">restype_letter</span><span class="p">)</span>
        <span class="n">atom_names</span> <span class="o">=</span> <span class="n">residue_atoms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">restype_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom_name</span> <span class="ow">in</span> <span class="n">atom_names</span><span class="p">:</span>
            <span class="n">atom_type</span> <span class="o">=</span> <span class="n">atom_order</span><span class="p">[</span><span class="n">atom_name</span><span class="p">]</span>
            <span class="n">restype_atom37_mask</span><span class="p">[</span><span class="n">restype</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">atom37_atom_exists</span> <span class="o">=</span> <span class="n">restype_atom37_mask</span><span class="p">[</span><span class="n">aatype</span><span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom14_atom_exists</span><span class="p">,</span> <span class="n">ri_atom14_to_atom37</span><span class="p">,</span> <span class="n">ri_atom37_to_atom14</span><span class="p">,</span> <span class="n">atom37_atom_exists</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">block_delete_msa_indices</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">msa_fraction_per_block</span><span class="p">,</span> <span class="n">randomize_num_blocks</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample MSA by deleting contiguous blocks.</span>

<span class="sd">    Jumper et al. (2021) Suppl. Alg. 1 &quot;MSABlockDeletion&quot;</span>

<span class="sd">    Arguments:</span>
<span class="sd">    protein: batch dict containing the msa</span>
<span class="sd">    config: ConfigDict with parameters</span>

<span class="sd">    Returns:</span>
<span class="sd">    updated protein</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_seq</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">block_num_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_seq</span> <span class="o">*</span> <span class="n">msa_fraction_per_block</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">randomize_num_blocks</span><span class="p">:</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_blocks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="n">num_blocks</span>
    <span class="n">del_block_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_seq</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">del_blocks</span> <span class="o">=</span> <span class="n">del_block_starts</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_num_seq</span><span class="p">)])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">del_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">del_blocks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_seq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">del_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">del_blocks</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))))</span>

    <span class="c1"># Make sure we keep the original sequence</span>
    <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_seq</span><span class="p">)]),</span>
                                <span class="n">del_indices</span><span class="p">)</span>
    <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">keep_indices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">keep_indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">keep_indices</span>


<span class="k">def</span> <span class="nf">sample_msa</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">max_seq</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample MSA randomly, remaining sequences are stored as `extra_*`.&quot;&quot;&quot;</span>
    <span class="n">num_seq</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">shuffled</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_seq</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffled</span><span class="p">)</span>
    <span class="n">shuffled</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">index_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shuffled</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">num_sel</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="n">num_seq</span><span class="p">)</span>

    <span class="n">sel_seq</span> <span class="o">=</span> <span class="n">index_order</span><span class="p">[:</span><span class="n">num_sel</span><span class="p">]</span>
    <span class="n">not_sel_seq</span> <span class="o">=</span> <span class="n">index_order</span><span class="p">[</span><span class="n">num_sel</span><span class="p">:]</span>
    <span class="n">is_sel</span> <span class="o">=</span> <span class="n">num_seq</span> <span class="o">-</span> <span class="n">num_sel</span>
    <span class="k">return</span> <span class="n">is_sel</span><span class="p">,</span> <span class="n">not_sel_seq</span><span class="p">,</span> <span class="n">sel_seq</span>


<span class="k">def</span> <span class="nf">gumbel_noise</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate Gumbel Noise of given Shape.&quot;&quot;&quot;</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-6</span>
    <span class="n">uniform_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="n">gumbel</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">uniform_noise</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gumbel</span>


<span class="k">def</span> <span class="nf">gumbel_argsort_sample_idx</span><span class="p">(</span><span class="n">logits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Samples with replacement from a distribution given by &#39;logits&#39;.&quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">gumbel_noise</span><span class="p">(</span><span class="n">logits</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">logits</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">gumbel_permutation</span><span class="p">(</span><span class="n">msa_mask</span><span class="p">,</span> <span class="n">msa_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;gumbel permutation.&quot;&quot;&quot;</span>
    <span class="n">has_msa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">msa_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="c1"># default logits is zero</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">has_msa</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">logits</span><span class="p">[</span><span class="o">~</span><span class="n">has_msa</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e6</span>
    <span class="c1"># one sample only</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">logits</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="c1"># skip first row</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="n">logits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">has_msa</span> <span class="o">=</span> <span class="n">has_msa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">logits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">msa_chains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># skip first row</span>
        <span class="n">msa_chains</span> <span class="o">=</span> <span class="n">msa_chains</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">msa_chains</span><span class="p">[</span><span class="o">~</span><span class="n">has_msa</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">keys</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">msa_chains</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_has_msa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">has_msa</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">num_pair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">msa_chains</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">num_unpair</span> <span class="o">=</span> <span class="n">num_has_msa</span> <span class="o">-</span> <span class="n">num_pair</span>
        <span class="n">num_chains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">keys</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">logits</span><span class="p">[</span><span class="n">has_msa</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_has_msa</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
        <span class="n">logits</span><span class="p">[</span><span class="o">~</span><span class="n">has_msa</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cur_mask</span> <span class="o">=</span> <span class="n">msa_chains</span> <span class="o">==</span> <span class="n">k</span>
                <span class="n">cur_cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cur_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">cur_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">logits</span><span class="p">[</span><span class="n">cur_mask</span><span class="p">]</span> <span class="o">*=</span> <span class="n">num_unpair</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_chains</span> <span class="o">*</span> <span class="n">cur_cnt</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logits</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    <span class="n">shuffled</span> <span class="o">=</span> <span class="n">gumbel_argsort_sample_idx</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">shuffled</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sample_msa_v2</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">msa_chains</span><span class="p">,</span> <span class="n">msa_mask</span><span class="p">,</span> <span class="n">max_seq</span><span class="p">,</span> <span class="n">biased_msa_by_chain</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample MSA randomly in multimer, remaining sequences are stored as `extra_*`.&quot;&quot;&quot;</span>
    <span class="n">num_seq</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_sel</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="n">num_seq</span><span class="p">)</span>
    <span class="n">msa_chain</span> <span class="o">=</span> <span class="p">(</span><span class="n">msa_chains</span> <span class="k">if</span> <span class="n">biased_msa_by_chain</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">index_order</span> <span class="o">=</span> <span class="n">gumbel_permutation</span><span class="p">(</span><span class="n">msa_mask</span><span class="p">,</span> <span class="n">msa_chain</span><span class="p">)</span>
    <span class="n">num_sel</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="n">num_seq</span><span class="p">)</span>
    <span class="n">sel_seq</span> <span class="o">=</span> <span class="n">index_order</span><span class="p">[:</span><span class="n">num_sel</span><span class="p">]</span>
    <span class="n">not_sel_seq</span> <span class="o">=</span> <span class="n">index_order</span><span class="p">[</span><span class="n">num_sel</span><span class="p">:]</span>
    <span class="n">is_sel</span> <span class="o">=</span> <span class="n">num_seq</span> <span class="o">-</span> <span class="n">num_sel</span>
    <span class="k">return</span> <span class="n">is_sel</span><span class="p">,</span> <span class="n">not_sel_seq</span><span class="p">,</span> <span class="n">sel_seq</span>


<span class="k">def</span> <span class="nf">shape_list</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get the list of dimensions of an array&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">static</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">static</span><span class="p">):</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">shaped_categorical</span><span class="p">(</span><span class="n">probability</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get categorical shape&quot;&quot;&quot;</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">shape_list</span><span class="p">(</span><span class="n">probability</span><span class="p">)</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">flat_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">probability</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">))</span>
    <span class="n">numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_classes</span><span class="p">))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">flat_prob</span> <span class="ow">in</span> <span class="n">flat_probs</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">flat_prob</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">ds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">make_masked_msa</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">hhblits_profile</span><span class="p">,</span> <span class="n">uniform_prob</span><span class="p">,</span> <span class="n">profile_prob</span><span class="p">,</span> <span class="n">same_prob</span><span class="p">,</span> <span class="n">replace_fraction</span><span class="p">,</span> <span class="n">residue_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">msa_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_evogen</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;create masked msa for BERT on raw MSA features&quot;&quot;&quot;</span>

    <span class="n">random_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.05</span><span class="p">]</span> <span class="o">*</span> <span class="mi">20</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">probability</span> <span class="o">=</span> <span class="n">uniform_prob</span> <span class="o">*</span> <span class="n">random_aatype</span> <span class="o">+</span> <span class="n">profile_prob</span> <span class="o">*</span> <span class="n">hhblits_profile</span> <span class="o">+</span> <span class="n">same_prob</span> <span class="o">*</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="n">msa</span><span class="p">)</span>

    <span class="n">pad_shapes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">probability</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
    <span class="n">pad_shapes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask_prob</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">profile_prob</span> <span class="o">-</span> <span class="n">same_prob</span> <span class="o">-</span> <span class="n">uniform_prob</span>

    <span class="n">probability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">probability</span><span class="p">,</span> <span class="n">pad_shapes</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="n">mask_prob</span><span class="p">,))</span>

    <span class="n">masked_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">replace_fraction</span>

    <span class="n">bert_msa</span> <span class="o">=</span> <span class="n">shaped_categorical</span><span class="p">(</span><span class="n">probability</span><span class="p">)</span>
    <span class="n">bert_msa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masked_aatype</span><span class="p">,</span> <span class="n">bert_msa</span><span class="p">,</span> <span class="n">msa</span><span class="p">)</span>

    <span class="n">bert_mask</span> <span class="o">=</span> <span class="n">masked_aatype</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">true_msa</span> <span class="o">=</span> <span class="n">msa</span>
    <span class="n">msa</span> <span class="o">=</span> <span class="n">bert_msa</span>
    <span class="k">if</span> <span class="n">is_evogen</span><span class="p">:</span>
        <span class="n">additional_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bert_msa</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">residue_index</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">],</span>
                                           <span class="n">msa_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">],</span>
                                           <span class="n">bert_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">]),</span>
                                          <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">make_masked_msa_result</span> <span class="o">=</span> <span class="n">bert_mask</span><span class="p">,</span> <span class="n">true_msa</span><span class="p">,</span> <span class="n">msa</span><span class="p">,</span> <span class="n">additional_input</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">make_masked_msa_result</span> <span class="o">=</span> <span class="n">bert_mask</span><span class="p">,</span> <span class="n">true_msa</span><span class="p">,</span> <span class="n">msa</span>
    <span class="k">return</span> <span class="n">make_masked_msa_result</span>


<span class="k">def</span> <span class="nf">share_mask_by_entity</span><span class="p">(</span><span class="n">mask_position</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">sym_id</span><span class="p">,</span> <span class="n">num_sym</span><span class="p">):</span>
    <span class="s2">&quot;share mask by entity&quot;</span>
    <span class="n">entity_id</span> <span class="o">=</span> <span class="n">entity_id</span>
    <span class="n">sym_id</span> <span class="o">=</span> <span class="n">sym_id</span>
    <span class="n">num_sym</span> <span class="o">=</span> <span class="n">num_sym</span>
    <span class="n">unique_entity_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">entity_id</span><span class="p">)</span>
    <span class="n">first_sym_mask</span> <span class="o">=</span> <span class="n">sym_id</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">cur_entity_id</span> <span class="ow">in</span> <span class="n">unique_entity_ids</span><span class="p">:</span>
        <span class="n">cur_entity_mask</span> <span class="o">=</span> <span class="n">entity_id</span> <span class="o">==</span> <span class="n">cur_entity_id</span>
        <span class="n">cur_num_sym</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_sym</span><span class="p">[</span><span class="n">cur_entity_mask</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cur_num_sym</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cur_sym_mask</span> <span class="o">=</span> <span class="n">first_sym_mask</span> <span class="o">&amp;</span> <span class="n">cur_entity_mask</span>
            <span class="n">cur_sym_bert_mask</span> <span class="o">=</span> <span class="n">mask_position</span><span class="p">[:,</span> <span class="n">cur_sym_mask</span><span class="p">]</span>
            <span class="n">mask_position</span><span class="p">[:,</span> <span class="n">cur_entity_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_sym_bert_mask</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cur_num_sym</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">cur_sym_bert_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_sym_bert_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cur_num_sym</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask_position</span>


<span class="k">def</span> <span class="nf">gumbel_max_sample</span><span class="p">(</span><span class="n">logits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Samples from a probability distribution given by &#39;logits&#39;.&quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">gumbel_noise</span><span class="p">(</span><span class="n">logits</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logits</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">make_masked_msa_v2</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">hhblits_profile</span><span class="p">,</span> <span class="n">msa_mask</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">sym_id</span><span class="p">,</span> <span class="n">num_sym</span><span class="p">,</span>
                       <span class="n">uniform_prob</span><span class="p">,</span> <span class="n">profile_prob</span><span class="p">,</span> <span class="n">same_prob</span><span class="p">,</span>
                       <span class="n">replace_fraction</span><span class="p">,</span> <span class="n">share_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bert_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;create masked msa for BERT on raw MSA features&quot;&quot;&quot;</span>

    <span class="n">random_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.05</span><span class="p">]</span> <span class="o">*</span> <span class="mi">20</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">probability</span> <span class="o">=</span> <span class="n">uniform_prob</span> <span class="o">*</span> <span class="n">random_aatype</span> <span class="o">+</span> <span class="n">profile_prob</span> <span class="o">*</span> <span class="n">hhblits_profile</span> <span class="o">+</span> <span class="n">same_prob</span> <span class="o">*</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="n">msa</span><span class="p">)</span>

    <span class="n">pad_shapes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">probability</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
    <span class="n">pad_shapes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask_prob</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">profile_prob</span> <span class="o">-</span> <span class="n">same_prob</span> <span class="o">-</span> <span class="n">uniform_prob</span>
    <span class="k">assert</span> <span class="n">mask_prob</span> <span class="o">&gt;=</span> <span class="mf">0.0</span>
    <span class="n">probability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">probability</span><span class="p">,</span> <span class="n">pad_shapes</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="n">mask_prob</span><span class="p">,))</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">mask_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">sh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">replace_fraction</span>
    <span class="n">mask_position</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">msa_mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bert_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask_position</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bert_mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">share_mask</span><span class="p">:</span>
        <span class="n">mask_position</span> <span class="o">=</span> <span class="n">share_mask_by_entity</span><span class="p">(</span><span class="n">mask_position</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">sym_id</span><span class="p">,</span> <span class="n">num_sym</span><span class="p">)</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">probability</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    <span class="n">bert_msa</span> <span class="o">=</span> <span class="n">gumbel_max_sample</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">bert_msa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_position</span><span class="p">,</span> <span class="n">bert_msa</span><span class="p">,</span> <span class="n">msa</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">bert_msa</span> <span class="o">*=</span> <span class="n">msa_mask</span>

    <span class="n">mask_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask_position</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask_position</span><span class="p">,</span> <span class="n">msa</span><span class="p">,</span> <span class="n">bert_msa</span>


<span class="k">def</span> <span class="nf">nearest_neighbor_clusters</span><span class="p">(</span><span class="n">msa_mask</span><span class="p">,</span> <span class="n">msa</span><span class="p">,</span> <span class="n">extra_msa_mask</span><span class="p">,</span> <span class="n">extra_msa</span><span class="p">,</span> <span class="n">gap_agreement_weight</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assign each extra MSA sequence to its nearest neighbor in sampled MSA.&quot;&quot;&quot;</span>

    <span class="c1"># Determine how much weight we assign to each agreement.  In theory, we could</span>
    <span class="c1"># use a full blosum matrix here, but right now let&#39;s just down-weight gap</span>
    <span class="c1"># agreement because it could be spurious.</span>
    <span class="c1"># Never put weight on agreeing on BERT mask</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">21</span><span class="p">),</span> <span class="n">gap_agreement_weight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Make agreement score as weighted Hamming distance</span>
    <span class="n">sample_one_hot</span> <span class="o">=</span> <span class="n">msa_mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">msa</span><span class="p">)</span>
    <span class="n">num_seq</span><span class="p">,</span> <span class="n">num_res</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sample_one_hot</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">array_extra_msa_mask</span> <span class="o">=</span> <span class="n">extra_msa_mask</span>
    <span class="k">if</span> <span class="n">array_extra_msa_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">extra_one_hot</span> <span class="o">=</span> <span class="n">extra_msa_mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">extra_msa</span><span class="p">)</span>
        <span class="n">extra_num_seq</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extra_one_hot</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">agreement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">extra_one_hot</span><span class="p">,</span> <span class="p">[</span><span class="n">extra_num_seq</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">*</span> <span class="mi">23</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sample_one_hot</span> <span class="o">*</span> <span class="n">weights</span><span class="p">,</span> <span class="p">[</span><span class="n">num_seq</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">*</span> <span class="mi">23</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># Assign each sequence in the extra sequences to the closest MSA sample</span>
        <span class="n">extra_cluster_assignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">agreement</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra_cluster_assignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">return</span> <span class="n">extra_cluster_assignment</span>


<span class="k">def</span> <span class="nf">nearest_neighbor_clusters_v2</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">msa_mask</span><span class="p">,</span> <span class="n">extra_msa</span><span class="p">,</span> <span class="n">extra_msa_mask</span><span class="p">,</span>
                                 <span class="n">deletion_matrix</span><span class="p">,</span> <span class="n">extra_deletion_matrix</span><span class="p">,</span> <span class="n">gap_agreement_weight</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assign each extra MSA sequence to its nearest neighbor in sampled MSA.&quot;&quot;&quot;</span>

    <span class="c1"># Determine how much weight we assign to each agreement.  In theory, we could</span>
    <span class="c1"># use a full blosum matrix here, but right now let&#39;s just down-weight gap</span>
    <span class="c1"># agreement because it could be spurious.</span>
    <span class="c1"># Never put weight on agreeing on BERT mask.</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">21</span><span class="p">),</span> <span class="n">gap_agreement_weight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">msa_one_hot</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">msa</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
    <span class="n">extra_one_hot</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">extra_msa</span><span class="p">)</span>

    <span class="n">msa_one_hot_masked</span> <span class="o">=</span> <span class="n">msa_mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">msa_one_hot</span>
    <span class="n">extra_one_hot_masked</span> <span class="o">=</span> <span class="n">extra_msa_mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">extra_one_hot</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">*</span> <span class="n">msa_one_hot_masked</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">extra_one_hot_masked</span><span class="p">,</span> <span class="p">(</span><span class="n">extra_one_hot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extra_one_hot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">extra_one_hot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">agreement</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">@</span> <span class="n">t2</span><span class="o">.</span><span class="n">T</span>
    <span class="n">cluster_assignment</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="mf">1e3</span> <span class="o">*</span> <span class="n">agreement</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cluster_assignment</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;mr, nr-&gt;mn&quot;</span><span class="p">,</span> <span class="n">msa_mask</span><span class="p">,</span> <span class="n">extra_msa_mask</span><span class="p">)</span>

    <span class="n">cluster_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cluster_assignment</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cluster_count</span> <span class="o">+=</span> <span class="mf">1.0</span>  <span class="c1"># We always include the sequence itself.</span>

    <span class="n">msa_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;nm, mrc-&gt;nrc&quot;</span><span class="p">,</span> <span class="n">cluster_assignment</span><span class="p">,</span> <span class="n">extra_one_hot_masked</span><span class="p">)</span>
    <span class="n">msa_sum</span> <span class="o">+=</span> <span class="n">msa_one_hot_masked</span>

    <span class="n">cluster_profile</span> <span class="o">=</span> <span class="n">msa_sum</span> <span class="o">/</span> <span class="n">cluster_count</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">del_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
        <span class="s2">&quot;nm, mc-&gt;nc&quot;</span><span class="p">,</span> <span class="n">cluster_assignment</span><span class="p">,</span> <span class="n">extra_msa_mask</span> <span class="o">*</span> <span class="n">extra_deletion_matrix</span>
    <span class="p">)</span>
    <span class="n">del_sum</span> <span class="o">+=</span> <span class="n">deletion_matrix</span>  <span class="c1"># Original sequence.</span>
    <span class="n">cluster_deletion_mean</span> <span class="o">=</span> <span class="n">del_sum</span> <span class="o">/</span> <span class="n">cluster_count</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cluster_profile</span><span class="p">,</span> <span class="n">cluster_deletion_mean</span>


<span class="k">def</span> <span class="nf">summarize_clusters</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">msa_mask</span><span class="p">,</span> <span class="n">extra_cluster_assignment</span><span class="p">,</span> <span class="n">extra_msa_mask</span><span class="p">,</span> <span class="n">extra_msa</span><span class="p">,</span> <span class="n">extra_deletion_matrix</span><span class="p">,</span>
                       <span class="n">deletion_matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Produce profile and deletion_matrix_mean within each cluster.&quot;&quot;&quot;</span>
    <span class="n">num_seq</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">csum</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_seq</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">extra_cluster_assignment</span> <span class="o">==</span> <span class="n">i</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">extra_msa_mask</span>
    <span class="n">mask_counts</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="o">+</span> <span class="n">msa_mask</span> <span class="o">+</span> <span class="n">csum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>  <span class="c1"># Include center</span>

    <span class="n">msa_sum</span> <span class="o">=</span> <span class="n">csum</span><span class="p">(</span><span class="n">mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">extra_msa</span><span class="p">))</span>
    <span class="n">msa_sum</span> <span class="o">+=</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">msa</span><span class="p">)</span>  <span class="c1"># Original sequence</span>
    <span class="n">cluster_profile</span> <span class="o">=</span> <span class="n">msa_sum</span> <span class="o">/</span> <span class="n">mask_counts</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">del</span> <span class="n">msa_sum</span>

    <span class="n">del_sum</span> <span class="o">=</span> <span class="n">csum</span><span class="p">(</span><span class="n">mask</span> <span class="o">*</span> <span class="n">extra_deletion_matrix</span><span class="p">)</span>
    <span class="n">del_sum</span> <span class="o">+=</span> <span class="n">deletion_matrix</span>  <span class="c1"># Original sequence</span>
    <span class="n">cluster_deletion_mean</span> <span class="o">=</span> <span class="n">del_sum</span> <span class="o">/</span> <span class="n">mask_counts</span>
    <span class="k">del</span> <span class="n">del_sum</span>

    <span class="k">return</span> <span class="n">cluster_profile</span><span class="p">,</span> <span class="n">cluster_deletion_mean</span>


<span class="k">def</span> <span class="nf">crop_extra_msa</span><span class="p">(</span><span class="n">extra_msa</span><span class="p">,</span> <span class="n">max_extra_msa</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;MSA features are cropped so only `max_extra_msa` sequences are kept.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">extra_msa</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">num_seq</span> <span class="o">=</span> <span class="n">extra_msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">num_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">max_extra_msa</span><span class="p">,</span> <span class="n">num_seq</span><span class="p">)</span>
        <span class="n">shuffled</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_seq</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffled</span><span class="p">)</span>
        <span class="n">select_indices</span> <span class="o">=</span> <span class="n">shuffled</span><span class="p">[:</span><span class="n">num_sel</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">select_indices</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">make_msa_feat</span><span class="p">(</span><span class="n">between_segment_residues</span><span class="p">,</span> <span class="n">aatype</span><span class="p">,</span> <span class="n">msa</span><span class="p">,</span> <span class="n">deletion_matrix</span><span class="p">,</span> <span class="n">cluster_deletion_mean</span><span class="p">,</span> <span class="n">cluster_profile</span><span class="p">,</span>
                  <span class="n">extra_deletion_matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create and concatenate MSA features.&quot;&quot;&quot;</span>
    <span class="c1"># Whether there is a domain break. Always zero for chains, but keeping</span>
    <span class="c1"># for compatibility with domain datasets.</span>
    <span class="n">has_break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">between_segment_residues</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">aatype_1hot</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="n">aatype</span><span class="p">)</span>

    <span class="n">target_feat</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">has_break</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">aatype_1hot</span><span class="p">]</span>

    <span class="n">msa_1hot</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">msa</span><span class="p">)</span>
    <span class="n">has_deletion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">deletion_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">deletion_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">deletion_matrix</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="n">msa_feat</span> <span class="o">=</span> <span class="p">[</span><span class="n">msa_1hot</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">has_deletion</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">deletion_value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">cluster_profile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">deletion_mean_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">cluster_deletion_mean</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">msa_feat</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">cluster_profile</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">deletion_mean_value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">extra_has_deletion</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">extra_deletion_value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">extra_deletion_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extra_has_deletion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">extra_deletion_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">extra_deletion_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">extra_deletion_matrix</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="n">msa_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">msa_feat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">target_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">target_feat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">extra_has_deletion</span><span class="p">,</span> <span class="n">extra_deletion_value</span><span class="p">,</span> <span class="n">msa_feat</span><span class="p">,</span> <span class="n">target_feat</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">make_msa_feat_v2</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">deletion_matrix</span><span class="p">,</span> <span class="n">cluster_deletion_mean</span><span class="p">,</span> <span class="n">cluster_profile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create and concatenate MSA features.&quot;&quot;&quot;</span>
    <span class="n">msa_1hot</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">msa</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
    <span class="n">has_deletion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">deletion_matrix</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">deletion_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">deletion_matrix</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">deletion_mean_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">cluster_deletion_mean</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">msa_feat</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">msa_1hot</span><span class="p">,</span>
        <span class="n">has_deletion</span><span class="p">,</span>
        <span class="n">deletion_value</span><span class="p">,</span>
        <span class="n">cluster_profile</span><span class="p">,</span>
        <span class="n">deletion_mean_value</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">msa_feat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">msa_feat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">msa_feat</span>


<span class="k">def</span> <span class="nf">make_extra_msa_feat</span><span class="p">(</span><span class="n">extra_msa</span><span class="p">,</span> <span class="n">extra_deletion_matrix</span><span class="p">,</span> <span class="n">extra_msa_mask</span><span class="p">,</span> <span class="n">num_extra_msa</span><span class="p">):</span>
    <span class="c1"># 23 = 20 amino acids + &#39;X&#39; for unknown + gap + bert mask</span>
    <span class="n">extra_msa</span> <span class="o">=</span> <span class="n">extra_msa</span><span class="p">[:</span><span class="n">num_extra_msa</span><span class="p">]</span>
    <span class="n">deletion_matrix</span> <span class="o">=</span> <span class="n">extra_deletion_matrix</span><span class="p">[:</span><span class="n">num_extra_msa</span><span class="p">]</span>
    <span class="n">has_deletion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">deletion_matrix</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">deletion_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">deletion_matrix</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">extra_msa_mask</span> <span class="o">=</span> <span class="n">extra_msa_mask</span><span class="p">[:</span><span class="n">num_extra_msa</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;extra_msa&quot;</span><span class="p">:</span> <span class="n">extra_msa</span><span class="p">,</span>
            <span class="s2">&quot;extra_msa_mask&quot;</span><span class="p">:</span> <span class="n">extra_msa_mask</span><span class="p">,</span>
            <span class="s2">&quot;extra_msa_has_deletion&quot;</span><span class="p">:</span> <span class="n">has_deletion</span><span class="p">,</span>
            <span class="s2">&quot;extra_msa_deletion_value&quot;</span><span class="p">:</span> <span class="n">deletion_value</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">make_random_seed</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">seed_maker_t</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="n">MS_MIN32</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">MS_MAX32</span><span class="p">,</span> <span class="n">random_recycle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">random_recycle</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed_maker_t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed_maker_t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">random_crop_to_size</span><span class="p">(</span><span class="n">seq_length</span><span class="p">,</span> <span class="n">template_mask</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">,</span> <span class="n">max_templates</span><span class="p">,</span>
                        <span class="n">subsample_templates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_recycle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Crop randomly to `crop_size`, or keep as is if shorter than that.&quot;&quot;&quot;</span>
    <span class="n">seq_length</span> <span class="o">=</span> <span class="n">seq_length</span>
    <span class="n">seq_length_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seq_length</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">template_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_templates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">template_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_templates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">num_res_crop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">seq_length</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">)</span>
    <span class="n">num_res_crop_size_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_res_crop_size</span><span class="p">)</span>

    <span class="c1"># Ensures that the cropping of residues and templates happens in the same way</span>
    <span class="c1"># across ensembling iterations.</span>
    <span class="c1"># Do not use for randomness that should vary in ensembling.</span>

    <span class="k">if</span> <span class="n">subsample_templates</span><span class="p">:</span>
        <span class="n">templates_crop_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">make_random_seed</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(),</span> <span class="n">seed_maker_t</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">num_templates</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                                    <span class="n">random_recycle</span><span class="o">=</span><span class="n">random_recycle</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">templates_crop_start</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">num_templates_crop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">num_templates</span> <span class="o">-</span> <span class="n">templates_crop_start</span><span class="p">,</span> <span class="n">max_templates</span><span class="p">)</span>
    <span class="n">num_templates_crop_size_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_templates_crop_size</span><span class="p">)</span>

    <span class="n">num_res_crop_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">make_random_seed</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(),</span> <span class="n">seed_maker_t</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                              <span class="n">high</span><span class="o">=</span><span class="n">seq_length_int</span> <span class="o">-</span> <span class="n">num_res_crop_size_int</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                              <span class="n">random_recycle</span><span class="o">=</span><span class="n">random_recycle</span><span class="p">))</span>

    <span class="n">templates_select_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">make_random_seed</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">num_templates</span><span class="p">],</span> <span class="n">seed_maker_t</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                                                           <span class="n">random_recycle</span><span class="o">=</span><span class="n">random_recycle</span><span class="p">))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_res_crop_size</span><span class="p">,</span> <span class="n">num_templates_crop_size_int</span><span class="p">,</span> <span class="n">num_res_crop_start</span><span class="p">,</span> <span class="n">num_res_crop_size_int</span><span class="p">,</span> \
           <span class="n">templates_crop_start</span><span class="p">,</span> <span class="n">templates_select_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<div class="viewcode-block" id="atom37_to_torsion_angles"><a class="viewcode-back" href="../../../data/mindsponge.data.atom37_to_torsion_angles.html#mindsponge.data.atom37_to_torsion_angles">[文档]</a><span class="k">def</span> <span class="nf">atom37_to_torsion_angles</span><span class="p">(</span>
        <span class="n">aatype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">all_atom_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">all_atom_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">alt_torsions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">is_multimer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the seven torsion angles of each residue and encodes them in sine and cosine.</span>
<span class="sd">    The order of the seven torsion angles is [pre_omega, phi, psi, chi_1, chi_2, chi_3, chi_4]</span>
<span class="sd">    Here, pre_omega represents the twist angle between a given amino acid and the previous amino acid.</span>
<span class="sd">    The phi represents twist angle between `C-CA-N-(C+1)`, psi represents twist angle between `(N-1)-C-CA-N`.</span>

<span class="sd">    Args:</span>
<span class="sd">        aatype (numpy.array):           Amino acid type with shape :math:`(batch\_size, N_{res})`.</span>
<span class="sd">        all_atom_pos (numpy.array):     Atom37 representation of all atomic coordinates with</span>
<span class="sd">                                        shape :math:`(batch\_size, N_{res}, 37, 3)`.</span>
<span class="sd">        all_atom_mask (numpy.array):    Atom37 representation of the mask on all atomic coordinates with</span>
<span class="sd">                                        shape :math:`(batch\_size, N_{res})`.</span>
<span class="sd">        alt_torsions (bool):            Indicates whether to set the sign angle of shielding torsion to zero.</span>
<span class="sd">                                        Default: False.</span>
<span class="sd">        is_multimer (bool):             It will be True when multimer is used. Default: False</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict containing</span>

<span class="sd">        - torsion_angles_sin_cos (numpy.array), with shape :math:`(N_{res}, 7, 2)` where</span>
<span class="sd">          the final 2 dimensions denote sin and cos respectively. If is_multimer is True, the shape will</span>
<span class="sd">          be :math:`(N_{seq}, N_{res}, 7, 2)` .</span>
<span class="sd">        - alt_torsion_angles_sin_cos (numpy.array), same as &#39;torsion_angles_sin_cos&#39;, but with the angle shifted</span>
<span class="sd">          by pi for all chi angles affected by the naming ambiguities. shape is :math:`(N_{res}, 7, 2)`.</span>
<span class="sd">          If is_multimer is True, the shape will be :math:`(N_{seq}, N_{res}, 7, 2)` .</span>
<span class="sd">        - torsion_angles_mask (numpy.array), Mask for which chi angles are present. shape is :math:`(N_{res}, 7)` .</span>
<span class="sd">          If is_multimer is True, the shape will be :math:`(N_{seq}, N_{res}, 7, 2)` .</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.data.data_transform import atom37_to_torsion_angles</span>
<span class="sd">        &gt;&gt;&gt; n_res = 16</span>
<span class="sd">        &gt;&gt;&gt; bs = 1</span>
<span class="sd">        &gt;&gt;&gt; aatype = np.random.randn(bs, n_res).astype(np.int32)</span>
<span class="sd">        &gt;&gt;&gt; all_atom_pos = np.random.randn(bs, n_res, 37, 3).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; all_atom_mask = np.random.randn(bs, n_res, 37).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; angle_label_feature = atom37_to_torsion_angles(aatype, all_atom_pos, all_atom_mask)</span>
<span class="sd">        &gt;&gt;&gt; print(angle_label_feature.keys())</span>
<span class="sd">        dict_keys([&#39;torsion_angles_sin_cos&#39;, &#39;alt_torsion_angles_sin_cos&#39;, &#39;torsion_angles_mask&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">true_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">aatype</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

    <span class="c1"># get the number residue</span>
    <span class="n">num_batch</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">true_aatype</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">paddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_batch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">padding_atom_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">paddings</span><span class="p">,</span> <span class="n">all_atom_pos</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">paddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_batch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">37</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">padding_atom_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">paddings</span><span class="p">,</span> <span class="n">all_atom_mask</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># compute padding atom position for omega, phi and psi</span>
    <span class="n">omega_atom_pos_padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">padding_atom_pos</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
         <span class="n">all_atom_pos</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
         <span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phi_atom_pos_padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">padding_atom_pos</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
         <span class="n">all_atom_pos</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
         <span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">psi_atom_pos_padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">all_atom_pos</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
         <span class="n">all_atom_pos</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:]</span>
         <span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># compute padding atom position mask for omega, phi and psi</span>
    <span class="n">omega_mask_padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">padding_atom_mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">all_atom_mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">phi_mask_padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">padding_atom_mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">all_atom_mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">psi_mask_padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">all_atom_mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">all_atom_mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

    <span class="n">chi_atom_pos_indices</span> <span class="o">=</span> <span class="n">get_chi_atom_pos_indices</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">is_multimer</span><span class="p">:</span>
        <span class="n">atom_pos_indices</span> <span class="o">=</span> <span class="n">chi_atom_pos_indices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">true_aatype</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">atom_pos_indices</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span><span class="n">chi_atom_pos_indices</span><span class="p">,</span> <span class="n">true_aatype</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">chi_atom_pos</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span><span class="n">all_atom_pos</span><span class="p">,</span> <span class="n">atom_pos_indices</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">is_multimer</span><span class="p">)</span>

    <span class="n">angles_mask</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chi_angles_mask</span><span class="p">)</span>
    <span class="n">angles_mask</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">angles_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angles_mask</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_multimer</span><span class="p">:</span>
        <span class="n">chis_mask</span> <span class="o">=</span> <span class="n">angles_mask</span><span class="p">[</span><span class="n">true_aatype</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chis_mask</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span><span class="n">angles_mask</span><span class="p">,</span> <span class="n">true_aatype</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">chi_angle_atoms_mask</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span><span class="n">all_atom_mask</span><span class="p">,</span> <span class="n">atom_pos_indices</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">is_multimer</span><span class="p">)</span>

    <span class="n">chi_angle_atoms_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">chi_angle_atoms_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">chis_mask</span> <span class="o">=</span> <span class="n">chis_mask</span> <span class="o">*</span> <span class="n">chi_angle_atoms_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">torsions_atom_pos_padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">omega_atom_pos_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
         <span class="n">phi_atom_pos_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
         <span class="n">psi_atom_pos_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
         <span class="n">chi_atom_pos</span>
         <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">torsion_angles_mask_padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">omega_mask_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span>
         <span class="n">phi_mask_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span>
         <span class="n">psi_mask_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span>
         <span class="n">chis_mask</span>
         <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">torsion_frames</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rigids_from_3_points</span><span class="p">(</span>
        <span class="n">point_on_neg_x_axis</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">torsions_atom_pos_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]),</span>
        <span class="n">origin</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">torsions_atom_pos_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]),</span>
        <span class="n">point_on_xy_plane</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">torsions_atom_pos_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
    <span class="n">inv_torsion_frames</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">invert_rigids</span><span class="p">(</span><span class="n">torsion_frames</span><span class="p">)</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">torsions_atom_pos_padding</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">forth_atom_rel_pos</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rigids_mul_vecs</span><span class="p">(</span><span class="n">inv_torsion_frames</span><span class="p">,</span> <span class="n">vecs</span><span class="p">)</span>
    <span class="n">torsion_angles_sin_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">forth_atom_rel_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">forth_atom_rel_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">torsion_angles_sin_cos</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">torsion_angles_sin_cos</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_multimer</span><span class="p">:</span>
        <span class="n">torsion_angles_sin_cos</span> <span class="o">=</span> <span class="n">torsion_angles_sin_cos</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])[((</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion_angles_sin_cos</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">chi_is_ambiguous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chi_pi_periodic</span><span class="p">)[</span><span class="n">true_aatype</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">torsion_angles_sin_cos</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">chi_is_ambiguous</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chi_pi_periodic</span><span class="p">),</span> <span class="n">true_aatype</span><span class="p">)</span>

    <span class="n">mirror_torsion_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">num_batch</span><span class="p">,</span> <span class="n">num_res</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span>
         <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">chi_is_ambiguous</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">alt_torsion_angles_sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">torsion_angles_sin_cos</span> <span class="o">*</span> <span class="n">mirror_torsion_angles</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">alt_torsions</span><span class="p">:</span>
        <span class="n">fix_torsions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">torsion_angles_sin_cos</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">torsion_angles_sin_cos</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">torsion_angles_sin_cos</span> <span class="o">=</span> <span class="n">torsion_angles_sin_cos</span> <span class="o">*</span> <span class="n">torsion_angles_mask_padding</span><span class="p">[</span>
            <span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">fix_torsions</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">torsion_angles_mask_padding</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="n">alt_torsion_angles_sin_cos</span> <span class="o">=</span> <span class="n">alt_torsion_angles_sin_cos</span> <span class="o">*</span> <span class="n">torsion_angles_mask_padding</span><span class="p">[</span>
            <span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">fix_torsions</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">torsion_angles_mask_padding</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">is_multimer</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;torsion_angles_sin_cos&#39;</span><span class="p">:</span> <span class="n">torsion_angles_sin_cos</span><span class="p">,</span>
            <span class="s1">&#39;alt_torsion_angles_sin_cos&#39;</span><span class="p">:</span> <span class="n">alt_torsion_angles_sin_cos</span><span class="p">,</span>
            <span class="s1">&#39;torsion_angles_mask&#39;</span><span class="p">:</span> <span class="n">torsion_angles_mask_padding</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;torsion_angles_sin_cos&#39;</span><span class="p">:</span> <span class="n">torsion_angles_sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># (N, 7, 2)</span>
        <span class="s1">&#39;alt_torsion_angles_sin_cos&#39;</span><span class="p">:</span> <span class="n">alt_torsion_angles_sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># (N, 7, 2)</span>
        <span class="s1">&#39;torsion_angles_mask&#39;</span><span class="p">:</span> <span class="n">torsion_angles_mask_padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># (N, 7)</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="atom37_to_frames"><a class="viewcode-back" href="../../../data/mindsponge.data.atom37_to_frames.html#mindsponge.data.atom37_to_frames">[文档]</a><span class="k">def</span> <span class="nf">atom37_to_frames</span><span class="p">(</span>
        <span class="n">aatype</span><span class="p">,</span>
        <span class="n">all_atom_positions</span><span class="p">,</span>
        <span class="n">all_atom_mask</span><span class="p">,</span>
        <span class="n">is_affine</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the torsion angle of up to 8 rigid groups for each residue, shape is :math:`[N_{res}, 8, 12]`,</span>
<span class="sd">    where 8 is indicates that each residue can be divided into up to 8 rigid groups according to the dependence of</span>
<span class="sd">    the atom on the torsion angle, there are 1 backbone frame and 7 side-chain frames.</span>
<span class="sd">    For the meaning of 12 ,the first 9 elements are the 9 components of rotation matrix, the last</span>
<span class="sd">    3 elements are the 3 component of translation matrix.</span>


<span class="sd">    Args:</span>
<span class="sd">        aatype(numpy.array):                Amino acid sequence, :math:`[N_{res}]` .</span>
<span class="sd">        all_atom_positions(numpy.array):    The coordinates of all atoms, presented as atom37, :math:`[N_{res}, 37, 3]`.</span>
<span class="sd">        all_atom_mask(numpy.array):         Mask of all atomic coordinates, :math:`[N_{res}, 37]`.</span>
<span class="sd">        is_affine(bool):                    Whether to perform affine, the default value is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary, the specific content is as follows.</span>

<span class="sd">        - **rigidgroups_gt_frames** (numpy.array) - The torsion angle of the 8 rigid body groups for each residue,</span>
<span class="sd">          :math:`[N_{res}, 8, 12]`.</span>
<span class="sd">        - **rigidgroups_gt_exists** (numpy.array) - The mask of rigidgroups_gt_frames denoting whether the rigid body</span>
<span class="sd">          group exists according to the experiment, :math:`[N_{res}, 8]`.</span>
<span class="sd">        - **rigidgroups_group_exists** (numpy.array) - Mask denoting whether given group is in principle present</span>
<span class="sd">          for given amino acid type, :math:`[N_{res}, 8]` .</span>
<span class="sd">        - **rigidgroups_group_is_ambiguous** (numpy.array) - Indicates that the position is chiral symmetry,</span>
<span class="sd">          :math:`[N_{res}, 8]` .</span>
<span class="sd">        - **rigidgroups_alt_gt_frames** (numpy.array) - 8 Frames with alternative atom renaming</span>
<span class="sd">          corresponding to &#39;all_atom_positions&#39; represented as flat</span>
<span class="sd">          12 dimensional array :math:`[N_{res}, 8, 12]` .</span>
<span class="sd">        - **backbone_affine_tensor** (numpy.array) - The translation and rotation of the local coordinates of each</span>
<span class="sd">          amino acid relative to the global coordinates, :math:`[N_{res}, 7]` , for the last dimension, the first 4</span>
<span class="sd">          elements are the affine tensor which contains the rotation information, the last 3 elements are the</span>
<span class="sd">          translations in space.</span>

<span class="sd">    Supported Platforms:</span>
<span class="sd">        ``Ascend`` ``GPU`` ``CPU``</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from mindsponge.data import atom37_to_frames</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import dtype as mstype</span>
<span class="sd">        &gt;&gt;&gt; from mindspore import Tensor</span>
<span class="sd">        &gt;&gt;&gt; aatype = np.ones(193,dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; all_atom_positions = np.ones((193,37,3),dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; all_atom_mask = np.ones((193,37),dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; result = atom37_to_frames(aatype,all_atom_positions,all_atom_mask)</span>
<span class="sd">        &gt;&gt;&gt; for key in result.keys():</span>
<span class="sd">        &gt;&gt;&gt;     print(key,result[key].shape)</span>
<span class="sd">        rigidgroups_gt_frames (193, 8, 12)</span>
<span class="sd">        rigidgroups_gt_exists (193, 8)</span>
<span class="sd">        rigidgroups_group_exists (193, 8)</span>
<span class="sd">        rigidgroups_group_is_ambiguous (193, 8)</span>
<span class="sd">        rigidgroups_alt_gt_frames (193, 8, 12)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">aatype_shape</span> <span class="o">=</span> <span class="n">aatype</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">flat_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">aatype</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">all_atom_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">all_atom_positions</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">all_atom_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">all_atom_mask</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">37</span><span class="p">])</span>

    <span class="n">rigid_group_names_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="mi">21</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="c1"># group 0: backbone frame</span>
    <span class="n">rigid_group_names_res</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CA&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">]</span>

    <span class="c1"># group 3: &#39;psi&#39;</span>
    <span class="n">rigid_group_names_res</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CA&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">]</span>

    <span class="c1"># group 4,5,6,7: &#39;chi1,2,3,4&#39;</span>
    <span class="k">for</span> <span class="n">restype</span><span class="p">,</span> <span class="n">letter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">restypes</span><span class="p">):</span>
        <span class="n">restype_name</span> <span class="o">=</span> <span class="n">restype_1to3</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">chi_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">chi_angles_mask</span><span class="p">[</span><span class="n">restype</span><span class="p">][</span><span class="n">chi_idx</span><span class="p">]:</span>
                <span class="n">atom_names</span> <span class="o">=</span> <span class="n">chi_angles_atoms</span><span class="p">[</span><span class="n">restype_name</span><span class="p">][</span><span class="n">chi_idx</span><span class="p">]</span>
                <span class="n">rigid_group_names_res</span><span class="p">[</span><span class="n">restype</span><span class="p">,</span> <span class="n">chi_idx</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">atom_names</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># create rigid group mask</span>
    <span class="n">rigid_group_mask_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">21</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">rigid_group_mask_res</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rigid_group_mask_res</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rigid_group_mask_res</span><span class="p">[:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="n">chi_angles_mask</span>

    <span class="n">lookup_table</span> <span class="o">=</span> <span class="n">atom_order</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rigid_group_atom37_idx_restype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">lookup_table</span><span class="p">[</span><span class="n">x</span><span class="p">])(</span>
        <span class="n">rigid_group_names_res</span><span class="p">)</span>

    <span class="n">rigid_group_atom37_idx_residx</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span>
        <span class="n">rigid_group_atom37_idx_restype</span><span class="p">,</span> <span class="n">flat_aatype</span><span class="p">)</span>

    <span class="n">base_atom_pos</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span>
        <span class="n">all_atom_positions</span><span class="p">,</span>
        <span class="n">rigid_group_atom37_idx_residx</span><span class="p">,</span>
        <span class="n">batch_dims</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">gt_frames</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rigids_from_3_points</span><span class="p">(</span>
        <span class="n">point_on_neg_x_axis</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">base_atom_pos</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span>
        <span class="n">origin</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">base_atom_pos</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]),</span>
        <span class="n">point_on_xy_plane</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">vecs_from_tensor</span><span class="p">(</span><span class="n">base_atom_pos</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]))</span>

    <span class="c1"># get the group mask</span>
    <span class="n">group_masks</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span><span class="n">rigid_group_mask_res</span><span class="p">,</span> <span class="n">flat_aatype</span><span class="p">)</span>

    <span class="c1"># get the atom mask</span>
    <span class="n">gt_atoms_exists</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span>
        <span class="n">all_atom_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="n">rigid_group_atom37_idx_residx</span><span class="p">,</span>
        <span class="n">batch_dims</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gt_masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">gt_atoms_exists</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">group_masks</span>

    <span class="n">rotations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">rotations</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">rotations</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">gt_frames</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rigids_mul_rots</span><span class="p">(</span><span class="n">gt_frames</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rots_from_tensor</span><span class="p">(</span><span class="n">rotations</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="n">rigid_group_is_ambiguous_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">21</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">rigid_group_rotations_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="p">[</span><span class="mi">21</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">restype_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">residue_atom_renaming_swaps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">restype</span> <span class="o">=</span> <span class="n">restype_order</span><span class="p">[</span><span class="n">restype_3to1</span><span class="p">[</span><span class="n">restype_name</span><span class="p">]]</span>
        <span class="n">chi_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">chi_angles_mask</span><span class="p">[</span><span class="n">restype</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">rigid_group_is_ambiguous_res</span><span class="p">[</span><span class="n">restype</span><span class="p">,</span> <span class="n">chi_idx</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">rigid_group_rotations_res</span><span class="p">[</span><span class="n">restype</span><span class="p">,</span> <span class="n">chi_idx</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">rigid_group_rotations_res</span><span class="p">[</span><span class="n">restype</span><span class="p">,</span> <span class="n">chi_idx</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Gather the ambiguity information for each residue.</span>
    <span class="n">rigid_group_is_ambiguous_res_index</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span>
        <span class="n">rigid_group_is_ambiguous_res</span><span class="p">,</span> <span class="n">flat_aatype</span><span class="p">)</span>
    <span class="n">rigid_group_ambiguity_rotation_res_index</span> <span class="o">=</span> <span class="n">np_gather_ops</span><span class="p">(</span>
        <span class="n">rigid_group_rotations_res</span><span class="p">,</span> <span class="n">flat_aatype</span><span class="p">)</span>

    <span class="c1"># Create the alternative ground truth frames.</span>
    <span class="n">alt_gt_frames</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rigids_mul_rots</span><span class="p">(</span>
        <span class="n">gt_frames</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rots_from_tensor</span><span class="p">(</span><span class="n">rigid_group_ambiguity_rotation_res_index</span><span class="p">,</span> <span class="n">use_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="n">gt_frames_flat12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">gt_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">alt_gt_frames_flat12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">alt_gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">alt_gt_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># reshape back to original residue layout</span>
    <span class="n">gt_frames_flat12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gt_frames_flat12</span><span class="p">,</span> <span class="n">aatype_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
    <span class="n">gt_masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gt_masks</span><span class="p">,</span> <span class="n">aatype_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span><span class="p">,))</span>
    <span class="n">group_masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">group_masks</span><span class="p">,</span> <span class="n">aatype_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span><span class="p">,))</span>
    <span class="n">gt_frames_flat12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gt_frames_flat12</span><span class="p">,</span> <span class="n">aatype_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
    <span class="n">rigid_group_is_ambiguous_res_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rigid_group_is_ambiguous_res_index</span><span class="p">,</span> <span class="n">aatype_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span><span class="p">,))</span>
    <span class="n">alt_gt_frames_flat12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">alt_gt_frames_flat12</span><span class="p">,</span>
                                      <span class="n">aatype_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_affine</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;rigidgroups_gt_frames&#39;</span><span class="p">:</span> <span class="n">gt_frames_flat12</span><span class="p">,</span>  <span class="c1"># shape (..., 8, 12)</span>
            <span class="s1">&#39;rigidgroups_gt_exists&#39;</span><span class="p">:</span> <span class="n">gt_masks</span><span class="p">,</span>  <span class="c1"># shape (..., 8)</span>
            <span class="s1">&#39;rigidgroups_group_exists&#39;</span><span class="p">:</span> <span class="n">group_masks</span><span class="p">,</span>  <span class="c1"># shape (..., 8)</span>
            <span class="s1">&#39;rigidgroups_group_is_ambiguous&#39;</span><span class="p">:</span>
                <span class="n">rigid_group_is_ambiguous_res_index</span><span class="p">,</span>  <span class="c1"># shape (..., 8)</span>
            <span class="s1">&#39;rigidgroups_alt_gt_frames&#39;</span><span class="p">:</span> <span class="n">alt_gt_frames_flat12</span><span class="p">,</span>  <span class="c1"># shape (..., 8, 12)</span>
        <span class="p">}</span>

    <span class="n">rotation</span> <span class="o">=</span> <span class="p">[[</span><span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span> <span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">5</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">6</span><span class="p">],</span> <span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">7</span><span class="p">],</span> <span class="n">gt_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">8</span><span class="p">]]]</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="p">[</span><span class="n">gt_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">gt_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">gt_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">backbone_affine_tensor</span> <span class="o">=</span> <span class="n">to_tensor</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;rigidgroups_gt_frames&#39;</span><span class="p">:</span> <span class="n">gt_frames_flat12</span><span class="p">,</span>  <span class="c1"># shape (..., 8, 12)</span>
        <span class="s1">&#39;rigidgroups_gt_exists&#39;</span><span class="p">:</span> <span class="n">gt_masks</span><span class="p">,</span>  <span class="c1"># shape (..., 8)</span>
        <span class="s1">&#39;rigidgroups_group_exists&#39;</span><span class="p">:</span> <span class="n">group_masks</span><span class="p">,</span>  <span class="c1"># shape (..., 8)</span>
        <span class="s1">&#39;rigidgroups_group_is_ambiguous&#39;</span><span class="p">:</span> <span class="n">rigid_group_is_ambiguous_res_index</span><span class="p">,</span>  <span class="c1"># shape (..., 8)</span>
        <span class="s1">&#39;rigidgroups_alt_gt_frames&#39;</span><span class="p">:</span> <span class="n">alt_gt_frames_flat12</span><span class="p">,</span>  <span class="c1"># shape (..., 8, 12)</span>
        <span class="s1">&#39;backbone_affine_tensor&#39;</span><span class="p">:</span> <span class="n">backbone_affine_tensor</span><span class="p">,</span>  <span class="c1"># shape (..., 7)</span>
    <span class="p">}</span></div>


<span class="k">def</span> <span class="nf">get_chi_atom_pos_indices</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get the atom indices for computing chi angles for all residue types&quot;&quot;&quot;</span>
    <span class="n">chi_atom_pos_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">residue_name</span> <span class="ow">in</span> <span class="n">restypes</span><span class="p">:</span>
        <span class="n">residue_name</span> <span class="o">=</span> <span class="n">restype_1to3</span><span class="p">[</span><span class="n">residue_name</span><span class="p">]</span>
        <span class="n">residue_chi_angles</span> <span class="o">=</span> <span class="n">chi_angles_atoms</span><span class="p">[</span><span class="n">residue_name</span><span class="p">]</span>
        <span class="n">atom_pos_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">chi_angle</span> <span class="ow">in</span> <span class="n">residue_chi_angles</span><span class="p">:</span>
            <span class="n">atom_pos_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">atom_order</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">chi_angle</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_pos_indices</span><span class="p">)):</span>
            <span class="n">atom_pos_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># For chi angles not defined on the AA.</span>
        <span class="n">chi_atom_pos_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_pos_indices</span><span class="p">)</span>

    <span class="n">chi_atom_pos_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># For UNKNOWN residue.</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chi_atom_pos_indices</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">gather</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;gather operation&quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">np_gather_ops</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">batch_dims</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_multimer</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;np gather operation&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_multimer</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">-</span> <span class="n">batch_dims</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">batch_dims</span><span class="p">]):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">remaining_dims</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">batch_dims</span><span class="p">)]</span>
        <span class="n">remaining_dims</span><span class="p">[</span><span class="n">axis</span> <span class="o">-</span> <span class="n">batch_dims</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">ranges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">remaining_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">params</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ranges</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">batch_dims</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gather</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">batch_dims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">-</span> <span class="n">batch_dims</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">-</span> <span class="n">batch_dims</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">gather</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">gather</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rot_to_quat</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">unstack_inputs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;transfer the rotation matrix to quaternion matrix&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">unstack_inputs</span><span class="p">:</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="p">[[</span><span class="n">xx</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">xz</span><span class="p">],</span> <span class="p">[</span><span class="n">yx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">yz</span><span class="p">],</span> <span class="p">[</span><span class="n">zx</span><span class="p">,</span> <span class="n">zy</span><span class="p">,</span> <span class="n">zz</span><span class="p">]]</span> <span class="o">=</span> <span class="n">rot</span>

    <span class="n">k</span> <span class="o">=</span> <span class="p">[[</span><span class="n">xx</span> <span class="o">+</span> <span class="n">yy</span> <span class="o">+</span> <span class="n">zz</span><span class="p">,</span> <span class="n">zy</span> <span class="o">-</span> <span class="n">yz</span><span class="p">,</span> <span class="n">xz</span> <span class="o">-</span> <span class="n">zx</span><span class="p">,</span> <span class="n">yx</span> <span class="o">-</span> <span class="n">xy</span><span class="p">],</span>
         <span class="p">[</span><span class="n">zy</span> <span class="o">-</span> <span class="n">yz</span><span class="p">,</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">zz</span><span class="p">,</span> <span class="n">xy</span> <span class="o">+</span> <span class="n">yx</span><span class="p">,</span> <span class="n">xz</span> <span class="o">+</span> <span class="n">zx</span><span class="p">],</span>
         <span class="p">[</span><span class="n">xz</span> <span class="o">-</span> <span class="n">zx</span><span class="p">,</span> <span class="n">xy</span> <span class="o">+</span> <span class="n">yx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">zz</span><span class="p">,</span> <span class="n">yz</span> <span class="o">+</span> <span class="n">zy</span><span class="p">],</span>
         <span class="p">[</span><span class="n">yx</span> <span class="o">-</span> <span class="n">xy</span><span class="p">,</span> <span class="n">xz</span> <span class="o">+</span> <span class="n">zx</span><span class="p">,</span> <span class="n">yz</span> <span class="o">+</span> <span class="n">zy</span><span class="p">,</span> <span class="n">zz</span> <span class="o">-</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">yy</span><span class="p">]]</span>

    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">k</span><span class="p">],</span>
                             <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># compute eigenvalues</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">qs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">to_tensor</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get affine based on rotation and translation&quot;&quot;&quot;</span>
    <span class="n">quaternion</span> <span class="o">=</span> <span class="n">rot_to_quat</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">quaternion</span><span class="p">]</span> <span class="o">+</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">translation</span><span class="p">],</span>
        <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">convert_monomer_features</span><span class="p">(</span><span class="n">chain_id</span><span class="p">,</span> <span class="n">aatype</span><span class="p">,</span> <span class="n">template_aatype</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reshapes and modifies monomer features for multimer models.&quot;&quot;&quot;</span>

    <span class="n">auth_chain_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">chain_id</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>
    <span class="n">new_order_list</span> <span class="o">=</span> <span class="n">MAP_HHBLITS_AATYPE_TO_OUR_AATYPE</span>
    <span class="n">monomer_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">aatype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">monomer_template_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">template_aatype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">monomer_template_aatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">new_order_list</span><span class="p">,</span> <span class="n">monomer_template_aatype</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">auth_chain_id</span><span class="p">,</span> <span class="n">monomer_aatype</span><span class="p">,</span> <span class="n">monomer_template_aatype</span>


<span class="k">def</span> <span class="nf">convert_unnecessary_leading_dim_feats</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">domain_name</span><span class="p">,</span> <span class="n">num_alignments</span><span class="p">,</span> <span class="n">seq_length</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get first dimension data of unnecessary features.&quot;&quot;&quot;</span>

    <span class="n">monomer_sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sequence</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">monomer_domain_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">domain_name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">domain_name</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">monomer_num_alignments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">num_alignments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">num_alignments</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">monomer_seq_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">seq_length</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">seq_length</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">converted_feature</span> <span class="o">=</span> <span class="p">(</span><span class="n">monomer_sequence</span><span class="p">,</span> <span class="n">monomer_domain_name</span><span class="p">,</span> <span class="n">monomer_num_alignments</span><span class="p">,</span> <span class="n">monomer_seq_length</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">converted_feature</span>


<span class="k">def</span> <span class="nf">process_unmerged_features</span><span class="p">(</span><span class="n">deletion_matrix_int</span><span class="p">,</span> <span class="n">deletion_matrix_int_all_seq</span><span class="p">,</span> <span class="n">aatype</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">num_chains</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Postprocessing stage for per-chain features before merging.&quot;&quot;&quot;</span>
    <span class="c1"># Convert deletion matrices to float.</span>
    <span class="n">deletion_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">deletion_matrix_int</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">deletion_matrix_all_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">deletion_matrix_int_all_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">all_atom_mask</span> <span class="o">=</span> <span class="n">STANDARD_ATOM_MASK</span><span class="p">[</span><span class="n">aatype</span><span class="p">]</span>
    <span class="n">all_atom_mask</span> <span class="o">=</span> <span class="n">all_atom_mask</span>
    <span class="n">all_atom_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_atom_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">deletion_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">deletion_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Add assembly_num_chains.</span>
    <span class="n">assembly_num_chains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">num_chains</span><span class="p">)</span>
    <span class="n">entity_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">entity_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">post_feature</span> <span class="o">=</span> <span class="p">(</span><span class="n">deletion_matrix</span><span class="p">,</span> <span class="n">deletion_matrix_all_seq</span><span class="p">,</span> <span class="n">deletion_mean</span><span class="p">,</span> <span class="n">all_atom_mask</span><span class="p">,</span> <span class="n">all_atom_positions</span><span class="p">,</span>
                    <span class="n">assembly_num_chains</span><span class="p">,</span> <span class="n">entity_mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">post_feature</span>


<span class="k">def</span> <span class="nf">get_crop_size</span><span class="p">(</span><span class="n">num_alignments_all_seq</span><span class="p">,</span> <span class="n">msa_all_seq</span><span class="p">,</span> <span class="n">msa_crop_size</span><span class="p">,</span> <span class="n">msa_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get maximum msa crop size</span>

<span class="sd">    Args:</span>
<span class="sd">        num_alignments_all_seq: num_alignments for all sequence, which record the total number of msa</span>
<span class="sd">        msa_all_seq: un-paired sequences for all msa.</span>
<span class="sd">        msa_crop_size: The total number of sequences to crop from the MSA.</span>
<span class="sd">        msa_size: number of msa</span>

<span class="sd">    Returns:</span>
<span class="sd">        msa_crop_size: msa sized to be cropped</span>
<span class="sd">        msa_crop_size_all_seq: msa_crop_size for features with &quot;_all_seq&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msa_size_all_seq</span> <span class="o">=</span> <span class="n">num_alignments_all_seq</span>
    <span class="n">msa_crop_size_all_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">msa_size_all_seq</span><span class="p">,</span> <span class="n">msa_crop_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># We reduce the number of un-paired sequences, by the number of times a</span>
    <span class="c1"># sequence from this chain&#39;s MSA is included in the paired MSA.  This keeps</span>
    <span class="c1"># the MSA size for each chain roughly constant.</span>
    <span class="n">msa_all_seq</span> <span class="o">=</span> <span class="n">msa_all_seq</span><span class="p">[:</span><span class="n">msa_crop_size_all_seq</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">num_non_gapped_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">msa_all_seq</span> <span class="o">!=</span> <span class="n">restypes_with_x_and_gap</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">num_non_gapped_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">num_non_gapped_pairs</span><span class="p">,</span> <span class="n">msa_crop_size_all_seq</span><span class="p">)</span>

    <span class="c1"># Restrict the unpaired crop size so that paired+unpaired sequences do not</span>
    <span class="c1"># exceed msa_seqs_per_chain for each chain.</span>
    <span class="n">max_msa_crop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">msa_crop_size</span> <span class="o">-</span> <span class="n">num_non_gapped_pairs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">msa_crop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">msa_size</span><span class="p">,</span> <span class="n">max_msa_crop_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">msa_crop_size</span><span class="p">,</span> <span class="n">msa_crop_size_all_seq</span>


<span class="k">def</span> <span class="nf">make_seq_mask</span><span class="p">(</span><span class="n">entity_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;seq mask info, True for entity_id &gt; 0, False for entity_id &lt;= 0.&quot;&quot;&quot;</span>

    <span class="n">seq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">entity_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">seq_mask</span>


<span class="k">def</span> <span class="nf">make_msa_mask</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask features are all ones, but will later be zero-padded.&quot;&quot;&quot;</span>

    <span class="n">msa_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">seq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">entity_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">msa_mask</span> <span class="o">*=</span> <span class="n">seq_mask</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">msa_mask</span>


<span class="k">def</span> <span class="nf">add_padding</span><span class="p">(</span><span class="n">feature_name</span><span class="p">,</span> <span class="n">feature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get padding data with specified shapes of feature&quot;&quot;&quot;</span>

    <span class="n">num_res</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="n">MSA_PAD_VALUES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feature_name</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_res</span><span class="p">],</span> <span class="n">feature</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">padding</span>


<span class="k">def</span> <span class="nf">generate_random_sample</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">model_config</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;generate_random_sample&#39;&#39;&#39;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">num_noise</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">latent</span><span class="o">.</span><span class="n">num_noise</span>
    <span class="n">latent_dim</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">latent</span><span class="o">.</span><span class="n">latent_dim</span>

    <span class="n">context_true_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">context_true_prob</span><span class="p">)</span>
    <span class="n">keep_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">keep_prob</span><span class="p">)</span>

    <span class="n">available_msa</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">available_msa_fraction</span> <span class="o">*</span> <span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">max_msa_clusters</span><span class="p">)</span>
    <span class="n">available_msa</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">available_msa</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">max_msa_clusters</span><span class="p">)</span>

    <span class="n">evogen_random_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_noise</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">max_msa_clusters</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">eval</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="n">latent_dim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># (Nseq,):</span>
    <span class="n">context_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">max_msa_clusters</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">max_msa_clusters</span><span class="p">)</span>
    <span class="n">context_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">context_true_prob</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">z1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">context_mask</span><span class="p">[</span><span class="n">available_msa</span><span class="p">:]</span> <span class="o">*=</span> <span class="mi">0</span>

    <span class="c1"># (Nseq,):</span>
    <span class="n">target_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">max_msa_clusters</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">model_config</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">max_msa_clusters</span><span class="p">)</span>
    <span class="n">target_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">keep_prob</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">z2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">context_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">target_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">evogen_context_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">context_mask</span><span class="p">,</span> <span class="n">target_mask</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">evogen_random_data</span><span class="p">,</span> <span class="n">evogen_context_mask</span>


<span class="k">def</span> <span class="nf">to_tensor_4x4</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
    <span class="n">rots</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">9</span><span class="p">]</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">9</span><span class="p">:]</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">rots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">rots</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">arrays</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">rots</span>
    <span class="n">arrays</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
    <span class="n">arrays</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">arrays</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2022, MindSpore.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
	<script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>