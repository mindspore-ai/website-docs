<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SSD for Object Detection &mdash; MindSpore master documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sentiment Classification Implemented by RNN" href="../nlp/sentiment_analysis.html" />
    <link rel="prev" title="ShuffleNet for Image Classification" href="shufflenet.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">CV</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="resnet50.html">ResNet-50 for Image Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="transfer_learning.html">ResNet50 Transfer Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="fgsm.html">FGSM Network Adversarial Attack</a></li>
<li class="toctree-l1"><a class="reference internal" href="vit.html">Vision Transformer Image Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="cnnctc.html">CNN and CTC for Recognizing Text from Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="fcn8s.html">FCN for Image Semantic Segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="shufflenet.html">ShuffleNet for Image Classification</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SSD for Object Detection</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#model-introduction">Model Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#model-structure">Model Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#model-features">Model Features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#environment-preparation">Environment Preparation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-preparation-and-processing">Data Preparation and Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-sampling">Data Sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-dataset">Creating a Dataset</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#model-building">Model Building</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#backbone-layer">Backbone Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extra-feature-layer">Extra Feature Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#anchor">Anchor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#detection-layer">Detection Layer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#loss-function">Loss Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#location-loss-function">Location Loss Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#confidence-loss-function">Confidence Loss Function</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#training-process">Training Process</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#1-prior-box-matching">(1) Prior box matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#2-loss-function">(2) Loss function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#3-data-augmentation">(3) Data augmentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#evaluation">Evaluation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ap-and-ar-explanations">AP and AR Explanations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ap-and-ar-formulas">AP and AR Formulas</a></li>
<li class="toctree-l3"><a class="reference internal" href="#output-metrics-for-the-following-code-running-results">Output Metrics for the Following Code Running Results</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NLP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../nlp/sentiment_analysis.html">Sentiment Classification Implemented by RNN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nlp/sequence_labeling.html">LSTM+CRF Sequence Labeling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generative</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../generative/gan.html">GAN for Image Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generative/dcgan.html">Generating Cartoon Head Portrait via DCGAN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generative/pix2pix.html">Pix2Pix for Image Translation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generative/cyclegan.html">CycleGAN for Image Style Migration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generative/diffusion.html">Diffusion Model</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>SSD for Object Detection</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/cv/ssd.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="ssd-for-object-detection">
<h1>SSD for Object Detection<a class="headerlink" href="#ssd-for-object-detection" title="Permalink to this headline"></a></h1>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/blob/r1.11/tutorials/application/source_en/cv/ssd.md"><img alt="View Source On Gitee" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/resource/_static/logo_source_en.png" /></a></p>
<section id="model-introduction">
<h2>Model Introduction<a class="headerlink" href="#model-introduction" title="Permalink to this headline"></a></h2>
<p>Single shot multibox detector (SSD) is an object detection algorithm proposed by Wei Liu at ECCV 2016. On the VOC 2007 test set using NVIDIA Titan X, the SSD reaches 74.3% mAP and 59 FPS for a 300 x 300 input network. For the 512 x 512 network, the SSD reaches 76.9% mAP, surpassing Faster RCNN (73.2% mAP). For details, see the paper.
Mainstream SSD object detection algorithms are classified into the following types:</p>
<ol class="arabic">
<li><p>Two-stage method: RCNN series<br></p>
<p>The candidate boxes are generated through the algorithm, and then classified and regressed.<br></p>
</li>
<li><p>One-stage method: YOLO and SSD<br></p>
<p>Location information is directly provided through the backbone network and does not need to be generated by region.<br></p>
</li>
</ol>
<p>SSD is the one-stage object detection algorithm. Feature extraction is performed by using a convolutional neural network, and different feature layers are used for detection output. Therefore, the SSD is a multi-scale detection method. At the feature layer to be detected, a 3 <span class="math notranslate nohighlight">\(\times\)</span> 3 convolution is directly used to transform the channel. SSD uses the anchor policy, and anchors with different length-width ratios are preset. Each output feature layer predicts a plurality of detection boxes (4 or 6) based on the anchor. A multi-scale detection method is used. The shallow layer is used to detect small objects, and the deep layer is used to detect large objects. The following figure shows the SSD framework.</p>
<p><img alt="SSD-1" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_1.png" /></p>
<section id="model-structure">
<h3>Model Structure<a class="headerlink" href="#model-structure" title="Permalink to this headline"></a></h3>
<p>The SSD uses VGG-16 as a basic model, and then adds a convolutional layer based on VGG-16 to obtain more feature maps for detection. The following figure shows the SSD network structure. The upper part is the SSD model, and the lower part is the YOLO model. It can be seen that the SSD uses a multi-scale feature map for detection.</p>
<p><img alt="SSD-2" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_2.jpg" />
<br /></p>
<p>Comparison of two one-stage object detection algorithms:<br>
The SSD first performs feature extraction continuously through convolution. On a network that needs to detect an object, an output is directly obtained through 3 <span class="math notranslate nohighlight">\(\times\)</span> 3 convolution. The number of convolution channels is determined by the number of anchors and the number of classes, which is equal to (Number of anchors x (Number of classes + 4)).
The SSD compares the YOLO series object detection methods. The difference is that the SSD obtains the final bounding box through convolution, while the YOLO obtains the one-dimensional vector in the form of full connection for the final output, and disassembles the vector to obtain the final detection box.</p>
</section>
<section id="model-features">
<h3>Model Features<a class="headerlink" href="#model-features" title="Permalink to this headline"></a></h3>
<ul>
<li><p>Multi-scale object detection</p>
<p>As shown in the SSD network structure, the SSD uses multiple feature layers. The sizes of the feature layers are 38 <span class="math notranslate nohighlight">\(\times\)</span> 38, 19 <span class="math notranslate nohighlight">\(\times\)</span> 19, 10 <span class="math notranslate nohighlight">\(\times\)</span> 10, 5 <span class="math notranslate nohighlight">\(\times\)</span> 5, 3 <span class="math notranslate nohighlight">\(\times\)</span> 3, and 1 <span class="math notranslate nohighlight">\(\times\)</span> 1. There are six feature map sizes in total. A large-scale feature map (a feature map in the front) can be used to detect small objects, and a small-scale feature map (a feature map in the rear) can be used to detect large objects. Multi-scale features have been proven highly effective for small object detection (the SSD belongs to intensive detection).</p>
</li>
<li><p>Convolution used for detection</p>
<p>Different from YOLO that finally uses a fully-connected layer, the SSD directly uses convolution to extract detection results from different feature maps. For a feature map whose shape is m <span class="math notranslate nohighlight">\(\times\)</span> n <span class="math notranslate nohighlight">\(\times\)</span> p, only a relatively small convolution kernel such as 3 <span class="math notranslate nohighlight">\(\times\)</span> 3 <span class="math notranslate nohighlight">\(\times\)</span> p needs to be used to obtain a detection value.</p>
</li>
<li><p>Preset anchor</p>
<p>In YOLOv1, a size of an object is directly predicted by a network. In this manner, a length-width ratio and a size of a prediction box are not limited, and training is difficult. In the SSD, a preset anchor (also called default bounding boxes in the SSD paper) is used. The size of the prediction box is fine-tuned under the guidance of anchor.</p>
</li>
</ul>
</section>
</section>
<section id="environment-preparation">
<h2>Environment Preparation<a class="headerlink" href="#environment-preparation" title="Permalink to this headline"></a></h2>
<p>This case is based on MindSpore. Before the experiment, ensure that mindspore, download, pycocotools, and opencv-python have been installed on the local host.</p>
</section>
<section id="data-preparation-and-processing">
<h2>Data Preparation and Processing<a class="headerlink" href="#data-preparation-and-processing" title="Permalink to this headline"></a></h2>
<p>The dataset used in this case is COCO 2017. To facilitate data saving and loading, the COCO dataset is converted into the MindRecord format before data reading. The MindSpore Record data format reduces disk I/O and network I/O overheads, improving user experience and performance.
First, we need to download the processed COCO dataset in MindRecord format.
Run the following code to download and decompress the dataset to a specified path.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">download</span> <span class="kn">import</span> <span class="n">download</span>

<span class="n">dataset_url</span> <span class="o">=</span> <span class="s2">&quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/ssd_datasets.zip&quot;</span>
<span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span>
<span class="n">path</span> <span class="o">=</span> <span class="n">download</span><span class="p">(</span><span class="n">dataset_url</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;zip&quot;</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/ssd_datasets.zip (16.6 MB)

file_sizes: 100%|██████████████████████████| 17.4M/17.4M [00:00&lt;00:00, 26.9MB/s]
Extracting zip file...
Successfully downloaded / unzipped to ./
</pre></div>
</div>
<p>We define some inputs for data processing.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">coco_root</span> <span class="o">=</span> <span class="s2">&quot;./datasets/&quot;</span>
<span class="n">anno_json</span> <span class="o">=</span> <span class="s2">&quot;./datasets/annotations/instances_val2017.json&quot;</span>

<span class="n">train_cls</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;background&#39;</span><span class="p">,</span> <span class="s1">&#39;person&#39;</span><span class="p">,</span> <span class="s1">&#39;bicycle&#39;</span><span class="p">,</span> <span class="s1">&#39;car&#39;</span><span class="p">,</span> <span class="s1">&#39;motorcycle&#39;</span><span class="p">,</span> <span class="s1">&#39;airplane&#39;</span><span class="p">,</span> <span class="s1">&#39;bus&#39;</span><span class="p">,</span>
             <span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="s1">&#39;truck&#39;</span><span class="p">,</span> <span class="s1">&#39;boat&#39;</span><span class="p">,</span> <span class="s1">&#39;traffic light&#39;</span><span class="p">,</span> <span class="s1">&#39;fire hydrant&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stop sign&#39;</span><span class="p">,</span> <span class="s1">&#39;parking meter&#39;</span><span class="p">,</span> <span class="s1">&#39;bench&#39;</span><span class="p">,</span> <span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span>
             <span class="s1">&#39;horse&#39;</span><span class="p">,</span> <span class="s1">&#39;sheep&#39;</span><span class="p">,</span> <span class="s1">&#39;cow&#39;</span><span class="p">,</span> <span class="s1">&#39;elephant&#39;</span><span class="p">,</span> <span class="s1">&#39;bear&#39;</span><span class="p">,</span> <span class="s1">&#39;zebra&#39;</span><span class="p">,</span>
             <span class="s1">&#39;giraffe&#39;</span><span class="p">,</span> <span class="s1">&#39;backpack&#39;</span><span class="p">,</span> <span class="s1">&#39;umbrella&#39;</span><span class="p">,</span> <span class="s1">&#39;handbag&#39;</span><span class="p">,</span> <span class="s1">&#39;tie&#39;</span><span class="p">,</span>
             <span class="s1">&#39;suitcase&#39;</span><span class="p">,</span> <span class="s1">&#39;frisbee&#39;</span><span class="p">,</span> <span class="s1">&#39;skis&#39;</span><span class="p">,</span> <span class="s1">&#39;snowboard&#39;</span><span class="p">,</span> <span class="s1">&#39;sports ball&#39;</span><span class="p">,</span>
             <span class="s1">&#39;kite&#39;</span><span class="p">,</span> <span class="s1">&#39;baseball bat&#39;</span><span class="p">,</span> <span class="s1">&#39;baseball glove&#39;</span><span class="p">,</span> <span class="s1">&#39;skateboard&#39;</span><span class="p">,</span>
             <span class="s1">&#39;surfboard&#39;</span><span class="p">,</span> <span class="s1">&#39;tennis racket&#39;</span><span class="p">,</span> <span class="s1">&#39;bottle&#39;</span><span class="p">,</span> <span class="s1">&#39;wine glass&#39;</span><span class="p">,</span> <span class="s1">&#39;cup&#39;</span><span class="p">,</span>
             <span class="s1">&#39;fork&#39;</span><span class="p">,</span> <span class="s1">&#39;knife&#39;</span><span class="p">,</span> <span class="s1">&#39;spoon&#39;</span><span class="p">,</span> <span class="s1">&#39;bowl&#39;</span><span class="p">,</span> <span class="s1">&#39;banana&#39;</span><span class="p">,</span> <span class="s1">&#39;apple&#39;</span><span class="p">,</span>
             <span class="s1">&#39;sandwich&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;broccoli&#39;</span><span class="p">,</span> <span class="s1">&#39;carrot&#39;</span><span class="p">,</span> <span class="s1">&#39;hot dog&#39;</span><span class="p">,</span> <span class="s1">&#39;pizza&#39;</span><span class="p">,</span>
             <span class="s1">&#39;donut&#39;</span><span class="p">,</span> <span class="s1">&#39;cake&#39;</span><span class="p">,</span> <span class="s1">&#39;chair&#39;</span><span class="p">,</span> <span class="s1">&#39;couch&#39;</span><span class="p">,</span> <span class="s1">&#39;potted plant&#39;</span><span class="p">,</span> <span class="s1">&#39;bed&#39;</span><span class="p">,</span>
             <span class="s1">&#39;dining table&#39;</span><span class="p">,</span> <span class="s1">&#39;toilet&#39;</span><span class="p">,</span> <span class="s1">&#39;tv&#39;</span><span class="p">,</span> <span class="s1">&#39;laptop&#39;</span><span class="p">,</span> <span class="s1">&#39;mouse&#39;</span><span class="p">,</span> <span class="s1">&#39;remote&#39;</span><span class="p">,</span>
             <span class="s1">&#39;keyboard&#39;</span><span class="p">,</span> <span class="s1">&#39;cell phone&#39;</span><span class="p">,</span> <span class="s1">&#39;microwave&#39;</span><span class="p">,</span> <span class="s1">&#39;oven&#39;</span><span class="p">,</span> <span class="s1">&#39;toaster&#39;</span><span class="p">,</span> <span class="s1">&#39;sink&#39;</span><span class="p">,</span>
             <span class="s1">&#39;refrigerator&#39;</span><span class="p">,</span> <span class="s1">&#39;book&#39;</span><span class="p">,</span> <span class="s1">&#39;clock&#39;</span><span class="p">,</span> <span class="s1">&#39;vase&#39;</span><span class="p">,</span> <span class="s1">&#39;scissors&#39;</span><span class="p">,</span>
             <span class="s1">&#39;teddy bear&#39;</span><span class="p">,</span> <span class="s1">&#39;hair drier&#39;</span><span class="p">,</span> <span class="s1">&#39;toothbrush&#39;</span><span class="p">]</span>

<span class="n">train_cls_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">train_cls</span><span class="p">):</span>
    <span class="n">train_cls_dict</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</pre></div>
</div>
<section id="data-sampling">
<h3>Data Sampling<a class="headerlink" href="#data-sampling" title="Permalink to this headline"></a></h3>
<p>To make the model more robust to various input object sizes and shapes, the SSD algorithm randomly samples each training image using one of the following options:</p>
<ul class="simple">
<li><p>Use the entire original input image.</p></li>
<li><p>Sample a region so that the minimum intersection-over-union ratio between the sampled region and the original image is 0.1, 0.3, 0.5, 0.7, or 0.9.</p></li>
<li><p>Randomly sample a region.</p></li>
</ul>
<p>The size of each sampling region is [0.3,1] of the size of the original image, and the aspect ratio is between 1/2 and 2. If the center of the actual label box is within the sampling region, the overlapping part is retained as the real label box of the new image. After the foregoing sampling steps, each sampling region is adjusted to a fixed size, and is flipped horizontally with a probability of 0.5.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">_rand</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the intersect of two sets of boxes.&quot;&quot;&quot;</span>
    <span class="n">max_yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">box_b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">min_yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">box_b</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="n">max_yx</span> <span class="o">-</span> <span class="n">min_yx</span><span class="p">),</span> <span class="n">a_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inter</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">jaccard_numpy</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the jaccard overlap of two sets of boxes.&quot;&quot;&quot;</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">)</span>
    <span class="n">area_a</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="n">area_b</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">box_b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">union</span> <span class="o">=</span> <span class="n">area_a</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">-</span> <span class="n">inter</span>
    <span class="k">return</span> <span class="n">inter</span> <span class="o">/</span> <span class="n">union</span>

<span class="k">def</span> <span class="nf">random_sample_crop</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Crop images and boxes randomly.&quot;&quot;&quot;</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">min_iou</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">min_iou</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
        <span class="n">image_t</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_rand</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_rand</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">height</span>
        <span class="c1"># aspect ratio constraint b/t .5 &amp; 2</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">/</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="ow">or</span> <span class="n">h</span> <span class="o">/</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">left</span> <span class="o">=</span> <span class="n">_rand</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">_rand</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">h</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">w</span><span class="p">)])</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">jaccard_numpy</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">rect</span><span class="p">)</span>

        <span class="c1"># dropout some boxes</span>
        <span class="n">drop_mask</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">drop_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">overlap</span><span class="p">[</span><span class="n">drop_mask</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_iou</span> <span class="ow">and</span> <span class="n">overlap</span><span class="p">[</span><span class="n">drop_mask</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">min_iou</span> <span class="o">+</span> <span class="mf">0.2</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">image_t</span> <span class="o">=</span> <span class="n">image_t</span><span class="p">[</span><span class="n">rect</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">rect</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">rect</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">rect</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># mask in that both m1 and m2 are true</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">*</span> <span class="n">m2</span> <span class="o">*</span> <span class="n">drop_mask</span>

        <span class="c1"># have any valid boxes? try again if not</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">continue</span>

        <span class="c1"># take only matching gt boxes</span>
        <span class="n">boxes_t</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">boxes_t</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">boxes_t</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">rect</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">boxes_t</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rect</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">boxes_t</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">boxes_t</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">rect</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
        <span class="n">boxes_t</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rect</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">image_t</span><span class="p">,</span> <span class="n">boxes_t</span>
    <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span>

<span class="k">def</span> <span class="nf">ssd_bboxes_encode</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Labels anchors with ground truth inputs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">jaccard_with_anchors</span><span class="p">(</span><span class="n">bbox</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute jaccard score a box and the anchors.&quot;&quot;&quot;</span>
        <span class="c1"># Intersection bbox and volume.</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="c1"># Volumes.</span>
        <span class="n">inter_vol</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span>
        <span class="n">union_vol</span> <span class="o">=</span> <span class="n">vol_anchors</span> <span class="o">+</span> <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">inter_vol</span>
        <span class="n">jaccard</span> <span class="o">=</span> <span class="n">inter_vol</span> <span class="o">/</span> <span class="n">union_vol</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">jaccard</span><span class="p">)</span>

    <span class="n">pre_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8732</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">t_boxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8732</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">t_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8732</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">boxes</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">jaccard_with_anchors</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="n">scores</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">scores</span> <span class="o">&gt;</span> <span class="n">matching_threshold</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scores</span> <span class="o">&gt;</span> <span class="n">pre_scores</span><span class="p">)</span>
        <span class="n">pre_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pre_scores</span><span class="p">,</span> <span class="n">scores</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">t_label</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">label</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">t_label</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">t_boxes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">bbox</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">t_boxes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">t_label</span><span class="p">)</span>

    <span class="c1"># Transform to tlbr.</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8732</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">bboxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_boxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">t_boxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">bboxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">t_boxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">-</span> <span class="n">t_boxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># Encode features.</span>
    <span class="n">bboxes_t</span> <span class="o">=</span> <span class="n">bboxes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">default_boxes_t</span> <span class="o">=</span> <span class="n">default_boxes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">bboxes_t</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bboxes_t</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">default_boxes_t</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">default_boxes_t</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">bboxes_t</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="n">default_boxes_t</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="mf">0.000001</span><span class="p">)</span>
    <span class="n">bboxes_t</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.2</span>
    <span class="n">bboxes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">bboxes_t</span>

    <span class="n">num_match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">t_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">])],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bboxes</span><span class="p">,</span> <span class="n">t_label</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">num_match</span>

<span class="k">def</span> <span class="nf">preprocess_fn</span><span class="p">(</span><span class="n">img_id</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">is_training</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Preprocess function for dataset.&quot;&quot;&quot;</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">setNumThreads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_infer_data</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">):</span>
        <span class="n">img_h</span><span class="p">,</span> <span class="n">img_w</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">input_h</span><span class="p">,</span> <span class="n">input_w</span> <span class="o">=</span> <span class="n">input_shape</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">input_w</span><span class="p">,</span> <span class="n">input_h</span><span class="p">))</span>

        <span class="c1"># When the channels of image is 1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_id</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">img_h</span><span class="p">,</span> <span class="n">img_w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_data_aug</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">is_training</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">)):</span>
        <span class="n">ih</span><span class="p">,</span> <span class="n">iw</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">image_size</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_training</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_infer_data</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span>
        <span class="c1"># Random crop</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">image</span><span class="p">,</span> <span class="n">box</span> <span class="o">=</span> <span class="n">random_sample_crop</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>
        <span class="n">ih</span><span class="p">,</span> <span class="n">iw</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Resize image</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>
        <span class="c1"># Flip image or not</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="n">_rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">.5</span>
        <span class="k">if</span> <span class="n">flip</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># When the channels of image is 1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">box</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">box</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">/</span> <span class="n">ih</span>
        <span class="n">box</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">box</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">/</span> <span class="n">iw</span>
        <span class="k">if</span> <span class="n">flip</span><span class="p">:</span>
            <span class="n">box</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">box</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">box</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">num_match</span> <span class="o">=</span> <span class="n">ssd_bboxes_encode</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">num_match</span>

    <span class="k">return</span> <span class="n">_data_aug</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">is_training</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="creating-a-dataset">
<h3>Creating a Dataset<a class="headerlink" href="#creating-a-dataset" title="Permalink to this headline"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">mindspore.dataset</span> <span class="kn">import</span> <span class="n">MindDataset</span>
<span class="kn">from</span> <span class="nn">mindspore.dataset.vision</span> <span class="kn">import</span> <span class="n">Decode</span><span class="p">,</span> <span class="n">HWC2CHW</span><span class="p">,</span> <span class="n">Normalize</span><span class="p">,</span> <span class="n">RandomColorAdjust</span>


<span class="k">def</span> <span class="nf">create_ssd_dataset</span><span class="p">(</span><span class="n">mindrecord_file</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">device_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">is_training</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create SSD dataset with MindDataset.&quot;&quot;&quot;</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">MindDataset</span><span class="p">(</span><span class="n">mindrecord_file</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;img_id&quot;</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="s2">&quot;annotation&quot;</span><span class="p">],</span> <span class="n">num_shards</span><span class="o">=</span><span class="n">device_num</span><span class="p">,</span>
                          <span class="n">shard_id</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="n">num_parallel_workers</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">is_training</span><span class="p">)</span>

    <span class="n">decode</span> <span class="o">=</span> <span class="n">Decode</span><span class="p">()</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="n">decode</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">])</span>

    <span class="n">change_swap_op</span> <span class="o">=</span> <span class="n">HWC2CHW</span><span class="p">()</span>
    <span class="c1"># Computed from random subset of ImageNet training images</span>
    <span class="n">normalize_op</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mf">0.485</span> <span class="o">*</span> <span class="mi">255</span><span class="p">,</span> <span class="mf">0.456</span> <span class="o">*</span> <span class="mi">255</span><span class="p">,</span> <span class="mf">0.406</span> <span class="o">*</span> <span class="mi">255</span><span class="p">],</span>
                             <span class="n">std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.229</span> <span class="o">*</span> <span class="mi">255</span><span class="p">,</span> <span class="mf">0.224</span> <span class="o">*</span> <span class="mi">255</span><span class="p">,</span> <span class="mf">0.225</span> <span class="o">*</span> <span class="mi">255</span><span class="p">])</span>
    <span class="n">color_adjust_op</span> <span class="o">=</span> <span class="n">RandomColorAdjust</span><span class="p">(</span><span class="n">brightness</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">contrast</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">saturation</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
    <span class="n">compose_map_func</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">img_id</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="n">preprocess_fn</span><span class="p">(</span><span class="n">img_id</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">annotation</span><span class="p">,</span> <span class="n">is_training</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">is_training</span><span class="p">:</span>
        <span class="n">output_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="s2">&quot;box&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;num_match&quot;</span><span class="p">]</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="p">[</span><span class="n">color_adjust_op</span><span class="p">,</span> <span class="n">normalize_op</span><span class="p">,</span> <span class="n">change_swap_op</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;img_id&quot;</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="s2">&quot;image_shape&quot;</span><span class="p">]</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="p">[</span><span class="n">normalize_op</span><span class="p">,</span> <span class="n">change_swap_op</span><span class="p">]</span>

    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="n">compose_map_func</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;img_id&quot;</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="s2">&quot;annotation&quot;</span><span class="p">],</span>
                          <span class="n">output_columns</span><span class="o">=</span><span class="n">output_columns</span><span class="p">,</span> <span class="n">python_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">,</span>
                          <span class="n">num_parallel_workers</span><span class="o">=</span><span class="n">num_parallel_workers</span><span class="p">)</span>

    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span> <span class="n">python_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">,</span>
                          <span class="n">num_parallel_workers</span><span class="o">=</span><span class="n">num_parallel_workers</span><span class="p">)</span>

    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dataset</span>
</pre></div>
</div>
</section>
</section>
<section id="model-building">
<h2>Model Building<a class="headerlink" href="#model-building" title="Permalink to this headline"></a></h2>
<p>The SSD network structure consists of the following parts:</p>
<p><img alt="SSD-3" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_3.jpg" /></p>
<ul class="simple">
<li><p>VGG16 Base Layer</p></li>
<li><p>Extra Feature Layer</p></li>
<li><p>Detection Layer</p></li>
<li><p>NMS</p></li>
<li><p>Anchor</p></li>
</ul>
<section id="backbone-layer">
<h3>Backbone Layer<a class="headerlink" href="#backbone-layer" title="Permalink to this headline"></a></h3>
<p><img alt="SSD-4" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_en/cv/images/SSD_4.png" /></p>
<p>After being preprocessed, the size of the input image is fixed at 300 x 300. The image passes through the backbone first. In this case, the first 13 convolutional layers of the VGG-16 network are used. Then, the fully-connected layers fc6 and fc7 of VGG-16 are respectively converted into 3 <span class="math notranslate nohighlight">\(\times\)</span> 3 convolutional layer block 6 and 1 <span class="math notranslate nohighlight">\(\times\)</span> 1 convolutional layer block 7, and features are further extracted. In block 6, a dilated convolution with 6 dilations is used, and padding of the dilated convolution is also 6. This is to increase a receptive field and keep the parameter quantity and the feature map size unchanged.</p>
</section>
<section id="extra-feature-layer">
<h3>Extra Feature Layer<a class="headerlink" href="#extra-feature-layer" title="Permalink to this headline"></a></h3>
<p>On the basis of VGG-16, the SSD further adds four deep convolutional layers to extract higher-layer semantic information:</p>
<p><img alt="SSD-5" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_5.png" /></p>
<p>Blocks 8 to 11 are used to extract higher semantic information. The number of channels in block 8 is 512, and the number of channels in block 9, block 10, and block 11 is 256. From block 7 to block 11, sizes of the five convolutional output feature maps are 19 x 19, 10 x 10, 5 x 5, 3 x 3, and 1 x 1 in sequence. To reduce the number of parameters, 1 x 1 convolution is used to reduce the number of channels to half of the number of output channels at this layer, and then 3 x 3 convolution is used for feature extraction.</p>
</section>
<section id="anchor">
<h3>Anchor<a class="headerlink" href="#anchor" title="Permalink to this headline"></a></h3>
<p>The SSD uses the PriorBox to generate regions. The PriorBox with a fixed width and height is used as the prior region of interest, and a stage is used to complete classification and regression. A large number of dense PriorBoxes are designed to ensure that each region of the entire image is detected one by one. The PriorBox location is represented by the coordinates of the center point and the width and height of the box (cx,cy,w,h), and is converted into a percentage.
PriorBox generation rule:
The SSD uses six feature layers to detect objects. At different feature layers, the scale of the PriorBox is different. The scale of the lowest layer is 0.1, and the scale of the highest layer is 0.95. The calculation formulas for other layers are as follows:</p>
<p><img alt="SSD-6" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_6.jpg" /></p>
<p>If the scale of a feature layer is fixed, PriorBox with different aspect ratios is set. The length and width of PriorBox are calculated as follows:</p>
<p><img alt="SSD-7" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_7.jpg" /></p>
<p>When ratio is 1, a PriorBox (length-width ratio=1) of a specific scale is calculated based on the feature layer and the next feature layer. The calculation formula is as follows:</p>
<p><img alt="SSD-8" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_8.jpg" /></p>
<p>PriorBox is generated for each point at each feature layer based on the preceding rules. (cx,cy) is determined by the current center point. Therefore, a large number of dense PriorBoxes are generated at each feature layer, as shown in the following figure.</p>
<p><img alt="SSD-9" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_9.png" /></p>
<p>The SSD uses feature maps obtained by using six convolutional layers: the fourth, the seventh, the eighth, the ninth, the tenth, and the eleventh layers. Sizes of the six feature maps become smaller, and receptive fields corresponding to the six feature maps become larger. Each point on the six feature maps corresponds to 4, 6, 6, 6, 4, and 4 PriorBoxes respectively. Coordinates of a point in a feature map may be obtained based on a downsampling rate in the original image. Four or six PriorBoxes of different sizes are generated by using the coordinates as a center. Then, a prediction amount of a class and a location corresponding to each PriorBox is predicted by using a feature of the feature map. For example, the size of the feature map obtained by the eighth convolutional layer is 10 x 10 x 512, each point corresponds to six PriorBoxes, and there are 600 PriorBoxes in total. The MultiBox class is defined to generate multiple prediction boxes.</p>
</section>
<section id="detection-layer">
<h3>Detection Layer<a class="headerlink" href="#detection-layer" title="Permalink to this headline"></a></h3>
<p><img alt="SSD-10" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_en/cv/images/SSD_10.jpg" /></p>
<p>The SSD model has six prediction feature maps in total. For a prediction feature map whose size is m*n and channel is p, it is assumed that each pixel of the prediction feature map generates k anchors, and each anchor corresponds to c classes and four regression offsets. A convolution operation is performed on the prediction feature map by using (4+c)k convolution kernels whose sizes are 3x3 and channel is p, to obtain an output feature map whose sizes are m*n and channel is (4+c)m*k. It contains the regression offset and probability scores of each anchor generated on the prediction feature map. Therefore, for a prediction feature map whose size is m*n, a total of (4+c)k*m*n results are generated. The number of output channels of the cls branch is k*class_num, and the number of output channels of the loc branch is k*4.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">nn</span>

<span class="k">def</span> <span class="nf">_make_layer</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
    <span class="n">in_channels</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">out_channels</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">())</span>
        <span class="n">in_channels</span> <span class="o">=</span> <span class="n">out_channels</span>
    <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">SequentialCell</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Vgg16</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;VGG16 module.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Vgg16</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b1</span> <span class="o">=</span> <span class="n">_make_layer</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b2</span> <span class="o">=</span> <span class="n">_make_layer</span><span class="p">([</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b3</span> <span class="o">=</span> <span class="n">_make_layer</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b4</span> <span class="o">=</span> <span class="n">_make_layer</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b5</span> <span class="o">=</span> <span class="n">_make_layer</span><span class="p">([</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">m1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m4</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m5</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># block1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># block2</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># block3</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># block4</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b4</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">block4</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m4</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># block5</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b5</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m5</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">block4</span><span class="p">,</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">mindspore.ops</span> <span class="k">as</span> <span class="nn">ops</span>

<span class="k">def</span> <span class="nf">_last_conv2d</span><span class="p">(</span><span class="n">in_channel</span><span class="p">,</span> <span class="n">out_channel</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_mod</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">in_channels</span> <span class="o">=</span> <span class="n">in_channel</span>
    <span class="n">out_channels</span> <span class="o">=</span> <span class="n">in_channel</span>
    <span class="n">depthwise_conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span>
                               <span class="n">padding</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">in_channels</span><span class="p">)</span>
    <span class="n">conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channel</span><span class="p">,</span> <span class="n">out_channel</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">has_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">in_channel</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.97</span><span class="p">,</span>
                        <span class="n">gamma_init</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta_init</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">moving_mean_init</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">moving_var_init</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">SequentialCell</span><span class="p">([</span><span class="n">depthwise_conv</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU6</span><span class="p">(),</span> <span class="n">conv</span><span class="p">])</span>

<span class="k">class</span> <span class="nc">FlattenConcat</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;FlattenConcat module.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FlattenConcat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ssd_boxes</span> <span class="o">=</span> <span class="mi">8732</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ssd_boxes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">MultiBox</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multibox conv layers. Each multibox layer contains class conf scores and localization predictions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiBox</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">81</span>
        <span class="n">out_channels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">512</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">]</span>
        <span class="n">num_default</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

        <span class="n">loc_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cls_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">out_channel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out_channels</span><span class="p">):</span>
            <span class="n">loc_layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_last_conv2d</span><span class="p">(</span><span class="n">out_channel</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">num_default</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                        <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_mod</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
            <span class="n">cls_layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_last_conv2d</span><span class="p">(</span><span class="n">out_channel</span><span class="p">,</span> <span class="n">num_classes</span> <span class="o">*</span> <span class="n">num_default</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                        <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_mod</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">multi_loc_layers</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">CellList</span><span class="p">(</span><span class="n">loc_layers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multi_cls_layers</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">CellList</span><span class="p">(</span><span class="n">cls_layers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flatten_concat</span> <span class="o">=</span> <span class="n">FlattenConcat</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="n">loc_outputs</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">cls_outputs</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_loc_layers</span><span class="p">)):</span>
            <span class="n">loc_outputs</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_loc_layers</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),)</span>
            <span class="n">cls_outputs</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_cls_layers</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten_concat</span><span class="p">(</span><span class="n">loc_outputs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten_concat</span><span class="p">(</span><span class="n">cls_outputs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SSD300Vgg16</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;SSD300Vgg16 module.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SSD300Vgg16</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># VGG16 backbone: block1~5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backbone</span> <span class="o">=</span> <span class="n">Vgg16</span><span class="p">()</span>

        <span class="c1"># SSD blocks: block6~7</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b6_1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b6_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">b7_1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b7_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Extra Feature Layers: block8~11</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b8_1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b8_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">b9_1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b9_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">b10_1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b10_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">b11_1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b11_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>

        <span class="c1"># boxes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multi_box</span> <span class="o">=</span> <span class="n">MultiBox</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># VGG16 backbone: block1~5</span>
        <span class="n">block4</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># SSD blocks: block6~7</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b6_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 1024</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b6_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b7_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 1024</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b7_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">block7</span> <span class="o">=</span> <span class="n">x</span>

        <span class="c1"># Extra Feature Layers: block8~11</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b8_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 256</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b8_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 512</span>
        <span class="n">block8</span> <span class="o">=</span> <span class="n">x</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b9_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 128</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b9_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 256</span>
        <span class="n">block9</span> <span class="o">=</span> <span class="n">x</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b10_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 128</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b10_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 256</span>
        <span class="n">block10</span> <span class="o">=</span> <span class="n">x</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b11_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 128</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b11_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 256</span>
        <span class="n">block11</span> <span class="o">=</span> <span class="n">x</span>

        <span class="c1"># boxes</span>
        <span class="n">multi_feature</span> <span class="o">=</span> <span class="p">(</span><span class="n">block4</span><span class="p">,</span> <span class="n">block7</span><span class="p">,</span> <span class="n">block8</span><span class="p">,</span> <span class="n">block9</span><span class="p">,</span> <span class="n">block10</span><span class="p">,</span> <span class="n">block11</span><span class="p">)</span>
        <span class="n">pred_loc</span><span class="p">,</span> <span class="n">pred_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_box</span><span class="p">(</span><span class="n">multi_feature</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="n">pred_label</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">pred_label</span><span class="p">)</span>
        <span class="n">pred_loc</span> <span class="o">=</span> <span class="n">pred_loc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">pred_label</span> <span class="o">=</span> <span class="n">pred_label</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_loc</span><span class="p">,</span> <span class="n">pred_label</span>
</pre></div>
</div>
</section>
</section>
<section id="loss-function">
<h2>Loss Function<a class="headerlink" href="#loss-function" title="Permalink to this headline"></a></h2>
<p>The object function of the SSD algorithm is divided into two parts: calculating a confidence loss (conf) between a corresponding preselection box and a target category and a corresponding location loss (loc):</p>
<p><img alt="SSD-11" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_11.jpg" /></p>
<p>In the preceding information:<br>
N indicates the number of positive samples in the prior box.<br>
c indicates the prediction value of class confidence.<br>
l indicates the location prediction value of the corresponding bounding box of the prior box.<br>
g indicates the location parameter of the ground truth.<br>
α is used to adjust the ratio of confidence loss to location loss. The default value is <strong>1</strong>.</p>
<section id="location-loss-function">
<h3>Location Loss Function<a class="headerlink" href="#location-loss-function" title="Permalink to this headline"></a></h3>
<p>Smooth L1 Loss is used for all positive samples. The location information is encoded.</p>
<p><img alt="SSD-12" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_12.jpg" /></p>
</section>
<section id="confidence-loss-function">
<h3>Confidence Loss Function<a class="headerlink" href="#confidence-loss-function" title="Permalink to this headline"></a></h3>
<p>The confidence loss is the softmax loss on multi-class confidence (c).</p>
<p><img alt="SSD-13" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_en/cv/images/SSD_13.jpg" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">class_loss</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate category losses.&quot;&quot;&quot;</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">logits</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">Tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">pos_weight</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">sigmiod_cross_entropy</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">binary_cross_entropy_with_logits</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weight</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">pos_weight</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="n">sigmoid</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">p_t</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="n">sigmoid</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">label</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigmoid</span><span class="p">)</span>
    <span class="n">modulating_factor</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_t</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">alpha_weight_factor</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="mf">0.75</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">label</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.75</span><span class="p">)</span>
    <span class="n">focal_loss</span> <span class="o">=</span> <span class="n">modulating_factor</span> <span class="o">*</span> <span class="n">alpha_weight_factor</span> <span class="o">*</span> <span class="n">sigmiod_cross_entropy</span>
    <span class="k">return</span> <span class="n">focal_loss</span>
</pre></div>
</div>
</section>
</section>
<section id="metrics">
<h2>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline"></a></h2>
<p>In SSD, non-maximum suppression (NMS) is not required during training. However, during inspection, for example, when an image is input and a box is required, the NMS needs to be used to filter out the prediction boxes that overlap with each other.<br>
The NMS process is as follows:</p>
<ol class="arabic simple">
<li><p>Sort by confidence score.</p></li>
<li><p>Select the ratio bounding box with the highest confidence to add to the final output list and remove it from the bounding box list.<br></p></li>
<li><p>Calculate the region of all bounding boxes.<br></p></li>
<li><p>Calculate the IoU of the bounding box with the highest confidence and other candidate boxes.<br></p></li>
<li><p>Delete the bounding box where the IoU is greater than the threshold.<br></p></li>
<li><p>Repeat the preceding steps until the bounding box list is empty.<br></p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">pycocotools.coco</span> <span class="kn">import</span> <span class="n">COCO</span>
<span class="kn">from</span> <span class="nn">pycocotools.cocoeval</span> <span class="kn">import</span> <span class="n">COCOeval</span>


<span class="k">def</span> <span class="nf">apply_eval</span><span class="p">(</span><span class="n">eval_param_dict</span><span class="p">):</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">eval_param_dict</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
    <span class="n">net</span><span class="o">.</span><span class="n">set_train</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">eval_param_dict</span><span class="p">[</span><span class="s2">&quot;dataset&quot;</span><span class="p">]</span>
    <span class="n">anno_json</span> <span class="o">=</span> <span class="n">eval_param_dict</span><span class="p">[</span><span class="s2">&quot;anno_json&quot;</span><span class="p">]</span>
    <span class="n">coco_metrics</span> <span class="o">=</span> <span class="n">COCOMetrics</span><span class="p">(</span><span class="n">anno_json</span><span class="o">=</span><span class="n">anno_json</span><span class="p">,</span>
                               <span class="n">classes</span><span class="o">=</span><span class="n">train_cls</span><span class="p">,</span>
                               <span class="n">num_classes</span><span class="o">=</span><span class="mi">81</span><span class="p">,</span>
                               <span class="n">max_boxes</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                               <span class="n">nms_threshold</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                               <span class="n">min_score</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">create_dict_iterator</span><span class="p">(</span><span class="n">output_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">img_id</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;img_id&#39;</span><span class="p">]</span>
        <span class="n">img_np</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span>
        <span class="n">image_shape</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;image_shape&#39;</span><span class="p">]</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">Tensor</span><span class="p">(</span><span class="n">img_np</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">batch_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img_np</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pred_batch</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;boxes&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()[</span><span class="n">batch_idx</span><span class="p">],</span>
                <span class="s2">&quot;box_scores&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()[</span><span class="n">batch_idx</span><span class="p">],</span>
                <span class="s2">&quot;img_id&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">img_id</span><span class="p">[</span><span class="n">batch_idx</span><span class="p">])),</span>
                <span class="s2">&quot;image_shape&quot;</span><span class="p">:</span> <span class="n">image_shape</span><span class="p">[</span><span class="n">batch_idx</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="n">coco_metrics</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pred_batch</span><span class="p">)</span>
    <span class="n">eval_metrics</span> <span class="o">=</span> <span class="n">coco_metrics</span><span class="o">.</span><span class="n">get_metrics</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">eval_metrics</span>


<span class="k">def</span> <span class="nf">apply_nms</span><span class="p">(</span><span class="n">all_boxes</span><span class="p">,</span> <span class="n">all_scores</span><span class="p">,</span> <span class="n">thres</span><span class="p">,</span> <span class="n">max_boxes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply NMS to bboxes.&quot;&quot;&quot;</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">all_boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">all_boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">all_boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">all_boxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">areas</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">order</span> <span class="o">=</span> <span class="n">all_scores</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">order</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_boxes</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">xx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">yy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">xx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">yy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">xx2</span> <span class="o">-</span> <span class="n">xx1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">yy2</span> <span class="o">-</span> <span class="n">yy1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span>

        <span class="n">ovr</span> <span class="o">=</span> <span class="n">inter</span> <span class="o">/</span> <span class="p">(</span><span class="n">areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">areas</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">-</span> <span class="n">inter</span><span class="p">)</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ovr</span> <span class="o">&lt;=</span> <span class="n">thres</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">keep</span>


<span class="k">class</span> <span class="nc">COCOMetrics</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate mAP of predicted bboxes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anno_json</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">min_score</span><span class="p">,</span> <span class="n">nms_threshold</span><span class="p">,</span> <span class="n">max_boxes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_score</span> <span class="o">=</span> <span class="n">min_score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nms_threshold</span> <span class="o">=</span> <span class="n">nms_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_boxes</span> <span class="o">=</span> <span class="n">max_boxes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">val_cls_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">cls</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">classes</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coco_gt</span> <span class="o">=</span> <span class="n">COCO</span><span class="p">(</span><span class="n">anno_json</span><span class="p">)</span>
        <span class="n">cat_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coco_gt</span><span class="o">.</span><span class="n">loadCats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coco_gt</span><span class="o">.</span><span class="n">getCatIds</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cat</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span> <span class="n">cat</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">cat_ids</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_ids</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span>
        <span class="n">pred_boxes</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span>
        <span class="n">box_scores</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s1">&#39;box_scores&#39;</span><span class="p">]</span>
        <span class="n">img_id</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s1">&#39;img_id&#39;</span><span class="p">]</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="s1">&#39;image_shape&#39;</span><span class="p">]</span>

        <span class="n">final_boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_label</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_score</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_id</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">):</span>
            <span class="n">class_box_scores</span> <span class="o">=</span> <span class="n">box_scores</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span>
            <span class="n">score_mask</span> <span class="o">=</span> <span class="n">class_box_scores</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_score</span>
            <span class="n">class_box_scores</span> <span class="o">=</span> <span class="n">class_box_scores</span><span class="p">[</span><span class="n">score_mask</span><span class="p">]</span>
            <span class="n">class_boxes</span> <span class="o">=</span> <span class="n">pred_boxes</span><span class="p">[</span><span class="n">score_mask</span><span class="p">]</span> <span class="o">*</span> <span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">score_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">nms_index</span> <span class="o">=</span> <span class="n">apply_nms</span><span class="p">(</span><span class="n">class_boxes</span><span class="p">,</span> <span class="n">class_box_scores</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nms_threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_boxes</span><span class="p">)</span>
                <span class="n">class_boxes</span> <span class="o">=</span> <span class="n">class_boxes</span><span class="p">[</span><span class="n">nms_index</span><span class="p">]</span>
                <span class="n">class_box_scores</span> <span class="o">=</span> <span class="n">class_box_scores</span><span class="p">[</span><span class="n">nms_index</span><span class="p">]</span>

                <span class="n">final_boxes</span> <span class="o">+=</span> <span class="n">class_boxes</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">final_score</span> <span class="o">+=</span> <span class="n">class_box_scores</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">final_label</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">class_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">val_cls_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_box_scores</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">loc</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">final_boxes</span><span class="p">,</span> <span class="n">final_label</span><span class="p">,</span> <span class="n">final_score</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;image_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_id</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;bbox&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;category_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;predictions.json&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictions</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="n">coco_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coco_gt</span><span class="o">.</span><span class="n">loadRes</span><span class="p">(</span><span class="s1">&#39;predictions.json&#39;</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">COCOeval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coco_gt</span><span class="p">,</span> <span class="n">coco_dt</span><span class="p">,</span> <span class="n">iouType</span><span class="o">=</span><span class="s1">&#39;bbox&#39;</span><span class="p">)</span>
        <span class="n">E</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">imgIds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_ids</span>
        <span class="n">E</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>
        <span class="n">E</span><span class="o">.</span><span class="n">accumulate</span><span class="p">()</span>
        <span class="n">E</span><span class="o">.</span><span class="n">summarize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">E</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">SsdInferWithDecoder</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SSD Infer wrapper to decode the bbox locations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">default_boxes</span><span class="p">,</span> <span class="n">ckpt_path</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SsdInferWithDecoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">param_dict</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">load_checkpoint</span><span class="p">(</span><span class="n">ckpt_path</span><span class="p">)</span>
        <span class="n">ms</span><span class="o">.</span><span class="n">load_param_into_net</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">param_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_boxes</span> <span class="o">=</span> <span class="n">default_boxes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_scaling_xy</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_scaling_wh</span> <span class="o">=</span> <span class="mf">0.2</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">pred_loc</span><span class="p">,</span> <span class="n">pred_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">default_bbox_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_boxes</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">default_bbox_wh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_boxes</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span>
        <span class="n">pred_xy</span> <span class="o">=</span> <span class="n">pred_loc</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_scaling_xy</span> <span class="o">*</span> <span class="n">default_bbox_wh</span> <span class="o">+</span> <span class="n">default_bbox_xy</span>
        <span class="n">pred_wh</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">pred_loc</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_scaling_wh</span><span class="p">)</span> <span class="o">*</span> <span class="n">default_bbox_wh</span>

        <span class="n">pred_xy_0</span> <span class="o">=</span> <span class="n">pred_xy</span> <span class="o">-</span> <span class="n">pred_wh</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">pred_xy_1</span> <span class="o">=</span> <span class="n">pred_xy</span> <span class="o">+</span> <span class="n">pred_wh</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">pred_xy</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">pred_xy_0</span><span class="p">,</span> <span class="n">pred_xy_1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pred_xy</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pred_xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pred_xy</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">pred_xy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_xy</span><span class="p">,</span> <span class="n">pred_label</span>
</pre></div>
</div>
</section>
<section id="training-process">
<h2>Training Process<a class="headerlink" href="#training-process" title="Permalink to this headline"></a></h2>
<section id="1-prior-box-matching">
<h3>(1) Prior box matching<a class="headerlink" href="#1-prior-box-matching" title="Permalink to this headline"></a></h3>
<p>During training, you need to determine the prior box to which the ground truth in the training image matches. The bounding box corresponding to the matched prior box is responsible for predicting the ground truth.</p>
<p>The principles for matching the prior box of the SSD with the ground truth are as follows:</p>
<ol class="arabic simple">
<li><p>For each ground truth in the image, find the prior box with the largest IoU. The prior box matches the ground truth. In this way, each ground truth must match a prior box. Generally, a prior box that matches the ground truth is referred to as a positive sample. On the contrary, if a prior box does not match any ground truth, the prior box can only match the background, and is a negative sample.</p></li>
<li><p>For the remaining unmatched prior boxes, if the IoU of a ground truth is greater than a threshold (generally 0.5), the prior box is also matched with the ground truth. Although a ground truth can match multiple prior boxes, there are too few ground truths compared with prior boxes. Therefore, there are many negative samples compared with positive samples. To ensure that positive and negative samples are balanced, the SSD uses hard negative mining, that is, negative samples are sampled. During sampling, negative samples are sorted in descending order based on confidence loss (a smaller confidence of the prediction background indicates a larger loss). The top-k samples with a larger loss are selected as negative samples for training, to ensure that the ratio of positive samples to negative samples is close to 1:3.</p></li>
</ol>
<p>Notes:</p>
<ol class="arabic simple">
<li><p>Generally, a prior box that matches the ground truth is referred to as a positive sample. On the contrary, if a prior box does not match any ground truth, the prior box is referred to as a negative sample.</p></li>
<li><p>A ground truth can match multiple prior boxes, but each prior box can match only one ground truth.</p></li>
<li><p>If the IoUs of multiple ground truths and a prior box are all greater than the threshold, the prior box is matched only with the largest IoU.</p></li>
</ol>
<p><img alt="SSD-14" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_en/cv/images/SSD_14.jpg" /></p>
<p>As shown in the preceding figure, the basic idea of matching prior boxes and ground truth boxes during training is as follows: Each prior box is regressed to the ground truth box. The control of this process requires the help of the loss layer. The loss layer calculates the error between the actual value and the prediction value to guide the learning direction.</p>
</section>
<section id="2-loss-function">
<h3>(2) Loss function<a class="headerlink" href="#2-loss-function" title="Permalink to this headline"></a></h3>
<p>The loss function uses the weighted sum of the position loss function and the confidence loss function mentioned above.</p>
</section>
<section id="3-data-augmentation">
<h3>(3) Data augmentation<a class="headerlink" href="#3-data-augmentation" title="Permalink to this headline"></a></h3>
<p>Use the previously defined data augmentation mode to perform data augmentation on the created data augmentation mode.</p>
<p>During model training, the number of epochs for model training is set to 60, and the training set and validation set are created using the create_ssd_dataset class. The value of <strong>batch_size</strong> is <strong>5</strong>, and the image size is adjusted to 300 x 300. The loss functions are the weighted sum of the position loss function and the confidence loss function. The optimizer is Momentum, and the initial learning rate is set to <strong>0.001</strong>. The callback functions LossMonitor and TimeMonitor are used to monitor the change of the loss value after each epoch ends during training and the running time of each epoch and step. The model is saved once every 10 epochs are trained.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>

<span class="kn">from</span> <span class="nn">mindspore.common</span> <span class="kn">import</span> <span class="n">set_seed</span>

<span class="k">class</span> <span class="nc">GeneratDefaultBoxes</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Default boxes for SSD, follows the order of (W, H, archor_sizes).</span>
<span class="sd">    `self.default_boxes` has a shape of [archor_sizes, H, W, 4], the last dimension is [y, x, h, w].</span>
<span class="sd">    `self.default_boxes_tlbr` has a shape as `self.default_boxes`, the last dimension is [y1, x1, y2, x2].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fk</span> <span class="o">=</span> <span class="mi">300</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>
        <span class="n">scale_rate</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.95</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">scales</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span> <span class="o">+</span> <span class="n">scale_rate</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idex</span><span class="p">,</span> <span class="n">feature_size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="mi">38</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="n">sk1</span> <span class="o">=</span> <span class="n">scales</span><span class="p">[</span><span class="n">idex</span><span class="p">]</span>
            <span class="n">sk2</span> <span class="o">=</span> <span class="n">scales</span><span class="p">[</span><span class="n">idex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">sk3</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sk1</span> <span class="o">*</span> <span class="n">sk2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idex</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">idex</span><span class="p">]:</span>
                <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">sk1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">sk1</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">all_sizes</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_sizes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sk1</span><span class="p">,</span> <span class="n">sk1</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">aspect_ratio</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">idex</span><span class="p">]:</span>
                    <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">sk1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aspect_ratio</span><span class="p">),</span> <span class="n">sk1</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aspect_ratio</span><span class="p">)</span>
                    <span class="n">all_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>
                    <span class="n">all_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                <span class="n">all_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sk3</span><span class="p">,</span> <span class="n">sk3</span><span class="p">))</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_sizes</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">][</span><span class="n">idex</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">feature_size</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">all_sizes</span><span class="p">:</span>
                    <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">fk</span><span class="p">[</span><span class="n">idex</span><span class="p">],</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">fk</span><span class="p">[</span><span class="n">idex</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">default_boxes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">to_tlbr</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cx</span> <span class="o">+</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># For IoU calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_boxes_tlbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">to_tlbr</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_boxes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_boxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_boxes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>

<span class="n">default_boxes_tlbr</span> <span class="o">=</span> <span class="n">GeneratDefaultBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">default_boxes_tlbr</span>
<span class="n">default_boxes</span> <span class="o">=</span> <span class="n">GeneratDefaultBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">default_boxes</span>

<span class="n">y1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">default_boxes_tlbr</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">vol_anchors</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
<span class="n">matching_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore.common.initializer</span> <span class="kn">import</span> <span class="n">initializer</span><span class="p">,</span> <span class="n">TruncatedNormal</span>


<span class="k">def</span> <span class="nf">init_net_param</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">initialize_mode</span><span class="o">=</span><span class="s1">&#39;TruncatedNormal&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Init the parameters in net.&quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;beta&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="s1">&#39;bias&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initialize_mode</span> <span class="o">==</span> <span class="s1">&#39;TruncatedNormal&#39;</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">initializer</span><span class="p">(</span><span class="n">TruncatedNormal</span><span class="p">(</span><span class="mf">0.02</span><span class="p">),</span> <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">initialize_mode</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_lr</span><span class="p">(</span><span class="n">global_step</span><span class="p">,</span> <span class="n">lr_init</span><span class="p">,</span> <span class="n">lr_end</span><span class="p">,</span> <span class="n">lr_max</span><span class="p">,</span> <span class="n">warmup_epochs</span><span class="p">,</span> <span class="n">total_epochs</span><span class="p">,</span> <span class="n">steps_per_epoch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; generate learning rate array&quot;&quot;&quot;</span>
    <span class="n">lr_each_step</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_steps</span> <span class="o">=</span> <span class="n">steps_per_epoch</span> <span class="o">*</span> <span class="n">total_epochs</span>
    <span class="n">warmup_steps</span> <span class="o">=</span> <span class="n">steps_per_epoch</span> <span class="o">*</span> <span class="n">warmup_epochs</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_steps</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">warmup_steps</span><span class="p">:</span>
            <span class="n">lr</span> <span class="o">=</span> <span class="n">lr_init</span> <span class="o">+</span> <span class="p">(</span><span class="n">lr_max</span> <span class="o">-</span> <span class="n">lr_init</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">warmup_steps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lr</span> <span class="o">=</span> <span class="n">lr_end</span> <span class="o">+</span> <span class="p">(</span><span class="n">lr_max</span> <span class="o">-</span> <span class="n">lr_end</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">warmup_steps</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_steps</span> <span class="o">-</span> <span class="n">warmup_steps</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="k">if</span> <span class="n">lr</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">lr</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">lr_each_step</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>

    <span class="n">current_step</span> <span class="o">=</span> <span class="n">global_step</span>
    <span class="n">lr_each_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lr_each_step</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">learning_rate</span> <span class="o">=</span> <span class="n">lr_each_step</span><span class="p">[</span><span class="n">current_step</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">learning_rate</span>

</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">mindspore.amp</span> <span class="kn">import</span> <span class="n">DynamicLossScaler</span>

<span class="n">set_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># load data</span>
<span class="n">mindrecord_dir</span> <span class="o">=</span> <span class="s2">&quot;./datasets/MindRecord_COCO&quot;</span>
<span class="n">mindrecord_file</span> <span class="o">=</span> <span class="s2">&quot;./datasets/MindRecord_COCO/ssd.mindrecord0&quot;</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="n">create_ssd_dataset</span><span class="p">(</span><span class="n">mindrecord_file</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">dataset_size</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>

<span class="n">image</span><span class="p">,</span> <span class="n">get_loc</span><span class="p">,</span> <span class="n">gt_label</span><span class="p">,</span> <span class="n">num_matched_boxes</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">create_tuple_iterator</span><span class="p">())</span>

<span class="c1"># Network definition and initialization</span>
<span class="n">network</span> <span class="o">=</span> <span class="n">SSD300Vgg16</span><span class="p">()</span>
<span class="n">init_net_param</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>

<span class="c1"># Define the learning rate</span>
<span class="n">lr</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">get_lr</span><span class="p">(</span><span class="n">global_step</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">dataset_size</span><span class="p">,</span>
                   <span class="n">lr_init</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">lr_end</span><span class="o">=</span><span class="mf">0.001</span> <span class="o">*</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">lr_max</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                   <span class="n">warmup_epochs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">total_epochs</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">steps_per_epoch</span><span class="o">=</span><span class="n">dataset_size</span><span class="p">))</span>

<span class="c1"># Define the optimizer</span>
<span class="n">opt</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Momentum</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">,</span> <span class="n">network</span><span class="o">.</span><span class="n">get_parameters</span><span class="p">()),</span> <span class="n">lr</span><span class="p">,</span>
                  <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.00015</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="mi">1024</span><span class="p">))</span>

<span class="c1"># Define the forward procedure</span>
<span class="k">def</span> <span class="nf">forward_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gt_loc</span><span class="p">,</span> <span class="n">gt_label</span><span class="p">,</span> <span class="n">num_matched_boxes</span><span class="p">):</span>
    <span class="n">pred_loc</span><span class="p">,</span> <span class="n">pred_label</span> <span class="o">=</span> <span class="n">network</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gt_label</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">num_matched_boxes</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">num_matched_boxes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

    <span class="c1"># Positioning loss</span>
    <span class="n">mask_loc</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">smooth_l1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">SmoothL1Loss</span><span class="p">()(</span><span class="n">pred_loc</span><span class="p">,</span> <span class="n">gt_loc</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask_loc</span>
    <span class="n">loss_loc</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">smooth_l1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Category loss</span>
    <span class="n">loss_cls</span> <span class="o">=</span> <span class="n">class_loss</span><span class="p">(</span><span class="n">pred_label</span><span class="p">,</span> <span class="n">gt_label</span><span class="p">)</span>
    <span class="n">loss_cls</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">loss_cls</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">loss_cls</span> <span class="o">+</span> <span class="n">loss_loc</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_matched_boxes</span><span class="p">)</span>

<span class="n">grad_fn</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">value_and_grad</span><span class="p">(</span><span class="n">forward_fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">loss_scaler</span> <span class="o">=</span> <span class="n">DynamicLossScaler</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Gradient updates</span>
<span class="k">def</span> <span class="nf">train_step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gt_loc</span><span class="p">,</span> <span class="n">gt_label</span><span class="p">,</span> <span class="n">num_matched_boxes</span><span class="p">):</span>
    <span class="n">loss</span><span class="p">,</span> <span class="n">grads</span> <span class="o">=</span> <span class="n">grad_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gt_loc</span><span class="p">,</span> <span class="n">gt_label</span><span class="p">,</span> <span class="n">num_matched_boxes</span><span class="p">)</span>
    <span class="n">opt</span><span class="p">(</span><span class="n">grads</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loss</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=================== Starting Training =====================&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">):</span>
    <span class="n">network</span><span class="o">.</span><span class="n">set_train</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">begin_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">get_loc</span><span class="p">,</span> <span class="n">gt_label</span><span class="p">,</span> <span class="n">num_matched_boxes</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">create_tuple_iterator</span><span class="p">()):</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">train_step</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">get_loc</span><span class="p">,</span> <span class="n">gt_label</span><span class="p">,</span> <span class="n">num_matched_boxes</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">begin_time</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch:[</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">epoch</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span><span class="si">}</span><span class="s2">], &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;loss:</span><span class="si">{</span><span class="n">loss</span><span class="si">}</span><span class="s2"> , &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;time:</span><span class="si">{</span><span class="n">times</span><span class="si">}</span><span class="s2">s &quot;</span><span class="p">)</span>
<span class="n">ms</span><span class="o">.</span><span class="n">save_checkpoint</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="s2">&quot;ssd-60_9.ckpt&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=================== Training Success =====================&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>=================== Starting Training =====================
Epoch:[1/60], loss:1365.3849 , time:42.76231384277344s
Epoch:[2/60], loss:1350.9009 , time:43.63900399208069s
Epoch:[3/60], loss:1325.2102 , time:48.01434779167175s
Epoch:[4/60], loss:1297.8125 , time:40.65014576911926s
Epoch:[5/60], loss:1269.7281 , time:40.627623081207275s
Epoch:[6/60], loss:1240.8068 , time:42.14572191238403s
Epoch:[7/60], loss:1210.52 , time:41.091148853302s
Epoch:[8/60], loss:1178.0127 , time:41.88719820976257s
Epoch:[9/60], loss:1142.2338 , time:41.147764444351196s
Epoch:[10/60], loss:1101.929 , time:42.21702218055725s
Epoch:[11/60], loss:1055.7747 , time:40.66824555397034s
Epoch:[12/60], loss:1002.66125 , time:40.70291781425476s
Epoch:[13/60], loss:942.0149 , time:42.10250663757324s
Epoch:[14/60], loss:874.245 , time:41.27074885368347s
Epoch:[15/60], loss:801.06055 , time:40.62501621246338s
Epoch:[16/60], loss:725.4527 , time:41.78050708770752s
Epoch:[17/60], loss:651.15564 , time:40.619580030441284s
Epoch:[18/60], loss:581.7435 , time:41.07759237289429s
Epoch:[19/60], loss:519.85223 , time:41.74708104133606s
Epoch:[20/60], loss:466.71866 , time:40.79696846008301s
Epoch:[21/60], loss:422.35846 , time:40.40337634086609s
Epoch:[22/60], loss:385.95758 , time:41.0706627368927s
Epoch:[23/60], loss:356.3252 , time:41.02973508834839s
Epoch:[24/60], loss:332.2302 , time:41.101938009262085s
Epoch:[25/60], loss:312.56158 , time:40.12760329246521s
Epoch:[26/60], loss:296.3943 , time:40.62085247039795s
Epoch:[27/60], loss:282.99237 , time:42.20474720001221s
Epoch:[28/60], loss:271.7844 , time:40.27843761444092s
Epoch:[29/60], loss:262.32687 , time:40.6625394821167s
Epoch:[30/60], loss:254.28302 , time:41.42288422584534s
Epoch:[31/60], loss:247.38882 , time:40.49200940132141s
Epoch:[32/60], loss:241.44067 , time:41.48827362060547s
Epoch:[33/60], loss:236.28123 , time:41.1355299949646s
Epoch:[34/60], loss:231.78201 , time:40.45781660079956s
Epoch:[35/60], loss:227.84433 , time:40.92684364318848s
Epoch:[36/60], loss:224.38614 , time:40.89856195449829s
Epoch:[37/60], loss:221.34372 , time:41.585039138793945s
Epoch:[38/60], loss:218.66156 , time:40.8972954750061s
Epoch:[39/60], loss:216.29553 , time:42.22093486785889s
Epoch:[40/60], loss:214.20854 , time:40.75188755989075s
Epoch:[41/60], loss:212.36868 , time:41.51768183708191s
Epoch:[42/60], loss:210.74985 , time:40.3460476398468s
Epoch:[43/60], loss:209.32901 , time:40.65240502357483s
Epoch:[44/60], loss:208.08626 , time:41.250218629837036s
Epoch:[45/60], loss:207.00375 , time:40.334686040878296s
Epoch:[46/60], loss:206.06656 , time:40.822086811065674s
Epoch:[47/60], loss:205.2609 , time:40.492422103881836s
Epoch:[48/60], loss:204.57387 , time:41.39555335044861s
Epoch:[49/60], loss:203.9947 , time:40.29546666145325s
Epoch:[50/60], loss:203.51189 , time:39.61115860939026s
Epoch:[51/60], loss:203.11642 , time:41.232492446899414s
Epoch:[52/60], loss:202.79791 , time:40.896180152893066s
Epoch:[53/60], loss:202.54779 , time:40.62282419204712s
Epoch:[54/60], loss:202.35779 , time:40.751235485076904s
Epoch:[55/60], loss:202.2188 , time:41.790447473526s
Epoch:[56/60], loss:202.12277 , time:41.371476888656616s
Epoch:[57/60], loss:202.05978 , time:41.00389575958252s
Epoch:[58/60], loss:202.02513 , time:40.384965658187866s
Epoch:[59/60], loss:202.00772 , time:40.91265916824341s
Epoch:[60/60], loss:201.9999 , time:41.31216502189636s
=================== Training Success =====================
</pre></div>
</div>
</section>
</section>
<section id="evaluation">
<h2>Evaluation<a class="headerlink" href="#evaluation" title="Permalink to this headline"></a></h2>
<p>Customize the eval_net() class to evaluate the trained model and invoke the SsdInferWithDecoder class to return the predicted coordinates and labels. The average precision (AP) and average recall (AR) are then calculated for different IoU threshold, area, and maxDets settings. Use the COCOMetrics class to calculate mAP. The evaluation metrics of the model on the test set are as follows:</p>
<section id="ap-and-ar-explanations">
<h3>AP and AR Explanations<a class="headerlink" href="#ap-and-ar-explanations" title="Permalink to this headline"></a></h3>
<ul class="simple">
<li><p>TP: IoU &gt; Number of detection boxes with the specified threshold (The same ground truth is calculated only once.)</p></li>
<li><p>FP: IoU ≤ Number of detection boxes with the specified threshold, or the number of redundant detection boxes with the same ground truth.</p></li>
<li><p>FN: The number of GTs that are not detected.</p></li>
</ul>
</section>
<section id="ap-and-ar-formulas">
<h3>AP and AR Formulas<a class="headerlink" href="#ap-and-ar-formulas" title="Permalink to this headline"></a></h3>
<ul>
<li><p>Average precision (AP):</p>
<p><img alt="SSD-15" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_15.jpg" /></p>
<p>The AP is the ratio of the correct prediction result of positive samples to the sum of the prediction result of the positive samples and the incorrect prediction result, and mainly reflects an error rate of a prediction result.</p>
</li>
<li><p>Average recall (AR):</p>
<p><img alt="SSD-16" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.11/tutorials/application/source_zh_cn/cv/images/SSD_16.jpg" /></p>
<p>The AR is the ratio of the correct prediction result of positive samples to the sum of the correct prediction result of positive samples and the incorrect prediction result of positive samples. The AR mainly reflects the missing detection rate in the prediction result.</p>
</li>
</ul>
</section>
<section id="output-metrics-for-the-following-code-running-results">
<h3>Output Metrics for the Following Code Running Results<a class="headerlink" href="#output-metrics-for-the-following-code-running-results" title="Permalink to this headline"></a></h3>
<ul class="simple">
<li><p>The first value is the mean average precision (mAP), that is, the average value of APs of each class.</p></li>
<li><p>The second value is the mAP value when IoU is set to 0.5, which is the evaluation standard of VOC.</p></li>
<li><p>The third value is the mAP value that is strictly evaluated, which can reflect the position accuracy of the algorithm box. The middle values are the mAP values of the object size.</p></li>
</ul>
<p>For the AR, check the mAR value when maxDets is 10/100 to reflect the detection rate. If the two values are close, it indicates that 100 boxes do not need to be detected for the dataset, which can improve the performance.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mindrecord_file</span> <span class="o">=</span> <span class="s2">&quot;./datasets/MindRecord_COCO/ssd_eval.mindrecord0&quot;</span>

<span class="k">def</span> <span class="nf">ssd_eval</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">,</span> <span class="n">ckpt_path</span><span class="p">,</span> <span class="n">anno_json</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;SSD evaluation.&quot;&quot;&quot;</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">create_ssd_dataset</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                            <span class="n">is_training</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">network</span> <span class="o">=</span> <span class="n">SSD300Vgg16</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Load Checkpoint!&quot;</span><span class="p">)</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">SsdInferWithDecoder</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">default_boxes</span><span class="p">),</span> <span class="n">ckpt_path</span><span class="p">)</span>

    <span class="n">net</span><span class="o">.</span><span class="n">set_train</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span> <span class="o">*</span> <span class="n">batch_size</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">========================================</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total images num: &quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
    <span class="n">eval_param_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;net&quot;</span><span class="p">:</span> <span class="n">net</span><span class="p">,</span> <span class="s2">&quot;dataset&quot;</span><span class="p">:</span> <span class="n">ds</span><span class="p">,</span> <span class="s2">&quot;anno_json&quot;</span><span class="p">:</span> <span class="n">anno_json</span><span class="p">}</span>
    <span class="n">mAP</span> <span class="o">=</span> <span class="n">apply_eval</span><span class="p">(</span><span class="n">eval_param_dict</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">========================================</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mAP: </span><span class="si">{</span><span class="n">mAP</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">eval_net</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start Eval!&quot;</span><span class="p">)</span>
    <span class="n">ssd_eval</span><span class="p">(</span><span class="n">mindrecord_file</span><span class="p">,</span> <span class="s2">&quot;./ssd-60_9.ckpt&quot;</span><span class="p">,</span> <span class="n">anno_json</span><span class="p">)</span>

<span class="n">eval_net</span><span class="p">()</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Start Eval!
Load Checkpoint!


========================================

total images num:  9
loading annotations into memory...
Done (t=0.00s)
creating index...
index created!
Loading and preparing results...
DONE (t=0.47s)
creating index...
index created!
Running per image evaluation...
Evaluate annotation type *bbox*
DONE (t=0.97s).
Accumulating evaluation results...
DONE (t=0.20s).
 Average Precision  (AP) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.003
 Average Precision  (AP) @[ IoU=0.50      | area=   all | maxDets=100 ] = 0.006
 Average Precision  (AP) @[ IoU=0.75      | area=   all | maxDets=100 ] = 0.000
 Average Precision  (AP) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.000
 Average Precision  (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.052
 Average Precision  (AP) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.016
 Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=  1 ] = 0.005
 Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets= 10 ] = 0.037
 Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.071
 Average Recall     (AR) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.000
 Average Recall     (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.057
 Average Recall     (AR) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.328

========================================

mAP: 0.0025924737758294216
</pre></div>
</div>
</section>
</section>
<section id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline"></a></h2>
<p>[1] Liu W, Anguelov D, Erhan D, et al. Ssd: Single shot multibox detector[C]//European conference on computer vision. Springer, Cham, 2016: 21-37.<br></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="shufflenet.html" class="btn btn-neutral float-left" title="ShuffleNet for Image Classification" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../nlp/sentiment_analysis.html" class="btn btn-neutral float-right" title="Sentiment Classification Implemented by RNN" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
        <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>