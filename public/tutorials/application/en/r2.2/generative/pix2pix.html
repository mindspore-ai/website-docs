<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pix2Pix for Image Translation &mdash; MindSpore master documentation</title><script>;(()=>{const e=localStorage.getItem("ms-theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches;(e?"dark"===e:t)&&document.documentElement.setAttribute("data-o-theme","dark")})();</script><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script><script src="../_static/jquery.js"></script>
        <script src="../_static/js/theme.js"></script><script src="../_static/underscore.js"></script><script src="../_static/doctools.js"></script><script crossorigin="anonymous" integrity="sha256-1fEPhSsRKlFKGfK3eO710tEweHh1fwokU5wFGDHO+vg=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script><script async="async" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/mathjax/MathJax-3.2.2/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="CycleGAN for Image Style Migration" href="cyclegan.html" />
    <link rel="prev" title="Generating Cartoon Head Portrait via DCGAN" href="dcgan.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> MindSpore
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">CV</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cv/resnet50.html">ResNet-50 for Image Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cv/transfer_learning.html">ResNet50 Transfer Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cv/vit.html">Vision Transformer Image Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cv/cnnctc.html">CNN and CTC for Recognizing Text from Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cv/fcn8s.html">FCN for Image Semantic Segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cv/shufflenet.html">ShuffleNet for Image Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cv/ssd.html">SSD for Object Detection</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NLP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../nlp/sentiment_analysis.html">Sentiment Classification Implemented by RNN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nlp/sequence_labeling.html">LSTM+CRF Sequence Labeling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generative</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="gan.html">GAN for Image Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="dcgan.html">Generating Cartoon Head Portrait via DCGAN</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Pix2Pix for Image Translation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pix2pix-overview">Pix2Pix Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-principles">Basic Principles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#preparations">Preparations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#configuring-the-environment-file">Configuring the Environment File</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preparing-data">Preparing Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-display">Data Display</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#creating-a-network">Creating a Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generator-g-structure">Generator G Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-the-u-net-skip-connection-block">Defining the U-Net Skip Connection Block</a></li>
<li class="toctree-l4"><a class="reference internal" href="#u-net-based-generator">U-Net-based Generator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#patchgan-based-discriminator">PatchGAN-based Discriminator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-of-pix2pix-generator-and-discriminator">Initialization of Pix2Pix Generator and Discriminator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#training">Training</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inference">Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cyclegan.html">CycleGAN for Image Style Migration</a></li>
<li class="toctree-l1"><a class="reference internal" href="diffusion.html">Diffusion Model</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MindSpore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Pix2Pix for Image Translation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/generative/pix2pix.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section class="tex2jax_ignore mathjax_ignore" id="pix2pix-for-image-translation">
<h1>Pix2Pix for Image Translation<a class="headerlink" href="#pix2pix-for-image-translation" title="Permalink to this headline"></a></h1>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/blob/r2.2/tutorials/application/source_en/generative/pix2pix.md"><img alt="View Source On Gitee" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.2/resource/_static/logo_source_en.svg" /></a></p>
<section id="pix2pix-overview">
<h2>Pix2Pix Overview<a class="headerlink" href="#pix2pix-overview" title="Permalink to this headline"></a></h2>
<p>Pix2Pix is a deep learning image translation model implemented based on the condition generative adversarial network (cGAN). This model was proposed by Phillip Isola et al. at CVPR 2017, which can translate semantics/labels to real images, grayscale images to color images, aerial images to maps, daytime to nighttime, and line manuscript images to real images. Pix2Pix is a classic work of applying cGAN to supervised image-to-image translation. It consists of two models: <strong>generator</strong> and <strong>discriminator</strong>.</p>
<p>Traditionally, although the goal of such tasks is the same to predict pixels from pixels, each item is handled with a separate dedicated machine. The network used by Pix2Pix serves as a general framework, uses the same architecture and objectives, and trains only on different data to obtain satisfactory results, given that many people have used this network to publish their own works of art.</p>
</section>
<section id="basic-principles">
<h2>Basic Principles<a class="headerlink" href="#basic-principles" title="Permalink to this headline"></a></h2>
<p>There are some differences in principles between the cGAN generator and the traditional GAN generator. The cGAN generator uses the input image as the guidance information, and continuously attempts to generate a “fake” image for confusing the discriminator. The essence of converting an input image into a corresponding “fake” image is to map a pixel to another pixel. However, a traditional GAN generator generates an image based on a given random noise, and the output image is generated based on other constraints. This is the difference between cGAN and GAN in image translation tasks. The task of the discriminator in Pix2Pix is to determine whether the image output from the generator is a real training image or a generated “fake” image. During the continuous game between the generator and the discriminator, the model reaches a balance point. The image output by the generator and the real training data make the discriminator have a 50% probability of correct judgment.</p>
<p>Before this tutorial, you need to define some symbols to be used in the entire process:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x\)</span>: indicates the data of the observed image.</p></li>
<li><p><span class="math notranslate nohighlight">\(z\)</span>: indicates the data of random noise.</p></li>
<li><p><span class="math notranslate nohighlight">\(y=G(x,z)\)</span>: indicates the generator network, which gives a “fake” image generated by the observed image <span class="math notranslate nohighlight">\(x\)</span> and random noise <span class="math notranslate nohighlight">\(z\)</span>, where <span class="math notranslate nohighlight">\(x\)</span> comes from the training data rather than the generator.</p></li>
<li><p><span class="math notranslate nohighlight">\(D(x,G(x,z))\)</span>: indicates the discriminator network, which provides the probability that an image is determined as a real image. <span class="math notranslate nohighlight">\(x\)</span> comes from the training data, and <span class="math notranslate nohighlight">\(G(x,z)\)</span> comes from the generator.</p></li>
</ul>
<p>The objectives of cGAN can be expressed as follows:</p>
<div class="math notranslate nohighlight">
\[L_{cGAN}(G,D)=E_{(x,y)}[log(D(x,y))]+E_{(x,z)}[log(1-D(x,G(x,z)))]\]</div>
<p>The formula is a loss function of cGAN. <code class="docutils literal notranslate"><span class="pre">D</span></code> tries to correctly classify real images and “fake” images, that is, maximize the parameter <span class="math notranslate nohighlight">\(log D(x,y)\)</span>. <code class="docutils literal notranslate"><span class="pre">G</span></code> tries to deceive <code class="docutils literal notranslate"><span class="pre">D</span></code> with the generated “fake” image <span class="math notranslate nohighlight">\(y\)</span>, that is, minimize the value of <span class="math notranslate nohighlight">\(log(1-D(G(x,z)))\)</span>. The objectives of cGAN can be simplified as follows:</p>
<div class="math notranslate nohighlight">
\[arg\min_{G}\max_{D}L_{cGAN}(G,D)\]</div>
<p><img alt="pix2pix1" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.2/tutorials/application/source_zh_cn/generative/images/pix2pix_1.png" /></p>
<p>To compare the differences between cGAN and GAN, the objectives of GAN can be expressed as follows:</p>
<div class="math notranslate nohighlight">
\[L_{GAN}(G,D)=E_{y}[log(D(y))]+E_{(x,z)}[log(1-D(x,z))]\]</div>
<p>It can be seen from the formula that GAN directly generates a “fake” image from random noise <span class="math notranslate nohighlight">\(z\)</span> without using any information of the observed image <span class="math notranslate nohighlight">\(x\)</span>. Previous approaches have found it beneficial to mix the GAN objective with a more traditional loss. The task of the discriminator remains unchanged, that is, to distinguish real images from “fake” images. However, the task of the generator is not only to deceive the discriminator, it is also close to the training data on the basis of traditional losses. Assume that cGAN and L1 regularization are used together, then:</p>
<div class="math notranslate nohighlight">
\[L_{L1}(G)=E_{(x,y,z)}[||y-G(x,z)||_{1}]\]</div>
<p>Our final objective is:</p>
<div class="math notranslate nohighlight">
\[arg\min_{G}\max_{D}L_{cGAN}(G,D)+\lambda L_{L1}(G)\]</div>
<p>The image translation problem is essentially the pixel-to-pixel mapping problem. Pix2Pix uses the same network structure and objective function. The preceding tasks can be implemented by replacing different training datasets. This task uses the MindSpore framework to implement the Pix2Pix application.</p>
</section>
<section id="preparations">
<h2>Preparations<a class="headerlink" href="#preparations" title="Permalink to this headline"></a></h2>
<section id="configuring-the-environment-file">
<h3>Configuring the Environment File<a class="headerlink" href="#configuring-the-environment-file" title="Permalink to this headline"></a></h3>
<p>You can run this case in either dynamic or static mode on the GPU, CPU, or Ascend platform.</p>
</section>
<section id="preparing-data">
<h3>Preparing Data<a class="headerlink" href="#preparing-data" title="Permalink to this headline"></a></h3>
<p>In this tutorial, we will use <a class="reference external" href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/models/application/dataset_pix2pix.tar">specified dataset</a> which is processed facades data and can be directly read using the mindspore.dataset method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">download</span> <span class="kn">import</span> <span class="n">download</span>

<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/models/application/dataset_pix2pix.tar&quot;</span>

<span class="n">download</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="s2">&quot;./dataset&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;tar&quot;</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="data-display">
<h3>Data Display<a class="headerlink" href="#data-display" title="Permalink to this headline"></a></h3>
<p>Call <code class="docutils literal notranslate"><span class="pre">Pix2PixDataset</span></code> and <code class="docutils literal notranslate"><span class="pre">create_train_dataset</span></code> to read the training set. Here, we directly download the processed dataset.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">dataset</span> <span class="k">as</span> <span class="n">ds</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">MindDataset</span><span class="p">(</span><span class="s2">&quot;./dataset/dataset_pix2pix/train.mindrecord&quot;</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input_images&quot;</span><span class="p">,</span> <span class="s2">&quot;target_images&quot;</span><span class="p">],</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">data_iter</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">create_dict_iterator</span><span class="p">(</span><span class="n">output_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1"># Visualize some training data.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">140</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_iter</span><span class="p">[</span><span class="s1">&#39;input_images&#39;</span><span class="p">][:</span><span class="mi">10</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
<section id="creating-a-network">
<h2>Creating a Network<a class="headerlink" href="#creating-a-network" title="Permalink to this headline"></a></h2>
<p>After the data is processed, you can set up the network. The generator, discriminator, and loss function will be discussed in detail one by one. Generator G uses the U-Net structure. The input contour map <span class="math notranslate nohighlight">\(x\)</span> is encoded and then decoded into a real image. Discriminator D uses the condition discriminator PatchGAN proposed by the author. A function of the discriminator D is to determine, under a condition of the contour map <span class="math notranslate nohighlight">\(x\)</span>, that the generated image <span class="math notranslate nohighlight">\(G(x)\)</span> is false, and that the generated image <span class="math notranslate nohighlight">\(G(x)\)</span> is true.</p>
<section id="generator-g-structure">
<h3>Generator G Structure<a class="headerlink" href="#generator-g-structure" title="Permalink to this headline"></a></h3>
<p>U-Net is a fully convolutional structure proposed by the pattern recognition and image processing team of University of Freiburg in Germany. It is divided into two parts. The left part is the compression path formed by convolution and downsampling operations, and the right part is the expansion path formed by convolution and upsampling. The input of each expanded network block is formed by combining the features sampled at the upper layer and the features of the compression path part. The network model is a U-shaped structure and therefore is called U-Net. Compared with the common network where the sampling is reduced to a low dimension and then increased to the original resolution, the U-Net adds skip-connection. The corresponding feature maps and the decoded feature maps of the same size are combined by channel. It is used to reserve pixel-level details at different resolutions.</p>
<p><img alt="pix2pix2" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.2/tutorials/application/source_zh_cn/generative/images/pix2pix_2.png" /></p>
<section id="defining-the-u-net-skip-connection-block">
<h4>Defining the U-Net Skip Connection Block<a class="headerlink" href="#defining-the-u-net-skip-connection-block" title="Permalink to this headline"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span>
<span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">mindspore.ops</span> <span class="k">as</span> <span class="nn">ops</span>

<span class="k">class</span> <span class="nc">UNetSkipConnectionBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outer_nc</span><span class="p">,</span> <span class="n">inner_nc</span><span class="p">,</span> <span class="n">in_planes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">submodule</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outermost</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">innermost</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">norm_mode</span><span class="o">=</span><span class="s1">&#39;batch&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UNetSkipConnectionBlock</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">down_norm</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">inner_nc</span><span class="p">)</span>
        <span class="n">up_norm</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">outer_nc</span><span class="p">)</span>
        <span class="n">use_bias</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">norm_mode</span> <span class="o">==</span> <span class="s1">&#39;instance&#39;</span><span class="p">:</span>
            <span class="n">down_norm</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">inner_nc</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">up_norm</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">outer_nc</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">use_bias</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">in_planes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">in_planes</span> <span class="o">=</span> <span class="n">outer_nc</span>
        <span class="n">down_conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">inner_nc</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                              <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">has_bias</span><span class="o">=</span><span class="n">use_bias</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
        <span class="n">down_relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">up_relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">outermost</span><span class="p">:</span>
            <span class="n">up_conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2dTranspose</span><span class="p">(</span><span class="n">inner_nc</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">outer_nc</span><span class="p">,</span>
                                         <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                         <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
            <span class="n">down</span> <span class="o">=</span> <span class="p">[</span><span class="n">down_conv</span><span class="p">]</span>
            <span class="n">up</span> <span class="o">=</span> <span class="p">[</span><span class="n">up_relu</span><span class="p">,</span> <span class="n">up_conv</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Tanh</span><span class="p">()]</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">down</span> <span class="o">+</span> <span class="p">[</span><span class="n">submodule</span><span class="p">]</span> <span class="o">+</span> <span class="n">up</span>
        <span class="k">elif</span> <span class="n">innermost</span><span class="p">:</span>
            <span class="n">up_conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2dTranspose</span><span class="p">(</span><span class="n">inner_nc</span><span class="p">,</span> <span class="n">outer_nc</span><span class="p">,</span>
                                         <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                         <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">has_bias</span><span class="o">=</span><span class="n">use_bias</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
            <span class="n">down</span> <span class="o">=</span> <span class="p">[</span><span class="n">down_relu</span><span class="p">,</span> <span class="n">down_conv</span><span class="p">]</span>
            <span class="n">up</span> <span class="o">=</span> <span class="p">[</span><span class="n">up_relu</span><span class="p">,</span> <span class="n">up_conv</span><span class="p">,</span> <span class="n">up_norm</span><span class="p">]</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">down</span> <span class="o">+</span> <span class="n">up</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">up_conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2dTranspose</span><span class="p">(</span><span class="n">inner_nc</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">outer_nc</span><span class="p">,</span>
                                         <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                         <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">has_bias</span><span class="o">=</span><span class="n">use_bias</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
            <span class="n">down</span> <span class="o">=</span> <span class="p">[</span><span class="n">down_relu</span><span class="p">,</span> <span class="n">down_conv</span><span class="p">,</span> <span class="n">down_norm</span><span class="p">]</span>
            <span class="n">up</span> <span class="o">=</span> <span class="p">[</span><span class="n">up_relu</span><span class="p">,</span> <span class="n">up_conv</span><span class="p">,</span> <span class="n">up_norm</span><span class="p">]</span>

            <span class="n">model</span> <span class="o">=</span> <span class="n">down</span> <span class="o">+</span> <span class="p">[</span><span class="n">submodule</span><span class="p">]</span> <span class="o">+</span> <span class="n">up</span>
            <span class="k">if</span> <span class="n">dropout</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">SequentialCell</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_connections</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">outermost</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_connections</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">out</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</section>
<section id="u-net-based-generator">
<h4>U-Net-based Generator<a class="headerlink" href="#u-net-based-generator" title="Permalink to this headline"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UNetGenerator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="p">,</span> <span class="n">ngf</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">n_layers</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">norm_mode</span><span class="o">=</span><span class="s1">&#39;bn&#39;</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UNetGenerator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">unet_block</span> <span class="o">=</span> <span class="n">UNetSkipConnectionBlock</span><span class="p">(</span><span class="n">ngf</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">ngf</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">in_planes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">submodule</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                             <span class="n">norm_mode</span><span class="o">=</span><span class="n">norm_mode</span><span class="p">,</span> <span class="n">innermost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_layers</span> <span class="o">-</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">unet_block</span> <span class="o">=</span> <span class="n">UNetSkipConnectionBlock</span><span class="p">(</span><span class="n">ngf</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">ngf</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">in_planes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">submodule</span><span class="o">=</span><span class="n">unet_block</span><span class="p">,</span>
                                                 <span class="n">norm_mode</span><span class="o">=</span><span class="n">norm_mode</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="n">dropout</span><span class="p">)</span>
        <span class="n">unet_block</span> <span class="o">=</span> <span class="n">UNetSkipConnectionBlock</span><span class="p">(</span><span class="n">ngf</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ngf</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">in_planes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">submodule</span><span class="o">=</span><span class="n">unet_block</span><span class="p">,</span>
                                             <span class="n">norm_mode</span><span class="o">=</span><span class="n">norm_mode</span><span class="p">)</span>
        <span class="n">unet_block</span> <span class="o">=</span> <span class="n">UNetSkipConnectionBlock</span><span class="p">(</span><span class="n">ngf</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ngf</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">in_planes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">submodule</span><span class="o">=</span><span class="n">unet_block</span><span class="p">,</span>
                                             <span class="n">norm_mode</span><span class="o">=</span><span class="n">norm_mode</span><span class="p">)</span>
        <span class="n">unet_block</span> <span class="o">=</span> <span class="n">UNetSkipConnectionBlock</span><span class="p">(</span><span class="n">ngf</span><span class="p">,</span> <span class="n">ngf</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">in_planes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">submodule</span><span class="o">=</span><span class="n">unet_block</span><span class="p">,</span>
                                             <span class="n">norm_mode</span><span class="o">=</span><span class="n">norm_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">UNetSkipConnectionBlock</span><span class="p">(</span><span class="n">out_planes</span><span class="p">,</span> <span class="n">ngf</span><span class="p">,</span> <span class="n">in_planes</span><span class="o">=</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">submodule</span><span class="o">=</span><span class="n">unet_block</span><span class="p">,</span>
                                             <span class="n">outermost</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm_mode</span><span class="o">=</span><span class="n">norm_mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The input of the original cGAN is two types of information: condition x and noise z. The generator here uses only the condition information. Therefore, the generator cannot generate diversified results. Pix2Pix uses dropout during training and testing. In this way, diversified results can be generated.</p>
</section>
</section>
<section id="patchgan-based-discriminator">
<h3>PatchGAN-based Discriminator<a class="headerlink" href="#patchgan-based-discriminator" title="Permalink to this headline"></a></h3>
<p>PatchGAN structure used by the discriminator can be considered as convolution. Each point in the generated matrix represents a patch of the original image. The values in the matrix are used to determine whether each patch in the original image is true or false.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>

<span class="k">class</span> <span class="nc">ConvNormRelu</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_planes</span><span class="p">,</span>
                 <span class="n">out_planes</span><span class="p">,</span>
                 <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                 <span class="n">norm_mode</span><span class="o">=</span><span class="s1">&#39;batch&#39;</span><span class="p">,</span>
                 <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;CONSTANT&#39;</span><span class="p">,</span>
                 <span class="n">use_relu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ConvNormRelu</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_planes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm_mode</span> <span class="o">==</span> <span class="s1">&#39;instance&#39;</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_planes</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">has_bias</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm_mode</span> <span class="o">==</span> <span class="s1">&#39;instance&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">kernel_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">==</span> <span class="s1">&#39;CONSTANT&#39;</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span>
                             <span class="n">has_bias</span><span class="o">=</span><span class="n">has_bias</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">)</span>
            <span class="n">layers</span> <span class="o">=</span> <span class="p">[</span><span class="n">conv</span><span class="p">,</span> <span class="n">norm</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">paddings</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">padding</span><span class="p">),</span> <span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">padding</span><span class="p">))</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">paddings</span><span class="o">=</span><span class="n">paddings</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="n">has_bias</span><span class="o">=</span><span class="n">has_bias</span><span class="p">)</span>
            <span class="n">layers</span> <span class="o">=</span> <span class="p">[</span><span class="n">pad</span><span class="p">,</span> <span class="n">conv</span><span class="p">,</span> <span class="n">norm</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">use_relu</span><span class="p">:</span>
            <span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">relu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">SequentialCell</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

<span class="k">class</span> <span class="nc">Discriminator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_planes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ndf</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">n_layers</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">norm_mode</span><span class="o">=</span><span class="s1">&#39;batch&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Discriminator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">ndf</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">nf_mult</span> <span class="o">=</span> <span class="n">ndf</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">):</span>
            <span class="n">nf_mult_prev</span> <span class="o">=</span> <span class="n">nf_mult</span>
            <span class="n">nf_mult</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="n">ndf</span>
            <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ConvNormRelu</span><span class="p">(</span><span class="n">nf_mult_prev</span><span class="p">,</span> <span class="n">nf_mult</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">norm_mode</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">nf_mult_prev</span> <span class="o">=</span> <span class="n">nf_mult</span>
        <span class="n">nf_mult</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n_layers</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="n">ndf</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ConvNormRelu</span><span class="p">(</span><span class="n">nf_mult_prev</span><span class="p">,</span> <span class="n">nf_mult</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">norm_mode</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">nf_mult</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">SequentialCell</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">x_y</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">(</span><span class="n">x_y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</pre></div>
</div>
</section>
<section id="initialization-of-pix2pix-generator-and-discriminator">
<h3>Initialization of Pix2Pix Generator and Discriminator<a class="headerlink" href="#initialization-of-pix2pix-generator-and-discriminator" title="Permalink to this headline"></a></h3>
<p>Instantiate the Pix2Pix generator and discriminator.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">mindspore.common</span> <span class="kn">import</span> <span class="n">initializer</span> <span class="k">as</span> <span class="n">init</span>

<span class="n">g_in_planes</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">g_out_planes</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">g_ngf</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">g_layers</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">d_in_planes</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">d_ndf</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">d_layers</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">init_gain</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="n">init_type</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span>


<span class="n">net_generator</span> <span class="o">=</span> <span class="n">UNetGenerator</span><span class="p">(</span><span class="n">in_planes</span><span class="o">=</span><span class="n">g_in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="o">=</span><span class="n">g_out_planes</span><span class="p">,</span>
                              <span class="n">ngf</span><span class="o">=</span><span class="n">g_ngf</span><span class="p">,</span> <span class="n">n_layers</span><span class="o">=</span><span class="n">g_layers</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">net_generator</span><span class="o">.</span><span class="n">cells_and_names</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2dTranspose</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">init_gain</span><span class="p">),</span> <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;xavier&#39;</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">XavierUniform</span><span class="p">(</span><span class="n">init_gain</span><span class="p">),</span> <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;initialization method [</span><span class="si">%s</span><span class="s1">] is not implemented&#39;</span> <span class="o">%</span> <span class="n">init_type</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">):</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="s1">&#39;zeros&#39;</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>


<span class="n">net_discriminator</span> <span class="o">=</span> <span class="n">Discriminator</span><span class="p">(</span><span class="n">in_planes</span><span class="o">=</span><span class="n">d_in_planes</span><span class="p">,</span> <span class="n">ndf</span><span class="o">=</span><span class="n">d_ndf</span><span class="p">,</span>
                                  <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n_layers</span><span class="o">=</span><span class="n">d_layers</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">net_discriminator</span><span class="o">.</span><span class="n">cells_and_names</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2dTranspose</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">init_gain</span><span class="p">),</span> <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;xavier&#39;</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">XavierUniform</span><span class="p">(</span><span class="n">init_gain</span><span class="p">),</span> <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;initialization method [</span><span class="si">%s</span><span class="s1">] is not implemented&#39;</span> <span class="o">%</span> <span class="n">init_type</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">):</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">initializer</span><span class="p">(</span><span class="s1">&#39;zeros&#39;</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Pix2Pix</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pix2Pix model network&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">,</span> <span class="n">generator</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Pix2Pix</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">auto_prefix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net_discriminator</span> <span class="o">=</span> <span class="n">discriminator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net_generator</span> <span class="o">=</span> <span class="n">generator</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reala</span><span class="p">):</span>
        <span class="n">fakeb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_generator</span><span class="p">(</span><span class="n">reala</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fakeb</span>
</pre></div>
</div>
</section>
</section>
<section id="training">
<h2>Training<a class="headerlink" href="#training" title="Permalink to this headline"></a></h2>
<p>Training is divided into two parts: discriminator training and generator training. The discriminator is trained to improve the probability of discriminating real images to the greatest extent. The training generator is expected to produce better fake images. In the two parts, the losses in the training process are obtained separately, and statistics are collected at the end of each epoch.</p>
<p>The training process is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">value_and_grad</span><span class="p">,</span> <span class="n">Tensor</span>

<span class="n">epoch_num</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">ckpt_dir</span> <span class="o">=</span> <span class="s2">&quot;results/ckpt&quot;</span>
<span class="n">dataset_size</span> <span class="o">=</span> <span class="mi">400</span>
<span class="n">val_pic_size</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">lr</span> <span class="o">=</span> <span class="mf">0.0002</span>
<span class="n">n_epochs</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">n_epochs_decay</span> <span class="o">=</span> <span class="mi">100</span>

<span class="k">def</span> <span class="nf">get_lr</span><span class="p">():</span>
    <span class="n">lrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">lr</span><span class="p">]</span> <span class="o">*</span> <span class="n">dataset_size</span> <span class="o">*</span> <span class="n">n_epochs</span>
    <span class="n">lr_epoch</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_epochs_decay</span><span class="p">):</span>
        <span class="n">lr_epoch</span> <span class="o">=</span> <span class="n">lr</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_epochs_decay</span> <span class="o">-</span> <span class="n">epoch</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_epochs_decay</span>
        <span class="n">lrs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lr_epoch</span><span class="p">]</span> <span class="o">*</span> <span class="n">dataset_size</span>
    <span class="n">lrs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lr_epoch</span><span class="p">]</span> <span class="o">*</span> <span class="n">dataset_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">epoch_num</span> <span class="o">-</span> <span class="n">n_epochs_decay</span> <span class="o">-</span> <span class="n">n_epochs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lrs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">MindDataset</span><span class="p">(</span><span class="s2">&quot;./dataset/dataset_pix2pix/train.mindrecord&quot;</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input_images&quot;</span><span class="p">,</span> <span class="s2">&quot;target_images&quot;</span><span class="p">],</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_parallel_workers</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">steps_per_epoch</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_dataset_size</span><span class="p">()</span>
<span class="n">loss_f</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">()</span>
<span class="n">l1_loss</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">L1Loss</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">forword_dis</span><span class="p">(</span><span class="n">reala</span><span class="p">,</span> <span class="n">realb</span><span class="p">):</span>
    <span class="n">lambda_dis</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">fakeb</span> <span class="o">=</span> <span class="n">net_generator</span><span class="p">(</span><span class="n">reala</span><span class="p">)</span>
    <span class="n">pred0</span> <span class="o">=</span> <span class="n">net_discriminator</span><span class="p">(</span><span class="n">reala</span><span class="p">,</span> <span class="n">fakeb</span><span class="p">)</span>
    <span class="n">pred1</span> <span class="o">=</span> <span class="n">net_discriminator</span><span class="p">(</span><span class="n">reala</span><span class="p">,</span> <span class="n">realb</span><span class="p">)</span>
    <span class="n">loss_d</span> <span class="o">=</span> <span class="n">loss_f</span><span class="p">(</span><span class="n">pred1</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pred1</span><span class="p">))</span> <span class="o">+</span> <span class="n">loss_f</span><span class="p">(</span><span class="n">pred0</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pred0</span><span class="p">))</span>
    <span class="n">loss_dis</span> <span class="o">=</span> <span class="n">loss_d</span> <span class="o">*</span> <span class="n">lambda_dis</span>
    <span class="k">return</span> <span class="n">loss_dis</span>

<span class="k">def</span> <span class="nf">forword_gan</span><span class="p">(</span><span class="n">reala</span><span class="p">,</span> <span class="n">realb</span><span class="p">):</span>
    <span class="n">lambda_gan</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">lambda_l1</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">fakeb</span> <span class="o">=</span> <span class="n">net_generator</span><span class="p">(</span><span class="n">reala</span><span class="p">)</span>
    <span class="n">pred0</span> <span class="o">=</span> <span class="n">net_discriminator</span><span class="p">(</span><span class="n">reala</span><span class="p">,</span> <span class="n">fakeb</span><span class="p">)</span>
    <span class="n">loss_1</span> <span class="o">=</span> <span class="n">loss_f</span><span class="p">(</span><span class="n">pred0</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pred0</span><span class="p">))</span>
    <span class="n">loss_2</span> <span class="o">=</span> <span class="n">l1_loss</span><span class="p">(</span><span class="n">fakeb</span><span class="p">,</span> <span class="n">realb</span><span class="p">)</span>
    <span class="n">loss_gan</span> <span class="o">=</span> <span class="n">loss_1</span> <span class="o">*</span> <span class="n">lambda_gan</span> <span class="o">+</span> <span class="n">loss_2</span> <span class="o">*</span> <span class="n">lambda_l1</span>
    <span class="k">return</span> <span class="n">loss_gan</span>

<span class="n">d_opt</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">net_discriminator</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="n">get_lr</span><span class="p">(),</span>
                <span class="n">beta1</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">beta2</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span> <span class="n">loss_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g_opt</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">net_generator</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="o">=</span><span class="n">get_lr</span><span class="p">(),</span>
                <span class="n">beta1</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">beta2</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span> <span class="n">loss_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">grad_d</span> <span class="o">=</span> <span class="n">value_and_grad</span><span class="p">(</span><span class="n">forword_dis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">net_discriminator</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">())</span>
<span class="n">grad_g</span> <span class="o">=</span> <span class="n">value_and_grad</span><span class="p">(</span><span class="n">forword_gan</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">net_generator</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">train_step</span><span class="p">(</span><span class="n">reala</span><span class="p">,</span> <span class="n">realb</span><span class="p">):</span>
    <span class="n">loss_dis</span><span class="p">,</span> <span class="n">d_grads</span> <span class="o">=</span> <span class="n">grad_d</span><span class="p">(</span><span class="n">reala</span><span class="p">,</span> <span class="n">realb</span><span class="p">)</span>
    <span class="n">loss_gan</span><span class="p">,</span> <span class="n">g_grads</span> <span class="o">=</span> <span class="n">grad_g</span><span class="p">(</span><span class="n">reala</span><span class="p">,</span> <span class="n">realb</span><span class="p">)</span>
    <span class="n">d_opt</span><span class="p">(</span><span class="n">d_grads</span><span class="p">)</span>
    <span class="n">g_opt</span><span class="p">(</span><span class="n">g_grads</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loss_dis</span><span class="p">,</span> <span class="n">loss_gan</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">ckpt_dir</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">ckpt_dir</span><span class="p">)</span>

<span class="n">g_losses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">d_losses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data_loader</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">create_dict_iterator</span><span class="p">(</span><span class="n">output_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_epochs</span><span class="o">=</span><span class="n">epoch_num</span><span class="p">)</span>

<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epoch_num</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_loader</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">input_image</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;input_images&quot;</span><span class="p">])</span>
        <span class="n">target_image</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;target_images&quot;</span><span class="p">])</span>
        <span class="n">dis_loss</span><span class="p">,</span> <span class="n">gen_loss</span> <span class="o">=</span> <span class="n">train_step</span><span class="p">(</span><span class="n">input_image</span><span class="p">,</span> <span class="n">target_image</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">microseconds</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ms per step:</span><span class="si">{:.2f}</span><span class="s2">  epoch:</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">  step:</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">  Dloss:</span><span class="si">{:.4f}</span><span class="s2">  Gloss:</span><span class="si">{:.4f}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">delta</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">),</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">epoch_num</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">steps_per_epoch</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">dis_loss</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">gen_loss</span><span class="p">)))</span>
        <span class="n">d_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dis_loss</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
        <span class="n">g_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen_loss</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">epoch_num</span><span class="p">:</span>
        <span class="n">mindspore</span><span class="o">.</span><span class="n">save_checkpoint</span><span class="p">(</span><span class="n">net_generator</span><span class="p">,</span> <span class="n">ckpt_dir</span> <span class="o">+</span> <span class="s2">&quot;Generator.ckpt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ms per step:532.31   epoch:1/100  step:0/25  Dloss:0.6940  Gloss:38.1245
ms per step:304.35   epoch:1/100  step:2/25  Dloss:0.6489  Gloss:39.4826
ms per step:299.15   epoch:1/100  step:4/25  Dloss:0.5506  Gloss:36.7634
ms per step:301.06   epoch:1/100  step:6/25  Dloss:1.6741  Gloss:47.7600
ms per step:299.72   epoch:1/100  step:8/25  Dloss:0.4604  Gloss:39.7121
......                                                            ......
ms per step:290.44   epoch:100/100  step:16/25  Dloss:0.6009  Gloss:9.1915
ms per step:289.95   epoch:100/100  step:18/25  Dloss:0.4617  Gloss:9.8740
ms per step:290.24   epoch:100/100  step:20/25  Dloss:0.4402  Gloss:8.2490
ms per step:287.70   epoch:100/100  step:22/25  Dloss:0.3814  Gloss:9.3652
ms per step:289.41   epoch:100/100  step:24/25  Dloss:0.4199  Gloss:9.2418
</pre></div>
</div>
</section>
<section id="inference">
<h2>Inference<a class="headerlink" href="#inference" title="Permalink to this headline"></a></h2>
<p>Obtain the CKPT file after the preceding training process is complete, import the weight parameters in the CKPT file to the model by using load_checkpoint and load_param_into_net, obtain data for inference, and demonstrate the inference effect. (Only 100 epochs are performed during the training process.)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mindspore</span> <span class="kn">import</span> <span class="n">load_checkpoint</span><span class="p">,</span> <span class="n">load_param_into_net</span>

<span class="n">param_g</span> <span class="o">=</span> <span class="n">load_checkpoint</span><span class="p">(</span><span class="n">ckpt_dir</span> <span class="o">+</span> <span class="s2">&quot;Generator.ckpt&quot;</span><span class="p">)</span>
<span class="n">load_param_into_net</span><span class="p">(</span><span class="n">net_generator</span><span class="p">,</span> <span class="n">param_g</span><span class="p">)</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">MindDataset</span><span class="p">(</span><span class="s2">&quot;./dataset/dataset_pix2pix/train.mindrecord&quot;</span><span class="p">,</span> <span class="n">columns_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input_images&quot;</span><span class="p">,</span> <span class="s2">&quot;target_images&quot;</span><span class="p">],</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">data_iter</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">create_dict_iterator</span><span class="p">())</span>
<span class="n">predict_show</span> <span class="o">=</span> <span class="n">net_generator</span><span class="p">(</span><span class="n">data_iter</span><span class="p">[</span><span class="s2">&quot;input_images&quot;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">140</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">((</span><span class="n">data_iter</span><span class="p">[</span><span class="s2">&quot;input_images&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">11</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">((</span><span class="n">predict_show</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

</pre></div>
</div>
<p>The inference effect of each dataset is as follows:</p>
<p><img alt="pix2pix3" src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r2.2/tutorials/application/source_zh_cn/generative/images/pix2pix_3.png" /></p>
</section>
<section id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline"></a></h2>
<p>[1] Phillip Isola,Jun-Yan Zhu,Tinghui Zhou,Alexei A. Efros. Image-to-Image Translation with Conditional Adversarial Networks.[J]. CoRR,2016,abs/1611.07004.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="dcgan.html" class="btn btn-neutral float-left" title="Generating Cartoon Head Portrait via DCGAN" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="cyclegan.html" class="btn btn-neutral float-right" title="CycleGAN for Image Style Migration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 
</body>
</html>