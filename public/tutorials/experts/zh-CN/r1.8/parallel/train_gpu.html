

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>分布式并行训练基础样例（GPU） &mdash; MindSpore master documentation</title>
  

  
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
   
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  
  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="分布式并行训练Transformer模型" href="transformer.html" />
    <link rel="prev" title="分布式并行训练基础样例（Ascend）" href="train_ascend.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> MindSpore
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">数据处理</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataset/augment.html">自动数据增强</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataset/eager.html">轻量化数据处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataset/cache.html">单节点数据缓存</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataset/optimize.html">数据处理性能优化</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">网络构建</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../network/op_overload.html">优化器的编译优化</a></li>
<li class="toctree-l1"><a class="reference internal" href="../network/custom_cell_reverse.html">自定义Cell的反向</a></li>
<li class="toctree-l1"><a class="reference internal" href="../network/ms_class.html">调用自定义类</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">模型训练优化</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../others/mixed_precision.html">混合精度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../others/gradient_accumulation.html">梯度累积算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../others/adaptive_summation.html">自适应梯度求和算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../others/dimention_reduce_training.html">降维训练算法</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">自定义算子</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../operation/op_custom.html">自定义算子（基于Custom表达）</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">模型推理</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../infer/inference.html">模型推理总览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infer/cpu_gpu_mindir.html">GPU推理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infer/ascend_910_mindir.html">Ascend 910 AI处理器上推理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infer/ascend_310_mindir.html">Ascend 310 AI处理器上使用MindIR模型进行推理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infer/ascend_310_air.html">Ascend 310 AI处理器上使用AIR模型进行推理</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">调试调优</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../debug/function_debug.html">功能调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug/performance_optimization.html">性能调优</a></li>
<li class="toctree-l1"><a class="reference external" href="https://mindspore.cn/mindinsight/docs/zh-CN/r1.8/accuracy_problem_preliminary_location.html">精度调优↗</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">分布式并行</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">分布式并行总览</a></li>
<li class="toctree-l1"><a class="reference internal" href="communicate_ops.html">分布式集合通信原语</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="distributed_case.html">分布式案例</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="train_ascend.html">分布式并行训练基础样例（Ascend）</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">分布式并行训练基础样例（GPU）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#概述">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#准备环节">准备环节</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#配置分布式环境">配置分布式环境</a></li>
<li class="toctree-l4"><a class="reference internal" href="#调用集合通信库">调用集合通信库</a></li>
<li class="toctree-l4"><a class="reference internal" href="#下载数据集">下载数据集</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#数据并行模式加载数据集">数据并行模式加载数据集</a></li>
<li class="toctree-l3"><a class="reference internal" href="#定义网络">定义网络</a></li>
<li class="toctree-l3"><a class="reference internal" href="#定义损失函数及优化器">定义损失函数及优化器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#定义损失函数">定义损失函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#定义优化器">定义优化器</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#训练网络">训练网络</a></li>
<li class="toctree-l3"><a class="reference internal" href="#运行脚本">运行脚本</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#单机多卡训练">单机多卡训练</a></li>
<li class="toctree-l4"><a class="reference internal" href="#多机多卡训练">多机多卡训练</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#分布式训练模型参数保存与加载">分布式训练模型参数保存与加载</a></li>
<li class="toctree-l3"><a class="reference internal" href="#不依赖openmpi进行训练">不依赖OpenMPI进行训练</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#运行脚本-1">运行脚本</a></li>
<li class="toctree-l4"><a class="reference internal" href="#安全认证">安全认证</a></li>
<li class="toctree-l4"><a class="reference internal" href="#容灾恢复">容灾恢复</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="transformer.html">分布式并行训练Transformer模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="pangu_alpha.html">鹏程·盘古模型网络多维度混合并行解析</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="distributed_inference.html">分布式推理</a></li>
<li class="toctree-l1"><a class="reference internal" href="save_load.html">保存和加载模型（HyBrid Parallel模式）</a></li>
<li class="toctree-l1"><a class="reference internal" href="fault_recover.html">分布式故障恢复</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_dimensional.html">多维度混合并行</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_features.html">其他特性</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">环境变量</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../env/env_var_list.html">环境变量</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MindSpore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="distributed_case.html">分布式案例</a> &raquo;</li>
      <li>分布式并行训练基础样例（GPU）</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/parallel/train_gpu.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="分布式并行训练基础样例gpu">
<h1>分布式并行训练基础样例（GPU）<a class="headerlink" href="#分布式并行训练基础样例gpu" title="Permalink to this headline"></a></h1>
<p><a href="https://gitee.com/mindspore/docs/blob/r1.8/tutorials/experts/source_zh_cn/parallel/train_gpu.md" target="_blank"><img src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/r1.8/resource/_static/logo_source.png"></a></p>
<section id="概述">
<h2>概述<a class="headerlink" href="#概述" title="Permalink to this headline"></a></h2>
<p>本篇教程我们主要讲解，如何在GPU处理器硬件平台上，利用MindSpore通过数据并行及自动并行模式，使用CIFAR-10数据集训练ResNet-50网络。</p>
<blockquote>
<div><p>你可以在这里下载完整的样例代码：</p>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/tree/r1.8/docs/sample_code/distributed_training">https://gitee.com/mindspore/docs/tree/r1.8/docs/sample_code/distributed_training</a></p>
</div></blockquote>
<p>目录结构如下：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>└─sample_code
    ├─distributed_training
    │      rank_table_16pcs.json
    │      rank_table_8pcs.json
    │      rank_table_2pcs.json
    │      cell_wrapper.py
    │      model_accu.py
    │      resnet.py
    │      resnet50_distributed_training.py
    │      resnet50_distributed_training_gpu.py
    │      resnet50_distributed_training_grad_accu.py
    │      run.sh
    │      run_gpu.sh
    │      run_grad_accu.sh
    │      run_cluster.sh
</pre></div>
</div>
<p>其中，<code class="docutils literal notranslate"><span class="pre">resnet.py</span></code>和<code class="docutils literal notranslate"><span class="pre">resnet50_distributed_training_gpu.py</span></code>是定义网络结构的脚本。<code class="docutils literal notranslate"><span class="pre">run_gpu.sh</span></code>是执行脚本，其余文件为Ascend 910的样例代码。</p>
</section>
<section id="准备环节">
<h2>准备环节<a class="headerlink" href="#准备环节" title="Permalink to this headline"></a></h2>
<p>为了保证分布式训练的正常进行，我们需要先对分布式环境进行配置和初步的测试。在完成之后，再做CIFAR-10数据集的准备。</p>
<section id="配置分布式环境">
<h3>配置分布式环境<a class="headerlink" href="#配置分布式环境" title="Permalink to this headline"></a></h3>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">OpenMPI-4.0.3</span></code>：MindSpore采用的多进程通信库。</p>
<p>OpenMPI-4.0.3源码下载地址：<a class="reference external" href="https://www.open-mpi.org/software/ompi/v4.0/">https://www.open-mpi.org/software/ompi/v4.0/</a>，选择<code class="docutils literal notranslate"><span class="pre">openmpi-4.0.3.tar.gz</span></code>下载。</p>
<p>参考OpenMPI官网教程安装：<a class="reference external" href="https://www.open-mpi.org/faq/?category=building#easy-build">https://www.open-mpi.org/faq/?category=building#easy-build</a>。</p>
</li>
<li><p>主机间免密登陆（涉及多机训练时需要）。若训练涉及多机，则需要配置多机间免密登陆，可参考以下步骤进行配置：</p>
<ol class="arabic simple">
<li><p>每台主机确定同一个用户作为登陆用户（不推荐root）；</p></li>
<li><p>执行<code class="docutils literal notranslate"><span class="pre">ssh-keygen</span> <span class="pre">-t</span> <span class="pre">rsa</span> <span class="pre">-P</span> <span class="pre">&quot;&quot;</span></code>生成密钥；</p></li>
<li><p>执行<code class="docutils literal notranslate"><span class="pre">ssh-copy-id</span> <span class="pre">DEVICE-IP</span></code>设置需要免密登陆的机器IP；</p></li>
<li><p>执行<code class="docutils literal notranslate"><span class="pre">ssh</span> <span class="pre">DEVICE-IP</span></code>，若不需要输入密码即可登录，则说明以上配置成功；</p></li>
<li><p>在所有机器上执行以上命令，确保两两互通。</p></li>
</ol>
</li>
</ul>
</section>
<section id="调用集合通信库">
<h3>调用集合通信库<a class="headerlink" href="#调用集合通信库" title="Permalink to this headline"></a></h3>
<p>在GPU硬件平台上，MindSpore分布式并行训练中的通信使用的是英伟达集合通信库<code class="docutils literal notranslate"><span class="pre">NVIDIA</span> <span class="pre">Collective</span> <span class="pre">Communication</span> <span class="pre">Library</span></code>(以下简称为NCCL)。</p>
<blockquote>
<div><p>GPU平台上，MindSpore暂不支持用户进行：</p>
<p><code class="docutils literal notranslate"><span class="pre">get_local_rank</span></code>、<code class="docutils literal notranslate"><span class="pre">get_local_size</span></code>、<code class="docutils literal notranslate"><span class="pre">get_world_rank_from_group_rank</span></code>、<code class="docutils literal notranslate"><span class="pre">get_group_rank_from_world_rank</span></code>、<code class="docutils literal notranslate"><span class="pre">create_group</span></code>操作。</p>
</div></blockquote>
<p>下面是调用通信库的代码样例，设文件名为nccl_allgather.py：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># nccl_allgather.py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">mindspore.ops</span> <span class="k">as</span> <span class="nn">ops</span>
<span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">from</span> <span class="nn">mindspore.communication</span> <span class="kn">import</span> <span class="n">init</span><span class="p">,</span> <span class="n">get_rank</span>


<span class="k">class</span> <span class="nc">Net</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Net</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allgather</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">AllGather</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">GRAPH_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;GPU&quot;</span><span class="p">)</span>
    <span class="n">init</span><span class="p">(</span><span class="s2">&quot;nccl&quot;</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">get_rank</span><span class="p">()</span>
    <span class="n">input_x</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">value</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">input_x</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
<p>其中，</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mode=GRAPH_MODE</span></code>：使用分布式训练需要指定运行模式为图模式（PyNative模式当前仅支持数据并行）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_target=&quot;GPU&quot;</span></code>: 指定设备为GPU。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">init(&quot;nccl&quot;)</span></code>：使能NCCL通信，并完成分布式训练初始化操作。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_rank()</span></code>：获得当前进程的rank号。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ops.AllGather</span></code>: 在GPU上，该算子会调用NCCL的AllGather通信操作，其含义以及更多的例子可在<a class="reference external" href="https://www.mindspore.cn/tutorials/experts/zh-CN/r1.8/parallel/communicate_ops.html">分布式集合通信原语</a>中找到。</p></li>
</ul>
<p>在GPU硬件平台上，MindSpore采用OpenMPI的mpirun来启动进程，通常每一个进程对应一个计算设备。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mpirun<span class="w"> </span>-n<span class="w"> </span>DEVICE_NUM<span class="w"> </span>python<span class="w"> </span>nccl_allgather.py
</pre></div>
</div>
<p>其中，DEVICE_NUM为所在机器的GPU数量。以DEVICE_NUM=4为例，预期的输出为：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[[0.],
 [1.],
 [2.],
 [3.]]
</pre></div>
</div>
<p>输出日志在程序执行后，可在<code class="docutils literal notranslate"><span class="pre">log/1/rank.0</span></code>中找到。若得到以上输出，则说明OpenMPI和NCCL工作正常，进程正常启动。</p>
</section>
<section id="下载数据集">
<h3>下载数据集<a class="headerlink" href="#下载数据集" title="Permalink to this headline"></a></h3>
<p>本样例采用<code class="docutils literal notranslate"><span class="pre">CIFAR-10</span></code>数据集，由10类32*32的彩色图片组成，每类包含6000张图片，共60000张。其中训练集共50000张图片，测试集共10000张图片。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">CIFAR-10</span></code>数据集下载链接：<a class="reference external" href="http://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz">http://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz</a>，如果点击下载不成功，请尝试复制链接地址后下载。</p>
</div></blockquote>
<p>Linux机器可采用以下命令下载到终端当前路径并解压数据集，解压后的数据所在文件夹为<code class="docutils literal notranslate"><span class="pre">cifar-10-batches-bin</span></code>。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>http://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz
tar<span class="w"> </span>-zxvf<span class="w"> </span>cifar-10-binary.tar.gz
</pre></div>
</div>
</section>
</section>
<section id="数据并行模式加载数据集">
<h2>数据并行模式加载数据集<a class="headerlink" href="#数据并行模式加载数据集" title="Permalink to this headline"></a></h2>
<p>分布式训练时，数据是以数据并行的方式导入的。下面我们以CIFAR-10数据集为例，介绍以数据并行方式导入CIFAR-10数据集的方法，<code class="docutils literal notranslate"><span class="pre">data_path</span></code>是指数据集的路径，即<code class="docutils literal notranslate"><span class="pre">cifar-10-batches-bin</span></code>文件夹的路径。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">import</span> <span class="nn">mindspore.dataset</span> <span class="k">as</span> <span class="nn">ds</span>
<span class="kn">import</span> <span class="nn">mindspore.dataset.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>
<span class="kn">import</span> <span class="nn">mindspore.dataset.vision</span> <span class="k">as</span> <span class="nn">vision</span>
<span class="kn">from</span> <span class="nn">mindspore.communication</span> <span class="kn">import</span> <span class="n">get_rank</span><span class="p">,</span> <span class="n">get_group_size</span>


<span class="k">def</span> <span class="nf">create_dataset</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="n">repeat_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">rank_id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rank_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">resize_height</span> <span class="o">=</span> <span class="mi">224</span>
    <span class="n">resize_width</span> <span class="o">=</span> <span class="mi">224</span>
    <span class="n">rescale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">255.0</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># get rank_id and rank_size</span>
    <span class="n">rank_id</span> <span class="o">=</span> <span class="n">get_rank</span><span class="p">()</span>
    <span class="n">rank_size</span> <span class="o">=</span> <span class="n">get_group_size</span><span class="p">()</span>
    <span class="n">data_set</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">Cifar10Dataset</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="n">num_shards</span><span class="o">=</span><span class="n">rank_size</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="n">rank_id</span><span class="p">)</span>

    <span class="c1"># define map operations</span>
    <span class="n">random_crop_op</span> <span class="o">=</span> <span class="n">vision</span><span class="o">.</span><span class="n">RandomCrop</span><span class="p">((</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">random_horizontal_op</span> <span class="o">=</span> <span class="n">vision</span><span class="o">.</span><span class="n">RandomHorizontalFlip</span><span class="p">()</span>
    <span class="n">resize_op</span> <span class="o">=</span> <span class="n">vision</span><span class="o">.</span><span class="n">Resize</span><span class="p">((</span><span class="n">resize_height</span><span class="p">,</span> <span class="n">resize_width</span><span class="p">))</span>
    <span class="n">rescale_op</span> <span class="o">=</span> <span class="n">vision</span><span class="o">.</span><span class="n">Rescale</span><span class="p">(</span><span class="n">rescale</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
    <span class="n">normalize_op</span> <span class="o">=</span> <span class="n">vision</span><span class="o">.</span><span class="n">Normalize</span><span class="p">((</span><span class="mf">0.4465</span><span class="p">,</span> <span class="mf">0.4822</span><span class="p">,</span> <span class="mf">0.4914</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2010</span><span class="p">,</span> <span class="mf">0.1994</span><span class="p">,</span> <span class="mf">0.2023</span><span class="p">))</span>
    <span class="n">changeswap_op</span> <span class="o">=</span> <span class="n">vision</span><span class="o">.</span><span class="n">HWC2CHW</span><span class="p">()</span>
    <span class="n">type_cast_op</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">TypeCast</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">c_trans</span> <span class="o">=</span> <span class="p">[</span><span class="n">random_crop_op</span><span class="p">,</span> <span class="n">random_horizontal_op</span><span class="p">]</span>
    <span class="n">c_trans</span> <span class="o">+=</span> <span class="p">[</span><span class="n">resize_op</span><span class="p">,</span> <span class="n">rescale_op</span><span class="p">,</span> <span class="n">normalize_op</span><span class="p">,</span> <span class="n">changeswap_op</span><span class="p">]</span>

    <span class="c1"># apply map operations on images</span>
    <span class="n">data_set</span> <span class="o">=</span> <span class="n">data_set</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="n">type_cast_op</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
    <span class="n">data_set</span> <span class="o">=</span> <span class="n">data_set</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="n">c_trans</span><span class="p">,</span> <span class="n">input_columns</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">)</span>

    <span class="c1"># apply shuffle operations</span>
    <span class="n">data_set</span> <span class="o">=</span> <span class="n">data_set</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">buffer_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># apply batch operations</span>
    <span class="n">data_set</span> <span class="o">=</span> <span class="n">data_set</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># apply repeat operations</span>
    <span class="n">data_set</span> <span class="o">=</span> <span class="n">data_set</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat_num</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_set</span>
</pre></div>
</div>
<p>其中，与单机不同的是，在数据集接口需要传入<code class="docutils literal notranslate"><span class="pre">num_shards</span></code>和<code class="docutils literal notranslate"><span class="pre">shard_id</span></code>参数，分别对应卡的数量和逻辑序号，建议通过NCCL接口获取：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">get_rank</span></code>：获取当前设备在集群中的ID。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_group_size</span></code>：获取集群数量。</p></li>
</ul>
<blockquote>
<div><p>数据并行场景加载数据集时，建议对每卡指定相同的数据集文件，若是各卡加载的数据集不同，可能会影响计算精度。</p>
</div></blockquote>
</section>
<section id="定义网络">
<h2>定义网络<a class="headerlink" href="#定义网络" title="Permalink to this headline"></a></h2>
<p>在GPU硬件平台上，网络的定义和Ascend 910 AI处理器一致。
<strong>数据并行</strong>及<strong>自动并行</strong>模式下，网络定义方式与单机写法一致，可以参考 <a class="reference external" href="https://gitee.com/mindspore/docs/blob/r1.8/docs/sample_code/resnet/resnet.py">ResNet网络样例脚本</a>。</p>
<blockquote>
<div><ul class="simple">
<li><p>半自动并行模式时，未配置策略的算子默认以数据并行方式执行。</p></li>
<li><p>自动并行模式支持通过策略搜索算法自动获取高效的算子并行策略，同时也支持用户对算子手动配置特定的并行策略。</p></li>
<li><p>如果某个<code class="docutils literal notranslate"><span class="pre">parameter</span></code>被多个算子使用，则每个算子对这个<code class="docutils literal notranslate"><span class="pre">parameter</span></code>的切分策略需要保持一致，否则将报错。</p></li>
</ul>
</div></blockquote>
</section>
<section id="定义损失函数及优化器">
<h2>定义损失函数及优化器<a class="headerlink" href="#定义损失函数及优化器" title="Permalink to this headline"></a></h2>
<p>与在Ascend的<a class="reference external" href="https://www.mindspore.cn/tutorials/experts/zh-CN/r1.8/parallel/train_ascend.html">分布式并行训练基础样例</a>一致。</p>
<section id="定义损失函数">
<h3>定义损失函数<a class="headerlink" href="#定义损失函数" title="Permalink to this headline"></a></h3>
<p>自动并行以算子为粒度切分模型，通过算法搜索得到最优并行策略，所以与单机训练不同的是，为了有更好的并行训练效果， 损失函数建议使用MindSpore算子来实现，而不是直接用封装好的损失函数类。</p>
<p>在Loss部分，我们采用<code class="docutils literal notranslate"><span class="pre">SoftmaxCrossEntropyWithLogits</span></code>的展开形式，即按照数学公式， 将其展开为多个MindSpore算子进行实现，样例代码如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore.ops</span> <span class="k">as</span> <span class="nn">ops</span>
<span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">import</span> <span class="nn">mindspore.nn</span> <span class="k">as</span> <span class="nn">nn</span>


<span class="k">class</span> <span class="nc">SoftmaxCrossEntropyExpand</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Cell</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SoftmaxCrossEntropyExpand</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exp</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Exp</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">ReduceSum</span><span class="p">(</span><span class="n">keep_dims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onehot</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">OneHot</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_value</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">off_value</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">div</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">RealDiv</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Log</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_cross_entropy</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">ReduceSum</span><span class="p">(</span><span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul2</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Mul</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">ReduceMean</span><span class="p">(</span><span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">ReduceMax</span><span class="p">(</span><span class="n">keep_dims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Sub</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logit</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="n">logit_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logit</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">logit</span><span class="p">,</span> <span class="n">logit_max</span><span class="p">))</span>
        <span class="n">exp_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">softmax_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">exp_sum</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">onehot</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">logit</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">off_value</span><span class="p">)</span>
        <span class="n">softmax_result_log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">softmax_result</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_cross_entropy</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">softmax_result_log</span><span class="p">,</span> <span class="n">label</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul2</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">scalar_to_array</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">loss</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loss</span>
</pre></div>
</div>
</section>
<section id="定义优化器">
<h3>定义优化器<a class="headerlink" href="#定义优化器" title="Permalink to this headline"></a></h3>
<p>采用<code class="docutils literal notranslate"><span class="pre">Momentum</span></code>优化器作为参数更新工具，这里定义与单机一致，不再展开，具体可以参考样例代码中的实现。</p>
</section>
</section>
<section id="训练网络">
<h2>训练网络<a class="headerlink" href="#训练网络" title="Permalink to this headline"></a></h2>
<p>训练之前，我们需要先配置一些自动并行的参数。<code class="docutils literal notranslate"><span class="pre">set_auto_parallel_context</span></code>是配置并行训练模式的接口，必须在初始化网络之前调用。常用参数包括：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">parallel_mode</span></code>：分布式并行模式，默认为单机模式<code class="docutils literal notranslate"><span class="pre">ParallelMode.STAND_ALONE</span></code>。在本例中，可选择数据并行<code class="docutils literal notranslate"><span class="pre">ParallelMode.DATA_PARALLEL</span></code>及自动并行<code class="docutils literal notranslate"><span class="pre">ParallelMode.AUTO_PARALLEL</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parameter_broadcast</span></code>：训练开始前自动广播0号卡上数据并行的参数权值到其他卡上，默认值为<code class="docutils literal notranslate"><span class="pre">False</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gradients_mean</span></code>：反向计算时，框架内部会将数据并行参数分散在多台机器的梯度值进行收集，得到全局梯度值后再传入优化器中更新。默认值为<code class="docutils literal notranslate"><span class="pre">False</span></code>，设置为True对应<code class="docutils literal notranslate"><span class="pre">allreduce_mean</span></code>操作，False对应<code class="docutils literal notranslate"><span class="pre">allreduce_sum</span></code>操作。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_num</span></code>和<code class="docutils literal notranslate"><span class="pre">global_rank</span></code>建议采用默认值，框架内会调用NCCL接口获取。</p></li>
</ul>
<p>如脚本中存在多个网络用例，请在执行下个用例前调用<code class="docutils literal notranslate"><span class="pre">reset_auto_parallel_context</span></code>将所有参数还原到默认值。</p>
<p>在下面的样例中我们指定并行模式为自动并行，用户如需切换为数据并行模式只需将<code class="docutils literal notranslate"><span class="pre">parallel_mode</span></code>改为<code class="docutils literal notranslate"><span class="pre">DATA_PARALLEL</span></code>。</p>
<blockquote>
<div><p>PyNative模式当前支持数据并行，使用方法和图模式下的数据并行一致，只需将<code class="docutils literal notranslate"><span class="pre">mode</span></code>指定为<code class="docutils literal notranslate"><span class="pre">PYNATIVE_MODE</span></code>即可。</p>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">from</span> <span class="nn">mindspore.nn</span> <span class="kn">import</span> <span class="n">Momentum</span>
<span class="kn">from</span> <span class="nn">mindspore.communication</span> <span class="kn">import</span> <span class="n">init</span>
<span class="kn">from</span> <span class="nn">resnet</span> <span class="kn">import</span> <span class="n">resnet50</span>

<span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">GRAPH_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;GPU&quot;</span><span class="p">)</span>
<span class="n">init</span><span class="p">(</span><span class="s2">&quot;nccl&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_train_cifar</span><span class="p">(</span><span class="n">epoch_size</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">ms</span><span class="o">.</span><span class="n">set_auto_parallel_context</span><span class="p">(</span><span class="n">parallel_mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">ParallelMode</span><span class="o">.</span><span class="n">AUTO_PARALLEL</span><span class="p">,</span> <span class="n">gradients_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">loss_cb</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">LossMonitor</span><span class="p">()</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">create_dataset</span><span class="p">(</span><span class="n">data_path</span><span class="p">)</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">resnet50</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">SoftmaxCrossEntropyExpand</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">opt</span> <span class="o">=</span> <span class="n">Momentum</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">,</span> <span class="n">net</span><span class="o">.</span><span class="n">get_parameters</span><span class="p">()),</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">loss_fn</span><span class="o">=</span><span class="n">loss</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">opt</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epoch_size</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">loss_cb</span><span class="p">],</span> <span class="n">dataset_sink_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>其中，</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dataset_sink_mode=True</span></code>：表示采用数据集的下沉模式，即训练的计算下沉到硬件平台中执行。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LossMonitor</span></code>：能够通过回调函数返回Loss值，用于监控损失函数。</p></li>
</ul>
</section>
<section id="运行脚本">
<h2>运行脚本<a class="headerlink" href="#运行脚本" title="Permalink to this headline"></a></h2>
<p>在GPU硬件平台上，MindSpore采用OpenMPI的<code class="docutils literal notranslate"><span class="pre">mpirun</span></code>进行分布式训练。 在完成了模型、损失函数和优化器的定义之后，我们就完成了模型的并行策略的配置， 下面直接执行运行脚本。</p>
<section id="单机多卡训练">
<h3>单机多卡训练<a class="headerlink" href="#单机多卡训练" title="Permalink to this headline"></a></h3>
<p>下面以使用8张卡的分布式训练脚本为例，演示如何运行脚本：</p>
<blockquote>
<div><p>你可以在这里找到样例的运行脚本：</p>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/blob/r1.8/docs/sample_code/distributed_training/run_gpu.sh">https://gitee.com/mindspore/docs/blob/r1.8/docs/sample_code/distributed_training/run_gpu.sh</a>。</p>
<p>如果通过root用户执行脚本，<code class="docutils literal notranslate"><span class="pre">mpirun</span></code>需要加上<code class="docutils literal notranslate"><span class="pre">--allow-run-as-root</span></code>参数。</p>
</div></blockquote>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;==============================================================================================================&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Please run the script as: &quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;bash run_gpu.sh DATA_PATH&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;For example: bash run_gpu.sh /path/dataset&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;It is better to use the absolute path.&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;==============================================================================================================&quot;</span>
<span class="nv">DATA_PATH</span><span class="o">=</span><span class="nv">$1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">DATA_PATH</span><span class="o">=</span><span class="si">${</span><span class="nv">DATA_PATH</span><span class="si">}</span>

rm<span class="w"> </span>-rf<span class="w"> </span>device
mkdir<span class="w"> </span>device
cp<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>./resnet.py<span class="w"> </span>./device
<span class="nb">cd</span><span class="w"> </span>./device
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start training&quot;</span>
mpirun<span class="w"> </span>-n<span class="w"> </span><span class="m">8</span><span class="w"> </span>pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>&gt;<span class="w"> </span>train.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
</pre></div>
</div>
<p>脚本会在后台运行，日志文件会保存到device目录下，共跑了10个epoch，每个epoch有234个step，关于Loss部分结果保存在train.log中。将loss值grep出来后，示例如下：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
</pre></div>
</div>
</section>
<section id="多机多卡训练">
<h3>多机多卡训练<a class="headerlink" href="#多机多卡训练" title="Permalink to this headline"></a></h3>
<p>在运行多机多卡训练前，需要保证每个节点上都有相同的OpenMPI、NCCL、Python以及MindSpore版本。</p>
<section id="mpirun-h">
<h4>mpirun -H<a class="headerlink" href="#mpirun-h" title="Permalink to this headline"></a></h4>
<p>若训练涉及多机，则需要额外在<code class="docutils literal notranslate"><span class="pre">mpirun</span></code>命令中设置多机配置。你可以直接在<code class="docutils literal notranslate"><span class="pre">mpirun</span></code>命令中用<code class="docutils literal notranslate"><span class="pre">-H</span></code>选项进行设置，比如</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>mpirun -n 16 -H DEVICE1_IP:8,DEVICE2_IP:8 python hello.py
</pre></div>
</div>
<p>表示在ip为DEVICE1_IP和DEVICE2_IP的机器上分别起8个进程运行程序。</p>
</section>
<section id="mpirun--hostfile">
<h4>mpirun –hostfile<a class="headerlink" href="#mpirun--hostfile" title="Permalink to this headline"></a></h4>
<p>GPU的多机多卡的执行也可以通过构造hostfile文件来进行。 为方便调试，建议用这种方法来执行多机多卡脚本。 之后使用<code class="docutils literal notranslate"><span class="pre">mpirun</span> <span class="pre">--hostfile</span> <span class="pre">$HOST_FILE</span></code>的形式来执行。下面我们以hostfile启动方式来给出详细的多机多卡配置。</p>
<p>hostfile文件每一行格式为<code class="docutils literal notranslate"><span class="pre">[hostname]</span> <span class="pre">slots=[slotnum]</span></code>，hostname可以是ip或者主机名。需要注意的是，不同机器上的用户名需要相同，但是hostname不可以相同。如下，表示在DEVICE1上有8张卡；ip为192.168.0.1的机器上也有8张卡：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DEVICE1 slots=8
192.168.0.1 slots=8
</pre></div>
</div>
<p>两机十六卡的执行脚本如下，需要传入变量<code class="docutils literal notranslate"><span class="pre">DATA_PATH</span></code>和<code class="docutils literal notranslate"><span class="pre">HOSTFILE</span></code>，表示数据集的路径和hostfile文件的路径。我们需要设置mpi中mca的btl参数来指定进行mpi通信的网卡，否则可能会在调用mpi接口时初始化失败。btl参数指定了节点间采用tcp协议，节点内采用环路进行通信。btl_tcp_if_include指定节点间通信所经过的网卡的ip地址需要在给定的子网中。更多mpirun的选项设置可见OpenMPI的官网。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nv">DATA_PATH</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">HOSTFILE</span><span class="o">=</span><span class="nv">$2</span>

rm<span class="w"> </span>-rf<span class="w"> </span>device
mkdir<span class="w"> </span>device
cp<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>./resnet.py<span class="w"> </span>./device
<span class="nb">cd</span><span class="w"> </span>./device
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start training&quot;</span>
mpirun<span class="w"> </span>-n<span class="w"> </span><span class="m">16</span><span class="w"> </span>--mca<span class="w"> </span>btl<span class="w"> </span>tcp,self<span class="w"> </span>--mca<span class="w"> </span>btl_tcp_if_include<span class="w"> </span><span class="m">192</span>.168.0.0/24<span class="w"> </span>--hostfile<span class="w"> </span><span class="nv">$HOSTFILE</span><span class="w"> </span>-x<span class="w"> </span><span class="nv">DATA_PATH</span><span class="o">=</span><span class="nv">$DATA_PATH</span><span class="w"> </span>-x<span class="w"> </span>PATH<span class="w"> </span>-mca<span class="w"> </span>pml<span class="w"> </span>ob1<span class="w"> </span>mpirun_gpu_clusher.sh<span class="w"> </span><span class="p">&amp;</span>
</pre></div>
</div>
<p>考虑到不同机器上的一些环境变量可能会不一样，我们采用mpirun启动一个<code class="docutils literal notranslate"><span class="pre">mpirun_gpu_cluster.sh</span></code>的形式，在不同机器上的该脚本文件中指定所需的环境变量。此处我们配置了<code class="docutils literal notranslate"><span class="pre">NCCL_SOCKET_IFNAME</span></code>，来指定NCCL进行通信时的网卡。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1"># mpirun_gpu_clusher.sh</span>
<span class="c1"># 你可以在这里设置每台机器上不同的环境变量，如下面的网卡名字</span>

<span class="nb">export</span><span class="w"> </span><span class="nv">NCCL_SOCKET_IFNAME</span><span class="o">=</span><span class="s2">&quot;en5&quot;</span><span class="w"> </span><span class="c1"># 需进行节点间通信的网卡的名字，不同机器上可能不一致，使用ifconfig查看。</span>
pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>&gt;<span class="w"> </span>train.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="分布式训练模型参数保存与加载">
<h2>分布式训练模型参数保存与加载<a class="headerlink" href="#分布式训练模型参数保存与加载" title="Permalink to this headline"></a></h2>
<p>在GPU上进行分布式训练时，模型参数的保存和加载的方法与Ascend上一致，可参考<a class="reference external" href="https://www.mindspore.cn/tutorials/experts/zh-CN/r1.8/parallel/train_ascend.html#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD">分布式训练模型参数保存和加载</a>。</p>
</section>
<section id="不依赖openmpi进行训练">
<h2>不依赖OpenMPI进行训练<a class="headerlink" href="#不依赖openmpi进行训练" title="Permalink to this headline"></a></h2>
<p>出于训练时的安全及可靠性要求，MindSpore GPU还支持<strong>不依赖OpenMPI的分布式训练</strong>。</p>
<p>OpenMPI在分布式训练的场景中，起到在Host侧同步数据以及进程间组网的功能；MindSpore通过<strong>复用Parameter Server模式训练架构</strong>，取代了OpenMPI能力。</p>
<p>参考<a class="reference external" href="https://mindspore.cn/tutorials/experts/zh-CN/r1.8/parallel/parameter_server_training.html">Parameter Server模式</a>训练教程，将多个MindSpore训练进程作为<code class="docutils literal notranslate"><span class="pre">Worker</span></code>启动，并且额外启动一个<code class="docutils literal notranslate"><span class="pre">Scheduler</span></code>，对脚本做少量修改，即可执行<strong>不依赖OpenMPI的分布式训练</strong>。</p>
<p>执行Worker脚本前需要导出环境变量，如<a class="reference external" href="https://mindspore.cn/tutorials/experts/zh-CN/r1.8/parallel/parameter_server_training.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE">环境变量设置</a>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>export MS_SERVER_NUM=0                # Server number
export MS_WORKER_NUM=8                # Worker number
export MS_SCHED_HOST=127.0.0.1        # Scheduler IP address
export MS_SCHED_PORT=6667             # Scheduler port
export MS_ROLE=MS_WORKER              # The role of this process: MS_SCHED represents the scheduler, MS_WORKER represents the worker, MS_PSERVER represents the Server
</pre></div>
</div>
<blockquote>
<div><p>在此模式下，不建议启动MS_PSERVER角色的进程，因为此角色在数据并行训练中无影响。</p>
</div></blockquote>
<section id="运行脚本-1">
<h3>运行脚本<a class="headerlink" href="#运行脚本-1" title="Permalink to this headline"></a></h3>
<p>在GPU硬件平台上，下面以使用8张卡的分布式训练脚本为例，演示如何运行脚本：</p>
<blockquote>
<div><p>你可以在这里找到样例的运行目录：</p>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/tree/r1.8/docs/sample_code/distributed_training">https://gitee.com/mindspore/docs/tree/r1.8/docs/sample_code/distributed_training</a>。</p>
</div></blockquote>
<p>相比OpenMPI方式启动，此模式需要调用<a class="reference external" href="https://mindspore.cn/tutorials/experts/zh-CN/r1.8/parallel/parameter_server_training.html">Parameter Server模式</a>中的<code class="docutils literal notranslate"><span class="pre">set_ps_context</span></code>接口，告诉MindSpore此次任务使用了PS模式训练架构:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mindspore</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="kn">from</span> <span class="nn">mindspore.communication</span> <span class="kn">import</span> <span class="n">init</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">ms</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">GRAPH_MODE</span><span class="p">,</span> <span class="n">device_target</span><span class="o">=</span><span class="s2">&quot;GPU&quot;</span><span class="p">)</span>
    <span class="n">ms</span><span class="o">.</span><span class="n">set_ps_context</span><span class="p">(</span><span class="n">config_file_path</span><span class="o">=</span><span class="s2">&quot;/path/to/config_file.json&quot;</span><span class="p">,</span> <span class="n">enable_ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">client_password</span><span class="o">=</span><span class="s2">&quot;123456&quot;</span><span class="p">,</span> <span class="n">server_password</span><span class="o">=</span><span class="s2">&quot;123456&quot;</span><span class="p">)</span>
    <span class="n">init</span><span class="p">(</span><span class="s2">&quot;nccl&quot;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>其中，</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mode=GRAPH_MODE</span></code>：使用分布式训练需要指定运行模式为图模式（PyNative模式当前仅支持数据并行）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">init(&quot;nccl&quot;)</span></code>：使能NCCL通信，并完成分布式训练初始化操作。</p></li>
<li><p>默认情况下，安全加密通道是关闭的，需要通过<code class="docutils literal notranslate"><span class="pre">set_ps_context</span></code>正确配置安全加密通道或者关闭安全加密通道后，才能调用init(“nccl”)，否则初始化组网会失败。</p></li>
</ul>
<p>若想使用安全加密通道，请设置<code class="docutils literal notranslate"><span class="pre">set_ps_context(config_file_path=&quot;/path/to/config_file.json&quot;,</span> <span class="pre">enable_ssl=True,</span> <span class="pre">client_password=&quot;123456&quot;,</span> <span class="pre">server_password=&quot;123456&quot;)</span></code>等配置，详细参数配置说明请参考Python API <a class="reference external" href="https://www.mindspore.cn/docs/zh-CN/r1.8/api_python/mindspore/mindspore.set_ps_context.html#mindspore.set_ps_context">mindspore.set_ps_context</a>，以及本文档<span class="xref myst">安全认证</span>章节。</p>
<p>脚本内容<code class="docutils literal notranslate"><span class="pre">run_gpu_cluster.sh</span></code>如下，在启动Worker和Scheduler之前，需要添加相关环境变量设置：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;==========================================&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Please run the script as: &quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;bash run_gpu_cluster.sh DATA_PATH&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;For example: bash run_gpu_cluster.sh /path/dataset&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;It is better to use the absolute path.&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;===========================================&quot;</span>
<span class="nv">DATA_PATH</span><span class="o">=</span><span class="nv">$1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">DATA_PATH</span><span class="o">=</span><span class="si">${</span><span class="nv">DATA_PATH</span><span class="si">}</span>

rm<span class="w"> </span>-rf<span class="w"> </span>device
mkdir<span class="w"> </span>device
cp<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>./resnet.py<span class="w"> </span>./device
<span class="nb">cd</span><span class="w"> </span>./device
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start training&quot;</span>

<span class="c1"># Launch 8 workers.</span>
<span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span><span class="m">0</span><span class="p">;</span>i&lt;<span class="m">8</span><span class="p">;</span>i++<span class="o">))</span><span class="p">;</span>
<span class="k">do</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_WORKER_NUM</span><span class="o">=</span><span class="m">8</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_HOST</span><span class="o">=</span>XXX.XXX.XXX.XXX<span class="w">  </span><span class="c1"># Scheduler IP address</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_PORT</span><span class="o">=</span>XXXX<span class="w">             </span><span class="c1"># Scheduler port</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_ROLE</span><span class="o">=</span>MS_WORKER
<span class="w">    </span>pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>&gt;<span class="w"> </span>worker_<span class="nv">$i</span>.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
<span class="k">done</span>

<span class="c1"># Launch 1 scheduler.</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_WORKER_NUM</span><span class="o">=</span><span class="m">8</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_HOST</span><span class="o">=</span>XXX.XXX.XXX.XXX<span class="w">  </span><span class="c1"># Scheduler IP address</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_PORT</span><span class="o">=</span>XXXX<span class="w">             </span><span class="c1"># Scheduler port</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_ROLE</span><span class="o">=</span>MS_SCHED
pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>&gt;<span class="w"> </span>scheduler.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
</pre></div>
</div>
<p>执行如下指令：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./run_gpu_cluster.sh<span class="w"> </span>DATA_PATH
</pre></div>
</div>
<p>即可单机内部执行8卡分布式训练，若希望执行跨机训练，则需要将脚本拆分，如执行2机8卡训练，每台机器执行启动4Worker：</p>
<p>脚本<code class="docutils literal notranslate"><span class="pre">run_gpu_cluster_1.sh</span></code>在机器1上启动1<code class="docutils literal notranslate"><span class="pre">Scheduler</span></code>和<code class="docutils literal notranslate"><span class="pre">Worker1</span></code>到<code class="docutils literal notranslate"><span class="pre">Worker4</span></code>：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;==========================================&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Please run the script as: &quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;bash run_gpu_cluster.sh DATA_PATH&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;For example: bash run_gpu_cluster.sh /path/dataset&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;It is better to use the absolute path.&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;===========================================&quot;</span>
<span class="nv">DATA_PATH</span><span class="o">=</span><span class="nv">$1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">DATA_PATH</span><span class="o">=</span><span class="si">${</span><span class="nv">DATA_PATH</span><span class="si">}</span>

rm<span class="w"> </span>-rf<span class="w"> </span>device
mkdir<span class="w"> </span>device
cp<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>./resnet.py<span class="w"> </span>./device
<span class="nb">cd</span><span class="w"> </span>./device
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start training&quot;</span>

<span class="c1"># Launch 1-4 workers.</span>
<span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span><span class="m">0</span><span class="p">;</span>i&lt;<span class="m">4</span><span class="p">;</span>i++<span class="o">))</span><span class="p">;</span>
<span class="k">do</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_WORKER_NUM</span><span class="o">=</span><span class="m">8</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_HOST</span><span class="o">=</span>XXX.XXX.XXX.XXX<span class="w">  </span><span class="c1"># Scheduler IP address</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_PORT</span><span class="o">=</span>XXXX<span class="w">             </span><span class="c1"># Scheduler port</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_ROLE</span><span class="o">=</span>MS_WORKER
<span class="w">    </span>pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>&gt;<span class="w"> </span>worker_<span class="nv">$i</span>.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
<span class="k">done</span>

<span class="c1"># Launch 1 scheduler.</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_WORKER_NUM</span><span class="o">=</span><span class="m">8</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_HOST</span><span class="o">=</span>XXX.XXX.XXX.XXX<span class="w">  </span><span class="c1"># Scheduler IP address</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_PORT</span><span class="o">=</span>XXXX<span class="w">             </span><span class="c1"># Scheduler port</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_ROLE</span><span class="o">=</span>MS_SCHED
pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>&gt;<span class="w"> </span>scheduler.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
</pre></div>
</div>
<p>脚本<code class="docutils literal notranslate"><span class="pre">run_gpu_cluster_2.sh</span></code>在机器2上启动<code class="docutils literal notranslate"><span class="pre">Worker5</span></code>到<code class="docutils literal notranslate"><span class="pre">Worker8</span></code>(无需再执行Scheduler)：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;==========================================&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Please run the script as: &quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;bash run_gpu_cluster.sh DATA_PATH&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;For example: bash run_gpu_cluster.sh /path/dataset&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;It is better to use the absolute path.&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;===========================================&quot;</span>
<span class="nv">DATA_PATH</span><span class="o">=</span><span class="nv">$1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">DATA_PATH</span><span class="o">=</span><span class="si">${</span><span class="nv">DATA_PATH</span><span class="si">}</span>

rm<span class="w"> </span>-rf<span class="w"> </span>device
mkdir<span class="w"> </span>device
cp<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>./resnet.py<span class="w"> </span>./device
<span class="nb">cd</span><span class="w"> </span>./device
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start training&quot;</span>

<span class="c1"># Launch 5-8 workers.</span>
<span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span><span class="m">4</span><span class="p">;</span>i&lt;<span class="m">8</span><span class="p">;</span>i++<span class="o">))</span><span class="p">;</span>
<span class="k">do</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_WORKER_NUM</span><span class="o">=</span><span class="m">8</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_HOST</span><span class="o">=</span>XXX.XXX.XXX.XXX<span class="w">  </span><span class="c1"># Scheduler IP address</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_PORT</span><span class="o">=</span>XXXX<span class="w">             </span><span class="c1"># Scheduler port</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_ROLE</span><span class="o">=</span>MS_WORKER
<span class="w">    </span>pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu.py<span class="w"> </span>&gt;<span class="w"> </span>worker_<span class="nv">$i</span>.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
<span class="k">done</span>
</pre></div>
</div>
<p>在两台主机分别执行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./run_gpu_cluster_1.sh<span class="w"> </span>DATA_PATH
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./run_gpu_cluster_2.sh<span class="w"> </span>DATA_PATH
</pre></div>
</div>
<p>即可执行2机8卡分布式训练任务。</p>
<p>若希望启动数据并行模式训练，需要将脚本<code class="docutils literal notranslate"><span class="pre">resnet50_distributed_training_gpu.py</span></code>中<code class="docutils literal notranslate"><span class="pre">set_auto_parallel_context</span></code>入参并行模式改为<code class="docutils literal notranslate"><span class="pre">DATA_PARALLEL</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">set_auto_parallel_context</span><span class="p">(</span><span class="n">parallel_mode</span><span class="o">=</span><span class="n">ParallelMode</span><span class="o">.</span><span class="n">DATA_PARALLEL</span><span class="p">,</span> <span class="n">gradients_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>脚本会在后台运行，日志文件会保存到当前目录下，共跑了10个epoch，每个epoch有234个step，关于Loss部分结果保存在worker_*.log中。将loss值grep出来后，示例如下：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
epoch: 1 step: 1, loss is 2.3025854
</pre></div>
</div>
</section>
<section id="安全认证">
<h3>安全认证<a class="headerlink" href="#安全认证" title="Permalink to this headline"></a></h3>
<p>要支持节点/进程间的SSL安全认证，要开启安全认证，通过Python API <code class="docutils literal notranslate"><span class="pre">mindspore.set_ps_context</span></code>配置<code class="docutils literal notranslate"><span class="pre">enable_ssl=True</span></code>(不传入时默认为False，表示不启用SSL安全认证)，config_file_path指定的config.json配置文件需要添加如下字段：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;server_cert_path&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;server.p12&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;crl_path&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;client_cert_path&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;client.p12&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;ca_cert_path&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;ca.crt&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;cipher_list&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;ECDHE-R SA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-DSS-AES256-GCM-SHA384:DHE-PSK-AES128-GCM-SHA256:DHE-PSK-AES256-GCM-SHA384:DHE-PSK-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-PSK-CHACHA20-POLY1305:DHE-RSA-AES128-CCM:DHE-RSA-AES256-CCM:DHE-RSA-CHACHA20-POLY1305:DHE-PSK-AES128-CCM:DHE-PSK-AES256-CCM:ECDHE-ECDSA-AES128-CCM:ECDHE-ECDSA-AES256-CCM:ECDHE-ECDSA-CHACHA20-POLY1305&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;cert_expire_warning_time_in_day&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">90</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>server_cert_path: 服务端包含了证书和秘钥的密文的p12文件（SSL专用证书文件）路径。</p></li>
<li><p>crl_path: 吊销列表（用于区分无效不可信证书和有效可信证书）的文件路径。</p></li>
<li><p>client_cert_path: 客户端包含了证书和秘钥的密文的p12文件（SSL专用证书文件）路径。</p></li>
<li><p>ca_cert_path: 根证书路径。</p></li>
<li><p>cipher_list: 密码套件（支持的SSL加密类型列表）。</p></li>
<li><p>cert_expire_warning_time_in_day: 证书过期的告警时间。</p></li>
</ul>
<p>p12文件中的秘钥为密文存储，在启动时需要传入密码，具体参数请参考Python API <a class="reference external" href="https://www.mindspore.cn/docs/zh-CN/r1.8/api_python/mindspore/mindspore.set_ps_context.html#mindspore.set_ps_context">mindspore.set_ps_context</a>中的<code class="docutils literal notranslate"><span class="pre">client_password</span></code>以及<code class="docutils literal notranslate"><span class="pre">server_password</span></code>字段。</p>
</section>
<section id="容灾恢复">
<h3>容灾恢复<a class="headerlink" href="#容灾恢复" title="Permalink to this headline"></a></h3>
<p>模型训练对分布式训练架构的可靠性、可服务性要求比较高，MindSpore支持数据并行下容灾恢复，多卡数据并行训练场景集群(多个Worker和1个Scheduler)中存在进程异常退出，被重新拉起后，训练任务继续能正常执行；</p>
<p>场景约束：
在图模式下，采用<code class="docutils literal notranslate"><span class="pre">MindData</span></code>进行数据下沉模式训练，开启数据并行模式，采用上述的非<code class="docutils literal notranslate"><span class="pre">OpenMPI</span></code>的方式拉起Worker进程。</p>
<p>在上述场景下，训练过程中如果有节点挂掉，保证在相同的环境变量（<code class="docutils literal notranslate"><span class="pre">MS_ENABLE_RECOVERY</span></code> 和 <code class="docutils literal notranslate"><span class="pre">MS_RECOVERY_PATH</span></code>）下，重新拉起对应进程对应的脚本后训练可继续，并且不影响精度收敛。</p>
<p>1） 开启容灾：</p>
<p>通过环境变量开启容灾：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_ENABLE_RECOVERY</span><span class="o">=</span><span class="m">1</span><span class="w">             </span><span class="c1">#开启容灾</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_RECOVERY_PATH</span><span class="o">=</span>“/xxx/xxx”<span class="w">      </span><span class="c1">#配置持久化路径文件夹，Worker和Scheduler进程在执行过程中会进行必要的持久化，如用于恢复组网的节点信息以及训练业务中间状态等</span>
</pre></div>
</div>
<p>2）配置checkpoint保存间隔，样例如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ckptconfig</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">CheckpointConfig</span><span class="p">(</span><span class="n">save_checkpoint_steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">keep_checkpoint_max</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ckpoint_cb</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">ModelCheckpoint</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="n">directory</span><span class="o">=</span><span class="s2">&quot;./ckpt_of_rank_/&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">get_rank</span><span class="p">()),</span> <span class="n">config</span><span class="o">=</span><span class="n">ckptconfig</span><span class="p">)</span>
</pre></div>
</div>
<p>每个Worker都开启保存checkpoint，并用不同的路径（如上述样例中的directory的设置使用了rank id，保证路径不会相同），防止同名checkpoint保存冲突。checkpoint用于异常进程恢复和正常进程回滚，训练的回滚是指集群中各个Worker都恢复到最新的checkpoint对应的状态，同时数据侧也回退到对应的step，然后继续训练。保存checkpoint的间隔是可配置的，这个间隔决定了容灾恢复的粒度，间隔越小，恢复到上次保存checkpoint所回退的step数就越小，但保存checkpoint频繁也可能会影响训练效率，间隔越大则效果相反。keep_checkpoint_max至少设置为2(防止checkpoint保存失败)。</p>
<blockquote>
<div><p>样例的运行目录：</p>
<p><a class="reference external" href="https://gitee.com/mindspore/docs/tree/r1.8/docs/sample_code/distributed_training">https://gitee.com/mindspore/docs/tree/r1.8/docs/sample_code/distributed_training</a>。</p>
</div></blockquote>
<p>涉及到的脚本有<code class="docutils literal notranslate"><span class="pre">run_gpu_cluster_recovery.sh</span></code>, <code class="docutils literal notranslate"><span class="pre">resnet50_distributed_training_gpu_recovery.py</span></code>, <code class="docutils literal notranslate"><span class="pre">resnet.py</span></code>。脚本内容<code class="docutils literal notranslate"><span class="pre">run_gpu_cluster_recovery.sh</span></code>如下：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;==========================================&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Please run the script as: &quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;bash run_gpu_cluster_recovery.sh DATA_PATH&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;For example: bash run_gpu_cluster_recovery.sh /path/dataset&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;It is better to use the absolute path.&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;===========================================&quot;</span>
<span class="nv">DATA_PATH</span><span class="o">=</span><span class="nv">$1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">DATA_PATH</span><span class="o">=</span><span class="si">${</span><span class="nv">DATA_PATH</span><span class="si">}</span>

<span class="nb">export</span><span class="w"> </span><span class="nv">MS_ENABLE_RECOVERY</span><span class="o">=</span><span class="m">1</span><span class="w">      </span><span class="c1"># Enable recovery</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_RECOVERY_PATH</span><span class="o">=</span>/XXX/XXX<span class="w"> </span><span class="c1"># Set recovery path</span>

rm<span class="w"> </span>-rf<span class="w"> </span>device
mkdir<span class="w"> </span>device
cp<span class="w"> </span>./resnet50_distributed_training_gpu_recovery.py<span class="w"> </span>./resnet.py<span class="w"> </span>./device
<span class="nb">cd</span><span class="w"> </span>./device
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start training&quot;</span>

<span class="c1"># Launch 1 scheduler.</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_WORKER_NUM</span><span class="o">=</span><span class="m">8</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_HOST</span><span class="o">=</span>XXX.XXX.XXX.XXX<span class="w">  </span><span class="c1"># Scheduler IP address</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_PORT</span><span class="o">=</span>XXXX<span class="w">             </span><span class="c1"># Scheduler port</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_ROLE</span><span class="o">=</span>MS_SCHED
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_NODE_ID</span><span class="o">=</span>sched<span class="w">               </span><span class="c1"># The node id for Scheduler</span>
pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu_recovery.py<span class="w"> </span>&gt;<span class="w"> </span>scheduler.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>

<span class="c1"># Launch 8 workers.</span>
<span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span><span class="m">0</span><span class="p">;</span>i&lt;<span class="m">8</span><span class="p">;</span>i++<span class="o">))</span><span class="p">;</span>
<span class="k">do</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_WORKER_NUM</span><span class="o">=</span><span class="m">8</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_HOST</span><span class="o">=</span>XXX.XXX.XXX.XXX<span class="w">  </span><span class="c1"># Scheduler IP address</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_PORT</span><span class="o">=</span>XXXX<span class="w">             </span><span class="c1"># Scheduler port</span>
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_ROLE</span><span class="o">=</span>MS_WORKER
<span class="w">    </span><span class="nb">export</span><span class="w"> </span><span class="nv">MS_NODE_ID</span><span class="o">=</span>worker_<span class="nv">$i</span><span class="w">           </span><span class="c1"># The node id for Workers</span>
<span class="w">    </span>pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu_recovery.py<span class="w"> </span>&gt;<span class="w"> </span>worker_<span class="nv">$i</span>.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
<span class="k">done</span>
</pre></div>
</div>
<p>在启动Worker和Scheduler之前，需要添加相关环境变量设置, 如Scheduler的IP和Port，当前进程的角色是Worker还是Scheduler。</p>
<p>执行下面的命令即可启动一个单机8卡的数据并行训练</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>bash<span class="w"> </span>run_gpu_cluster_recovery.sh<span class="w"> </span>YOUR_DATA_PATH<span class="s2">&quot;</span>
</pre></div>
</div>
<p>分布式训练开始，若训练过程中遇到异常，如进程异常退出，然后再重新启动对应的进程，训练流程即可恢复：
例如训练中途Scheduler进程异常退出，可执行下列命令重新启动Scheduler：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">DATA_PATH</span><span class="o">=</span>YOUR_DATA_PATH
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_ENABLE_RECOVERY</span><span class="o">=</span><span class="m">1</span><span class="w">           </span><span class="c1"># Enable recovery</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_RECOVERY_PATH</span><span class="o">=</span>/XXX/XXX<span class="w">      </span><span class="c1"># Set recovery path</span>

<span class="nb">cd</span><span class="w"> </span>./device

<span class="c1"># Launch 1 scheduler.</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_WORKER_NUM</span><span class="o">=</span><span class="m">8</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_HOST</span><span class="o">=</span>XXX.XXX.XXX.XXX<span class="w">  </span><span class="c1"># Scheduler IP address</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_SCHED_PORT</span><span class="o">=</span>XXXX<span class="w">             </span><span class="c1"># Scheduler port</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_ROLE</span><span class="o">=</span>MS_SCHED
<span class="nb">export</span><span class="w"> </span><span class="nv">MS_NODE_ID</span><span class="o">=</span>sched<span class="w">               </span><span class="c1"># The node id for Scheduler</span>
pytest<span class="w"> </span>-s<span class="w"> </span>-v<span class="w"> </span>./resnet50_distributed_training_gpu_recovery.py<span class="w"> </span>&gt;<span class="w"> </span>scheduler.log<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="w"> </span><span class="p">&amp;</span>
</pre></div>
</div>
<p>Worker和Scheduler的组网会自动恢复。</p>
<p>Worker进程出现异常退出处理方式类似(注:Worker进程出现异常退出，需要等30s后再拉起才能恢复训练，在这之前，Scheduler为了防止网络抖动和恶意注册，拒绝相同node id的Worker再次注册)。</p>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="train_ascend.html" class="btn btn-neutral float-left" title="分布式并行训练基础样例（Ascend）" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="transformer.html" class="btn btn-neutral float-right" title="分布式并行训练Transformer模型" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MindSpore.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   
</body>
</html>